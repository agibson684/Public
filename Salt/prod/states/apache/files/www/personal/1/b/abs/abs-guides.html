<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>Advanced Bash-Scripting Guide</b><br>
<b>An in-depth exploration of the art of shell scripting</b><br>
<b>Mendel Cooper</b><br>
<a href="mailto:thegrendel.abs@gmail.com">&lt;thegrendel.abs@gmail.com&gt;</a><br>
6.4<br>
30 Aug 2011<br>
<b>Revision History</b><br>
Revision 6.2<br>
17 Mar 2010<br>
Revised by: mc<br>
'ROWANBERRY' release<br>
Revision 6.3<br>
27 Apr 2011<br>
Revised by: mc<br>
'SWOZZLEBERRY' release<br>
Revision 6.4<br>
30 Aug 2011<br>
Revised by: mc<br>
'VORTEXBERRY' release<br>
This tutorial assumes no previous knowledge of scripting or programming, but progresses rapidly toward an<br>intermediate/advanced level of instruction<i>&nbsp;. . . all the while sneaking in little nuggets of UNIX® wisdom and<br>lore</i>. It serves as a textbook, a manual for self-study, and a reference and source of knowledge on shell<br>scripting techniques. The exercises and heavily-commented examples invite active reader participation, under<br>the premise that&nbsp;<b>the only way to really learn scripting is to write scripts</b>.<br>
This book is suitable for classroom use as a general introduction to programming concepts.<br>
<b>Dedication</b><br>
For Anita, the source of all the magic<br>
<hr>
<A name=2></a>Advanced Bash-Scripting Guide<br>
<b>Table of Contents</b><br>
<a href="abs-guides.html#7"><b>Chapter&nbsp;1.&nbsp;Shell&nbsp;Programming!.........................................................................................................................1</b></a><br>
<a href="abs-guides.html#9"><b>Chapter&nbsp;2.&nbsp;Starting&nbsp;Off&nbsp;With&nbsp;a&nbsp;Sha-Bang........................................................................................................3</b></a><br>
<a href="abs-guides.html#12">2.1.&nbsp;Invoking&nbsp;the&nbsp;script............................................................................................................................6<br>2.2.&nbsp;Preliminary&nbsp;Exercises.......................................................................................................................6</a><br>
<a href="abs-guides.html#13"><b>Part&nbsp;2.&nbsp;Basics.......................................................................................................................................................7</b></a><br>
<a href="abs-guides.html#14"><b>Chapter&nbsp;3.&nbsp;Special&nbsp;Characters...........................................................................................................................8</b></a><br>
<a href="abs-guides.html#36"><b>Chapter&nbsp;4.&nbsp;Introduction&nbsp;to&nbsp;Variables&nbsp;and&nbsp;Parameters..................................................................................30</b></a><br>
<a href="abs-guides.html#36">4.1.&nbsp;Variable&nbsp;Substitution......................................................................................................................30<br></a><a href="abs-guides.html#39">4.2.&nbsp;Variable&nbsp;Assignment.......................................................................................................................33<br></a><a href="abs-guides.html#40">4.3.&nbsp;Bash&nbsp;Variables&nbsp;Are&nbsp;Untyped..........................................................................................................34<br></a><a href="abs-guides.html#41">4.4.&nbsp;Special&nbsp;Variable&nbsp;Types...................................................................................................................35</a><br>
<a href="abs-guides.html#47"><b>Chapter&nbsp;5.&nbsp;Quoting</b></a><b>...........................................................................................................................................41</b><br>
<a href="abs-guides.html#47">5.1.&nbsp;Quoting&nbsp;Variables...........................................................................................................................41<br></a><a href="abs-guides.html#49">5.2.&nbsp;Escaping..........................................................................................................................................43</a><br>
<a href="abs-guides.html#57"><b>Chapter&nbsp;6.&nbsp;Exit&nbsp;and&nbsp;Exit&nbsp;Status.......................................................................................................................51</b></a><br>
<a href="abs-guides.html#60"><b>Chapter&nbsp;7.&nbsp;Tests</b></a><b>................................................................................................................................................54</b><br>
<a href="abs-guides.html#60">7.1.&nbsp;Test&nbsp;Constructs</a>...............................................................................................................................54<br><a href="abs-guides.html#68">7.2.&nbsp;File&nbsp;test&nbsp;operators............................................................................................................................62<br></a><a href="abs-guides.html#71">7.3.&nbsp;Other&nbsp;Comparison&nbsp;Operators..........................................................................................................65<br></a><a href="abs-guides.html#76">7.4.&nbsp;Nested&nbsp;if/then&nbsp;Condition&nbsp;Tests</a>.......................................................................................................70<br><a href="abs-guides.html#77">7.5.&nbsp;Testing&nbsp;Your&nbsp;Knowledge&nbsp;of&nbsp;Tests..................................................................................................71</a><br>
<a href="abs-guides.html#78"><b>Chapter&nbsp;8.&nbsp;Operations&nbsp;and&nbsp;Related&nbsp;Topics....................................................................................................72</b></a><br>
<a href="abs-guides.html#78">8.1.&nbsp;Operators.........................................................................................................................................72<br></a><a href="abs-guides.html#84">8.2.&nbsp;Numerical&nbsp;Constants.......................................................................................................................78<br></a><a href="abs-guides.html#86">8.3.&nbsp;The&nbsp;Double-Parentheses&nbsp;Construct.................................................................................................80<br></a><a href="abs-guides.html#87">8.4.&nbsp;Operator&nbsp;Precedence.......................................................................................................................81</a><br>
<a href="abs-guides.html#90"><b>Part&nbsp;3.&nbsp;Beyond&nbsp;the&nbsp;Basics.................................................................................................................................84</b></a><br>
<a href="abs-guides.html#91"><b>Chapter&nbsp;9.&nbsp;Another&nbsp;Look&nbsp;at&nbsp;Variables</b></a><b>...........................................................................................................85</b><br>
<a href="abs-guides.html#91">9.1.&nbsp;Internal&nbsp;Variables............................................................................................................................85<br></a><a href="abs-guides.html#110">9.2.&nbsp;Typing&nbsp;variables:&nbsp;declare&nbsp;or&nbsp;typeset.............................................................................................104</a><br>
<a href="abs-guides.html#112">9.2.1.&nbsp;Another&nbsp;use&nbsp;for&nbsp;declare.......................................................................................................106</a><br>
<a href="abs-guides.html#112">9.3.&nbsp;$RANDOM:&nbsp;generate&nbsp;random&nbsp;integer..........................................................................................106</a><br>
<a href="abs-guides.html#125"><b>Chapter&nbsp;10.&nbsp;Manipulating&nbsp;Variables.............................................................................................................119</b></a><br>
<a href="abs-guides.html#125">10.1.&nbsp;Manipulating&nbsp;Strings...................................................................................................................119</a><br>
<a href="abs-guides.html#132">10.1.1.&nbsp;Manipulating&nbsp;strings&nbsp;using&nbsp;awk........................................................................................126<br></a><a href="abs-guides.html#133">10.1.2.&nbsp;Further&nbsp;Reference..............................................................................................................127</a><br>
<a href="abs-guides.html#133">10.2.&nbsp;Parameter&nbsp;Substitution................................................................................................................127</a><br>
i<br>
<hr>
<A name=3></a>Advanced Bash-Scripting Guide<br>
<b>Table of Contents</b><br>
<a href="abs-guides.html#144"><b>Chapter&nbsp;11.&nbsp;Loops&nbsp;and&nbsp;Branches</b></a><b>..................................................................................................................138</b><br>
<a href="abs-guides.html#144">11.1.&nbsp;Loops</a>..........................................................................................................................................138<br><a href="abs-guides.html#157">11.2.&nbsp;Nested&nbsp;Loops..............................................................................................................................151<br></a><a href="abs-guides.html#158">11.3.&nbsp;Loop&nbsp;Control...............................................................................................................................152<br></a><a href="abs-guides.html#162">11.4.&nbsp;Testing&nbsp;and&nbsp;Branching................................................................................................................156</a><br>
<a href="abs-guides.html#170"><b>Chapter&nbsp;12.&nbsp;Command&nbsp;Substitution</b></a><b>.............................................................................................................164</b><br>
<a href="abs-guides.html#176"><b>Chapter&nbsp;13.&nbsp;Arithmetic&nbsp;Expansion................................................................................................................170</b></a><br>
<a href="abs-guides.html#177"><b>Chapter&nbsp;14.&nbsp;Recess&nbsp;Time................................................................................................................................171</b></a><br>
<a href="abs-guides.html#178"><b>Part&nbsp;4.&nbsp;Commands</b></a><b>..........................................................................................................................................172</b><br>
<a href="abs-guides.html#186"><b>Chapter&nbsp;15.&nbsp;Internal&nbsp;Commands&nbsp;and&nbsp;Builtins.............................................................................................180</b></a><br>
<a href="abs-guides.html#215">15.1.&nbsp;Job&nbsp;Control&nbsp;Commands</a>..............................................................................................................209<br>
<a href="abs-guides.html#220"><b>Chapter&nbsp;16.&nbsp;External&nbsp;Filters,&nbsp;Programs&nbsp;and&nbsp;Commands...........................................................................214</b></a><br>
<a href="abs-guides.html#220">16.1.&nbsp;Basic&nbsp;Commands........................................................................................................................214<br></a><a href="abs-guides.html#225">16.2.&nbsp;Complex&nbsp;Commands...................................................................................................................219<br></a><a href="abs-guides.html#236">16.3.&nbsp;Time&nbsp;/&nbsp;Date&nbsp;Commands..............................................................................................................230<br></a><a href="abs-guides.html#240">16.4.&nbsp;Text&nbsp;Processing&nbsp;Commands........................................................................................................234<br></a><a href="abs-guides.html#262">16.5.&nbsp;File&nbsp;and&nbsp;Archiving&nbsp;Commands...................................................................................................256<br></a><a href="abs-guides.html#280">16.6.&nbsp;Communications&nbsp;Commands......................................................................................................274<br></a><a href="abs-guides.html#295">16.7.&nbsp;Terminal&nbsp;Control&nbsp;Commands</a>.....................................................................................................289<br><a href="abs-guides.html#296">16.8.&nbsp;Math&nbsp;Commands.........................................................................................................................290<br></a><a href="abs-guides.html#307">16.9.&nbsp;Miscellaneous&nbsp;Commands..........................................................................................................301</a><br>
<a href="abs-guides.html#321"><b>Chapter&nbsp;17.&nbsp;System&nbsp;and&nbsp;Administrative&nbsp;Commands..................................................................................315</b></a><br>
<a href="abs-guides.html#350">17.1.&nbsp;Analyzing&nbsp;a&nbsp;System&nbsp;Script..........................................................................................................344</a><br>
<a href="abs-guides.html#352"><b>Part&nbsp;5.&nbsp;Advanced&nbsp;Topics.................................................................................................................................346</b></a><br>
<a href="abs-guides.html#354"><b>Chapter&nbsp;18.&nbsp;Regular&nbsp;Expressions..................................................................................................................348</b></a><br>
<a href="abs-guides.html#354">18.1.&nbsp;A&nbsp;Brief&nbsp;Introduction&nbsp;to&nbsp;Regular&nbsp;Expressions..............................................................................348<br></a><a href="abs-guides.html#358">18.2.&nbsp;Globbing</a>.....................................................................................................................................352<br>
<a href="abs-guides.html#360"><b>Chapter&nbsp;19.&nbsp;Here&nbsp;Documents.........................................................................................................................354</b></a><br>
<a href="abs-guides.html#370">19.1.&nbsp;Here&nbsp;Strings................................................................................................................................364</a><br>
<a href="abs-guides.html#374"><b>Chapter&nbsp;20.&nbsp;I/O&nbsp;Redirection...........................................................................................................................368</b></a><br>
<a href="abs-guides.html#377">20.1.&nbsp;Using&nbsp;exec...................................................................................................................................371<br></a><a href="abs-guides.html#380">20.2.&nbsp;Redirecting&nbsp;Code&nbsp;Blocks............................................................................................................374<br></a><a href="abs-guides.html#385">20.3.&nbsp;Applications................................................................................................................................379</a><br>
<a href="abs-guides.html#387"><b>Chapter&nbsp;21.&nbsp;Subshells</b></a><b>.....................................................................................................................................381</b><br>
ii<br>
<hr>
<A name=4></a>Advanced Bash-Scripting Guide<br>
<b>Table of Contents</b><br>
<a href="abs-guides.html#392"><b>Chapter&nbsp;22.&nbsp;Restricted&nbsp;Shells.........................................................................................................................386</b></a><br>
<a href="abs-guides.html#394"><b>Chapter&nbsp;23.&nbsp;Process&nbsp;Substitution...................................................................................................................388</b></a><br>
<a href="abs-guides.html#399"><b>Chapter&nbsp;24.&nbsp;Functions....................................................................................................................................393</b></a><br>
<a href="abs-guides.html#403">24.1.&nbsp;Complex&nbsp;Functions&nbsp;and&nbsp;Function&nbsp;Complexities.........................................................................397<br></a><a href="abs-guides.html#413">24.2.&nbsp;Local&nbsp;Variables...........................................................................................................................407</a><br>
<a href="abs-guides.html#415">24.2.1.&nbsp;Local&nbsp;variables&nbsp;and&nbsp;recursion............................................................................................409</a><br>
<a href="abs-guides.html#417">24.3.&nbsp;Recursion&nbsp;Without&nbsp;Local&nbsp;Variables............................................................................................411</a><br>
<a href="abs-guides.html#421"><b>Chapter&nbsp;25.&nbsp;Aliases</b></a><b>.........................................................................................................................................415</b><br>
<a href="abs-guides.html#424"><b>Chapter&nbsp;26.&nbsp;List&nbsp;Constructs...........................................................................................................................418</b></a><br>
<a href="abs-guides.html#427"><b>Chapter&nbsp;27.&nbsp;Arrays</b></a><b>.........................................................................................................................................421</b><br>
<a href="abs-guides.html#456"><b>Chapter&nbsp;28.&nbsp;Indirect&nbsp;References....................................................................................................................450</b></a><br>
<a href="abs-guides.html#460"><b>Chapter&nbsp;29.&nbsp;/dev&nbsp;and&nbsp;/proc.............................................................................................................................454</b></a><br>
<a href="abs-guides.html#460">29.1.&nbsp;/dev..............................................................................................................................................454<br></a><a href="abs-guides.html#463">29.2.&nbsp;/proc............................................................................................................................................457</a><br>
<a href="abs-guides.html#469"><b>Chapter&nbsp;30.&nbsp;Network&nbsp;Programming</b></a><b>.............................................................................................................463</b><br>
<a href="abs-guides.html#472"><b>Chapter&nbsp;31.&nbsp;Of&nbsp;Zeros&nbsp;and&nbsp;Nulls.....................................................................................................................466</b></a><br>
<a href="abs-guides.html#476"><b>Chapter&nbsp;32.&nbsp;Debugging...................................................................................................................................470</b></a><br>
<a href="abs-guides.html#487"><b>Chapter&nbsp;33.&nbsp;Options........................................................................................................................................481</b></a><br>
<a href="abs-guides.html#490"><b>Chapter&nbsp;34.&nbsp;Gotchas.......................................................................................................................................484</b></a><br>
<a href="abs-guides.html#499"><b>Chapter&nbsp;35.&nbsp;Scripting&nbsp;With&nbsp;Style</b></a><b>..................................................................................................................493</b><br>
<a href="abs-guides.html#499">35.1.&nbsp;Unofficial&nbsp;Shell&nbsp;Scripting&nbsp;Stylesheet..........................................................................................493</a><br>
<a href="abs-guides.html#502"><b>Chapter&nbsp;36.&nbsp;Miscellany...................................................................................................................................496</b></a><br>
<a href="abs-guides.html#502">36.1.&nbsp;Interactive&nbsp;and&nbsp;non-interactive&nbsp;shells&nbsp;and&nbsp;scripts.......................................................................496<br></a><a href="abs-guides.html#503">36.2.&nbsp;Shell&nbsp;Wrappers............................................................................................................................497<br></a><a href="abs-guides.html#508">36.3.&nbsp;Tests&nbsp;and&nbsp;Comparisons:&nbsp;Alternatives..........................................................................................502<br></a><a href="abs-guides.html#509">36.4.&nbsp;Recursion:&nbsp;a&nbsp;script&nbsp;calling&nbsp;itself..................................................................................................503<br></a><a href="abs-guides.html#511">36.5.&nbsp;&quot;Colorizing&quot;&nbsp;Scripts....................................................................................................................505<br></a><a href="abs-guides.html#524">36.6.&nbsp;Optimizations..............................................................................................................................518<br></a><a href="abs-guides.html#525">36.7.&nbsp;Assorted&nbsp;Tips..............................................................................................................................519</a><br>
<a href="abs-guides.html#525">36.7.1.&nbsp;Ideas&nbsp;for&nbsp;more&nbsp;powerful&nbsp;scripts.........................................................................................519<br></a><a href="abs-guides.html#535">36.7.2.&nbsp;Widgets..............................................................................................................................529</a><br>
<a href="abs-guides.html#537">36.8.&nbsp;Security&nbsp;Issues............................................................................................................................531</a><br>
<a href="abs-guides.html#537">36.8.1.&nbsp;Infected&nbsp;Shell&nbsp;Scripts.........................................................................................................531<br>36.8.2.&nbsp;Hiding&nbsp;Shell&nbsp;Script&nbsp;Source................................................................................................531</a><br>
iii<br>
<hr>
<A name=5></a>Advanced Bash-Scripting Guide<br>
<b>Table of Contents</b><br>
<a href="abs-guides.html#502"><b>Chapter&nbsp;36.&nbsp;Miscellany</b></a><br>
<a href="abs-guides.html#538">36.8.3.&nbsp;Writing&nbsp;Secure&nbsp;Shell&nbsp;Scripts.............................................................................................532</a><br>
<a href="abs-guides.html#538">36.9.&nbsp;Portability&nbsp;Issues.........................................................................................................................532</a><br>
<a href="abs-guides.html#539">36.9.1.&nbsp;A&nbsp;Test&nbsp;Suite.......................................................................................................................533</a><br>
<a href="abs-guides.html#540">36.10.&nbsp;Shell&nbsp;Scripting&nbsp;Under&nbsp;Windows...............................................................................................534</a><br>
<a href="abs-guides.html#541"><b>Chapter&nbsp;37.&nbsp;Bash,&nbsp;versions&nbsp;2,&nbsp;3,&nbsp;and&nbsp;4</b></a><b>..........................................................................................................535</b><br>
<a href="abs-guides.html#541">37.1.&nbsp;Bash,&nbsp;version&nbsp;2............................................................................................................................535<br></a><a href="abs-guides.html#545">37.2.&nbsp;Bash,&nbsp;version&nbsp;3............................................................................................................................539</a><br>
<a href="abs-guides.html#548">37.2.1.&nbsp;Bash,&nbsp;version&nbsp;3.1...............................................................................................................542<br>37.2.2.&nbsp;Bash,&nbsp;version&nbsp;3.2...............................................................................................................542</a><br>
<a href="abs-guides.html#549">37.3.&nbsp;Bash,&nbsp;version&nbsp;4............................................................................................................................543</a><br>
<a href="abs-guides.html#556">37.3.1.&nbsp;Bash,&nbsp;version&nbsp;4.1...............................................................................................................550<br></a><a href="abs-guides.html#557">37.3.2.&nbsp;Bash,&nbsp;version&nbsp;4.2...............................................................................................................551</a><br>
<a href="abs-guides.html#561"><b>Chapter&nbsp;38.&nbsp;Endnotes</b></a><b>.....................................................................................................................................555</b><br>
<a href="abs-guides.html#561">38.1.&nbsp;Author's&nbsp;Note..............................................................................................................................555<br>38.2.&nbsp;About&nbsp;the&nbsp;Author........................................................................................................................555<br>38.3.&nbsp;Where&nbsp;to&nbsp;Go&nbsp;For&nbsp;Help.................................................................................................................555<br></a><a href="abs-guides.html#562">38.4.&nbsp;Tools&nbsp;Used&nbsp;to&nbsp;Produce&nbsp;This&nbsp;Book..............................................................................................556</a><br>
<a href="abs-guides.html#562">38.4.1.&nbsp;Hardware...........................................................................................................................556<br>38.4.2.&nbsp;Software&nbsp;and&nbsp;Printware.....................................................................................................556</a><br>
<a href="abs-guides.html#562">38.5.&nbsp;Credits.........................................................................................................................................556<br></a><a href="abs-guides.html#564">38.6.&nbsp;Disclaimer...................................................................................................................................558</a><br>
<a href="abs-guides.html#565"><b>Bibliography....................................................................................................................................................559</b></a><br>
<a href="abs-guides.html#572"><b>Appendix&nbsp;A.&nbsp;Contributed&nbsp;Scripts..................................................................................................................566</b></a><br>
<a href="abs-guides.html#776"><b>Appendix&nbsp;B.&nbsp;Reference&nbsp;Cards........................................................................................................................770</b></a><br>
<a href="abs-guides.html#781"><b>Appendix&nbsp;C.&nbsp;A&nbsp;Sed&nbsp;and&nbsp;Awk&nbsp;Micro-Primer................................................................................................775</b></a><br>
<a href="abs-guides.html#781">C.1.&nbsp;Sed................................................................................................................................................775<br></a><a href="abs-guides.html#784">C.2.&nbsp;Awk..............................................................................................................................................778</a><br>
<a href="abs-guides.html#787"><b>Appendix&nbsp;D.&nbsp;Exit&nbsp;Codes&nbsp;With&nbsp;Special&nbsp;Meanings.........................................................................................781</b></a><br>
<a href="abs-guides.html#788"><b>Appendix&nbsp;E.&nbsp;A&nbsp;Detailed&nbsp;Introduction&nbsp;to&nbsp;I/O&nbsp;and&nbsp;I/O&nbsp;Redirection.............................................................782</b></a><br>
<a href="abs-guides.html#790"><b>Appendix&nbsp;F.&nbsp;Command-Line&nbsp;Options...........................................................................................................784</b></a><br>
<a href="abs-guides.html#790">F.1.&nbsp;Standard&nbsp;Command-Line&nbsp;Options................................................................................................784<br></a><a href="abs-guides.html#791">F.2.&nbsp;Bash&nbsp;Command-Line&nbsp;Options......................................................................................................785</a><br>
<a href="abs-guides.html#793"><b>Appendix&nbsp;G.&nbsp;Important&nbsp;Files.........................................................................................................................787</b></a><br>
<a href="abs-guides.html#794"><b>Appendix&nbsp;H.&nbsp;Important&nbsp;System&nbsp;Directories.................................................................................................788</b></a><br>
iv<br>
<hr>
<A name=6></a>Advanced Bash-Scripting Guide<br>
<b>Table of Contents</b><br>
<a href="abs-guides.html#796"><b>Appendix&nbsp;I.&nbsp;An&nbsp;Introduction&nbsp;to&nbsp;Programmable&nbsp;Completion</b></a><b>.....................................................................790</b><br>
<a href="abs-guides.html#799"><b>Appendix&nbsp;J.&nbsp;Localization................................................................................................................................793</b></a><br>
<a href="abs-guides.html#803"><b>Appendix&nbsp;K.&nbsp;History&nbsp;Commands..................................................................................................................797</b></a><br>
<a href="abs-guides.html#804"><b>Appendix&nbsp;L.&nbsp;Sample&nbsp;.bashrc&nbsp;and&nbsp;.bash_profile&nbsp;Files..................................................................................798</b></a><br>
<a href="abs-guides.html#819"><b>Appendix&nbsp;M.&nbsp;Converting&nbsp;DOS&nbsp;Batch&nbsp;Files&nbsp;to&nbsp;Shell&nbsp;Scripts........................................................................813</b></a><br>
<a href="abs-guides.html#823"><b>Appendix&nbsp;N.&nbsp;Exercises....................................................................................................................................817</b></a><br>
<a href="abs-guides.html#823">N.1.&nbsp;Analyzing&nbsp;Scripts.........................................................................................................................817<br></a><a href="abs-guides.html#825">N.2.&nbsp;Writing&nbsp;Scripts.............................................................................................................................819</a><br>
<a href="abs-guides.html#835"><b>Appendix&nbsp;O.&nbsp;Revision&nbsp;History.......................................................................................................................829</b></a><br>
<a href="abs-guides.html#838"><b>Appendix&nbsp;P.&nbsp;Download&nbsp;and&nbsp;Mirror&nbsp;Sites</b></a><b>.....................................................................................................832</b><br>
<a href="abs-guides.html#839"><b>Appendix&nbsp;Q.&nbsp;To&nbsp;Do&nbsp;List..................................................................................................................................833</b></a><br>
<a href="abs-guides.html#840"><b>Appendix&nbsp;R.&nbsp;Copyright</b></a><b>..................................................................................................................................834</b><br>
<a href="abs-guides.html#843"><b>Appendix&nbsp;S.&nbsp;ASCII&nbsp;Table...............................................................................................................................837</b></a><br>
<a href="abs-guides.html#844">Index....................................................................................................................................................838</a><br>
<a href="abs-guides.html#881">Notes..............................................................................................................................................875</a><br>
v<br>
<hr>
<A name=7></a><b>Chapter 1. Shell Programming!</b><br>
<i>No programming language is perfect. There is<br>not even a single best language; there are only<br>languages well suited or perhaps poorly suited<br>for particular purposes.</i><br>
<i>--Herbert Mayer</i><br>
A working knowledge of shell scripting is essential to anyone wishing to become reasonably proficient at<br>system administration, even if they do not anticipate ever having to actually write a script. Consider that as a<br>Linux machine boots up, it executes the shell scripts in&nbsp;/etc/rc.d&nbsp;to restore the system configuration and<br>set up services. A detailed understanding of these startup scripts is important for analyzing the behavior of a<br>system, and possibly modifying it.<br>
The craft of scripting is not hard to master, since the scripts can be built in bite-sized sections and there is only<br>a fairly small set of shell-specific operators and options&nbsp;[1] to learn. The syntax is simple and straightforward,<br>similar to that of invoking and chaining together utilities at the command line, and there are only a few &quot;rules&quot;<br>governing their use. Most short scripts work right the first time, and debugging even the longer ones is<br>straightforward.<br>
&nbsp; &nbsp; In the 1970s, the BASIC language enabled anyone reasonably<br>
&nbsp; &nbsp; computer proficient to write programs on an early generation of<br>
&nbsp; &nbsp; microcomputers. Decades later, the Bash scripting language enables<br>
&nbsp; &nbsp; anyone with a rudimentary knowledge of Linux or UNIX to do the same<br>
&nbsp; &nbsp; on much more powerful machines.<br>
A shell script is a quick-and-dirty method of prototyping a complex application. Getting even a limited subset<br>of the functionality to work in a script is often a useful first stage in project development. In this way, the<br>structure of the application can be tested and tinkered with, and the major pitfalls found before proceeding to<br>the final coding in<i>&nbsp;C</i>,<i>&nbsp;C++</i>,<i>&nbsp;Java</i><a href="abs-guides.html#507">, Perl, or</a><i>&nbsp;Python</i>.<br>
Shell scripting hearkens back to the classic UNIX philosophy of breaking complex projects into simpler<br>subtasks, of chaining together components and utilities. Many consider this a better, or at least more<br>esthetically pleasing approach to problem solving than using one of the new generation of high powered<br>all-in-one languages, such as<i>&nbsp;Perl</i>, which attempt to be all things to all people, but at the cost of forcing you to<br>alter your thinking processes to fit the tool.<br>
<a href="abs-guides.html#566">According to Herbert Mayer, &quot;a useful language needs arrays, pointers, and a generic mechanism for building<br></a>data structures.&quot; By these criteria, shell scripting falls somewhat short of being &quot;useful.&quot; Or, perhaps not. . . .<br>
When not to use shell scripts<br>
Resource-intensive tasks, especially where speed is a factor (sorting, hashing, recursion&nbsp;<br>
•&nbsp;<br>
[2] ...)<br>
Procedures involving heavy-duty math operations, especially floating point arithmetic, arbitrary<br>
•&nbsp;<br>
precision calculations, or complex numbers (use<i>&nbsp;C++</i>&nbsp;or<i>&nbsp;FORTRAN</i>&nbsp;instead)<br>Cross-platform portability required (use<br>
•&nbsp;<br>
<i>&nbsp;C</i>&nbsp;or<i>&nbsp;Java</i>&nbsp;instead)<br>
Chapter 1. Shell Programming!<br>
1<br>
<hr>
<A name=8></a>Advanced Bash-Scripting Guide<br>
Complex applications, where structured programming is a necessity (type-checking of variables,<br>
•&nbsp;<br>
function prototypes, etc.)<br>Mission-critical applications upon which you are betting the future of the company<br>
•&nbsp;<br>
Situations where<br>
•&nbsp;<br>
<i>&nbsp;security</i>&nbsp;is important, where you need to guarantee the integrity of your system and<br>
protect against intrusion, cracking, and vandalism<br>Project consists of subcomponents with interlocking dependencies<br>
•&nbsp;<br>
Extensive file operations required (<br>
•&nbsp;<br>
<i>Bash</i>&nbsp;is limited to serial file access, and that only in a<br>
particularly clumsy and inefficient line-by-line fashion.)<br>Need native support for multi-dimensional arrays<br>
•&nbsp;<br>
Need data structures, such as linked lists or trees<br>
•&nbsp;<br>
Need to generate / manipulate graphics or GUIs<br>
•&nbsp;<br>
Need direct access to system hardware or external peripherals<br>
•&nbsp;<br>
<a href="abs-guides.html#461">Need port or socket I/O</a><br>
•&nbsp;<br>
Need to use libraries or interface with legacy code<br>
•&nbsp;<br>
Proprietary, closed-source applications (Shell scripts put the source code right out in the open for all<br>
•&nbsp;<br>
the world to see.)<br>
If any of the above applies, consider a more powerful scripting language -- perhaps<i>&nbsp;Perl</i>,<i>&nbsp;Tcl</i>,<i>&nbsp;Python</i>,<i>&nbsp;Ruby<br></i>-- or possibly a compiled language such as<i>&nbsp;C</i>,<i>&nbsp;C++</i>, or<i>&nbsp;Java</i>. Even then, prototyping the application as a<br>shell script might still be a useful development step.<br>
We will be using Bash, an acronym&nbsp;[3] for &quot;Bourne-Again shell&quot; and a pun on Stephen Bourne's now classic<br><i>Bourne</i>&nbsp;shell. Bash has become a<i>&nbsp;de facto</i>&nbsp;standard for shell scripting on most flavors of UNIX. Most of the<br>principles this book covers apply equally well to scripting with other shells, such as the<i>&nbsp;Korn Shell</i>, from<br>which Bash derives some of its features,&nbsp;[4] and the<i>&nbsp;C Shell</i>&nbsp;and its variants. (Note that<i>&nbsp;C Shell</i>&nbsp;programming<br><a href="http://www.faqs.org/faqs/unix-faq/shell/csh-whynot/">is not recommended due to certain inherent problems, as pointed out in an October, 1993 Usenet post by Tom<br></a>Christiansen.)<br>
What follows is a tutorial on shell scripting. It relies heavily on examples to illustrate various features of the<br>shell. The example scripts work -- they've been tested, insofar as was possible -- and some of them are even<br>useful in real life. The reader can play with the actual working code of the examples in the source archive<br>(scriptname.sh&nbsp;or&nbsp;scriptname.bash),&nbsp;[5] give them<i>&nbsp;execute</i>&nbsp;permission (<b>chmod u+rx<br>scriptname</b><a href="http://bash.webofcrafts.net/abs-guide-latest.tar.bz2">), then run them to see what happens. Should the source archive not be available, then<br></a><a href="http://www.tldp.org/LDP/abs/abs-guide.html.tar.gz">cut-and-paste from the HTML or pdf rendered versions. Be aware that some of the scripts presented here<br></a>introduce features before they are explained, and this may require the reader to temporarily skip ahead for<br>enlightenment.<br>
<a href="mailto:thegrendel.abs@gmail.com">Unless otherwise noted, the author of this book wrote the example scripts that follow.</a><br>
<i>His countenance was bold and bashed not.</i><br>
<i>--Edmund Spenser</i><br>
Chapter 1. Shell Programming!<br>
2<br>
<hr>
<A name=9></a><b>Chapter 2. Starting Off With a Sha-Bang</b><br>
<i>Shell programming is a 1950s juke box . . .</i><br>
<i>--Larry Wall</i><br>
In the simplest case, a script is nothing more than a list of system commands stored in a file. At the very least,<br>this saves the effort of retyping that particular sequence of commands each time it is invoked.<br>
<b>Example 2-1.<i>&nbsp;cleanup</i></b><b>: A script to clean up log files in /var/log</b><br>
# Cleanup<br>
# Run as root, of course.<br>
cd /var/log<br>
cat /dev/null &gt; messages<br>
cat /dev/null &gt; wtmp<br>
echo &quot;Log files cleaned up.&quot;<br>
There is nothing unusual here, only a set of commands that could just as easily have been invoked one by one<br>from the command-line on the console or in a terminal window. The advantages of placing the commands in a<br>script go far beyond not having to retype them time and again. The script becomes a<i>&nbsp;program</i>&nbsp;-- a<i>&nbsp;tool</i>&nbsp;-- and it<br>can easily be modified or customized for a particular application.<br>
<b>Example 2-2.<i>&nbsp;cleanup</i></b><b>: An improved clean-up script</b><br>
#!/bin/bash<br>
# Proper header for a Bash script.<br>
# Cleanup, version 2<br>
# Run as root, of course.<br>
# Insert code here to print error message and exit if not root.<br>
LOG_DIR=/var/log<br>
# Variables are better than hard-coded values.<br>
cd $LOG_DIR<br>
cat /dev/null &gt; messages<br>
cat /dev/null &gt; wtmp<br>
echo &quot;Logs cleaned up.&quot;<br>
exit # &nbsp;The right and proper method of &quot;exiting&quot; from a script.<br>
&nbsp; &nbsp; &nbsp;# &nbsp;A bare &quot;exit&quot; (no parameter) returns the exit status<br>
&nbsp; &nbsp; &nbsp;#+ of the preceding command.&nbsp;<br>
Now<i>&nbsp;that's</i>&nbsp;beginning to look like a real script. But we can go even farther . . .<br>
<b>Example 2-3.<i>&nbsp;cleanup</i></b><b>: An enhanced and generalized version of above scripts.</b><br>
#!/bin/bash<br>
# Cleanup, version 3<br>
Chapter 2. Starting Off With a Sha-Bang<br>
3<br>
<hr>
<A name=10></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Warning:<br>
# &nbsp;-------<br>
# &nbsp;This script uses quite a number of features that will be explained<br>
#+ later on.<br>
# &nbsp;By the time you've finished the first half of the book,<br>
#+ there should be nothing mysterious about it.<br>
LOG_DIR=/var/log<br>
ROOT_UID=0 &nbsp; &nbsp; # Only users with $UID 0 have root privileges.<br>
LINES=50 &nbsp; &nbsp; &nbsp; # Default number of lines saved.<br>
E_XCD=86 &nbsp; &nbsp; &nbsp; # Can't change directory?<br>
E_NOTROOT=87 &nbsp; # Non-root exit error.<br>
# Run as root, of course.<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo &quot;Must be root to run this script.&quot;<br>
&nbsp; exit $E_NOTROOT<br>
fi &nbsp;<br>
if [ -n &quot;$1&quot; ]<br>
# Test whether command-line argument is present (non-empty).<br>
then<br>
&nbsp; lines=$1<br>
else &nbsp;<br>
&nbsp; lines=$LINES # Default, if not specified on command-line.<br>
fi &nbsp;<br>
# &nbsp;Stephane Chazelas suggests the following,<br>
#+ as a better way of checking command-line arguments,<br>
#+ but this is still a bit advanced for this stage of the tutorial.<br>
#<br>
# &nbsp; &nbsp;E_WRONGARGS=85 &nbsp;# Non-numerical argument (bad argument format).<br>
#<br>
# &nbsp; &nbsp;case &quot;$1&quot; in<br>
# &nbsp; &nbsp;&quot;&quot; &nbsp; &nbsp; &nbsp;) lines=50;;<br>
# &nbsp; &nbsp;*[!0-9]*) echo &quot;Usage: `basename $0` file-to-cleanup&quot;; exit $E_WRONGARGS;;<br>
# &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; ) lines=$1;;<br>
# &nbsp; &nbsp;esac<br>
#<br>
#* Skip ahead to &quot;Loops&quot; chapter to decipher all this.<br>
cd $LOG_DIR<br>
if [ `pwd` != &quot;$LOG_DIR&quot; ] &nbsp;# or &nbsp; if [ &quot;$PWD&quot; != &quot;$LOG_DIR&quot; ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Not in /var/log?<br>
then<br>
&nbsp; echo &quot;Can't change to $LOG_DIR.&quot;<br>
&nbsp; exit $E_XCD<br>
fi &nbsp;# Doublecheck if in right directory before messing with log file.<br>
# Far more efficient is:<br>
#<br>
# cd /var/log || {<br>
# &nbsp; echo &quot;Cannot change to necessary directory.&quot; &gt;&amp;2<br>
# &nbsp; exit $E_XCD;<br>
# }<br>
Chapter 2. Starting Off With a Sha-Bang<br>
4<br>
<hr>
<A name=11></a><IMG src="abs-guide-11_1.png"><br>
Advanced Bash-Scripting Guide<br>
tail -n $lines messages &gt; mesg.temp # Save last section of message log file.<br>
mv mesg.temp messages &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Becomes new log directory.<br>
# &nbsp;cat /dev/null &gt; messages<br>
#* No longer needed, as the above method is safer.<br>
cat /dev/null &gt; wtmp &nbsp;# &nbsp;': &gt; wtmp' and '&gt; wtmp' &nbsp;have the same effect.<br>
echo &quot;Log files cleaned up.&quot;<br>
# &nbsp;Note that there are other log files in /var/log not affected<br>
#+ by this script.<br>
exit 0<br>
# &nbsp;A zero return value from the script upon exit indicates success<br>
#+ to the shell.<br>
Since you may not wish to wipe out the entire system log, this version of the script keeps the last section of<br>the message log intact. You will constantly discover ways of fine-tuning previously written scripts for<br>increased effectiveness.<br>
* * *<br>
The<i>&nbsp;sha-bang</i>&nbsp;( #!)&nbsp;[6] at the head of a script tells your system that this file is a set of commands to be fed to<br>the command interpreter indicated. The #! is actually a two-byte&nbsp;[7]<i>&nbsp;magic number</i>, a special marker that<br>designates a file type, or in this case an executable shell script (type&nbsp;<b>man magic</b>&nbsp;for more details on this<br>fascinating topic). Immediately following the<i>&nbsp;sha-bang</i>&nbsp;is a<i>&nbsp;path name</i>. This is the path to the program that<br>interprets the commands in the script, whether it be a shell, a programming language, or a utility. This<br>command interpreter then executes the commands in the script, starting at the top (the line following the<br><i>sha-bang</i>&nbsp;line), and ignoring comments.&nbsp;[8]<br>
#!/bin/sh<br>
#!/bin/bash<br>
#!/usr/bin/perl<br>
#!/usr/bin/tcl<br>
#!/bin/sed -f<br>
#!/bin/awk -f<br>
Each of the above script header lines calls a different command interpreter, be it&nbsp;/bin/sh, the default shell<br>(<b>bash</b>&nbsp;in a Linux system) or otherwise.&nbsp;[9] Using&nbsp;<b>#!/bin/sh</b>, the default Bourne shell in most commercial<br><a href="abs-guides.html#538">variants of UNIX, makes the script portable to non-Linux machines, though you sacrifice Bash-specific<br></a><a href="abs-guides.html#494">features. The script will, however, conform to the POSIX&nbsp;</a>[10]<b>&nbsp;sh</b>&nbsp;standard.<br>
Note that the path given at the &quot;sha-bang&quot; must be correct, otherwise an error message -- usually &quot;Command<br>not found.&quot; -- will be the only result of running the script.&nbsp;[11]<br>
#! can be omitted if the script consists only of a set of generic system commands, using no internal shell<br>directives. The second example, above, requires the initial #!, since the variable assignment line,&nbsp;<b>lines=50</b>,<br>uses a shell-specific construct.&nbsp;[12] Note again that&nbsp;<b>#!/bin/sh</b>&nbsp;invokes the default shell interpreter, which<br>defaults to&nbsp;/bin/bash&nbsp;on a Linux machine.<br>
This tutorial encourages a modular approach to constructing a script. Make note of and collect<br>&quot;boilerplate&quot; code snippets that might be useful in future scripts. Eventually you will build quite an<br>extensive library of nifty routines. As an example, the following script prolog tests whether the script has<br>
Chapter 2. Starting Off With a Sha-Bang<br>
5<br>
<hr>
<A name=12></a>Advanced Bash-Scripting Guide<br>
been invoked with the correct number of parameters.<br>
E_WRONG_ARGS=85<br>
script_parameters=&quot;-a -h -m -z&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-a = all, -h = help, etc.<br>
if [ $# -ne $Number_of_expected_args ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` $script_parameters&quot;<br>
&nbsp; # `basename $0` is the script's filename.<br>
&nbsp; exit $E_WRONG_ARGS<br>
fi<br>
Many times, you will write a script that carries out one particular task. The first script in this chapter is<br>an example. Later, it might occur to you to generalize the script to do other, similar tasks. Replacing the<br>literal (&quot;hard-wired&quot;) constants by variables is a step in that direction, as is replacing repetitive code<br><a href="abs-guides.html#399">blocks by functions.</a><br>
<b>2.1. Invoking the script</b><br>
Having written the script, you can invoke it by&nbsp;<b>sh scriptname</b>,&nbsp;[13] or alternatively&nbsp;<b>bash<br>scriptname</b>. (Not recommended is using&nbsp;<b>sh &lt;scriptname</b>, since this effectively disables reading from<br><a href="abs-guides.html#788">stdin</a><a href="abs-guides.html#223">&nbsp;within the script.) Much more convenient is to make the script itself directly executable with a chmod.</a><br>
Either:<br>
<b>chmod 555 scriptname</b>&nbsp;(gives everyone read/execute permission)&nbsp;[14]<br>
or<br>
<b>chmod +rx scriptname</b>&nbsp;(gives everyone read/execute permission)<br>
<b>chmod u+rx scriptname</b>&nbsp;(gives only the script owner read/execute permission)<br>
Having made the script executable, you may now test it by&nbsp;<b>./scriptname</b>.&nbsp;[15] If it begins with a<br>&quot;sha-bang&quot; line, invoking the script calls the correct command interpreter to run it.<br>
As a final step, after testing and debugging, you would likely want to move it to&nbsp;/usr/local/bin&nbsp;(as<i>&nbsp;root</i>,<br>of course), to make the script available to yourself and all other users as a systemwide executable. The script<br>could then be invoked by simply typing<b>&nbsp;scriptname [ENTER]</b>&nbsp;from the command-line.<br>
<b>2.2. Preliminary Exercises</b><br>
System administrators often write scripts to automate common tasks. Give several instances where<br>
1.&nbsp;<br>
such scripts would be useful.<br><a href="abs-guides.html#236">Write a script that upon invocation shows the time and date, lists all logged-in users, and gives the</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#333">system uptime. The script then saves this information to a logfile.</a><br>
Chapter 2. Starting Off With a Sha-Bang<br>
6<br>
<hr>
<A name=13></a><b>Part 2. Basics</b><br>
<b>Table of Contents<br></b><a href="abs-guides.html#14">3. Special Characters<br></a><a href="abs-guides.html#36">4. Introduction to Variables and Parameters</a><br>
<a href="abs-guides.html#36">4.1. Variable Substitution<br></a><a href="abs-guides.html#39">4.2. Variable Assignment<br></a><a href="abs-guides.html#40">4.3. Bash Variables Are Untyped<br></a><a href="abs-guides.html#41">4.4. Special Variable Types</a><br>
<a href="abs-guides.html#47">5. Quoting</a><br>
<a href="abs-guides.html#47">5.1. Quoting Variables<br></a><a href="abs-guides.html#49">5.2. Escaping</a><br>
<a href="abs-guides.html#57">6. Exit and Exit Status<br></a><a href="abs-guides.html#60">7. Tests</a><br>
<a href="abs-guides.html#60">7.1. Test Constructs<br></a><a href="abs-guides.html#68">7.2. File test operators<br></a><a href="abs-guides.html#71">7.3. Other Comparison Operators<br></a><a href="abs-guides.html#76">7.4. Nested&nbsp;<i>if/then</i>&nbsp;Condition Tests<br></a><a href="abs-guides.html#77">7.5. Testing Your Knowledge of Tests</a><br>
<a href="abs-guides.html#78">8. Operations and Related Topics</a><br>
<a href="abs-guides.html#78">8.1. Operators<br></a><a href="abs-guides.html#84">8.2. Numerical Constants<br></a><a href="abs-guides.html#86">8.3. The Double-Parentheses Construct<br></a><a href="abs-guides.html#87">8.4. Operator Precedence</a><br>
Part 2. Basics<br>
7<br>
<hr>
<A name=14></a><IMG src="abs-guide-14_1.png"><br>
<IMG src="abs-guide-14_2.png"><br>
<b>Chapter 3. Special Characters</b><br>
What makes a character<i>&nbsp;special</i>? If it has a meaning beyond its<i>&nbsp;literal meaning</i><a href="abs-guides.html#887">, a meta-meaning, then we refer<br></a>to it as a<i>&nbsp;special character</i>.<br>
<b>Special Characters Found In Scripts and Elsewhere</b><br>
#<br>
<b>Comments.</b><a href="abs-guides.html#11">&nbsp;Lines beginning with a # (with the exception of &nbsp;#!) are comments and will</a><i>&nbsp;not</i>&nbsp;be<br>executed.<br>
# This line is a comment.<br>
Comments may also occur following the end of a command.<br>
echo &quot;A comment will follow.&quot; # Comment here.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ Note whitespace before #<br>
<a href="abs-guides.html#34">Comments may also follow whitespace at the beginning of a line.</a><br>
&nbsp; &nbsp; &nbsp;# A tab precedes this comment.<br>
<a href="abs-guides.html#24">Comments may even be embedded within a pipe.</a><br>
initial=( `cat &quot;$startfile&quot; | sed -e '/#/d' | tr -d '\n' |\<br>
# Delete lines containing '#' comment character.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sed -e 's/\./\. /g' -e 's/_/_ /g'` )<br>
# Excerpted from life.sh script<br>
A command may not follow a comment on the same line. There is no method of<br>terminating the comment, in order for &quot;live code&quot; to begin on the same line. Use a new<br>line for the next command.<br>
<a href="abs-guides.html#47">Of course, a quoted or an escaped # in an echo statement does</a><i>&nbsp;not</i>&nbsp;begin a comment.<br><a href="abs-guides.html#137">Likewise, a # appears in certain parameter-substitution constructs and in &nbsp;numerical<br></a><a href="abs-guides.html#84">constant expressions.</a><br>
echo &quot;The # here does not begin a comment.&quot;<br>
echo 'The # here does not begin a comment.'<br>
echo The \# here does not begin a comment.<br>
echo The # here begins a comment.<br>
echo ${PATH#*:} &nbsp; &nbsp; &nbsp; # Parameter substitution, not a comment.<br>
echo $(( 2#101011 )) &nbsp;# Base conversion, not a comment.<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#47">The standard quoting and escape characters (&quot; ' \) escape the #.</a><br>
<a href="abs-guides.html#137">Certain pattern matching operations also use the #.</a><br>
;<br>
<b>Command separator [semicolon].</b>&nbsp;Permits putting two or more commands on the same line.<br>
echo hello; echo there<br>
if [ -x &quot;$filename&quot; ]; then &nbsp; &nbsp;# &nbsp;Note the space after the semicolon.<br>
Chapter 3. Special Characters<br>
8<br>
<hr>
<A name=15></a>Advanced Bash-Scripting Guide<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
&nbsp; echo &quot;File $filename exists.&quot;; cp $filename $filename.bak<br>
else &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
&nbsp; echo &quot;File $filename not found.&quot;; touch $filename<br>
fi; echo &quot;File test complete.&quot;<br>
<a href="abs-guides.html#225">Note that the &quot;;&quot; sometimes needs to be<i>&nbsp;escaped</i>.</a><br>
;;<br>
<a href="abs-guides.html#162"><b>Terminator in a case option [double semicolon].</b></a><br>
case &quot;$variable&quot; in<br>
&nbsp; abc) &nbsp;echo &quot;\$variable = abc&quot; ;;<br>
&nbsp; xyz) &nbsp;echo &quot;\$variable = xyz&quot; ;;<br>
esac<br>
;;&amp;, ;&amp;<br>
<a href="abs-guides.html#550"><b>Terminators in a</b></a><i><b>&nbsp;case</b></i><a href="abs-guides.html#549"><b>&nbsp;option (version 4+ of Bash).</b></a><br>
.<br>
<b>&quot;dot&quot; command [period].</b><a href="abs-guides.html#210">&nbsp;Equivalent to source (see Example 15-22). This is a bash builtin.</a><br>
.<br>
<b>&quot;dot&quot;, as a component of a filename.</b>&nbsp;When working with filenames, a leading dot is the prefix of a<br><a href="abs-guides.html#220">&quot;hidden&quot; file, a file that an ls will not normally show.</a><br>
bash$&nbsp;<b>touch .hidden-file<br></b>bash$&nbsp;<b>ls -l<br></b>total 10<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp;4034 Jul 18 22:04 data1.addressbook<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp;4602 May 25 13:58 data1.addressbook.bak<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp; 877 Dec 17 &nbsp;2000 employment.addressbook<br>
bash$&nbsp;<b>ls -al<br></b>total 14<br>
&nbsp;drwxrwxr-x &nbsp; &nbsp;2 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;1024 Aug 29 20:54 ./<br>
&nbsp;drwx------ &nbsp; 52 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;3072 Aug 29 20:51 ../<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4034 Jul 18 22:04 data1.addressbook<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4602 May 25 13:58 data1.addressbook.bak<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 877 Dec 17 &nbsp;2000 employment.addressbook<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug 29 20:54 .hidden-file<br>
When considering directory names,<i>&nbsp;a single dot</i>&nbsp;represents the current working directory, and<i>&nbsp;two dots<br></i>denote the parent directory.<br>
bash$&nbsp;<b>pwd<br></b>/home/bozo/projects<br>
bash$&nbsp;<b>cd .<br></b>bash$&nbsp;<b>pwd<br></b>/home/bozo/projects<br>
bash$&nbsp;<b>cd ..<br></b>bash$&nbsp;<b>pwd<br></b>/home/bozo/<br>
The<i>&nbsp;dot</i>&nbsp;often appears as the destination (directory) of a file movement command, in this context<br>meaning<i>&nbsp;current directory</i>.<br>
Chapter 3. Special Characters<br>
9<br>
<hr>
<A name=16></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>cp /home/bozo/current_work/junk/* .</b><br>
<a href="abs-guides.html#98">Copy all the &quot;junk&quot; files to $PWD.</a><br>
.<br>
<b>&quot;dot&quot; character match.</b><a href="abs-guides.html#354">&nbsp;When matching characters, as part of a regular expression, a &quot;dot&quot; matches a<br>single character.</a><br>
&quot;<br>
<a href="abs-guides.html#36"><b>partial quoting [double quote].</b></a><i>&nbsp;&quot;STRING&quot;</i>&nbsp;preserves (from interpretation) most of the special<br>characters within<i>&nbsp;STRING</i><a href="abs-guides.html#47">. See Chapter 5.</a><br>
'<br>
<a href="abs-guides.html#36"><b>full quoting [single quote].</b></a><i>&nbsp;'STRING'</i>&nbsp;preserves all special characters within<i>&nbsp;STRING</i>. This is a<br>stronger form of quoting than<i>&nbsp;&quot;STRING&quot;</i><a href="abs-guides.html#47">. See Chapter 5.</a><br>
,<br>
<a href="abs-guides.html#84"><b>comma operator.</b></a>&nbsp;The<i>&nbsp;comma operator&nbsp;</i>[16] links together a series of arithmetic operations. All are<br>evaluated, but only the last one is returned.<br>
let &quot;t2 = ((a = 9, 15 / 3))&quot;<br>
# Set &quot;a = 9&quot; and &quot;t2 = 15 / 3&quot;<br>
The<i>&nbsp;comma</i>&nbsp;operator can also concatenate strings.<br>
for file in /{,usr/}bin/*calc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp;Find all executable files ending in &quot;calc&quot;<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in /bin and /usr/bin directories.<br>
do<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ -x &quot;$file&quot; ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $file<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
done<br>
# /bin/ipcalc<br>
# /usr/bin/kcalc<br>
# /usr/bin/oidcalc<br>
# /usr/bin/oocalc<br>
# Thank you, Rory Winston, for pointing this out.<br>
,, ,<br>
<a href="abs-guides.html#553"><b>Lowercase conversion in</b></a><i><b>&nbsp;parameter substitution</b></i><a href="abs-guides.html#549"><b>&nbsp;(added in version 4 of Bash).</b></a><br>
\<br>
<a href="abs-guides.html#49"><b>escape [backslash].</b></a>&nbsp;A quoting mechanism for single characters.<br>
<b>\X</b><i>&nbsp;escapes</i>&nbsp;the character<i>&nbsp;X</i>. This has the effect of &quot;quoting&quot;<i>&nbsp;X</i>, equivalent to<i>&nbsp;'X'</i>. The \ may be used to<br>quote &quot; and ', so they are expressed literally.<br>
<a href="abs-guides.html#47">See Chapter 5 for an in-depth explanation of escaped characters.</a><br>
/<br>
<b>Filename path separator [forward slash].</b>&nbsp;Separates the components of a filename (as in<br>/home/bozo/projects/Makefile).<br>
<a href="abs-guides.html#78">This is also the division arithmetic operator.</a><br>
`<br>
<a href="abs-guides.html#170"><b>command substitution.</b></a>&nbsp;The<b>&nbsp;`command`</b>&nbsp;construct makes available the output of<b>&nbsp;command</b>&nbsp;for<br><a href="abs-guides.html#170">assignment to a variable. This is also known as backquotes or backticks.</a><br>
Chapter 3. Special Characters<br>
10<br>
<hr>
<A name=17></a>Advanced Bash-Scripting Guide<br>
:<br>
<b>null command [colon].</b>&nbsp;This is the shell equivalent of a &quot;NOP&quot; (<i>no op</i>, a do-nothing operation). It<br><a href="abs-guides.html#214">may be considered a synonym for the shell builtin true. The &quot;:&quot; command is itself a</a><i>&nbsp;Bash</i><a href="abs-guides.html#186">&nbsp;builtin, and<br></a><a href="abs-guides.html#57">its exit status is</a><i>&nbsp;true</i>&nbsp;(0).<br>
:<br>
echo $? &nbsp; # 0<br>
Endless loop:<br>
while :<br>
do<br>
&nbsp; &nbsp;operation-1<br>
&nbsp; &nbsp;operation-2<br>
&nbsp; &nbsp;...<br>
&nbsp; &nbsp;operation-n<br>
done<br>
# Same as:<br>
# &nbsp; &nbsp;while true<br>
# &nbsp; &nbsp;do<br>
# &nbsp; &nbsp; &nbsp;...<br>
# &nbsp; &nbsp;done<br>
Placeholder in if/then test:<br>
if condition<br>
then : &nbsp; # Do nothing and branch ahead<br>
else &nbsp; &nbsp; # Or else ...<br>
&nbsp; &nbsp;take-some-action<br>
fi<br>
<a href="abs-guides.html#80">Provide a placeholder where a binary operation is expected, see Example 8-2 and default parameters.</a><br>
: ${username=`whoami`}<br>
# ${username=`whoami`} &nbsp; Gives an error without the leading :<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unless &quot;username&quot; is a command or builtin...<br>
: ${1?&quot;Usage: $0 ARGUMENT&quot;} &nbsp; &nbsp; # From &quot;usage-message.sh example script.<br>
<a href="abs-guides.html#360">Provide a placeholder where a command is expected in a here document. See Example 19-10.</a><br>
<a href="abs-guides.html#133">Evaluate string of variables using parameter substitution (as in Example 10-7).</a><br>
: ${HOSTNAME?} ${USER?} ${MAIL?}<br>
# &nbsp;Prints error message<br>
#+ if one or more of essential environmental variables not set.<br>
<a href="abs-guides.html#140"><b>Variable expansion / substring replacement</b></a>.<br>
<a href="abs-guides.html#374">In combination with the &gt; redirection operator, truncates a file to zero length, without changing its<br></a>permissions. If the file did not previously exist, creates it.<br>
: &gt; data.xxx &nbsp; # File &quot;data.xxx&quot; now empty. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
# Same effect as &nbsp; cat /dev/null &gt;data.xxx<br>
# However, this does not fork a new process, since &quot;:&quot; is a builtin.<br>
<a href="abs-guides.html#245">See also Example 16-15.</a><br>
Chapter 3. Special Characters<br>
11<br>
<hr>
<A name=18></a><IMG src="abs-guide-18_1.png"><br>
Advanced Bash-Scripting Guide<br>
In combination with the &gt;&gt; redirection operator, has no effect on a pre-existing target file (<b>: &gt;&gt;<br>target_file</b>). If the file did not previously exist, creates it.<br>
This applies to regular files, not pipes, symlinks, and certain special files.<br>
May be used to begin a comment line, although this is not recommended. Using # for a comment<br>turns off error checking for the remainder of that line, so almost anything may appear in a comment.<br>However, this is not the case with :.<br>
: This is a comment that generates an error, ( if [ $x -eq 3] ).<br>
<a href="abs-guides.html#35">The &quot;:&quot; serves as a field separator, in&nbsp;</a><a href="abs-guides.html#793">/etc/passwd</a><a href="abs-guides.html#96">, and in the $PATH variable.</a><br>
bash$&nbsp;<b>echo $PATH<br></b>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games<br>
A<i>&nbsp;colon</i><a href="abs-guides.html#402">&nbsp;is acceptable as a function name.</a><br>
:()<br>
{<br>
&nbsp; echo &quot;The name of this function is &quot;$FUNCNAME&quot;<br>
&nbsp; # Why use a colon as a function name?<br>
&nbsp; # It's a way of obfuscating your code.<br>
}<br>
:<br>
# The name of this function is :<br>
<a href="abs-guides.html#538">This is not portable behavior, and therefore not a recommended practice.</a><br>
!<br>
<b>reverse (or negate) the sense of a test or exit status [bang].</b><a href="abs-guides.html#57">&nbsp;The ! operator inverts the exit status of<br></a><a href="abs-guides.html#58">the command to which it is applied (see Example 6-2). It also inverts the meaning of a test operator.<br></a>This can, for example, change the sense of<i>&nbsp;equal</i><a href="abs-guides.html#72">&nbsp;( = ) to</a><i>&nbsp;not-equal</i>&nbsp;( != ). The ! operator is a Bash<br><a href="abs-guides.html#187">keyword.</a><br>
<a href="abs-guides.html#456">In a different context, the ! also appears in indirect variable references.</a><br>
In yet another context, from the<i>&nbsp;command line</i>, the ! invokes the Bash<i>&nbsp;history mechanism</i>&nbsp;(see<br><a href="abs-guides.html#803">Appendix K). Note that within a script, the history mechanism is disabled.</a><br>
*<br>
<b>wild card [asterisk].</b><a href="abs-guides.html#358">&nbsp;The * character serves as a &quot;wild card&quot; for filename expansion in globbing. By<br></a>itself, it matches every filename in a given directory.<br>
bash$&nbsp;<b>echo *<br></b>abs-book.sgml add-drive.sh agram.sh alias.sh<br>
<a href="abs-guides.html#354">The * also represents any number (or zero) characters in a regular expression.</a><br>
*<br>
<a href="abs-guides.html#78"><b>arithmetic operator.</b></a>&nbsp;In the context of arithmetic operations, the * denotes multiplication.<br>
<a href="abs-guides.html#78">** A double asterisk can represent the exponentiation operator or extended file-match</a><a href="abs-guides.html#555"><i>&nbsp;globbing</i></a>.<br>
?<br>
<b>test operator.</b>&nbsp;Within certain expressions, the ? indicates a test for a condition.<br>
Chapter 3. Special Characters<br>
12<br>
<hr>
<A name=19></a><IMG src="abs-guide-19_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#86">In a double-parentheses construct, the ? can serve as an element of a C-style</a><i>&nbsp;trinary</i>&nbsp;operator.<br>
condition<b>?</b>result-if-true<b>:</b>result-if-false<br>
(( var0 = var1&lt;98?9:21 ))<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ ^<br>
# if [ &quot;$var1&quot; -lt 98 ]<br>
# then<br>
# &nbsp; var0=9<br>
# else<br>
# &nbsp; var0=21<br>
# fi<br>
<a href="abs-guides.html#133">In a parameter substitution expression, the ? tests whether a variable has been set.</a><br>
?<br>
<b>wild card.&nbsp;</b>The ? character serves as a single-character &quot;wild card&quot; for filename expansion in<br><a href="abs-guides.html#358">globbing, as well as representing one character in an extended regular expression.</a><br>
$<br>
<a href="abs-guides.html#36"><b>Variable substitution (contents of a variable).</b></a><br>
var1=5<br>
var2=23skidoo<br>
echo $var1 &nbsp; &nbsp; # 5<br>
echo $var2 &nbsp; &nbsp; # 23skidoo<br>
A $ prefixing a variable name indicates the<i>&nbsp;value</i>&nbsp;the variable holds.<br>
$<br>
<b>end-of-line.</b><a href="abs-guides.html#354">&nbsp;In a regular expression, a &quot;$&quot; addresses the end of a line of text.</a><br>
${}<br>
<a href="abs-guides.html#133"><b>Parameter substitution.</b></a><br>
$' ... '<br>
<a href="abs-guides.html#50"><b>Quoted string expansion.</b></a>&nbsp;This construct expands single or multiple escaped octal or hex values into<br>ASCII&nbsp;<a href="abs-guides.html#557">[17] or Unicode characters.</a><br>
$*, $@<br>
<a href="abs-guides.html#104"><b>positional parameters.</b></a><br>
$?<br>
<b>exit status variable.</b><a href="abs-guides.html#58">&nbsp;The $? variable holds the exit status of a command, a function, or of the script<br></a>itself.<br>
$$<br>
<b>process ID variable.</b><a href="abs-guides.html#109">&nbsp;The $$ variable holds the</a><i>&nbsp;process ID&nbsp;</i>[18] of the script in which it appears.<br>
()<br>
<b>command group.</b><br>
(a=hello; echo $a)<br>
A listing of commands within&nbsp;<i>parentheses</i><a href="abs-guides.html#387">&nbsp;starts a subshell.</a><br>
Variables inside parentheses, within the subshell, are not visible to the rest of the<br><a href="abs-guides.html#388">script. The parent process, the script, cannot read variables created in the child<br>process, the subshell.</a><br>
Chapter 3. Special Characters<br>
13<br>
<hr>
<A name=20></a><IMG src="abs-guide-20_1.png"><br>
Advanced Bash-Scripting Guide<br>
a=123<br>
( a=321; ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
echo &quot;a = $a&quot; &nbsp; # a = 123<br>
# &quot;a&quot; within parentheses acts like a local variable.<br>
<b>array initialization.</b><br>
Array=(element1 element2 element3)<br>
{xxx,yyy,zzz,...}<br>
<b>Brace expansion.</b><br>
echo \&quot;{These,words,are,quoted}\&quot; &nbsp; # &quot; prefix and suffix<br>
# &quot;These&quot; &quot;words&quot; &quot;are&quot; &quot;quoted&quot;<br>
cat {file1,file2,file3} &gt; combined_file<br>
# Concatenates the files file1, file2, and file3 into combined_file.<br>
cp file22.{txt,backup}<br>
# Copies &quot;file22.txt&quot; to &quot;file22.backup&quot;<br>
A command may act upon a comma-separated list of file specs within&nbsp;<i>braces</i>.&nbsp;[19] Filename<br><a href="abs-guides.html#358">expansion (globbing) applies to the file specs between the braces.</a><br>
No spaces allowed within the braces<i>&nbsp;unless</i>&nbsp;the spaces are quoted or escaped.<br>
<b>echo {file1,file2}\ :{\ A,&quot; B&quot;,' C'}</b><br>
file1 : A file1 : B file1 : C file2 : A file2 : B file2 :<br>
C<br>
{a..z}<br>
<b>Extended Brace expansion.</b><br>
echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
# Echoes characters between a and z.<br>
echo {0..3} # 0 1 2 3<br>
# Echoes characters between 0 and 3.<br>
base64_charset=( {A..Z} {a..z} {0..9} + / = )<br>
# Initializing an array, using extended brace expansion.<br>
# From vladz's &quot;base64.sh&quot; example script.<br>
The<i>&nbsp;{a..z}</i><a href="abs-guides.html#546">&nbsp;extended brace expansion construction is a feature introduced in version 3 of</a><i>&nbsp;Bash</i>.<br>
{}<br>
<b>Block of code [curly brackets].</b>&nbsp;Also referred to as an<i>&nbsp;inline group</i>, this construct, in effect, creates<br>an<i>&nbsp;anonymous function</i><a href="abs-guides.html#399">&nbsp;(a function without a name). However, unlike in a &quot;standard&quot; function, the<br></a>variables inside a code block remain visible to the remainder of the script.<br>
bash$&nbsp;<b>{ local a;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a=123; }<br></b>bash: local: can only be used in a<br>
function<br>
Chapter 3. Special Characters<br>
14<br>
<hr>
<A name=21></a>Advanced Bash-Scripting Guide<br>
a=123<br>
{ a=321; }<br>
echo &quot;a = $a&quot; &nbsp; # a = 321 &nbsp; (value inside code block)<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#374">The code block enclosed in braces may have I/O redirected to and from it.</a><br>
<b>Example 3-1. Code blocks and I/O redirection</b><br>
#!/bin/bash<br>
# Reading lines in /etc/fstab.<br>
File=/etc/fstab<br>
{<br>
read line1<br>
read line2<br>
} &lt; $File<br>
echo &quot;First line in $File is:&quot;<br>
echo &quot;$line1&quot;<br>
echo<br>
echo &quot;Second line in $File is:&quot;<br>
echo &quot;$line2&quot;<br>
exit 0<br>
# Now, how do you parse the separate fields of each line?<br>
# Hint: use awk, or . . .<br>
# . . . Hans-Joerg Diers suggests using the &quot;set&quot; Bash builtin.<br>
<b>Example 3-2. Saving the output of a code block to a file</b><br>
#!/bin/bash<br>
# rpm-check.sh<br>
# &nbsp;Queries an rpm file for description, listing,<br>
#+ and whether it can be installed.<br>
# &nbsp;Saves output to a file.<br>
#&nbsp;<br>
# &nbsp;This script illustrates using a code block.<br>
SUCCESS=0<br>
E_NOARGS=65<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` rpm-file&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi &nbsp;<br>
{ # Begin code block.<br>
&nbsp; echo<br>
&nbsp; echo &quot;Archive Description:&quot;<br>
&nbsp; rpm -qpi $1 &nbsp; &nbsp; &nbsp; # Query description.<br>
&nbsp; echo<br>
Chapter 3. Special Characters<br>
15<br>
<hr>
<A name=22></a><IMG src="abs-guide-22_1.png"><br>
<IMG src="abs-guide-22_2.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Archive Listing:&quot;<br>
&nbsp; rpm -qpl $1 &nbsp; &nbsp; &nbsp; # Query listing.<br>
&nbsp; echo<br>
&nbsp; rpm -i --test $1 &nbsp;# Query whether rpm file can be installed.<br>
&nbsp; if [ &quot;$?&quot; -eq $SUCCESS ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$1 can be installed.&quot;<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;$1 cannot be installed.&quot;<br>
&nbsp; fi &nbsp;<br>
&nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# End code block.<br>
} &gt; &quot;$1.test&quot; &nbsp; &nbsp; &nbsp; # Redirects output of everything in block to file.<br>
echo &quot;Results of rpm test in file $1.test&quot;<br>
# See rpm man page for explanation of options.<br>
exit 0<br>
Unlike a command group within (parentheses), as above, a code block enclosed by<br>{braces} will<i>&nbsp;not</i><a href="abs-guides.html#387">&nbsp;normally launch a subshell.&nbsp;</a>[20]<br>
{}<br>
<b>placeholder for text.</b><a href="abs-guides.html#230">&nbsp;Used after xargs&nbsp;-i&nbsp;(</a><i>replace strings</i>&nbsp;option). The {} double curly brackets are a<br>placeholder for output text.<br>
ls . | xargs -i -t cp ./{} $1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^ &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
# From &quot;ex42.sh&quot; (copydir.sh) example.<br>
{} \;<br>
<b>pathname.</b><a href="abs-guides.html#225">&nbsp;Mostly used in find constructs. This is</a><i>&nbsp;not</i><a href="abs-guides.html#186">&nbsp;a shell builtin.</a><br>
The &quot;;&quot; ends the&nbsp;-exec&nbsp;option of a<b>&nbsp;find</b>&nbsp;command sequence. It needs to be escaped to<br>protect it from interpretation by the shell.<br>
[ ]<br>
<b>test.</b><br>
<a href="abs-guides.html#60">Test expression between</a><b>&nbsp;[ ]</b>. Note that<b>&nbsp;[</b>&nbsp;is part of the shell<i>&nbsp;builtin</i><a href="abs-guides.html#64">&nbsp;test (and a synonym for it),</a><i>&nbsp;not</i>&nbsp;a<br>link to the external command&nbsp;/usr/bin/test.<br>
[[ ]]<br>
<b>test.</b><br>
<a href="abs-guides.html#187">Test expression between [[ ]]. More flexible than the single-bracket [ ] test, this is a shell keyword.</a><br>
<a href="abs-guides.html#65">See the discussion on the [[ ... ]] construct.</a><br>
[ ]<br>
<b>array element.</b><br>
<a href="abs-guides.html#427">In the context of an array, brackets set off the numbering of each element of that array.</a><br>
Array[1]=slot_1<br>
echo ${Array[1]}<br>
[ ]<br>
<b>range of characters.</b><br>
Chapter 3. Special Characters<br>
16<br>
<hr>
<A name=23></a><IMG src="abs-guide-23_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#354">As part of a regular expression, brackets delineate a range of characters to match.</a><br>
$[ ... ]<br>
<b>integer expansion.</b><br>
Evaluate integer expression between $[ ].<br>
a=3<br>
b=7<br>
echo $[$a+$b] &nbsp; # 10<br>
echo $[$a*$b] &nbsp; # 21<br>
Note that this usage is<i>&nbsp;deprecated</i><a href="abs-guides.html#86">, and has been replaced by the (( ... )) construct.</a><br>
(( ))<br>
<b>integer expansion.</b><br>
Expand and evaluate integer expression between (( )).<br>
<a href="abs-guides.html#86">See the discussion on the (( ... )) construct.</a><br>
&gt; &amp;&gt; &gt;&amp; &gt;&gt; &lt; &lt;&gt;<br>
<a href="abs-guides.html#374"><b>redirection.</b></a><br>
<b>scriptname &gt;filename</b>&nbsp;redirects the output of&nbsp;scriptname&nbsp;to file&nbsp;filename. Overwrite<br>filename&nbsp;if it already exists.<br>
<b>command &amp;&gt;filename</b>&nbsp;redirects both the&nbsp;<a href="abs-guides.html#788">stdout</a>&nbsp;and the&nbsp;stderr&nbsp;of&nbsp;command&nbsp;to&nbsp;filename.<br>
This is useful for suppressing output when testing for a condition. For example, let us<br>test whether a certain command exists.<br>
bash$&nbsp;<b>type bogus_command &amp;&gt;/dev/null</b><br>
bash$&nbsp;<b>echo $?<br></b>1<br>
Or in a script:<br>
command_test () { type &quot;$1&quot; &amp;&gt;/dev/null; }<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
cmd=rmdir &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Legitimate command.<br>
command_test $cmd; echo $? &nbsp; # 0<br>
cmd=bogus_command &nbsp; &nbsp;# Illegitimate command<br>
command_test $cmd; echo $? &nbsp; # 1<br>
<b>command &gt;&amp;2</b>&nbsp;redirects&nbsp;stdout&nbsp;of&nbsp;command&nbsp;to&nbsp;stderr.<br>
<b>scriptname &gt;&gt;filename</b>&nbsp;appends the output of&nbsp;scriptname&nbsp;to file&nbsp;filename. If<br>filename&nbsp;does not already exist, it is created.<br>
Chapter 3. Special Characters<br>
17<br>
<hr>
<A name=24></a>Advanced Bash-Scripting Guide<br>
<b>[i]&lt;&gt;filename</b>&nbsp;opens file&nbsp;filename<a href="abs-guides.html#374">&nbsp;for reading and writing, and assigns file descriptor i to it. If<br></a>filename&nbsp;does not exist, it is created.<br>
<a href="abs-guides.html#394"><b>process substitution.</b></a><br>
<b>(command)&gt;</b><br>
<b>&lt;(command)</b><br>
<a href="abs-guides.html#72">In a different context, the &quot;&lt;&quot; and &quot;&gt;&quot; characters act as string comparison operators.</a><br>
<a href="abs-guides.html#71">In yet another context, the &quot;&lt;&quot; and &quot;&gt;&quot; characters act as integer comparison operators. See also<br></a><a href="abs-guides.html#233">Example 16-9.</a><br>
&lt;&lt;<br>
<a href="abs-guides.html#360"><b>redirection used in a here document.</b></a><br>
&lt;&lt;&lt;<br>
<a href="abs-guides.html#370"><b>redirection used in a here string.</b></a><br>
&lt;, &gt;<br>
<a href="abs-guides.html#72"><b>ASCII comparison.</b></a><br>
veg1=carrots<br>
veg2=tomatoes<br>
if [[ &quot;$veg1&quot; &lt; &quot;$veg2&quot; ]]<br>
then<br>
&nbsp; echo &quot;Although $veg1 precede $veg2 in the dictionary,&quot;<br>
&nbsp; echo -n &quot;this does not necessarily imply anything &quot;<br>
&nbsp; echo &quot;about my culinary preferences.&quot;<br>
else<br>
&nbsp; echo &quot;What kind of dictionary are you using, anyhow?&quot;<br>
fi<br>
\&lt;, \&gt;<br>
<a href="abs-guides.html#355"><b>word boundary in a regular expression.</b></a><br>
bash$&nbsp;<b>grep '\&lt;the\&gt;' textfile</b><br>
|<br>
<b>pipe.</b>&nbsp;Passes the output (stdout&nbsp;of a previous command to the input (stdin) of the next one, or to<br>the shell. This is a method of chaining commands together.<br>
echo ls -l | sh<br>
# &nbsp;Passes the output of &quot;echo ls -l&quot; to the shell,<br>
#+ with the same result as a simple &quot;ls -l&quot;.<br>
cat *.lst | sort | uniq<br>
# Merges and sorts all &quot;.lst&quot; files, then deletes duplicate lines.<br>
A pipe, as a classic method of interprocess communication, sends the&nbsp;stdout<a href="abs-guides.html#882">&nbsp;of one process to the<br></a>stdin<a href="abs-guides.html#221">&nbsp;of another. In a typical case, a command, such as cat or echo, pipes a stream of data to a&nbsp;<br></a><i>filter</i>, a command that transforms its input for processing.&nbsp;[21]<br>
<b>cat $filename1 $filename2 | grep $search_word</b><br>
Chapter 3. Special Characters<br>
18<br>
<hr>
<A name=25></a><IMG src="abs-guide-25_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="http://www.faqs.org/faqs/unix-faq/faq/part3/">For an interesting note on the complexity of using UNIX pipes, see the UNIX FAQ, Part 3.</a><br>
The output of a command or commands may be piped to a script.<br>
#!/bin/bash<br>
# uppercase.sh : Changes input to uppercase.<br>
tr 'a-z' 'A-Z'<br>
# &nbsp;Letter ranges must be quoted<br>
#+ to prevent filename generation from single-letter filenames.<br>
exit 0<br>
Now, let us pipe the output of<b>&nbsp;ls -l</b>&nbsp;to this script.<br>
bash$&nbsp;<b>ls -l | ./uppercase.sh<br></b>-RW-RW-R-- &nbsp; &nbsp;1 BOZO &nbsp;BOZO &nbsp; &nbsp; &nbsp; 109 APR &nbsp;7 19:49 1.TXT<br>
&nbsp;-RW-RW-R-- &nbsp; &nbsp;1 BOZO &nbsp;BOZO &nbsp; &nbsp; &nbsp; 109 APR 14 16:48 2.TXT<br>
&nbsp;-RW-R--R-- &nbsp; &nbsp;1 BOZO &nbsp;BOZO &nbsp; &nbsp; &nbsp; 725 APR 20 20:56 DATA-FILE<br>
The&nbsp;stdout&nbsp;of each process in a pipe must be read as the&nbsp;stdin&nbsp;of the next. If this<br>is not the case, the data stream will<i>&nbsp;block</i>, and the pipe will not behave as expected.<br>
cat file1 file2 | ls -l | sort<br>
# The output from &quot;cat file1 file2&quot; disappears.<br>
<a href="abs-guides.html#42">A pipe runs as a child process, and therefore cannot alter script variables.</a><br>
variable=&quot;initial_value&quot;<br>
echo &quot;new_value&quot; | read variable<br>
echo &quot;variable = $variable&quot; &nbsp; &nbsp; # variable = initial_value<br>
If one of the commands in the pipe aborts, this prematurely terminates execution of the<br>pipe. Called a<i>&nbsp;broken pipe</i>, this condition sends a&nbsp;<i>SIGPIPE</i><a href="abs-guides.html#479">&nbsp;signal.</a><br>
&gt;|<br>
<a href="abs-guides.html#488"><b>force redirection (even if the noclobber option is set).</b></a>&nbsp;This will forcibly overwrite an existing file.<br>
||<br>
<a href="abs-guides.html#83"><b>OR logical operator.</b></a><a href="abs-guides.html#60">&nbsp;In a test construct, the || operator causes a return of 0 (success) if</a><i>&nbsp;either</i>&nbsp;of the<br>linked test conditions is true.<br>
&amp;<br>
<b>Run job in background.</b>&nbsp;A command followed by an &amp; will run in the background.<br>
bash$&nbsp;<b>sleep 10 &amp;<br></b>[1] 850<br>
[1]+ &nbsp;Done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sleep 10<br>
<a href="abs-guides.html#144">Within a script, commands and even loops may run in the background.</a><br>
<b>Example 3-3. Running a loop in the background</b><br>
#!/bin/bash<br>
# background-loop.sh<br>
for i in 1 2 3 4 5 6 7 8 9 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# First loop.<br>
do<br>
&nbsp; echo -n &quot;$i &quot;<br>
Chapter 3. Special Characters<br>
19<br>
<hr>
<A name=26></a><IMG src="abs-guide-26_1.png"><br>
Advanced Bash-Scripting Guide<br>
done &amp; # Run this loop in background.<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Will sometimes execute after second loop.<br>
echo &nbsp; # This 'echo' sometimes will not display.<br>
for i in 11 12 13 14 15 16 17 18 19 20 &nbsp; # Second loop.<br>
do<br>
&nbsp; echo -n &quot;$i &quot;<br>
done &nbsp;<br>
echo &nbsp; # This 'echo' sometimes will not display.<br>
# ======================================================<br>
# The expected output from the script:<br>
# 1 2 3 4 5 6 7 8 9 10&nbsp;<br>
# 11 12 13 14 15 16 17 18 19 20&nbsp;<br>
# Sometimes, though, you get:<br>
# 11 12 13 14 15 16 17 18 19 20&nbsp;<br>
# 1 2 3 4 5 6 7 8 9 10 bozo $<br>
# (The second 'echo' doesn't execute. Why?)<br>
# Occasionally also:<br>
# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20<br>
# (The first 'echo' doesn't execute. Why?)<br>
# Very rarely something like:<br>
# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20&nbsp;<br>
# The foreground loop preempts the background one.<br>
exit 0<br>
# &nbsp;Nasimuddin Ansari suggests adding &nbsp; &nbsp;sleep 1<br>
#+ after the &nbsp; echo -n &quot;$i&quot; &nbsp; in lines 6 and 14,<br>
#+ for some real fun.<br>
A command run in the background within a script may cause the script to hang,<br><a href="abs-guides.html#216">waiting for a keystroke. Fortunately, there is a remedy for this.</a><br>
&amp;&amp;<br>
<a href="abs-guides.html#82"><b>AND logical operator.</b></a><a href="abs-guides.html#60">&nbsp;In a test construct, the &amp;&amp; operator causes a return of 0 (success) only if</a><i>&nbsp;both<br></i>the linked test conditions are true.<br>
-<br>
<b>option, prefix.</b><a href="abs-guides.html#134">&nbsp;Option flag for a command or filter. Prefix for an operator. Prefix for a default<br>parameter in parameter substitution.</a><br>
<b>COMMAND -[Option1][Option2][...]</b><br>
<b>ls -al</b><br>
<b>sort -dfu $filename</b><br>
if [ $file1 -ot $file2 ]<br>
then # &nbsp; &nbsp; &nbsp;^<br>
&nbsp; echo &quot;File $file1 is older than $file2.&quot;<br>
fi<br>
if [ &quot;$a&quot; -eq &quot;$b&quot; ]<br>
Chapter 3. Special Characters<br>
20<br>
<hr>
<A name=27></a><IMG src="abs-guide-27_1.png"><br>
Advanced Bash-Scripting Guide<br>
then # &nbsp; &nbsp;^<br>
&nbsp; echo &quot;$a is equal to $b.&quot;<br>
fi<br>
if [ &quot;$c&quot; -eq 24 -a &quot;$d&quot; -eq 47 ]<br>
then # &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
&nbsp; echo &quot;$c equals 24 and $d equals 47.&quot;<br>
fi<br>
param2=${param1:-$DEFAULTVAL}<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
<b>--</b><br>
The<i>&nbsp;double-dash&nbsp;</i>--&nbsp;prefixes<i>&nbsp;long</i>&nbsp;(verbatim) options to commands.<br>
<b>sort --ignore-leading-blanks</b><br>
<a href="abs-guides.html#186">Used with a Bash builtin, it means the</a><i>&nbsp;end of options</i>&nbsp;to that particular command.<br>
This provides a handy means of removing files whose<i>&nbsp;names begin with a dash</i>.<br>
bash$&nbsp;<b>ls -l<br></b>-rw-r--r-- 1 bozo bozo 0 Nov 25 12:29 -badname<br>
bash$&nbsp;<b>rm -- -badname</b><br>
bash$&nbsp;<b>ls -l<br></b>total 0<br>
The<i>&nbsp;double-dash</i><a href="abs-guides.html#203">&nbsp;is also used in conjunction with set.</a><br>
<b>set -- $variable</b><a href="abs-guides.html#205">&nbsp;(as in Example 15-18)</a><br>
-<br>
<b>redirection from/to&nbsp;stdin&nbsp;or&nbsp;stdout&nbsp;[dash].</b><br>
bash$&nbsp;<b>cat -<br>abc<br></b>abc<br>
...<br>
<b>Ctl-D</b><br>
As expected,&nbsp;<b>cat -</b>&nbsp;echoes&nbsp;stdin, in this case keyboarded user input, to&nbsp;stdout. But, does I/O<br>redirection using<b>&nbsp;-</b>&nbsp;have real-world applications?<br>
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)<br>
# Move entire file tree from one directory to another<br>
# [courtesy Alan Cox &lt;a.cox@swansea.ac.uk&gt;, with a minor change]<br>
# 1) cd /source/directory<br>
# &nbsp; &nbsp;Source directory, where the files to be moved are.<br>
# 2) &amp;&amp;<br>
# &nbsp; &quot;And-list&quot;: if the 'cd' operation successful,<br>
# &nbsp; &nbsp;then execute the next command.<br>
Chapter 3. Special Characters<br>
21<br>
<hr>
<A name=28></a>Advanced Bash-Scripting Guide<br>
# 3) tar cf - .<br>
# &nbsp; &nbsp;The 'c' option 'tar' archiving command creates a new archive,<br>
# &nbsp; &nbsp;the 'f' (file) option, followed by '-' designates the target file<br>
# &nbsp; &nbsp;as stdout, and do it in current directory tree ('.').<br>
# 4) |<br>
# &nbsp; &nbsp;Piped to ...<br>
# 5) ( ... )<br>
# &nbsp; &nbsp;a subshell<br>
# 6) cd /dest/directory<br>
# &nbsp; &nbsp;Change to the destination directory.<br>
# 7) &amp;&amp;<br>
# &nbsp; &quot;And-list&quot;, as above<br>
# 8) tar xpvf -<br>
# &nbsp; &nbsp;Unarchive ('x'), preserve ownership and file permissions ('p'),<br>
# &nbsp; &nbsp;and send verbose messages to stdout ('v'),<br>
# &nbsp; &nbsp;reading data from stdin ('f' followed by '-').<br>
#<br>
# &nbsp; &nbsp;Note that 'x' is a command, and 'p', 'v', 'f' are options.<br>
#<br>
# Whew!<br>
# More elegant than, but equivalent to:<br>
# &nbsp; cd source/directory<br>
# &nbsp; tar cf - . | (cd ../dest/directory; tar xpvf -)<br>
#<br>
# &nbsp; &nbsp; Also having same effect:<br>
# cp -a /source/directory/* /dest/directory<br>
# &nbsp; &nbsp; Or:<br>
# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory<br>
# &nbsp; &nbsp; If there are hidden files in /source/directory.<br>
bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -<br>
# &nbsp;--uncompress tar file-- &nbsp; &nbsp; &nbsp;| --then pass it to &quot;tar&quot;--<br>
# &nbsp;If &quot;tar&quot; has not been patched to handle &quot;bunzip2&quot;,<br>
#+ this needs to be done in two discrete steps, using a pipe.<br>
# &nbsp;The purpose of the exercise is to unarchive &quot;bzipped&quot; kernel source.<br>
Note that in this context the &quot;-&quot; is not itself a Bash operator, but rather an option recognized by certain<br>UNIX utilities that write to&nbsp;stdout, such as<b>&nbsp;tar</b>,<b>&nbsp;cat</b>, etc.<br>
bash$&nbsp;<b>echo &quot;whatever&quot; | cat -<br></b>whatever<br>
Where a filename is expected,&nbsp;<i>-</i>&nbsp;redirects output to&nbsp;stdout&nbsp;(sometimes seen with&nbsp;<b>tar cf</b>), or<br>accepts input from&nbsp;stdin, rather than from a file.&nbsp;&nbsp;This is a method of using a file-oriented utility as<br>a filter in a pipe.<br>
bash$&nbsp;<b>file<br></b>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...<br>
<a href="abs-guides.html#266">By itself on the command-line, file fails with an error message.</a><br>
Add a &quot;-&quot; for a more useful result. This causes the shell to await user input.<br>
bash$&nbsp;<b>file -<br>abc<br></b>standard input: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ASCII text<br>
Chapter 3. Special Characters<br>
22<br>
<hr>
<A name=29></a><IMG src="abs-guide-29_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>file -<br>#!/bin/bash<br></b>standard input: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bourne-Again shell script text executable<br>
Now the command accepts input from&nbsp;stdin&nbsp;and analyzes it.<br>
The &quot;-&quot; can be used to pipe&nbsp;stdout<a href="abs-guides.html#525">&nbsp;to other commands. This permits such stunts as prepending lines<br>to a file.</a><br>
<a href="abs-guides.html#271">Using diff to compare a file with a</a><i>&nbsp;section</i>&nbsp;of another:<br>
<b>grep Linux file1 | diff file2 -</b><br>
Finally, a real-world example using&nbsp;<i>-</i><a href="abs-guides.html#262">&nbsp;with tar.</a><br>
<b>Example 3-4. Backup of all files changed in last day</b><br>
#!/bin/bash<br>
# &nbsp;Backs up all files in current directory modified within last 24 hours<br>
#+ in a &quot;tarball&quot; (tarred and gzipped file).<br>
BACKUPFILE=backup-$(date +%m-%d-%Y)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Embeds date in backup filename.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thanks, Joshua Tschida, for the idea.<br>
archive=${1:-$BACKUPFILE}<br>
# &nbsp;If no backup-archive filename specified on command-line,<br>
#+ it will default to &quot;backup-MM-DD-YYYY.tar.gz.&quot;<br>
tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar<br>
gzip $archive.tar<br>
echo &quot;Directory $PWD backed up in archive file \&quot;$archive.tar.gz\&quot;.&quot;<br>
# &nbsp;Stephane Chazelas points out that the above code will fail<br>
#+ if there are too many files found<br>
#+ or if any filenames contain blank characters.<br>
# He suggests the following alternatives:<br>
# -------------------------------------------------------------------<br>
# &nbsp; find . -mtime -1 -type f -print0 | xargs -0 tar rvf &quot;$archive.tar&quot;<br>
# &nbsp; &nbsp; &nbsp;using the GNU version of &quot;find&quot;.<br>
# &nbsp; find . -mtime -1 -type f -exec tar rvf &quot;$archive.tar&quot; '{}' \;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; portable to other UNIX flavors, but much slower.<br>
# -------------------------------------------------------------------<br>
exit 0<br>
Filenames beginning with &quot;-&quot; may cause problems when coupled with the &quot;-&quot;<br>redirection operator. A script should check for this and add an appropriate prefix to<br>such filenames, for example&nbsp;./-FILENAME,&nbsp;$PWD/-FILENAME, or<br>
Chapter 3. Special Characters<br>
23<br>
<hr>
<A name=30></a><IMG src="abs-guide-30_1.png"><br>
Advanced Bash-Scripting Guide<br>
$PATHNAME/-FILENAME.<br>
If the value of a variable begins with a&nbsp;<i>-</i>, this may likewise create problems.<br>
var=&quot;-n&quot;<br>
echo $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
# Has the effect of &quot;echo -n&quot;, and outputs nothing.<br>
-<br>
<b>previous working directory.</b>&nbsp;A<b>&nbsp;cd -</b>&nbsp;command changes to the previous working directory. This uses<br><a href="abs-guides.html#96">the $OLDPWD environmental variable.</a><br>
Do not confuse the &quot;-&quot; used in this sense with the &quot;-&quot; redirection operator just<br>discussed. The interpretation of the &quot;-&quot; depends on the context in which it appears.<br>
-<br>
<b>Minus.</b><a href="abs-guides.html#78">&nbsp;Minus sign in an arithmetic operation.</a><br>
=<br>
<b>Equals.</b><a href="abs-guides.html#39">&nbsp;Assignment operator</a><br>
a=28<br>
echo $a &nbsp; # 28<br>
<a href="abs-guides.html#72">In a different context, the &quot;=&quot; is a string comparison operator.</a><br>
+<br>
<b>Plus.</b><a href="abs-guides.html#78">&nbsp;Addition arithmetic operator.</a><br>
<a href="abs-guides.html#356">In a different context, the + is a Regular Expression operator.</a><br>
+<br>
<b>Option.</b>&nbsp;Option flag for a command or filter.<br>
<a href="abs-guides.html#186">Certain commands and builtins use the&nbsp;</a>+&nbsp;to enable certain options and the&nbsp;-&nbsp;to disable them. In<br><a href="abs-guides.html#133">parameter substitution, the&nbsp;</a>+<a href="abs-guides.html#135">&nbsp;prefixes an &nbsp;alternate value that a variable expands to.</a><br>
%<br>
<a href="abs-guides.html#78"><b>modulo.</b>&nbsp;Modulo (remainder of a division) arithmetic operation.</a><br>
let &quot;z = 5 % 3&quot;<br>
echo $z &nbsp;# 2<br>
<a href="abs-guides.html#139">In a different context, the % is a pattern matching operator.</a><br>
~<br>
<b>home directory [tilde].</b><a href="abs-guides.html#93">&nbsp;This corresponds to the $HOME internal variable.&nbsp;</a>~bozo&nbsp;is bozo's home<br>directory, and<b>&nbsp;ls ~bozo</b>&nbsp;lists the contents of it. ~/ is the current user's home directory, and<b>&nbsp;ls ~/</b>&nbsp;lists the<br>contents of it.<br>
bash$&nbsp;<b>echo ~bozo<br></b>/home/bozo<br>
bash$&nbsp;<b>echo ~<br></b>/home/bozo<br>
bash$&nbsp;<b>echo ~/<br></b>/home/bozo/<br>
bash$&nbsp;<b>echo ~:<br></b>/home/bozo:<br>
Chapter 3. Special Characters<br>
24<br>
<hr>
<A name=31></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>echo ~nonexistent-user<br></b>~nonexistent-user<br>
~+<br>
<b>current working directory.</b><a href="abs-guides.html#98">&nbsp;This corresponds to the $PWD internal variable.</a><br>
~-<br>
<b>previous working directory.</b><a href="abs-guides.html#96">&nbsp;This corresponds to the $OLDPWD internal variable.</a><br>
=~<br>
<a href="abs-guides.html#547"><b>regular expression match.</b></a><a href="abs-guides.html#545">&nbsp;This operator was introduced with version 3 of Bash.</a><br>
^<br>
<b>beginning-of-line.</b><a href="abs-guides.html#354">&nbsp;In a regular expression, a &quot;^&quot; addresses the beginning of a line of text.</a><br>
^, ^^<br>
<a href="abs-guides.html#553"><b>Uppercase conversion in</b></a><i><b>&nbsp;parameter substitution</b></i><a href="abs-guides.html#549"><b>&nbsp;(added in version 4 of Bash).</b></a><br>
Control Characters<br>
<b>change the behavior of the terminal or text display.</b>&nbsp;A control character is a<b>&nbsp;CONTROL</b>&nbsp;+<b>&nbsp;key<br></b>combination (pressed simultaneously). A control character may also be written in<i>&nbsp;octal</i>&nbsp;or<br><i>hexadecimal</i>&nbsp;notation, following an<i>&nbsp;escape</i>.<br>
Control characters are not normally useful inside a script.<br>
<b>Ctl-A</b><br>
◊&nbsp;<br>
Moves cursor to beginning of line of text (on the command-line).<br><b>Ctl-B</b><br>
◊&nbsp;<br>
<b>Backspace</b>&nbsp;(nondestructive).<br>
◊&nbsp;<br>
<b>Ctl-C</b><br>
<b>Break</b>. Terminate a foreground job.<br>
◊&nbsp;<br>
<b>Ctl-D</b><br>
<i>Log out</i><a href="abs-guides.html#57">&nbsp;from a shell (similar to exit).</a><br>
<b>EOF</b>&nbsp;(end-of-file). This also terminates input from&nbsp;stdin.<br>
When typing text on the console or in an<i>&nbsp;xterm</i>&nbsp;window,&nbsp;<b>Ctl-D</b>&nbsp;erases the character under<br>the cursor. When there are no characters present,&nbsp;<b>Ctl-D</b>&nbsp;logs out of the session, as expected.<br>In an<i>&nbsp;xterm</i>&nbsp;window, this has the effect of closing the window.<br><b>Ctl-E</b><br>
◊&nbsp;<br>
Moves cursor to end of line of text (on the command-line).<br><b>Ctl-F</b><br>
◊&nbsp;<br>
Moves cursor forward one character position (on the command-line).<br>
◊&nbsp;<br>
<b>Ctl-G</b><br>
<b>BEL</b>. On some old-time teletype terminals, this would actually ring a bell. In an<i>&nbsp;xterm</i>&nbsp;it<br>might beep.<br>
Chapter 3. Special Characters<br>
25<br>
<hr>
<A name=32></a>Advanced Bash-Scripting Guide<br>
<b>Ctl-H</b><br>
◊&nbsp;<br>
<b>Rubout</b>&nbsp;(destructive backspace). Erases characters the cursor backs over while backspacing.<br>
#!/bin/bash<br>
# Embedding Ctl-H in a string.<br>
a=&quot;^H^H&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Two Ctl-H's -- backspaces<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ctl-V ctl-H, using vi/vim<br>
echo &quot;abcdef&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcdef<br>
echo<br>
echo -n &quot;abcdef$a &quot; &nbsp; &nbsp; &nbsp; # abcd f<br>
# &nbsp;Space at end &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp;Backspaces twice.<br>
echo<br>
echo -n &quot;abcdef$a&quot; &nbsp; &nbsp; &nbsp; &nbsp;# abcdef<br>
# &nbsp;No space at end &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ Doesn't backspace (why?).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Results may not be quite as expected.<br>
echo; echo<br>
# Constantin Hagemeier suggests trying:<br>
# a=$'\010\010'<br>
# a=$'\b\b'<br>
# a=$'\x08\x08'<br>
# But, this does not change the results.<br>
########################################<br>
# Now, try this.<br>
rubout=&quot;^H^H^H^H^H&quot; &nbsp; &nbsp; &nbsp; # 5 x Ctl-H.<br>
echo -n &quot;12345678&quot;<br>
sleep 2<br>
echo -n &quot;$rubout&quot;<br>
sleep 2<br>
<b>Ctl-I</b><br>
◊&nbsp;<br>
<b>Horizontal tab</b>.<br>
◊&nbsp;<br>
<b>Ctl-J</b><br>
<b>Newline</b>&nbsp;(line feed). In a script, may also be expressed in octal notation -- '\012' or in<br>hexadecimal -- '\x0a'.<br><b>Ctl-K</b><br>
◊&nbsp;<br>
<b>Vertical tab</b>.<br>
When typing text on the console or in an<i>&nbsp;xterm</i>&nbsp;window,&nbsp;<b>Ctl-K</b>&nbsp;erases from the character<br>under the cursor to end of line. Within a script,&nbsp;<b>Ctl-K</b>&nbsp;may behave differently, as in Lee Lee<br>Maschmeyer's example, below.<br><b>Ctl-L</b><br>
◊&nbsp;<br>
<b>Formfeed</b><a href="abs-guides.html#295">&nbsp;(clear the terminal screen). In a terminal, this has the same effect as the clear<br></a>command. When sent to a printer, a&nbsp;<b>Ctl-L</b>&nbsp;causes an advance to end of the paper sheet.<br>
◊&nbsp;<br>
<b>Ctl-M</b><br>
Chapter 3. Special Characters<br>
26<br>
<hr>
<A name=33></a>Advanced Bash-Scripting Guide<br>
<b>Carriage return</b>.<br>
#!/bin/bash<br>
# Thank you, Lee Maschmeyer, for this example.<br>
read -n 1 -s -p \<br>
$'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Of course, '0d' is the hex equivalent of Control-M.<br>
echo &gt;&amp;2 &nbsp; # &nbsp;The '-s' makes anything typed silent,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ so it is necessary to go to new line explicitly.<br>
read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;'0a' is the hex equivalent of Control-J, linefeed.<br>
echo &gt;&amp;2<br>
###<br>
read -n 1 -s -p $'And Control-K\x0bgoes straight down.'<br>
echo &gt;&amp;2 &nbsp; # &nbsp;Control-K is vertical tab.<br>
# A better example of the effect of a vertical tab is:<br>
var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'<br>
echo &quot;$var&quot;<br>
# &nbsp;This works the same way as the above example. However:<br>
echo &quot;$var&quot; | col<br>
# &nbsp;This causes the right end of the line to be higher than the left end.<br>
# &nbsp;It also explains why we started and ended with a line feed --<br>
#+ to avoid a garbled screen.<br>
# As Lee Maschmeyer explains:<br>
# --------------------------<br>
# &nbsp;In the [first vertical tab example] . . . the vertical tab<br>
#+ makes the printing go straight down without a carriage return.<br>
# &nbsp;This is true only on devices, such as the Linux console,<br>
#+ that can't go &quot;backward.&quot;<br>
# &nbsp;The real purpose of VT is to go straight UP, not down.<br>
# &nbsp;It can be used to print superscripts on a printer.<br>
# &nbsp;The col utility can be used to emulate the proper behavior of VT.<br>
exit 0<br>
<b>Ctl-N</b><br>
◊&nbsp;<br>
Erases a line of text recalled from<i>&nbsp;history buffer&nbsp;</i>[22] (on the command-line).<br><b>Ctl-O</b><br>
◊&nbsp;<br>
Issues a<i>&nbsp;newline</i>&nbsp;(on the command-line).<br><b>Ctl-P</b><br>
◊&nbsp;<br>
Recalls last command from<i>&nbsp;history buffer</i>&nbsp;(on the command-line).<br><b>Ctl-Q</b><br>
◊&nbsp;<br>
Resume (<b>XON</b>).<br>
This resumes&nbsp;stdin&nbsp;in a terminal.<br><b>Ctl-R</b><br>
◊&nbsp;<br>
Backwards search for text in<i>&nbsp;history buffer</i>&nbsp;(on the command-line).<br>
Chapter 3. Special Characters<br>
27<br>
<hr>
<A name=34></a>Advanced Bash-Scripting Guide<br>
<b>Ctl-S</b><br>
◊&nbsp;<br>
Suspend (<b>XOFF</b>).<br>
This freezes&nbsp;stdin&nbsp;in a terminal. (Use Ctl-Q to restore input.)<br><b>Ctl-T</b><br>
◊&nbsp;<br>
Reverses the position of the character the cursor is on with the previous character (on the<br>command-line).<br><b>Ctl-U</b><br>
◊&nbsp;<br>
Erase a line of input, from the cursor backward to beginning of line. In some settings,&nbsp;<b>Ctl-U<br></b>erases the entire line of input,<i>&nbsp;regardless of cursor position</i>.<br><b>Ctl-V</b><br>
◊&nbsp;<br>
When inputting text,&nbsp;<b>Ctl-V</b>&nbsp;permits inserting control characters. For example, the following<br>two are equivalent:<br>
echo -e '\x0a'<br>
echo &lt;Ctl-V&gt;&lt;Ctl-J&gt;<br>
<b>Ctl-V</b>&nbsp;is primarily useful from within a text editor.<br><b>Ctl-W</b><br>
◊&nbsp;<br>
When typing text on the console or in an xterm window,&nbsp;<b>Ctl-W</b>&nbsp;erases from the character<br><a href="abs-guides.html#34">under the cursor backwards to the first instance of whitespace. In some settings,&nbsp;</a><b>Ctl-W<br></b>erases backwards to first non-alphanumeric character.<br><b>Ctl-X</b><br>
◊&nbsp;<br>
In certain word processing programs,<i>&nbsp;Cuts</i>&nbsp;highlighted text and copies to<i>&nbsp;clipboard</i>.<br><b>Ctl-Y</b><br>
◊&nbsp;<br>
<i>Pastes</i>&nbsp;back text previously erased (with&nbsp;<b>Ctl-U</b>&nbsp;or&nbsp;<b>Ctl-W</b>).<br><b>Ctl-Z</b><br>
◊&nbsp;<br>
<i>Pauses</i>&nbsp;a foreground job.<br>
<i>Substitute</i>&nbsp;operation in certain word processing applications.<br>
<b>EOF</b>&nbsp;(end-of-file) character in the MSDOS filesystem.<br>
Whitespace<br>
<b>functions as a separator between commands and/or variables.</b>&nbsp;Whitespace consists of either<br><i>spaces</i>,<i>&nbsp;tabs</i>,<i>&nbsp;blank lines</i>, or any combination thereof.&nbsp;<a href="abs-guides.html#490">[23] In some contexts, such as variable<br>assignment, whitespace is not permitted, and results in a syntax error.</a><br>
Blank lines have no effect on the action of a script, and are therefore useful for visually separating<br>functional sections.<br>
<a href="abs-guides.html#93">$IFS, the special variable separating</a><i>&nbsp;fields</i>&nbsp;of input to certain commands. It defaults to whitespace.<br>
Chapter 3. Special Characters<br>
28<br>
<hr>
<A name=35></a>Advanced Bash-Scripting Guide<br>
<b>Definition:</b>&nbsp;A<i>&nbsp;field</i>&nbsp;is a discrete chunk of data expressed as a string of consecutive characters.<br>Separating each field from adjacent fields is either<i>&nbsp;whitespace</i>&nbsp;or some other designated character<br>(often determined by the $IFS). In some contexts, a field may be called a<i>&nbsp;record</i>.<br>
To preserve<i>&nbsp;whitespace</i><a href="abs-guides.html#47">&nbsp;within a string or in a variable, use quoting.</a><br>
<a href="abs-guides.html#24">UNIX filters can target and operate on</a><i>&nbsp;whitespace</i><a href="abs-guides.html#357">&nbsp;using the POSIX character class [:space:].</a><br>
Chapter 3. Special Characters<br>
29<br>
<hr>
<A name=36></a><b>Chapter 4. Introduction to Variables and<br>Parameters</b><br>
<i>Variables</i>&nbsp;are how programming and scripting languages represent data. A variable is nothing more than a<br><i>label</i>, a name assigned to a location or set of locations in computer memory holding an item of data.<br>
Variables appear in arithmetic operations and manipulation of quantities, and in string parsing.<br>
<b>4.1. Variable Substitution</b><br>
The<i>&nbsp;name</i>&nbsp;of a variable is a placeholder for its<i>&nbsp;value</i>, the data it holds. Referencing (retrieving) its value is<br>called<i>&nbsp;variable substitution</i>.<br>
$<br>
Let us carefully distinguish between the<i>&nbsp;name</i>&nbsp;of a variable and its<i>&nbsp;value</i>. If&nbsp;<b>variable1</b>&nbsp;is the name<br>of a variable, then&nbsp;<b>$variable1</b>&nbsp;is a reference to its<i>&nbsp;value</i>, the data item it contains.&nbsp;[24]<br>
bash$&nbsp;<b>variable1=23</b><br>
bash$&nbsp;<b>echo variable1<br></b>variable1<br>
bash$&nbsp;<b>echo $variable1<br></b>23<br>
The only times a variable appears &quot;naked&quot; -- without the $ prefix -- is when declared or assigned,<br>when<i>&nbsp;unset</i><a href="abs-guides.html#206">, when exported, in an arithmetic expression within double parentheses (( ... )), or in the<br></a><a href="abs-guides.html#479">special case of a variable representing a signal (see Example 32-5). Assignment may be with an = (as<br></a>in&nbsp;<i>var1=27</i><a href="abs-guides.html#190">), in a read statement, and at the head of a loop (</a><i>for var2 in 1 2 3</i>).<br>
Enclosing a referenced value in<i>&nbsp;double quotes</i>&nbsp;(&quot; ... &quot;) does not interfere with variable substitution.<br>This is called<i>&nbsp;partial quoting</i>, sometimes referred to as &quot;weak quoting.&quot;&nbsp;Using single quotes (' ... ')<br>causes the variable name to be used literally, and no substitution will take place. This is<i>&nbsp;full quoting</i>,<br><a href="abs-guides.html#47">sometimes referred to as 'strong quoting.' See Chapter 5 for a detailed discussion.</a><br>
Note that&nbsp;<b>$variable</b>&nbsp;is actually a simplified form of&nbsp;<b>${variable}</b>. In contexts where the<br><b>$variable</b><a href="abs-guides.html#133">&nbsp;syntax causes an error, the longer form may work (see Section 10.2, below).</a><br>
<b>Example 4-1. Variable assignment and substitution</b><br>
#!/bin/bash<br>
# ex9.sh<br>
# Variables: assignment and substitution<br>
a=375<br>
hello=$a<br>
Chapter 4. Introduction to Variables and Parameters<br>
30<br>
<hr>
<A name=37></a>Advanced Bash-Scripting Guide<br>
#-------------------------------------------------------------------------<br>
# No space permitted on either side of = sign when initializing variables.<br>
# What happens if there is a space?<br>
# &nbsp;&quot;VARIABLE =value&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
#% Script tries to run &quot;VARIABLE&quot; command with one argument, &quot;=value&quot;.<br>
# &nbsp;&quot;VARIABLE= value&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
#% Script tries to run &quot;value&quot; command with<br>
#+ the environmental variable &quot;VARIABLE&quot; set to &quot;&quot;.<br>
#-------------------------------------------------------------------------<br>
echo hello &nbsp; &nbsp;# hello<br>
# Not a variable reference, just the string &quot;hello&quot; . . .<br>
echo $hello &nbsp; # 375<br>
# &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This *is* a variable reference.<br>
echo ${hello} # 375<br>
# Also a variable reference, as above.<br>
# Quoting . . .<br>
echo &quot;$hello&quot; &nbsp; &nbsp;# 375<br>
echo &quot;${hello}&quot; &nbsp;# 375<br>
echo<br>
hello=&quot;A B &nbsp;C &nbsp; D&quot;<br>
echo $hello &nbsp; # A B C D<br>
echo &quot;$hello&quot; # A B &nbsp;C &nbsp; D<br>
# As you see, echo $hello &nbsp; and &nbsp; echo &quot;$hello&quot; &nbsp; give different results.<br>
# Why?<br>
# =======================================<br>
# Quoting a variable preserves whitespace.<br>
# =======================================<br>
echo<br>
echo '$hello' &nbsp;# $hello<br>
# &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp;^<br>
# &nbsp;Variable referencing disabled (escaped) by single quotes,<br>
#+ which causes the &quot;$&quot; to be interpreted literally.<br>
# Notice the effect of different types of quoting.<br>
hello= &nbsp; &nbsp;# Setting it to a null value.<br>
echo &quot;\$hello (null value) = $hello&quot;<br>
# &nbsp;Note that setting a variable to a null value is not the same as<br>
#+ unsetting it, although the end result is the same (see below).<br>
# --------------------------------------------------------------<br>
# &nbsp;It is permissible to set multiple variables on the same line,<br>
#+ if separated by white space.<br>
# &nbsp;Caution, this may reduce legibility, and may not be portable.<br>
var1=21 &nbsp;var2=22 &nbsp;var3=$V3<br>
echo<br>
echo &quot;var1=$var1 &nbsp; var2=$var2 &nbsp; var3=$var3&quot;<br>
Chapter 4. Introduction to Variables and Parameters<br>
31<br>
<hr>
<A name=38></a><IMG src="abs-guide-38_1.png"><br>
Advanced Bash-Scripting Guide<br>
# May cause problems with older versions of &quot;sh&quot; . . .<br>
# --------------------------------------------------------------<br>
echo; echo<br>
numbers=&quot;one two three&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; ^<br>
other_numbers=&quot;1 2 3&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ ^<br>
# &nbsp;If there is whitespace embedded within a variable,<br>
#+ then quotes are necessary.<br>
# &nbsp;other_numbers=1 2 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Gives an error message.<br>
echo &quot;numbers = $numbers&quot;<br>
echo &quot;other_numbers = $other_numbers&quot; &nbsp; # other_numbers = 1 2 3<br>
# &nbsp;Escaping the whitespace also works.<br>
mixed_bag=2\ ---\ Whatever<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp;^ Space after escape (\).<br>
echo &quot;$mixed_bag&quot; &nbsp; &nbsp; &nbsp; &nbsp; # 2 --- Whatever<br>
echo; echo<br>
echo &quot;uninitialized_variable = $uninitialized_variable&quot;<br>
# Uninitialized variable has null value (no value at all!).<br>
uninitialized_variable= &nbsp; # &nbsp;Declaring, but not initializing it --<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ same as setting it to a null value, as above.<br>
echo &quot;uninitialized_variable = $uninitialized_variable&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # It still has a null value.<br>
uninitialized_variable=23 &nbsp; &nbsp; &nbsp; # Set it.<br>
unset uninitialized_variable &nbsp; &nbsp;# Unset it.<br>
echo &quot;uninitialized_variable = $uninitialized_variable&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # It still has a null value.<br>
echo<br>
exit 0<br>
An uninitialized variable has a &quot;null&quot; value -- no assigned value at all (<i>not</i>&nbsp;zero!).<br>
if [ -z &quot;$unassigned&quot; ]<br>
then<br>
&nbsp; echo &quot;\$unassigned is NULL.&quot;<br>
fi &nbsp; &nbsp; # $unassigned is NULL.<br>
Using a variable before assigning a value to it may cause problems. It is nevertheless<br>possible to perform arithmetic operations on an uninitialized variable.<br>
echo &quot;$uninitialized&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (blank line)<br>
let &quot;uninitialized += 5&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Add 5 to it.<br>
echo &quot;$uninitialized&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 5<br>
# &nbsp;Conclusion:<br>
# &nbsp;An uninitialized variable has no value,<br>
#+ however it evaluates as 0 in an arithmetic operation.<br>
<a href="abs-guides.html#211">See also Example 15-23.</a><br>
Chapter 4. Introduction to Variables and Parameters<br>
32<br>
<hr>
<A name=39></a><IMG src="abs-guide-39_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>4.2. Variable Assignment</b><br>
=<br>
the assignment operator (<i>no space before and after</i>)<br>
<a href="abs-guides.html#72">Do not confuse this with = and -eq, which test, rather than assign!</a><br>
Note that = can be either an<i>&nbsp;assignment</i>&nbsp;or a<i>&nbsp;test</i>&nbsp;operator, depending on context.<br>
<b>Example 4-2. Plain Variable Assignment</b><br>
#!/bin/bash<br>
# Naked variables<br>
echo<br>
# When is a variable &quot;naked&quot;, i.e., lacking the '$' in front?<br>
# When it is being assigned, rather than referenced.<br>
# Assignment<br>
a=879<br>
echo &quot;The value of \&quot;a\&quot; is $a.&quot;<br>
# Assignment using 'let'<br>
let a=16+5<br>
echo &quot;The value of \&quot;a\&quot; is now $a.&quot;<br>
echo<br>
# In a 'for' loop (really, a type of disguised assignment):<br>
echo -n &quot;Values of \&quot;a\&quot; in the loop are: &quot;<br>
for a in 7 8 9 11<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done<br>
echo<br>
echo<br>
# In a 'read' statement (also a type of assignment):<br>
echo -n &quot;Enter \&quot;a\&quot; &quot;<br>
read a<br>
echo &quot;The value of \&quot;a\&quot; is now $a.&quot;<br>
echo<br>
exit 0<br>
<b>Example 4-3. Variable Assignment, plain and fancy</b><br>
#!/bin/bash<br>
a=23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Simple case<br>
echo $a<br>
b=$a<br>
Chapter 4. Introduction to Variables and Parameters<br>
33<br>
<hr>
<A name=40></a>Advanced Bash-Scripting Guide<br>
echo $b<br>
# Now, getting a little bit fancier (command substitution).<br>
a=`echo Hello!` &nbsp; # Assigns result of 'echo' command to 'a' ...<br>
echo $a<br>
# &nbsp;Note that including an exclamation mark (!) within a<br>
#+ command substitution construct will not work from the command-line,<br>
#+ since this triggers the Bash &quot;history mechanism.&quot;<br>
# &nbsp;Inside a script, however, the history functions are disabled.<br>
a=`ls -l` &nbsp; &nbsp; &nbsp; &nbsp; # Assigns result of 'ls -l' command to 'a'<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unquoted, however, it removes tabs and newlines.<br>
echo<br>
echo &quot;$a&quot; &nbsp; &nbsp; &nbsp; &nbsp; # The quoted variable preserves whitespace.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (See the chapter on &quot;Quoting.&quot;)<br>
exit 0<br>
Variable assignment using the<i>&nbsp;$(...)</i><a href="abs-guides.html#170">&nbsp;mechanism (a newer method than backquotes). This is likewise a<br>form of command substitution.</a><br>
# From /etc/rc.d/rc.local<br>
R=$(cat /etc/redhat-release)<br>
arch=$(uname -m)<br>
<b>4.3. Bash Variables Are Untyped</b><br>
Unlike many other programming languages, Bash does not segregate its variables by &quot;type.&quot; Essentially,<i>&nbsp;Bash<br>variables are character strings</i>, but, depending on context, Bash permits arithmetic operations and<br>comparisons on variables. The determining factor is whether the value of a variable contains only digits.<br>
<b>Example 4-4. Integer or string?</b><br>
#!/bin/bash<br>
# int-or-string.sh<br>
a=2334 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Integer.<br>
let &quot;a += 1&quot;<br>
echo &quot;a = $a &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # a = 2335<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Integer, still.<br>
b=${a/23/BB} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Substitute &quot;BB&quot; for &quot;23&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# This transforms $b into a string.<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# b = BB35<br>
declare -i b &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Declaring it an integer doesn't help.<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# b = BB35<br>
let &quot;b += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # BB35 + 1<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# b = 1<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bash sets the &quot;integer value&quot; of a string to 0.<br>
c=BB34<br>
echo &quot;c = $c&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# c = BB34<br>
Chapter 4. Introduction to Variables and Parameters<br>
34<br>
<hr>
<A name=41></a><IMG src="abs-guide-41_1.png"><br>
Advanced Bash-Scripting Guide<br>
d=${c/BB/23} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Substitute &quot;23&quot; for &quot;BB&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# This makes $d an integer.<br>
echo &quot;d = $d&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# d = 2334<br>
let &quot;d += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2334 + 1<br>
echo &quot;d = $d&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# d = 2335<br>
echo<br>
# What about null variables?<br>
e='' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ... Or e=&quot;&quot; ... Or e=<br>
echo &quot;e = $e&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# e =<br>
let &quot;e += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Arithmetic operations allowed on a null variable?<br>
echo &quot;e = $e&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# e = 1<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Null variable transformed into an integer.<br>
# What about undeclared variables?<br>
echo &quot;f = $f&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# f =<br>
let &quot;f += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Arithmetic operations allowed?<br>
echo &quot;f = $f&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# f = 1<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Undeclared variable transformed into an integer.<br>
#<br>
# However ...<br>
let &quot;f /= $undecl_var&quot; &nbsp; # Divide by zero?<br>
# &nbsp; let: f /= : syntax error: operand expected (error token is &quot; &quot;)<br>
# Syntax error! Variable $undecl_var is not set to zero here!<br>
#<br>
# But still ...<br>
let &quot;f /= 0&quot;<br>
# &nbsp; let: f /= 0: division by 0 (error token is &quot;0&quot;)<br>
# Expected behavior.<br>
# &nbsp;Bash (usually) sets the &quot;integer value&quot; of null to zero<br>
#+ when performing an arithmetic operation.<br>
# &nbsp;But, don't try this at home, folks!<br>
# &nbsp;It's undocumented and probably non-portable behavior.<br>
# Conclusion: Variables in Bash are untyped,<br>
#+ with all attendant consequences.<br>
exit $?<br>
Untyped variables are both a blessing and a curse. They permit more flexibility in scripting and make it easier<br>to grind out lines of code (and give you enough rope to hang yourself!). However, they likewise permit subtle<br>errors to creep in and encourage sloppy programming habits.<br>
To lighten the burden of keeping track of variable types in a script, Bash<i>&nbsp;does</i><a href="abs-guides.html#110">&nbsp;permit declaring variables.</a><br>
<b>4.4. Special Variable Types</b><br>
<i>Local variables</i><br>
<a href="abs-guides.html#389">Variables visible only within a code block or function (see also local variables in functions)</a><br>
<i>Environmental variables</i><br>
Variables that affect the behavior of the shell and user interface<br>
<a href="abs-guides.html#882">In a more general context, each process has an &quot;environment&quot;, that is, a group of<br></a>variables that the process may reference. In this sense, the shell behaves like any other<br>
Chapter 4. Introduction to Variables and Parameters<br>
35<br>
<hr>
<A name=42></a><IMG src="abs-guide-42_1.png"><br>
<IMG src="abs-guide-42_2.png"><br>
Advanced Bash-Scripting Guide<br>
process.<br>
Every time a shell starts, it creates shell variables that correspond to its own<br>environmental variables. Updating or adding new environmental variables causes the<br>shell to update its environment, and all the shell's<i>&nbsp;child processes</i>&nbsp;(the commands it<br>executes) inherit this environment.<br>
The space allotted to the environment is limited. Creating too many environmental<br>variables or ones that use up excessive space may cause problems.<br>
bash$&nbsp;<b>eval &quot;`seq 10000 | sed -e 's/.*/export var&amp;=ZZZZZZZZZZZZZZ/'`&quot;</b><br>
bash$&nbsp;<b>du<br></b>bash: /usr/bin/du: Argument list too long<br>
Note: this &quot;error&quot; has been fixed, as of kernel version 2.6.23.<br>
(Thank you, Stéphane Chazelas for the clarification, and for providing the above<br>example.)<br>
If a script sets environmental variables, they need to be &quot;exported,&quot; that is, reported to the<br><i>environment</i><a href="abs-guides.html#206">&nbsp;local to the script. This is the function of the export command.</a><br>
A script can<b>&nbsp;export</b><a href="abs-guides.html#882">&nbsp;variables only to child processes, that is, only to commands or<br></a>processes which that particular script initiates. A script invoked from the<br>command-line&nbsp;<i>cannot</i>&nbsp;export variables back to the command-line environment.<br><a href="abs-guides.html#186"><i>Child processes cannot export variables back to the parent processes that spawned<br></i></a><i>them.</i><br>
<b>Definition:</b>&nbsp;A<i>&nbsp;child process</i>&nbsp;is a subprocess launched by another process, its<br><a href="abs-guides.html#186">parent.</a><br>
<i>Positional parameters</i><br>
Arguments passed to the script from the command line&nbsp;[25] :&nbsp;$0,&nbsp;$1,&nbsp;$2,&nbsp;$3&nbsp;. . .<br>
$0&nbsp;is the name of the script itself,&nbsp;$1&nbsp;is the first argument,&nbsp;$2&nbsp;the second,&nbsp;$3&nbsp;the third, and so forth.<br>[26]&nbsp;&nbsp;After&nbsp;$9, the arguments must be enclosed in brackets, for example,&nbsp;${10},&nbsp;${11},&nbsp;${12}.<br>
<a href="abs-guides.html#104">The special variables $* and $@ denote</a><i>&nbsp;all</i>&nbsp;the positional parameters.<br>
<b>Example 4-5. Positional Parameters</b><br>
#!/bin/bash<br>
# Call this script with at least 10 parameters, for example<br>
# ./scriptname 1 2 3 4 5 6 7 8 9 10<br>
MINPARAMS=10<br>
echo<br>
echo &quot;The name of this script is \&quot;$0\&quot;.&quot;<br>
# Adds ./ for current directory<br>
echo &quot;The name of this script is \&quot;`basename $0`\&quot;.&quot;<br>
Chapter 4. Introduction to Variables and Parameters<br>
36<br>
<hr>
<A name=43></a><IMG src="abs-guide-43_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Strips out path name info (see 'basename')<br>
echo<br>
if [ -n &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Tested variable is quoted.<br>
then<br>
&nbsp;echo &quot;Parameter #1 is $1&quot; &nbsp;# Need quotes to escape #<br>
fi&nbsp;<br>
if [ -n &quot;$2&quot; ]<br>
then<br>
&nbsp;echo &quot;Parameter #2 is $2&quot;<br>
fi&nbsp;<br>
if [ -n &quot;$3&quot; ]<br>
then<br>
&nbsp;echo &quot;Parameter #3 is $3&quot;<br>
fi&nbsp;<br>
# ...<br>
if [ -n &quot;${10}&quot; ] &nbsp;# Parameters &gt; $9 must be enclosed in {brackets}.<br>
then<br>
&nbsp;echo &quot;Parameter #10 is ${10}&quot;<br>
fi&nbsp;<br>
echo &quot;-----------------------------------&quot;<br>
echo &quot;All the command-line parameters are: &quot;$*&quot;&quot;<br>
if [ $# -lt &quot;$MINPARAMS&quot; ]<br>
then<br>
&nbsp; echo<br>
&nbsp; echo &quot;This script needs at least $MINPARAMS command-line arguments!&quot;<br>
fi &nbsp;<br>
echo<br>
exit 0<br>
<i>Bracket notation</i>&nbsp;for positional parameters leads to a fairly simple way of referencing the<i>&nbsp;last<br></i><a href="abs-guides.html#541">argument passed to a script on the command-line. This also requires indirect referencing.</a><br>
args=$# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Number of args passed.<br>
lastarg=${!args}<br>
# Note: This is an *indirect reference* to $args ...<br>
# Or: &nbsp; &nbsp; &nbsp; lastarg=${!#} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Thanks, Chris Monson.)<br>
# This is an *indirect reference* to the $# variable.<br>
# Note that lastarg=${!$#} doesn't work.<br>
Some scripts can perform different operations, depending on which name they are invoked with. For<br>this to work, the script needs to check&nbsp;$0, the name it was invoked by.&nbsp;[27] There must also exist<br><a href="abs-guides.html#225">symbolic links to all the alternate names of the script. See Example 16-2.</a><br>
If a script expects a command-line parameter but is invoked without one, this may<br>cause a<i>&nbsp;null variable assignment</i>, generally an undesirable result. One way to prevent<br>this is to append an extra character to both sides of the assignment statement using the<br>
Chapter 4. Introduction to Variables and Parameters<br>
37<br>
<hr>
<A name=44></a>Advanced Bash-Scripting Guide<br>
expected positional parameter.<br>
variable1_=$1_ &nbsp;# Rather than variable1=$1<br>
# This will prevent an error, even if positional parameter is absent.<br>
critical_argument01=$variable1_<br>
# The extra character can be stripped off later, like so.<br>
variable1=${variable1_/_/}<br>
# Side effects only if $variable1_ begins with an underscore.<br>
# This uses one of the parameter substitution templates discussed later.<br>
# (Leaving out the replacement pattern results in a deletion.)<br>
# &nbsp;A more straightforward way of dealing with this is<br>
#+ to simply test whether expected positional parameters have been passed.<br>
if [ -z $1 ]<br>
then<br>
&nbsp; exit $E_MISSING_POS_PARAM<br>
fi<br>
# &nbsp;However, as Fabian Kreutz points out,<br>
#+ the above method may have unexpected side-effects.<br>
# &nbsp;A better method is parameter substitution:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ${1:-$DefaultVal}<br>
# &nbsp;See the &quot;Parameter Substition&quot; section<br>
#+ in the &quot;Variables Revisited&quot; chapter.<br>
---<br>
<b>Example 4-6.<i>&nbsp;wh</i></b><b>,<i>&nbsp;whois</i></b><b>&nbsp;domain name lookup</b><br>
#!/bin/bash<br>
# ex18.sh<br>
# Does a 'whois domain-name' lookup on any of 3 alternate servers:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ripe.net, cw.net, radb.net<br>
# Place this script -- renamed 'wh' -- in /usr/local/bin<br>
# Requires symbolic links:<br>
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe<br>
# ln -s /usr/local/bin/wh /usr/local/bin/wh-apnic<br>
# ln -s /usr/local/bin/wh /usr/local/bin/wh-tucows<br>
E_NOARGS=75<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` [domain-name]&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi<br>
# Check script name and call proper server.<br>
case `basename $0` in &nbsp; &nbsp;# Or: &nbsp; &nbsp;case ${0##*/} in<br>
&nbsp; &nbsp; &quot;wh&quot; &nbsp; &nbsp; &nbsp; ) whois $1@whois.tucows.com;;<br>
&nbsp; &nbsp; &quot;wh-ripe&quot; &nbsp;) whois $1@whois.ripe.net;;<br>
&nbsp; &nbsp; &quot;wh-apnic&quot; ) whois $1@whois.apnic.net;;<br>
&nbsp; &nbsp; &quot;wh-cw&quot; &nbsp; &nbsp;) whois $1@whois.cw.net;;<br>
&nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;) echo &quot;Usage: `basename $0` [domain-name]&quot;;;<br>
Chapter 4. Introduction to Variables and Parameters<br>
38<br>
<hr>
<A name=45></a>Advanced Bash-Scripting Guide<br>
esac&nbsp;<br>
exit $?<br>
---<br>
The<b>&nbsp;shift</b>&nbsp;command reassigns the positional parameters, in effect shifting them to the left one notch.<br>
$1&nbsp;&lt;---&nbsp;$2,&nbsp;$2&nbsp;&lt;---&nbsp;$3,&nbsp;$3&nbsp;&lt;---&nbsp;$4, etc.<br>
The old&nbsp;$1&nbsp;disappears, but&nbsp;<i>$0&nbsp;(the script name) does not change</i>. If you use a large number of<br>positional parameters to a script,<b>&nbsp;shift</b>&nbsp;lets you access those past&nbsp;10<a href="abs-guides.html#42">, although {bracket} notation also<br></a>permits this.<br>
<b>Example 4-7. Using<i>&nbsp;shift</i></b><br>
#!/bin/bash<br>
# shft.sh: Using 'shift' to step through all the positional parameters.<br>
# &nbsp;Name this script something like shft.sh,<br>
#+ and invoke it with some parameters.<br>
#+ For example:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh shft.sh a b c def 23 Skidoo<br>
until [ -z &quot;$1&quot; ] &nbsp;# Until all parameters used up . . .<br>
do<br>
&nbsp; echo -n &quot;$1 &quot;<br>
&nbsp; shift<br>
done<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Extra linefeed.<br>
# But, what happens to the &quot;used-up&quot; parameters?<br>
echo &quot;$2&quot;<br>
# &nbsp;Nothing echoes!<br>
# &nbsp;When $2 shifts into $1 (and there is no $3 to shift into $2)<br>
#+ then $2 remains empty.<br>
# &nbsp;So, it is not a parameter *copy*, but a *move*.<br>
exit<br>
# &nbsp;See also the echo-params.sh script for a &quot;shiftless&quot;<br>
#+ alternative method of stepping through the positional params.<br>
The<b>&nbsp;shift</b>&nbsp;command can take a numerical parameter indicating how many positions to shift.<br>
#!/bin/bash<br>
# shift-past.sh<br>
shift 3 &nbsp; &nbsp;# Shift 3 positions.<br>
# &nbsp;n=3; shift $n<br>
# &nbsp;Has the same effect.<br>
echo &quot;$1&quot;<br>
exit 0<br>
# ======================== #<br>
Chapter 4. Introduction to Variables and Parameters<br>
39<br>
<hr>
<A name=46></a><IMG src="abs-guide-46_1.png"><br>
Advanced Bash-Scripting Guide<br>
$ sh shift-past.sh 1 2 3 4 5<br>
4<br>
# &nbsp;However, as Eleni Fragkiadaki, points out,<br>
#+ attempting a 'shift' past the number of<br>
#+ positional parameters ($#) returns an exit status of 1,<br>
#+ and the positional parameters themselves do not change.<br>
# &nbsp;This means possibly getting stuck in an endless loop. . . .<br>
# &nbsp;For example:<br>
# &nbsp; &nbsp; &nbsp;until [ -z &quot;$1&quot; ]<br>
# &nbsp; &nbsp; &nbsp;do<br>
# &nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot;$1 &quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; shift 20 &nbsp; &nbsp;# &nbsp;If less than 20 pos params,<br>
# &nbsp; &nbsp; &nbsp;done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ then loop never ends!<br>
#<br>
# When in doubt, add a sanity check. . . .<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift 20 || break<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^<br>
The<b>&nbsp;shift</b><a href="abs-guides.html#399">&nbsp;command works in a similar fashion on parameters passed to a function. See<br></a><a href="abs-guides.html#530">Example 36-16.</a><br>
Chapter 4. Introduction to Variables and Parameters<br>
40<br>
<hr>
<A name=47></a><b>Chapter 5. Quoting</b><br>
<a href="abs-guides.html#14">Quoting means just that, bracketing a string in quotes. This has the effect of protecting special characters in<br></a>the string from reinterpretation or expansion by the shell or shell script. (A character is &quot;special&quot; if it has an<br><a href="abs-guides.html#18">interpretation other than its literal meaning. For example, the asterisk * represents a</a><i>&nbsp;wild card</i>&nbsp;character in<br><a href="abs-guides.html#358">globbing and Regular Expressions).</a><br>
bash$&nbsp;<b>ls -l [Vv]*<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 324 Apr &nbsp;2 15:05 VIEWDATA.BAT<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 507 May &nbsp;4 14:25 vartrace.sh<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 539 Apr 14 17:11 viewdata.sh<br>
bash$&nbsp;<b>ls -l '[Vv]*'<br></b>ls: [Vv]*: No such file or directory<br>
In everyday speech or writing, when we &quot;quote&quot; a phrase, we set it apart and give it special meaning. In a<br>Bash script, when we<i>&nbsp;quote</i>&nbsp;a string, we set it apart and protect its<i>&nbsp;literal</i>&nbsp;meaning.<br>
Certain programs and utilities reinterpret or expand special characters in a quoted string. An important use of<br>quoting is protecting a command-line parameter from the shell, but still letting the calling program expand it.<br>
bash$&nbsp;<b>grep '[Ff]irst' *.txt<br></b>file1.txt:This is the first line of file1.txt.<br>
&nbsp;file2.txt:This is the First line of file2.txt.<br>
Note that the unquoted&nbsp;<b>grep [Ff]irst *.txt</b>&nbsp;works under the Bash shell.&nbsp;[28]<br>
<a href="abs-guides.html#187">Quoting can also suppress echo's &quot;appetite&quot; for newlines.</a><br>
bash$&nbsp;<b>echo $(ls -l)<br></b>total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh<br>
bash$&nbsp;<b>echo &quot;$(ls -l)&quot;<br></b>total 8<br>
&nbsp;-rw-rw-r-- &nbsp;1 bo bo &nbsp;13 Aug 21 12:57 t.sh<br>
&nbsp;-rw-rw-r-- &nbsp;1 bo bo &nbsp;78 Aug 21 12:57 u.sh<br>
<b>5.1. Quoting Variables</b><br>
When referencing a variable, it is generally advisable to enclose its name in double quotes. This prevents<br>reinterpretation of all special characters within the quoted string -- except $, ` (backquote), and \ (escape).&nbsp;[29]<br>Keeping $ as a special character within double quotes permits referencing a quoted variable<br>(<i>&quot;$variable&quot;</i><a href="abs-guides.html#36">), that is, replacing the variable with its value (see Example 4-1, above).</a><br>
Use double quotes to prevent word splitting.&nbsp;[30] An argument enclosed in double quotes presents itself as a<br><a href="abs-guides.html#34">single word, even if it contains whitespace separators.</a><br>
List=&quot;one two three&quot;<br>
Chapter 5. Quoting<br>
41<br>
<hr>
<A name=48></a><IMG src="abs-guide-48_1.png"><br>
Advanced Bash-Scripting Guide<br>
for a in $List &nbsp; &nbsp; # Splits the variable in parts at whitespace.<br>
do<br>
&nbsp; echo &quot;$a&quot;<br>
done<br>
# one<br>
# two<br>
# three<br>
echo &quot;---&quot;<br>
for a in &quot;$List&quot; &nbsp; # Preserves whitespace in a single variable.<br>
do # &nbsp; &nbsp; ^ &nbsp; &nbsp; ^<br>
&nbsp; echo &quot;$a&quot;<br>
done<br>
# one two three<br>
A more elaborate example:<br>
variable1=&quot;a variable containing five words&quot;<br>
COMMAND This is $variable1 &nbsp; &nbsp;# Executes COMMAND with 7 arguments:<br>
# &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;variable&quot; &quot;containing&quot; &quot;five&quot; &quot;words&quot;<br>
COMMAND &quot;This is $variable1&quot; &nbsp;# Executes COMMAND with 1 argument:<br>
# &quot;This is a variable containing five words&quot;<br>
variable2=&quot;&quot; &nbsp; &nbsp;# Empty.<br>
COMMAND $variable2 $variable2 $variable2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Executes COMMAND with no arguments.&nbsp;<br>
COMMAND &quot;$variable2&quot; &quot;$variable2&quot; &quot;$variable2&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Executes COMMAND with 3 empty arguments.&nbsp;<br>
COMMAND &quot;$variable2 $variable2 $variable2&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Executes COMMAND with 1 argument (2 spaces).&nbsp;<br>
# Thanks, Stéphane Chazelas.<br>
Enclosing the arguments to an<b>&nbsp;echo</b>&nbsp;statement in double quotes is necessary only when word splitting or<br><a href="abs-guides.html#34">preservation of whitespace is an issue.</a><br>
<b>Example 5-1. Echoing Weird Variables</b><br>
#!/bin/bash<br>
# weirdvars.sh: Echoing weird variables.<br>
echo<br>
var=&quot;'(]\\{}\$\&quot;&quot;<br>
echo $var &nbsp; &nbsp; &nbsp; &nbsp;# '(]\{}$&quot;<br>
echo &quot;$var&quot; &nbsp; &nbsp; &nbsp;# '(]\{}$&quot; &nbsp; &nbsp; Doesn't make a difference.<br>
echo<br>
IFS='\'<br>
echo $var &nbsp; &nbsp; &nbsp; &nbsp;# '(] {}$&quot; &nbsp; &nbsp; \ converted to space. Why?<br>
echo &quot;$var&quot; &nbsp; &nbsp; &nbsp;# '(]\{}$&quot;<br>
# Examples above supplied by Stephane Chazelas.<br>
Chapter 5. Quoting<br>
42<br>
<hr>
<A name=49></a><IMG src="abs-guide-49_1.png"><br>
<IMG src="abs-guide-49_2.png"><br>
Advanced Bash-Scripting Guide<br>
echo<br>
var2=&quot;\\\\\&quot;&quot;<br>
echo $var2 &nbsp; &nbsp; &nbsp; # &nbsp; &quot;<br>
echo &quot;$var2&quot; &nbsp; &nbsp; # \\&quot;<br>
echo<br>
# But ... var2=&quot;\\\\&quot;&quot; is illegal. Why?<br>
var3='\\\\'<br>
echo &quot;$var3&quot; &nbsp; &nbsp; # \\\\<br>
# Strong quoting works, though.<br>
exit<br>
Single quotes (' ') operate similarly to double quotes, but do not permit referencing variables, since the special<br>meaning of $ is turned off. Within single quotes,<i>&nbsp;every</i>&nbsp;special character except ' gets interpreted literally.<br>Consider single quotes (&quot;full quoting&quot;) to be a stricter method of quoting than double quotes (&quot;partial<br>quoting&quot;).<br>
Since even the escape character (\) gets a literal interpretation within single quotes, trying to enclose a<br>single quote within single quotes will not yield the expected result.<br>
echo &quot;Why can't I write 's between single quotes&quot;<br>
echo<br>
# The roundabout method.<br>
echo 'Why can'\''t I write '&quot;'&quot;'s between single quotes'<br>
# &nbsp; &nbsp;|-------| &nbsp;|----------| &nbsp; |-----------------------|<br>
# Three single-quoted strings, with escaped and quoted single quotes between.<br>
# This example courtesy of Stéphane Chazelas.<br>
<b>5.2. Escaping</b><br>
<i>Escaping</i>&nbsp;is a method of quoting single characters. The escape (\) preceding a character tells the shell to<br>interpret that character literally.<br>
<a href="abs-guides.html#187">With certain commands and utilities, such as echo and sed, escaping a character may have the opposite<br></a>effect - it can toggle on a special meaning for that character.<br>
<b>Special meanings of certain escaped characters</b><br>
used with<b>&nbsp;echo</b>&nbsp;and<b>&nbsp;sed<br></b>\n<br>
means newline<br>
\r<br>
means return<br>
\t<br>
means tab<br>
\v<br>
means vertical tab<br>
\b<br>
means backspace<br>
\a<br>
Chapter 5. Quoting<br>
43<br>
<hr>
<A name=50></a><IMG src="abs-guide-50_1.png"><br>
Advanced Bash-Scripting Guide<br>
means<i>&nbsp;alert</i>&nbsp;(beep or flash)<br>
\0xx<br>
<a href="abs-guides.html#882">translates to the octal ASCII equivalent of&nbsp;</a><i>0nn</i>, where&nbsp;<i>nn</i>&nbsp;is a string of digits<br>
The&nbsp;<b>$' ... '</b><a href="abs-guides.html#47">&nbsp;quoted string-expansion construct is a mechanism that uses escaped<br></a>octal or hex values to assign ASCII characters to variables, e.g.,<b>&nbsp;quote=$'\042'</b>.<br>
<b>Example 5-2. Escaped Characters</b><br>
#!/bin/bash<br>
# escaped.sh: escaped characters<br>
#############################################################<br>
### First, let's show some basic escaped-character usage. ###<br>
#############################################################<br>
# Escaping a newline.<br>
# ------------------<br>
echo &quot;&quot;<br>
echo &quot;This will print<br>
as two lines.&quot;<br>
# This will print<br>
# as two lines.<br>
echo &quot;This will print \<br>
as one line.&quot;<br>
# This will print as one line.<br>
echo; echo<br>
echo &quot;=============&quot;<br>
echo &quot;\v\v\v\v&quot; &nbsp; &nbsp; &nbsp;# Prints \v\v\v\v literally.<br>
# Use the -e option with 'echo' to print escaped characters.<br>
echo &quot;=============&quot;<br>
echo &quot;VERTICAL TABS&quot;<br>
echo -e &quot;\v\v\v\v&quot; &nbsp; # Prints 4 vertical tabs.<br>
echo &quot;==============&quot;<br>
echo &quot;QUOTATION MARK&quot;<br>
echo -e &quot;\042&quot; &nbsp; &nbsp; &nbsp; # Prints &quot; (quote, octal ASCII character 42).<br>
echo &quot;==============&quot;<br>
# The $'\X' construct makes the -e option unnecessary.<br>
echo; echo &quot;NEWLINE and (maybe) BEEP&quot;<br>
echo $'\n' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Newline.<br>
echo $'\a' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Alert (beep).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# May only flash, not beep, depending on terminal.<br>
# We have seen $'\nnn&quot; string expansion, and now . . .<br>
# =================================================================== #<br>
# Version 2 of Bash introduced the $'\nnn' string expansion construct.<br>
Chapter 5. Quoting<br>
44<br>
<hr>
<A name=51></a>Advanced Bash-Scripting Guide<br>
# =================================================================== #<br>
echo &quot;Introducing the \$\' ... \' string-expansion construct . . . &quot;<br>
echo &quot;. . . featuring more quotation marks.&quot;<br>
echo $'\t \042 \t' &nbsp; # Quote (&quot;) framed by tabs.<br>
# Note that &nbsp;'\nnn' is an octal value.<br>
# It also works with hexadecimal values, in an $'\xhhh' construct.<br>
echo $'\t \x22 \t' &nbsp;# Quote (&quot;) framed by tabs.<br>
# Thank you, Greg Keraunen, for pointing this out.<br>
# Earlier Bash versions allowed '\x022'.<br>
echo<br>
# Assigning ASCII characters to a variable.<br>
# ----------------------------------------<br>
quote=$'\042' &nbsp; &nbsp; &nbsp; &nbsp;# &quot; assigned to a variable.<br>
echo &quot;$quote Quoted string $quote and this lies outside the quotes.&quot;<br>
echo<br>
# Concatenating ASCII chars in a variable.<br>
triple_underline=$'\137\137\137' &nbsp;# 137 is octal ASCII code for '_'.<br>
echo &quot;$triple_underline UNDERLINE $triple_underline&quot;<br>
echo<br>
ABC=$'\101\102\103\010' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 101, 102, 103 are octal A, B, C.<br>
echo $ABC<br>
echo<br>
escape=$'\033' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 033 is octal for escape.<br>
echo &quot;\&quot;escape\&quot; echoes as $escape&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no visible output.<br>
echo<br>
exit 0<br>
A more elaborate example:<br>
<b>Example 5-3. Detecting key-presses</b><br>
#!/bin/bash<br>
# Author: Sigurd Solaas, 20 Apr 2011<br>
# Used in ABS Guide with permission.<br>
# Requires version 4.2+ of Bash.<br>
key=&quot;no value yet&quot;<br>
while true; do<br>
&nbsp; clear<br>
&nbsp; echo &quot;Bash Extra Keys Demo. Keys to try:&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;* Insert, Delete, Home, End, Page_Up and Page_Down&quot;<br>
&nbsp; echo &quot;* The four arrow keys&quot;<br>
&nbsp; echo &quot;* Tab, enter, escape, and space key&quot;<br>
&nbsp; echo &quot;* The letter and number keys, etc.&quot;<br>
&nbsp; echo<br>
Chapter 5. Quoting<br>
45<br>
<hr>
<A name=52></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot; &nbsp; &nbsp;d = show date/time&quot;<br>
&nbsp; echo &quot; &nbsp; &nbsp;q = quit&quot;<br>
&nbsp; echo &quot;================================&quot;<br>
&nbsp; echo<br>
&nbsp;# Convert the separate home-key to home-key_num_7:<br>
&nbsp;if [ &quot;$key&quot; = $'\x1b\x4f\x48' ]; then<br>
&nbsp; key=$'\x1b\x5b\x31\x7e'<br>
&nbsp; # &nbsp; Quoted string-expansion construct.&nbsp;<br>
&nbsp;fi<br>
&nbsp;# Convert the separate end-key to end-key_num_1.<br>
&nbsp;if [ &quot;$key&quot; = $'\x1b\x4f\x46' ]; then<br>
&nbsp; key=$'\x1b\x5b\x34\x7e'<br>
&nbsp;fi<br>
&nbsp;case &quot;$key&quot; in<br>
&nbsp; $'\x1b\x5b\x32\x7e') &nbsp;# Insert<br>
&nbsp; &nbsp;echo Insert Key<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x33\x7e') &nbsp;# Delete<br>
&nbsp; &nbsp;echo Delete Key<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x31\x7e') &nbsp;# Home_key_num_7<br>
&nbsp; &nbsp;echo Home Key<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x34\x7e') &nbsp;# End_key_num_1<br>
&nbsp; &nbsp;echo End Key<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x35\x7e') &nbsp;# Page_Up<br>
&nbsp; &nbsp;echo Page_Up<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x36\x7e') &nbsp;# Page_Down<br>
&nbsp; &nbsp;echo Page_Down<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x41') &nbsp;# Up_arrow<br>
&nbsp; &nbsp;echo Up arrow<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x42') &nbsp;# Down_arrow<br>
&nbsp; &nbsp;echo Down arrow<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x43') &nbsp;# Right_arrow<br>
&nbsp; &nbsp;echo Right arrow<br>
&nbsp; ;;<br>
&nbsp; $'\x1b\x5b\x44') &nbsp;# Left_arrow<br>
&nbsp; &nbsp;echo Left arrow<br>
&nbsp; ;;<br>
&nbsp; $'\x09') &nbsp;# Tab<br>
&nbsp; &nbsp;echo Tab Key<br>
&nbsp; ;;<br>
&nbsp; $'\x0a') &nbsp;# Enter<br>
&nbsp; &nbsp;echo Enter Key<br>
&nbsp; ;;<br>
&nbsp; $'\x1b') &nbsp;# Escape<br>
&nbsp; &nbsp;echo Escape Key<br>
&nbsp; ;;<br>
&nbsp; $'\x20') &nbsp;# Space<br>
&nbsp; &nbsp;echo Space Key<br>
&nbsp; ;;<br>
&nbsp; d)<br>
&nbsp; &nbsp;date<br>
&nbsp; ;;<br>
Chapter 5. Quoting<br>
46<br>
<hr>
<A name=53></a><IMG src="abs-guide-53_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; q)<br>
&nbsp; echo Time to quit...<br>
&nbsp; echo<br>
&nbsp; exit 0<br>
&nbsp; ;;<br>
&nbsp; *)<br>
&nbsp; &nbsp;echo You pressed: \'&quot;$key&quot;\'<br>
&nbsp; ;;<br>
&nbsp;esac<br>
&nbsp;echo<br>
&nbsp;echo &quot;================================&quot;<br>
&nbsp;unset K1 K2 K3<br>
&nbsp;read -s -N1 -p &quot;Press a key: &quot;<br>
&nbsp;K1=&quot;$REPLY&quot;<br>
&nbsp;read -s -N2 -t 0.001<br>
&nbsp;K2=&quot;$REPLY&quot;<br>
&nbsp;read -s -N1 -t 0.001<br>
&nbsp;K3=&quot;$REPLY&quot;<br>
&nbsp;key=&quot;$K1$K2$K3&quot;<br>
done<br>
exit $?<br>
<a href="abs-guides.html#541">See also Example 37-1.</a><br>
\&quot;<br>
gives the quote its literal meaning<br>
echo &quot;Hello&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Hello<br>
echo &quot;\&quot;Hello\&quot; ... he said.&quot; &nbsp; &nbsp;# &quot;Hello&quot; ... he said.<br>
\$<br>
gives the dollar sign its literal meaning (variable name following \$ will not be referenced)<br>
echo &quot;\$variable01&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $variable01<br>
echo &quot;The book cost \$7.98.&quot; &nbsp;# The book cost $7.98.<br>
\\<br>
gives the backslash its literal meaning<br>
echo &quot;\\&quot; &nbsp;# Results in \<br>
# Whereas . . .<br>
echo &quot;\&quot; &nbsp; # Invokes secondary prompt from the command-line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# In a script, gives an error message.<br>
# However . . .<br>
echo '\' &nbsp; # Results in \<br>
<a href="abs-guides.html#36">The behavior of \ depends on whether it is escaped, strong-quoted, weak-quoted, or appearing within<br></a><a href="abs-guides.html#170">command substitution or a here document.</a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Simple escaping and quoting<br>
echo \z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;z<br>
echo \\z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \z<br>
echo '\z' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # \z<br>
echo '\\z' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \\z<br>
Chapter 5. Quoting<br>
47<br>
<hr>
<A name=54></a>Advanced Bash-Scripting Guide<br>
echo &quot;\z&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # \z<br>
echo &quot;\\z&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \z<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Command substitution<br>
echo `echo \z` &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;z<br>
echo `echo \\z` &nbsp; &nbsp; &nbsp; # &nbsp;z<br>
echo `echo \\\z` &nbsp; &nbsp; &nbsp;# \z<br>
echo `echo \\\\z` &nbsp; &nbsp; # \z<br>
echo `echo \\\\\\z` &nbsp; # \z<br>
echo `echo \\\\\\\z` &nbsp;# \\z<br>
echo `echo &quot;\z&quot;` &nbsp; &nbsp; &nbsp;# \z<br>
echo `echo &quot;\\z&quot;` &nbsp; &nbsp; # \z<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Here document<br>
cat &lt;&lt;EOF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
\z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
EOF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # \z<br>
cat &lt;&lt;EOF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
\\z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
EOF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # \z<br>
# These examples supplied by Stéphane Chazelas.<br>
Elements of a string assigned to a variable may be escaped, but the escape character alone may not be<br>assigned to a variable.<br>
variable=\<br>
echo &quot;$variable&quot;<br>
# Will not work - gives an error message:<br>
# test.sh: : command not found<br>
# A &quot;naked&quot; escape cannot safely be assigned to a variable.<br>
#<br>
# &nbsp;What actually happens here is that the &quot;\&quot; escapes the newline and<br>
#+ the effect is &nbsp; &nbsp; &nbsp; &nbsp;variable=echo &quot;$variable&quot;<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invalid variable assignment<br>
variable=\<br>
23skidoo<br>
echo &quot;$variable&quot; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;23skidoo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This works, since the second line<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ is a valid variable assignment.<br>
variable=\&nbsp;<br>
# &nbsp; &nbsp; &nbsp; &nbsp;\^ &nbsp; &nbsp;escape followed by space<br>
echo &quot;$variable&quot; &nbsp; &nbsp; &nbsp; &nbsp;# space<br>
variable=\\<br>
echo &quot;$variable&quot; &nbsp; &nbsp; &nbsp; &nbsp;# \<br>
variable=\\\<br>
echo &quot;$variable&quot;<br>
# Will not work - gives an error message:<br>
# test.sh: \: command not found<br>
#<br>
# &nbsp;First escape escapes second one, but the third one is left &quot;naked&quot;,<br>
#+ with same result as first instance, above.<br>
variable=\\\\<br>
echo &quot;$variable&quot; &nbsp; &nbsp; &nbsp; &nbsp;# \\<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Second and fourth escapes escaped.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This is o.k.<br>
Chapter 5. Quoting<br>
48<br>
<hr>
<A name=55></a><IMG src="abs-guide-55_1.png"><br>
Advanced Bash-Scripting Guide<br>
Escaping a space can prevent word splitting in a command's argument list.<br>
file_list=&quot;/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7&quot;<br>
# List of files as argument(s) to a command.<br>
# Add two files to the list, and list all.<br>
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list<br>
echo &quot;-------------------------------------------------------------------------&quot;<br>
# What happens if we escape a couple of spaces?<br>
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list<br>
# Error: the first three files concatenated into a single argument to 'ls -l'<br>
# &nbsp; &nbsp; &nbsp; &nbsp;because the two escaped spaces prevent argument (word) splitting.<br>
The escape also provides a means of writing a multi-line command. Normally, each separate line constitutes a<br>different command, but an escape at the end of a line<i>&nbsp;escapes the newline character</i>, and the command<br>sequence continues on to the next line.<br>
(cd /source/directory &amp;&amp; tar cf - . ) | \<br>
(cd /dest/directory &amp;&amp; tar xpvf -)<br>
# Repeating Alan Cox's directory tree copy command,<br>
# but split into two lines for increased legibility.<br>
# As an alternative:<br>
tar cf - -C /source/directory . |<br>
tar xpvf - -C /dest/directory<br>
# See note below.<br>
# (Thanks, Stéphane Chazelas.)<br>
If a script line ends with a |, a pipe character, then a \, an escape, is not strictly necessary. It is, however,<br>good programming practice to always escape the end of a line of code that continues to the following<br>line.<br>
echo &quot;foo<br>
bar&quot;&nbsp;<br>
#foo<br>
#bar<br>
echo<br>
echo 'foo<br>
bar' &nbsp; &nbsp;# No difference yet.<br>
#foo<br>
#bar<br>
echo<br>
echo foo\<br>
bar &nbsp; &nbsp; # Newline escaped.<br>
#foobar<br>
echo<br>
echo &quot;foo\<br>
bar&quot; &nbsp; &nbsp; # Same here, as \ still interpreted as escape within weak quotes.<br>
#foobar<br>
echo<br>
Chapter 5. Quoting<br>
49<br>
<hr>
<A name=56></a>Advanced Bash-Scripting Guide<br>
echo 'foo\<br>
bar' &nbsp; &nbsp; # Escape character \ taken literally because of strong quoting.<br>
#foo\<br>
#bar<br>
# Examples suggested by Stéphane Chazelas.<br>
Chapter 5. Quoting<br>
50<br>
<hr>
<A name=57></a><IMG src="abs-guide-57_1.png"><br>
<b>Chapter 6. Exit and Exit Status</b><br>
<i>... there are dark corners in the Bourne shell, and<br>people use all of them.</i><br>
<i>--Chet Ramey</i><br>
The<b>&nbsp;exit</b>&nbsp;command terminates a script, just as in a<b>&nbsp;C</b>&nbsp;program. It can also return a value, which is available to<br>the script's parent process.<br>
Every command returns an<i>&nbsp;exit status</i>&nbsp;(sometimes referred to as a<i>&nbsp;return status</i>&nbsp;or<i>&nbsp;exit code</i>).&nbsp;&nbsp;A successful<br>command returns a 0, while an unsuccessful one returns a non-zero value that usually can be interpreted as an<br><i>error code</i>. Well-behaved UNIX commands, programs, and utilities return a 0 exit code upon successful<br>completion, though there are some exceptions.<br>
<a href="abs-guides.html#399">Likewise, functions within a script and the script itself return an exit status. The last command executed in the<br></a>function or script determines the exit status. Within a script, an&nbsp;<b>exit&nbsp;<i>nnn</i></b>&nbsp;command may be used to deliver<br>an&nbsp;<i>nnn</i>&nbsp;exit status to the shell (<i>nnn</i>&nbsp;must be an integer in the 0 - 255 range).<br>
When a script ends with an<b>&nbsp;exit</b>&nbsp;that has no parameter, the exit status of the script is the exit status of the<br>last command executed in the script (previous to the<b>&nbsp;exit</b>).<br>
#!/bin/bash<br>
COMMAND_1<br>
. . .<br>
COMMAND_LAST<br>
# Will exit with status of last command.<br>
exit<br>
The equivalent of a bare<b>&nbsp;exit</b>&nbsp;is<b>&nbsp;exit $?</b>&nbsp;or even just omitting the<b>&nbsp;exit</b>.<br>
#!/bin/bash<br>
COMMAND_1<br>
. . .<br>
COMMAND_LAST<br>
# Will exit with status of last command.<br>
exit $?<br>
#!/bin/bash<br>
COMMAND1<br>
. . .&nbsp;<br>
COMMAND_LAST<br>
Chapter 6. Exit and Exit Status<br>
51<br>
<hr>
<A name=58></a><IMG src="abs-guide-58_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Will exit with status of last command.<br>
$?&nbsp;reads the exit status of the last command executed. After a function returns,&nbsp;$?&nbsp;gives the exit status of the<br>last command executed in the function. This is Bash's way of giving functions a &quot;return value.&quot;&nbsp;[31]<br>
<a href="abs-guides.html#24">Following the execution of a pipe, a&nbsp;</a>$?&nbsp;gives the exit status of the last command executed.<br>
After a script terminates, a&nbsp;$?&nbsp;from the command-line gives the exit status of the script, that is, the last<br>command executed in the script, which is, by convention,&nbsp;<b>0</b>&nbsp;on success or an integer in the range 1 - 255 on<br>error.<br>
<b>Example 6-1. exit / exit status</b><br>
#!/bin/bash<br>
echo hello<br>
echo $? &nbsp; &nbsp;# Exit status 0 returned because command executed successfully.<br>
lskdf &nbsp; &nbsp; &nbsp;# Unrecognized command.<br>
echo $? &nbsp; &nbsp;# Non-zero exit status returned because command failed to execute.<br>
echo<br>
exit 113 &nbsp; # Will return 113 to shell.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# To verify this, type &quot;echo $?&quot; after script terminates.<br>
# &nbsp;By convention, an 'exit 0' indicates success,<br>
#+ while a non-zero exit value means an error or anomalous condition.<br>
<a href="abs-guides.html#109">$? is especially useful for testing the result of a command in a script (see Example 16-35 and Example 16-20).</a><br>
<a href="abs-guides.html#18">The !, the</a><i>&nbsp;logical not</i><a href="abs-guides.html#57">&nbsp;qualifier, reverses the outcome of a test or command, and this affects its exit status.</a><br>
<b>Example 6-2. Negating a condition using !</b><br>
true &nbsp; &nbsp;# The &quot;true&quot; builtin.<br>
echo &quot;exit status of \&quot;true\&quot; = $?&quot; &nbsp; &nbsp; # 0<br>
! true<br>
echo &quot;exit status of \&quot;! true\&quot; = $?&quot; &nbsp; # 1<br>
# Note that the &quot;!&quot; needs a space between it and the command.<br>
# &nbsp; &nbsp;!true &nbsp; leads to a &quot;command not found&quot; error<br>
#<br>
# The '!' operator prefixing a command invokes the Bash history mechanism.<br>
true<br>
!true<br>
# No error this time, but no negation either.<br>
# It just repeats the previous command (true).<br>
# =========================================================== #<br>
# Preceding a _pipe_ with ! inverts the exit status returned.<br>
ls | bogus_command &nbsp; &nbsp; # bash: bogus_command: command not found<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 127<br>
! ls | bogus_command &nbsp; # bash: bogus_command: command not found<br>
Chapter 6. Exit and Exit Status<br>
52<br>
<hr>
<A name=59></a><IMG src="abs-guide-59_1.png"><br>
Advanced Bash-Scripting Guide<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0<br>
# Note that the ! does not change the execution of the pipe.<br>
# Only the exit status changes.<br>
# =========================================================== #<br>
# Thanks, Stéphane Chazelas and Kristopher Newsome.<br>
<a href="abs-guides.html#787">Certain exit status codes have reserved meanings and should not be user-specified in a script.</a><br>
Chapter 6. Exit and Exit Status<br>
53<br>
<hr>
<A name=60></a><b>Chapter 7. Tests</b><br>
Every reasonably complete programming language can test for a condition, then act according to the result of<br><a href="abs-guides.html#64">the test. Bash has the test command, various bracket and parenthesis operators, and the</a><b>&nbsp;if/then</b>&nbsp;construct.<br>
<b>7.1. Test Constructs</b><br>
An<br>
•&nbsp;<br>
<b>&nbsp;if/then</b><a href="abs-guides.html#57">&nbsp;construct tests whether the exit status of a list of commands is 0 (since 0 means &quot;success&quot;</a><br>
by UNIX convention), and if so, executes one or more commands.<br>There exists a dedicated command called<br>
•&nbsp;<br>
<b>&nbsp;[</b><a href="abs-guides.html#22">&nbsp;(left bracket special character). It is a synonym for</a><b>&nbsp;test</b>,<br>
<a href="abs-guides.html#186">and a builtin for efficiency reasons. This command considers its arguments as comparison expressions<br></a>or file tests and returns an exit status corresponding to the result of the comparison (0 for true, 1 for<br>false).<br><a href="abs-guides.html#65">With version 2.02, Bash introduced the [[ ... ]]</a><br>
•&nbsp;<br>
<a href="abs-guides.html#65"><i>&nbsp;extended test command</i></a>, which performs comparisons<br>
in a manner more familiar to programmers from other languages. Note that<b>&nbsp;[[</b><a href="abs-guides.html#187">&nbsp;is a keyword, not a<br></a>command.<br>
Bash sees&nbsp;<b>[[ $a -lt $b ]]</b>&nbsp;as a single element, which returns an exit status.<br>
•&nbsp;<br>
<a href="abs-guides.html#86">The (( ... )) and let ... constructs return an exit status,</a><i>&nbsp;according to whether the arithmetic expressions<br>they evaluate expand to a non-zero value</i><a href="abs-guides.html#176">. These arithmetic-expansion constructs may therefore be<br></a><a href="abs-guides.html#71">used to perform arithmetic comparisons.</a><br>
(( 0 &amp;&amp; 1 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Logical AND<br>
echo $? &nbsp; &nbsp; # 1 &nbsp; &nbsp; ***<br>
# And so ...<br>
let &quot;num = (( 0 &amp;&amp; 1 ))&quot;<br>
echo $num &nbsp; # 0<br>
# But ...<br>
let &quot;num = (( 0 &amp;&amp; 1 ))&quot;<br>
echo $? &nbsp; &nbsp; # 1 &nbsp; &nbsp; ***<br>
(( 200 || 11 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Logical OR<br>
echo $? &nbsp; &nbsp; # 0 &nbsp; &nbsp; ***<br>
# ...<br>
let &quot;num = (( 200 || 11 ))&quot;<br>
echo $num &nbsp; # 1<br>
let &quot;num = (( 200 || 11 ))&quot;<br>
echo $? &nbsp; &nbsp; # 0 &nbsp; &nbsp; ***<br>
(( 200 | 11 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bitwise OR<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 &nbsp; &nbsp; ***<br>
# ...<br>
let &quot;num = (( 200 | 11 ))&quot;<br>
echo $num &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 203<br>
let &quot;num = (( 200 | 11 ))&quot;<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 &nbsp; &nbsp; ***<br>
# The &quot;let&quot; construct returns the same exit status<br>
#+ as the double-parentheses arithmetic expansion.<br>
Chapter 7. Tests<br>
54<br>
<hr>
<A name=61></a><IMG src="abs-guide-61_1.png"><br>
Advanced Bash-Scripting Guide<br>
Again, note that the<i>&nbsp;exit status</i>&nbsp;of an arithmetic expression is<i>&nbsp;not</i>&nbsp;an error value.<br>
var=-2 &amp;&amp; (( var+=2 ))<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 1<br>
var=-2 &amp;&amp; (( var+=2 )) &amp;&amp; echo $var<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Will not echo $var!<br>
•&nbsp;<br>
An<b>&nbsp;if</b>&nbsp;can test any command, not just conditions enclosed within brackets.<br>
if cmp a b &amp;&gt; /dev/null &nbsp;# Suppress output.<br>
then echo &quot;Files a and b are identical.&quot;<br>
else echo &quot;Files a and b differ.&quot;<br>
fi<br>
# The very useful &quot;if-grep&quot; construct:<br>
# -----------------------------------&nbsp;<br>
if grep -q Bash file<br>
&nbsp; then echo &quot;File contains at least one occurrence of Bash.&quot;<br>
fi<br>
word=Linux<br>
letter_sequence=inu<br>
if echo &quot;$word&quot; | grep -q &quot;$letter_sequence&quot;<br>
# The &quot;-q&quot; option to grep suppresses output.<br>
then<br>
&nbsp; echo &quot;$letter_sequence found in $word&quot;<br>
else<br>
&nbsp; echo &quot;$letter_sequence not found in $word&quot;<br>
fi<br>
if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED<br>
&nbsp; then echo &quot;Command succeeded.&quot;<br>
&nbsp; else echo &quot;Command failed.&quot;<br>
fi<br>
<i>These last two examples courtesy of Stéphane Chazelas.</i><br>
•&nbsp;<br>
<b>Example 7-1. What is truth?</b><br>
#!/bin/bash<br>
# &nbsp;Tip:<br>
# &nbsp;If you're unsure of how a certain condition would evaluate,<br>
#+ test it in an if-test.<br>
echo<br>
echo &quot;Testing \&quot;0\&quot;&quot;<br>
if [ 0 ] &nbsp; &nbsp; &nbsp;# zero<br>
then<br>
&nbsp; echo &quot;0 is true.&quot;<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Or else ...<br>
&nbsp; echo &quot;0 is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 is true.<br>
echo<br>
Chapter 7. Tests<br>
55<br>
<hr>
<A name=62></a>Advanced Bash-Scripting Guide<br>
echo &quot;Testing \&quot;1\&quot;&quot;<br>
if [ 1 ] &nbsp; &nbsp; &nbsp;# one<br>
then<br>
&nbsp; echo &quot;1 is true.&quot;<br>
else<br>
&nbsp; echo &quot;1 is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1 is true.<br>
echo<br>
echo &quot;Testing \&quot;-1\&quot;&quot;<br>
if [ -1 ] &nbsp; &nbsp; # minus one<br>
then<br>
&nbsp; echo &quot;-1 is true.&quot;<br>
else<br>
&nbsp; echo &quot;-1 is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# -1 is true.<br>
echo<br>
echo &quot;Testing \&quot;NULL\&quot;&quot;<br>
if [ ] &nbsp; &nbsp; &nbsp; &nbsp;# NULL (empty condition)<br>
then<br>
&nbsp; echo &quot;NULL is true.&quot;<br>
else<br>
&nbsp; echo &quot;NULL is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# NULL is false.<br>
echo<br>
echo &quot;Testing \&quot;xyz\&quot;&quot;<br>
if [ xyz ] &nbsp; &nbsp;# string<br>
then<br>
&nbsp; echo &quot;Random string is true.&quot;<br>
else<br>
&nbsp; echo &quot;Random string is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Random string is true.<br>
echo<br>
echo &quot;Testing \&quot;\$xyz\&quot;&quot;<br>
if [ $xyz ] &nbsp; # Tests if $xyz is null, but...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # it's only an uninitialized variable.<br>
then<br>
&nbsp; echo &quot;Uninitialized variable is true.&quot;<br>
else<br>
&nbsp; echo &quot;Uninitialized variable is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Uninitialized variable is false.<br>
echo<br>
echo &quot;Testing \&quot;-n \$xyz\&quot;&quot;<br>
if [ -n &quot;$xyz&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# More pedantically correct.<br>
then<br>
&nbsp; echo &quot;Uninitialized variable is true.&quot;<br>
else<br>
&nbsp; echo &quot;Uninitialized variable is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Uninitialized variable is false.<br>
echo<br>
Chapter 7. Tests<br>
56<br>
<hr>
<A name=63></a><IMG src="abs-guide-63_1.png"><br>
Advanced Bash-Scripting Guide<br>
xyz= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Initialized, but set to null value.<br>
echo &quot;Testing \&quot;-n \$xyz\&quot;&quot;<br>
if [ -n &quot;$xyz&quot; ]<br>
then<br>
&nbsp; echo &quot;Null variable is true.&quot;<br>
else<br>
&nbsp; echo &quot;Null variable is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Null variable is false.<br>
echo<br>
# When is &quot;false&quot; true?<br>
echo &quot;Testing \&quot;false\&quot;&quot;<br>
if [ &quot;false&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;It seems that &quot;false&quot; is just a string.<br>
then<br>
&nbsp; echo &quot;\&quot;false\&quot; is true.&quot; #+ and it tests true.<br>
else<br>
&nbsp; echo &quot;\&quot;false\&quot; is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;false&quot; is true.<br>
echo<br>
echo &quot;Testing \&quot;\$false\&quot;&quot; &nbsp;# Again, uninitialized variable.<br>
if [ &quot;$false&quot; ]<br>
then<br>
&nbsp; echo &quot;\&quot;\$false\&quot; is true.&quot;<br>
else<br>
&nbsp; echo &quot;\&quot;\$false\&quot; is false.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;$false&quot; is false.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Now, we get the expected result.<br>
# &nbsp;What would happen if we tested the uninitialized variable &quot;$true&quot;?<br>
echo<br>
exit 0<br>
<b>Exercise.</b><a href="abs-guides.html#61">&nbsp;Explain the behavior of Example 7-1, above.</a><br>
if [ condition-true ]<br>
then<br>
&nbsp; &nbsp;command 1<br>
&nbsp; &nbsp;command 2<br>
&nbsp; &nbsp;...<br>
else &nbsp;# Or else ...<br>
&nbsp; &nbsp; &nbsp; # Adds default code block executing if original condition tests false.<br>
&nbsp; &nbsp;command 3<br>
&nbsp; &nbsp;command 4<br>
&nbsp; &nbsp;...<br>
fi<br>
When<i>&nbsp;if</i>&nbsp;and<i>&nbsp;then</i>&nbsp;are on same line in a condition test, a semicolon must terminate the<i>&nbsp;if</i>&nbsp;statement. Both<i>&nbsp;if<br></i>and<i>&nbsp;then</i><a href="abs-guides.html#187">&nbsp;are keywords. Keywords (or commands) begin statements, and before a new statement on the<br></a>same line begins, the old one must terminate.<br>
Chapter 7. Tests<br>
57<br>
<hr>
<A name=64></a><IMG src="abs-guide-64_1.png"><br>
Advanced Bash-Scripting Guide<br>
if [ -x &quot;$filename&quot; ]; then<br>
<b>Else if and elif</b><br>
elif<br>
<b>elif</b>&nbsp;is a contraction for<i>&nbsp;else if</i>. The effect is to nest an inner if/then construct within an outer one.<br>
if [ condition1 ]<br>
then<br>
&nbsp; &nbsp;command1<br>
&nbsp; &nbsp;command2<br>
&nbsp; &nbsp;command3<br>
elif [ condition2 ]<br>
# Same as else if<br>
then<br>
&nbsp; &nbsp;command4<br>
&nbsp; &nbsp;command5<br>
else<br>
&nbsp; &nbsp;default-command<br>
fi<br>
The&nbsp;<b>if test condition-true</b>&nbsp;construct is the exact equivalent of&nbsp;<b>if [ condition-true ]</b>. As<br>it happens, the left bracket,<b>&nbsp;[</b>&nbsp;, is a<i>&nbsp;token&nbsp;</i>[32] which invokes the<b>&nbsp;test</b>&nbsp;command. The closing right bracket,<b>&nbsp;]</b>&nbsp;, in<br>an if/test should not therefore be strictly necessary, however newer versions of Bash require it.<br>
The<b>&nbsp;test</b><a href="abs-guides.html#186">&nbsp;command is a Bash builtin which tests file types and compares strings. Therefore, in a Bash<br></a>script,<b>&nbsp;test</b>&nbsp;does<i>&nbsp;not</i>&nbsp;call the external&nbsp;/usr/bin/test&nbsp;binary, which is part of the<i>&nbsp;sh-utils</i>&nbsp;package.<br>Likewise,<b>&nbsp;[</b>&nbsp;does not call&nbsp;/usr/bin/[, which is linked to&nbsp;/usr/bin/test.<br>
bash$&nbsp;<b>type test<br></b>test is a shell builtin<br>
bash$&nbsp;<b>type '['<br></b>[ is a shell builtin<br>
bash$&nbsp;<b>type '[['<br></b>[[ is a shell keyword<br>
bash$&nbsp;<b>type ']]'<br></b>]] is a shell keyword<br>
bash$&nbsp;<b>type ']'<br></b>bash: type: ]: not found<br>
If, for some reason, you wish to use&nbsp;/usr/bin/test&nbsp;in a Bash script, then specify it by full<br>pathname.<br>
<b>Example 7-2. Equivalence of<i>&nbsp;test</i></b><b>,&nbsp;/usr/bin/test, [ ], and&nbsp;/usr/bin/[</b><br>
#!/bin/bash<br>
echo<br>
if test -z &quot;$1&quot;<br>
then<br>
&nbsp; echo &quot;No command-line arguments.&quot;<br>
else<br>
&nbsp; echo &quot;First command-line argument is $1.&quot;<br>
Chapter 7. Tests<br>
58<br>
<hr>
<A name=65></a>Advanced Bash-Scripting Guide<br>
fi<br>
echo<br>
if /usr/bin/test -z &quot;$1&quot; &nbsp; &nbsp; &nbsp;# Equivalent to &quot;test&quot; builtin.<br>
# &nbsp;^^^^^^^^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Specifying full pathname.<br>
then<br>
&nbsp; echo &quot;No command-line arguments.&quot;<br>
else<br>
&nbsp; echo &quot;First command-line argument is $1.&quot;<br>
fi<br>
echo<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Functionally identical to above code blocks.<br>
# &nbsp; if [ -z &quot;$1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;should work, but...<br>
#+ &nbsp;Bash responds to a missing close-bracket with an error message.<br>
then<br>
&nbsp; echo &quot;No command-line arguments.&quot;<br>
else<br>
&nbsp; echo &quot;First command-line argument is $1.&quot;<br>
fi<br>
echo<br>
if /usr/bin/[ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # Again, functionally identical to above.<br>
# if /usr/bin/[ -z &quot;$1&quot; &nbsp; &nbsp; &nbsp; # Works, but gives an error message.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Note:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This has been fixed in Bash, version 3.x.<br>
then<br>
&nbsp; echo &quot;No command-line arguments.&quot;<br>
else<br>
&nbsp; echo &quot;First command-line argument is $1.&quot;<br>
fi<br>
echo<br>
exit 0<br>
The [[ ]] construct is the more versatile Bash version of [ ]. This is the<i>&nbsp;extended test command</i>, adopted from<br><i>ksh88</i>.<br>
* * *<br>
No filename expansion or word splitting takes place between [[ and ]], but there is parameter expansion and<br>command substitution.<br>
file=/etc/passwd<br>
if [[ -e $file ]]<br>
then<br>
&nbsp; echo &quot;Password file exists.&quot;<br>
fi<br>
Using the<b>&nbsp;[[ ... ]]</b>&nbsp;test construct, rather than<b>&nbsp;[ ... ]</b>&nbsp;can prevent many logic errors in scripts. For example, the<br>&amp;&amp;, ||, &lt;, and &gt; operators work within a [[ ]] test, despite giving an error within a [ ] construct.<br>
Chapter 7. Tests<br>
59<br>
<hr>
<A name=66></a><IMG src="abs-guide-66_1.png"><br>
Advanced Bash-Scripting Guide<br>
<i>Arithmetic evaluation</i>&nbsp;of octal / hexadecimal constants takes place automatically within a [[ ... ]] construct.<br>
# [[ Octal and hexadecimal evaluation ]]<br>
# Thank you, Moritz Gronbach, for pointing this out.<br>
decimal=15<br>
octal=017 &nbsp; # = 15 (decimal)<br>
hex=0x0f &nbsp; &nbsp;# = 15 (decimal)<br>
if [ &quot;$decimal&quot; -eq &quot;$octal&quot; ]<br>
then<br>
&nbsp; echo &quot;$decimal equals $octal&quot;<br>
else<br>
&nbsp; echo &quot;$decimal is not equal to $octal&quot; &nbsp; &nbsp; &nbsp; # 15 is not equal to 017<br>
fi &nbsp; &nbsp; &nbsp;# Doesn't evaluate within [ single brackets ]!<br>
if [[ &quot;$decimal&quot; -eq &quot;$octal&quot; ]]<br>
then<br>
&nbsp; echo &quot;$decimal equals $octal&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 15 equals 017<br>
else<br>
&nbsp; echo &quot;$decimal is not equal to $octal&quot;<br>
fi &nbsp; &nbsp; &nbsp;# Evaluates within [[ double brackets ]]!<br>
if [[ &quot;$decimal&quot; -eq &quot;$hex&quot; ]]<br>
then<br>
&nbsp; echo &quot;$decimal equals $hex&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 15 equals 0x0f<br>
else<br>
&nbsp; echo &quot;$decimal is not equal to $hex&quot;<br>
fi &nbsp; &nbsp; &nbsp;# [[ $hexadecimal ]] also evaluates!<br>
Following an<b>&nbsp;if</b>, neither the<b>&nbsp;test</b>&nbsp;command nor the test brackets ( [ ] or [[ ]] ) are strictly necessary.<br>
dir=/home/bozo<br>
if cd &quot;$dir&quot; 2&gt;/dev/null; then &nbsp; # &quot;2&gt;/dev/null&quot; hides error message.<br>
&nbsp; echo &quot;Now in $dir.&quot;<br>
else<br>
&nbsp; echo &quot;Can't change to $dir.&quot;<br>
fi<br>
The &quot;if COMMAND&quot; construct returns the exit status of COMMAND.<br>
Similarly, a condition within test brackets may stand alone without an<b>&nbsp;if</b>, when used in combination with<br><a href="abs-guides.html#424">a list construct.</a><br>
var1=20<br>
var2=22<br>
[ &quot;$var1&quot; -ne &quot;$var2&quot; ] &amp;&amp; echo &quot;$var1 is not equal to $var2&quot;<br>
home=/home/bozo<br>
[ -d &quot;$home&quot; ] || echo &quot;$home directory does not exist.&quot;<br>
<a href="abs-guides.html#86">The (( )) construct expands and evaluates an arithmetic expression. If the expression evaluates as zero, it<br></a><a href="abs-guides.html#57">returns an exit status of 1, or &quot;false&quot;. A non-zero expression returns an exit status of 0, or &quot;true&quot;. This is in<br></a>marked contrast to using the<b>&nbsp;test</b>&nbsp;and [ ] constructs previously discussed.<br>
Chapter 7. Tests<br>
60<br>
<hr>
<A name=67></a>Advanced Bash-Scripting Guide<br>
<b>Example 7-3. Arithmetic Tests using (( ))</b><br>
#!/bin/bash<br>
# arith-tests.sh<br>
# Arithmetic tests.<br>
# The (( ... )) construct evaluates and tests numerical expressions.<br>
# Exit status opposite from [ ... ] construct!<br>
(( 0 ))<br>
echo &quot;Exit status of \&quot;(( 0 ))\&quot; is $?.&quot; &nbsp; &nbsp; &nbsp; &nbsp; # 1<br>
(( 1 ))<br>
echo &quot;Exit status of \&quot;(( 1 ))\&quot; is $?.&quot; &nbsp; &nbsp; &nbsp; &nbsp; # 0<br>
(( 5 &gt; 4 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# true<br>
echo &quot;Exit status of \&quot;(( 5 &gt; 4 ))\&quot; is $?.&quot; &nbsp; &nbsp; # 0<br>
(( 5 &gt; 9 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# false<br>
echo &quot;Exit status of \&quot;(( 5 &gt; 9 ))\&quot; is $?.&quot; &nbsp; &nbsp; # 1<br>
(( 5 == 5 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # true<br>
echo &quot;Exit status of \&quot;(( 5 == 5 ))\&quot; is $?.&quot; &nbsp; &nbsp;# 0<br>
# (( 5 = 5 )) &nbsp;gives an error message.<br>
(( 5 - 5 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0<br>
echo &quot;Exit status of \&quot;(( 5 - 5 ))\&quot; is $?.&quot; &nbsp; &nbsp; # 1<br>
(( 5 / 4 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Division o.k.<br>
echo &quot;Exit status of \&quot;(( 5 / 4 ))\&quot; is $?.&quot; &nbsp; &nbsp; # 0<br>
(( 1 / 2 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Division result &lt; 1.<br>
echo &quot;Exit status of \&quot;(( 1 / 2 ))\&quot; is $?.&quot; &nbsp; &nbsp; # Rounded off to 0.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1<br>
(( 1 / 0 )) 2&gt;/dev/null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Illegal division by 0.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^<br>
echo &quot;Exit status of \&quot;(( 1 / 0 ))\&quot; is $?.&quot; &nbsp; &nbsp; # 1<br>
# What effect does the &quot;2&gt;/dev/null&quot; have?<br>
# What would happen if it were removed?<br>
# Try removing it, then rerunning the script.<br>
# ======================================= #<br>
# (( ... )) also useful in an if-then test.<br>
var1=5<br>
var2=4<br>
if (( var1 &gt; var2 ))<br>
then #^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp;Note: Not $var1, $var2. Why?<br>
&nbsp; echo &quot;$var1 is greater than $var2&quot;<br>
fi &nbsp; &nbsp; # 5 is greater than 4<br>
exit 0<br>
Chapter 7. Tests<br>
61<br>
<hr>
<A name=68></a>Advanced Bash-Scripting Guide<br>
<b>7.2. File test operators</b><br>
<b>Returns true if...</b><br>
-e<br>
file exists<br>
-a<br>
file exists<br>
This is identical in effect to -e. It has been &quot;deprecated,&quot;&nbsp;[33] and its use is discouraged.<br>
-f<br>
file is a&nbsp;<i>regular</i><a href="abs-guides.html#460">&nbsp;file (not a directory or device file)</a><br>
-s<br>
file is not zero size<br>
-d<br>
file is a directory<br>
-b<br>
<a href="abs-guides.html#889">file is a block device</a><br>
-c<br>
<a href="abs-guides.html#889">file is a character device</a><br>
device0=&quot;/dev/sda2&quot; &nbsp; &nbsp;# / &nbsp; (root directory)<br>
if [ -b &quot;$device0&quot; ]<br>
then<br>
&nbsp; echo &quot;$device0 is a block device.&quot;<br>
fi<br>
# /dev/sda2 is a block device.<br>
device1=&quot;/dev/ttyS1&quot; &nbsp; # PCMCIA modem card.<br>
if [ -c &quot;$device1&quot; ]<br>
then<br>
&nbsp; echo &quot;$device1 is a character device.&quot;<br>
fi<br>
# /dev/ttyS1 is a character device.<br>
-p<br>
<a href="abs-guides.html#24">file is a pipe</a><br>
function show_input_type()<br>
{<br>
&nbsp; &nbsp;[ -p /dev/fd/0 ] &amp;&amp; echo PIPE || echo STDIN<br>
}<br>
show_input_type &quot;Input&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # STDIN<br>
echo &quot;Input&quot; | show_input_type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# PIPE<br>
# This example courtesy of Carl Anderson.<br>
-h<br>
<a href="abs-guides.html#224">file is a symbolic link</a><br>
-L<br>
Chapter 7. Tests<br>
62<br>
<hr>
<A name=69></a>Advanced Bash-Scripting Guide<br>
file is a symbolic link<br>
-S<br>
<a href="abs-guides.html#461">file is a socket</a><br>
-t<br>
<a href="abs-guides.html#374">file (descriptor) is associated with a terminal device</a><br>
<a href="abs-guides.html#503">This test option &nbsp;may be used to check whether the&nbsp;</a>stdin&nbsp;<b>[ -t 0 ]</b>&nbsp;or&nbsp;stdout&nbsp;<b>[ -t 1 ]</b>&nbsp;in a<br>given script is a terminal.<br>
-r<br>
file has read permission (<i>for the user running the test</i>)<br>
-w<br>
file has write permission (for the user running the test)<br>
-x<br>
file has execute permission (for the user running the test)<br>
-g<br>
set-group-id (sgid) flag set on file or directory<br>
If a directory has the&nbsp;<i>sgid</i>&nbsp;flag set, then a file created within that directory belongs to the group that<br>owns the directory, not necessarily to the group of the user who created the file. This may be useful<br>for a directory shared by a workgroup.<br>
-u<br>
set-user-id (suid) flag set on file<br>
A binary owned by<i>&nbsp;root</i>&nbsp;with&nbsp;<i>set-user-id</i>&nbsp;flag set runs with<i>&nbsp;root</i>&nbsp;privileges, even when an<br>ordinary user invokes it.&nbsp;[34] This is useful for executables (such as<b>&nbsp;pppd</b>&nbsp;and<b>&nbsp;cdrecord</b>) that need to<br>access system hardware. Lacking the<i>&nbsp;suid</i>&nbsp;flag, these binaries could not be invoked by a<i>&nbsp;non-root<br></i>user.<br>
-rwsr-xr-t &nbsp; &nbsp;1 root &nbsp; &nbsp; &nbsp; 178236 Oct &nbsp;2 &nbsp;2000 /usr/sbin/pppd<br>
A file with the&nbsp;<i>suid</i>&nbsp;flag set shows an<i>&nbsp;s</i>&nbsp;in its permissions.<br>
-k<br>
<i>sticky bit</i>&nbsp;set<br>
Commonly known as the<i>&nbsp;sticky bit,</i>&nbsp;the<i>&nbsp;save-text-mode</i>&nbsp;flag is a special type of file permission. If a<br>file has this flag set, that file will be kept in cache memory, for quicker access.&nbsp;[35] If set on a<br>directory, it restricts write permission. Setting the sticky bit adds a<i>&nbsp;t</i>&nbsp;to the permissions on the file or<br>directory listing.<br>
drwxrwxrwt &nbsp; &nbsp;7 root &nbsp; &nbsp; &nbsp; &nbsp; 1024 May 19 21:26 tmp/<br>
If a user does not own a directory that has the sticky bit set, but has write permission in that directory,<br>she can only delete those files that she owns in it. This keeps users from inadvertently overwriting or<br>deleting each other's files in a publicly accessible directory, such as&nbsp;/tmp. (The<i>&nbsp;owner</i>&nbsp;of the<br>directory or<i>&nbsp;root</i>&nbsp;can, of course, delete or rename files there.)<br>
-O<br>
you are owner of file<br>
-G<br>
group-id of file same as yours<br>
-N<br>
Chapter 7. Tests<br>
63<br>
<hr>
<A name=70></a>Advanced Bash-Scripting Guide<br>
file modified since it was last read<br>
f1 -nt f2<br>
file&nbsp;<i>f1</i>&nbsp;is newer than&nbsp;<i>f2</i><br>
f1 -ot f2<br>
file&nbsp;<i>f1</i>&nbsp;is older than&nbsp;<i>f2</i><br>
f1 -ef f2<br>
files&nbsp;<i>f1</i>&nbsp;and&nbsp;<i>f2</i>&nbsp;are hard links to the same file<br>
!<br>
&quot;not&quot; -- reverses the sense of the tests above (returns true if condition absent).<br>
<b>Example 7-4. Testing for broken links</b><br>
#!/bin/bash<br>
# broken-link.sh<br>
# Written by Lee bigelow &lt;ligelowbee@yahoo.com&gt;<br>
# Used in ABS Guide with permission.<br>
# &nbsp;A pure shell script to find dead symlinks and output them quoted<br>
#+ so they can be fed to xargs and dealt with :)<br>
#+ eg. sh broken-link.sh /somedir /someotherdir|xargs rm<br>
#<br>
# &nbsp;This, however, is a better method:<br>
#<br>
# &nbsp;find &quot;somedir&quot; -type l -print0|\<br>
# &nbsp;xargs -r0 file|\<br>
# &nbsp;grep &quot;broken symbolic&quot;|<br>
# &nbsp;sed -e 's/^\|: *broken symbolic.*$/&quot;/g'<br>
#<br>
#+ but that wouldn't be pure Bash, now would it.<br>
# &nbsp;Caution: beware the /proc file system and any circular links!<br>
################################################################<br>
# &nbsp;If no args are passed to the script set directories-to-search&nbsp;<br>
#+ to current directory. &nbsp;Otherwise set the directories-to-search&nbsp;<br>
#+ to the args passed.<br>
######################<br>
[ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@<br>
# &nbsp;Setup the function linkchk to check the directory it is passed&nbsp;<br>
#+ for files that are links and don't exist, then print them quoted.<br>
# &nbsp;If one of the elements in the directory is a subdirectory then&nbsp;<br>
#+ send that subdirectory to the linkcheck function.<br>
##########<br>
linkchk () {<br>
&nbsp; &nbsp; for element in $1/*; do<br>
&nbsp; &nbsp; &nbsp; [ -h &quot;$element&quot; -a ! -e &quot;$element&quot; ] &amp;&amp; echo \&quot;$element\&quot;<br>
&nbsp; &nbsp; &nbsp; [ -d &quot;$element&quot; ] &amp;&amp; linkchk $element<br>
&nbsp; &nbsp; # Of course, '-h' tests for symbolic link, '-d' for directory.<br>
&nbsp; &nbsp; done<br>
}<br>
# &nbsp;Send each arg that was passed to the script to the linkchk() function<br>
#+ if it is a valid directoy. &nbsp;If not, then print the error message<br>
#+ and usage info.<br>
Chapter 7. Tests<br>
64<br>
<hr>
<A name=71></a>Advanced Bash-Scripting Guide<br>
##################<br>
for directory in $directorys; do<br>
&nbsp; &nbsp; if [ -d $directory ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then linkchk $directory<br>
&nbsp; &nbsp; &nbsp; &nbsp; else&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$directory is not a directory&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Usage: $0 dir1 dir2 ...&quot;<br>
&nbsp; &nbsp; fi<br>
done<br>
exit $?<br>
<a href="abs-guides.html#472">Example 31-1, Example 11-7, Example 11-3, Example 31-3, and Example A-1 also illustrate uses of the file<br></a>test operators.<br>
<b>7.3. Other Comparison Operators</b><br>
A<i>&nbsp;binary</i>&nbsp;comparison operator compares two variables or quantities.<i>&nbsp;Note that integer and string comparison<br>use a different set of operators.</i><br>
<b>integer comparison</b><br>
-eq<br>
is equal to<br>
<b>if [ &quot;$a&quot; -eq &quot;$b&quot; ]</b><br>
-ne<br>
is not equal to<br>
<b>if [ &quot;$a&quot; -ne &quot;$b&quot; ]</b><br>
-gt<br>
is greater than<br>
<b>if [ &quot;$a&quot; -gt &quot;$b&quot; ]</b><br>
-ge<br>
is greater than or equal to<br>
<b>if [ &quot;$a&quot; -ge &quot;$b&quot; ]</b><br>
-lt<br>
is less than<br>
<b>if [ &quot;$a&quot; -lt &quot;$b&quot; ]</b><br>
-le<br>
is less than or equal to<br>
<b>if [ &quot;$a&quot; -le &quot;$b&quot; ]</b><br>
&lt;<br>
<a href="abs-guides.html#86">is less than (within double parentheses)</a><br>
<b>((&quot;$a&quot; &lt; &quot;$b&quot;))</b><br>
&lt;=<br>
is less than or equal to (within double parentheses)<br>
Chapter 7. Tests<br>
65<br>
<hr>
<A name=72></a><IMG src="abs-guide-72_1.png"><br>
<IMG src="abs-guide-72_2.png"><br>
Advanced Bash-Scripting Guide<br>
<b>((&quot;$a&quot; &lt;= &quot;$b&quot;))</b><br>
&gt;<br>
is greater than (within double parentheses)<br>
<b>((&quot;$a&quot; &gt; &quot;$b&quot;))</b><br>
&gt;=<br>
is greater than or equal to (within double parentheses)<br>
<b>((&quot;$a&quot; &gt;= &quot;$b&quot;))</b><br>
<b>string comparison</b><br>
=<br>
is equal to<br>
<b>if [ &quot;$a&quot; = &quot;$b&quot; ]</b><br>
<a href="abs-guides.html#34">Note the whitespace framing the</a><b>&nbsp;=</b>.<br>
<b>if [ &quot;$a&quot;=&quot;$b&quot; ]</b>&nbsp;is<i>&nbsp;not</i>&nbsp;equivalent to the above.<br>
==<br>
is equal to<br>
<b>if [ &quot;$a&quot; == &quot;$b&quot; ]</b><br>
This is a synonym for =.<br>
<a href="abs-guides.html#65">The == comparison operator behaves differently within a double-brackets test than<br></a>within single brackets.<br>
[[ $a == z* ]] &nbsp; # True if $a starts with an &quot;z&quot; (pattern matching).<br>
[[ $a == &quot;z*&quot; ]] # True if $a is equal to z* (literal matching).<br>
[ $a == z* ] &nbsp; &nbsp; # File globbing and word splitting take place.<br>
[ &quot;$a&quot; == &quot;z*&quot; ] # True if $a is equal to z* (literal matching).<br>
# Thanks, Stéphane Chazelas<br>
!=<br>
is not equal to<br>
<b>if [ &quot;$a&quot; != &quot;$b&quot; ]</b><br>
<a href="abs-guides.html#65">This operator uses pattern matching within a [[ ... ]] construct.</a><br>
&lt;<br>
<a href="abs-guides.html#882">is less than, in ASCII alphabetical order</a><br>
<b>if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</b><br>
<b>if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</b><br>
Chapter 7. Tests<br>
66<br>
<hr>
<A name=73></a><IMG src="abs-guide-73_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#49">Note that the &quot;&lt;&quot; needs to be escaped within a&nbsp;</a><b>[ ]</b>&nbsp;construct.<br>
&gt;<br>
is greater than, in ASCII alphabetical order<br>
<b>if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</b><br>
<b>if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</b><br>
Note that the &quot;&gt;&quot; needs to be escaped within a&nbsp;<b>[ ]</b>&nbsp;construct.<br>
<a href="abs-guides.html#442">See Example 27-11 for an application of this comparison operator.</a><br>
-z<br>
string is<i>&nbsp;null</i>, that is, has zero length<br>
&nbsp;String='' &nbsp; # Zero-length (&quot;null&quot;) string variable.<br>
if [ -z &quot;$String&quot; ]<br>
then<br>
&nbsp; echo &quot;\$String is null.&quot;<br>
else<br>
&nbsp; echo &quot;\$String is NOT null.&quot;<br>
fi &nbsp; &nbsp; # $String is null.<br>
-n<br>
string is not<i>&nbsp;null.</i><br>
The&nbsp;<b>-n</b>&nbsp;test requires that the string be quoted within the test brackets. Using an<br>unquoted string with<i>&nbsp;! -z</i>, or even just the unquoted string alone within test brackets<br><a href="abs-guides.html#74">(see Example 7-6) normally works, however, this is an unsafe practice.</a><i>&nbsp;Always</i>&nbsp;quote a<br>tested string.&nbsp;[36]<br>
<b>Example 7-5. Arithmetic and string comparisons</b><br>
#!/bin/bash<br>
a=4<br>
b=5<br>
# &nbsp;Here &quot;a&quot; and &quot;b&quot; can be treated either as integers or strings.<br>
# &nbsp;There is some blurring between the arithmetic and string comparisons,<br>
#+ since Bash variables are not strongly typed.<br>
# &nbsp;Bash permits integer operations and comparisons on variables<br>
#+ whose value consists of all-integer characters.<br>
# &nbsp;Caution advised, however.<br>
echo<br>
if [ &quot;$a&quot; -ne &quot;$b&quot; ]<br>
then<br>
&nbsp; echo &quot;$a is not equal to $b&quot;<br>
&nbsp; echo &quot;(arithmetic comparison)&quot;<br>
fi<br>
echo<br>
Chapter 7. Tests<br>
67<br>
<hr>
<A name=74></a>Advanced Bash-Scripting Guide<br>
if [ &quot;$a&quot; != &quot;$b&quot; ]<br>
then<br>
&nbsp; echo &quot;$a is not equal to $b.&quot;<br>
&nbsp; echo &quot;(string comparison)&quot;<br>
&nbsp; # &nbsp; &nbsp; &quot;4&quot; &nbsp;!= &quot;5&quot;<br>
&nbsp; # ASCII 52 != ASCII 53<br>
fi<br>
# In this particular instance, both &quot;-ne&quot; and &quot;!=&quot; work.<br>
echo<br>
exit 0<br>
<b>Example 7-6. Testing whether a string is<i>&nbsp;null</i></b><br>
#!/bin/bash<br>
# &nbsp;str-test.sh: Testing null strings and unquoted strings,<br>
#+ but not strings and sealing wax, not to mention cabbages and kings . . .<br>
# Using &nbsp; if [ ... ]<br>
# If a string has not been initialized, it has no defined value.<br>
# This state is called &quot;null&quot; (not the same as zero!).<br>
if [ -n $string1 ] &nbsp; &nbsp;# string1 has not been declared or initialized.<br>
then<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is not null.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is null.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Wrong result.<br>
# Shows $string1 as not null, although it was not initialized.<br>
echo<br>
# Let's try it again.<br>
if [ -n &quot;$string1&quot; ] &nbsp;# This time, $string1 is quoted.<br>
then<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is not null.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is null.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Quote strings within test brackets!<br>
echo<br>
if [ $string1 ] &nbsp; &nbsp; &nbsp; # This time, $string1 stands naked.<br>
then<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is not null.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is null.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# This works fine.<br>
# The [ ... ] test operator alone detects whether the string is null.<br>
# However it is good practice to quote it (if [ &quot;$string1&quot; ]).<br>
#<br>
# As Stephane Chazelas points out,<br>
# &nbsp; &nbsp;if [ $string1 ] &nbsp; &nbsp;has one argument, &quot;]&quot;<br>
# &nbsp; &nbsp;if [ &quot;$string1&quot; ] &nbsp;has two arguments, the empty &quot;$string1&quot; and &quot;]&quot;&nbsp;<br>
echo<br>
Chapter 7. Tests<br>
68<br>
<hr>
<A name=75></a>Advanced Bash-Scripting Guide<br>
string1=initialized<br>
if [ $string1 ] &nbsp; &nbsp; &nbsp; # Again, $string1 stands unquoted.<br>
then<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is not null.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is null.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Again, gives correct result.<br>
# Still, it is better to quote it (&quot;$string1&quot;), because . . .<br>
string1=&quot;a = b&quot;<br>
if [ $string1 ] &nbsp; &nbsp; &nbsp; # Again, $string1 stands unquoted.<br>
then<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is not null.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;String \&quot;string1\&quot; is null.&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Not quoting &quot;$string1&quot; now gives wrong result!<br>
exit 0 &nbsp; # Thank you, also, Florian Wisser, for the &quot;heads-up&quot;.<br>
<b>Example 7-7.<i>&nbsp;zmore</i></b><br>
#!/bin/bash<br>
# zmore<br>
# View gzipped files with 'more' filter.<br>
E_NOARGS=85<br>
E_NOTFOUND=86<br>
E_NOTGZIP=87<br>
if [ $# -eq 0 ] # same effect as: &nbsp;if [ -z &quot;$1&quot; ]<br>
# $1 can exist, but be empty: &nbsp;zmore &quot;&quot; arg2 arg3<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot; &gt;&amp;2<br>
&nbsp; # Error message to stderr.<br>
&nbsp; exit $E_NOARGS<br>
&nbsp; # Returns 65 as exit status of script (error code).<br>
fi &nbsp;<br>
filename=$1<br>
if [ ! -f &quot;$filename&quot; ] &nbsp; # Quoting $filename allows for possible spaces.<br>
then<br>
&nbsp; echo &quot;File $filename not found!&quot; &gt;&amp;2 &nbsp; # Error message to stderr.<br>
&nbsp; exit $E_NOTFOUND<br>
fi &nbsp;<br>
if [ ${filename##*.} != &quot;gz&quot; ]<br>
# Using bracket in variable substitution.<br>
then<br>
&nbsp; echo &quot;File $1 is not a gzipped file!&quot;<br>
&nbsp; exit $E_NOTGZIP<br>
fi &nbsp;<br>
zcat $1 | more<br>
Chapter 7. Tests<br>
69<br>
<hr>
<A name=76></a><IMG src="abs-guide-76_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Uses the 'more' filter.<br>
# May substitute 'less' if desired.<br>
exit $? &nbsp; # Script returns exit status of pipe.<br>
# &nbsp;Actually &quot;exit $?&quot; is unnecessary, as the script will, in any case,<br>
#+ return the exit status of the last command executed.<br>
<b>compound comparison</b><br>
-a<br>
logical and<br>
<i>exp1 -a exp2</i>&nbsp;returns true if<i>&nbsp;both</i>&nbsp;exp1 and exp2 are true.<br>
-o<br>
logical or<br>
<i>exp1 -o exp2</i>&nbsp;returns true if either exp1<i>&nbsp;or</i>&nbsp;exp2 is true.<br>
These are similar to the Bash comparison operators<b>&nbsp;&amp;&amp;</b>&nbsp;and<b>&nbsp;||</b><a href="abs-guides.html#65">, used within double brackets.</a><br>
[[ condition1 &amp;&amp; condition2 ]]<br>
The<b>&nbsp;-o</b>&nbsp;and<b>&nbsp;-a</b><a href="abs-guides.html#64">&nbsp;operators work with the test command or occur within single test brackets.</a><br>
if [ &quot;$expr1&quot; -a &quot;$expr2&quot; ]<br>
then<br>
&nbsp; echo &quot;Both expr1 and expr2 are true.&quot;<br>
else<br>
&nbsp; echo &quot;Either expr1 or expr2 is false.&quot;<br>
fi<br>
But, as<i>&nbsp;rihad</i>&nbsp;points out:<br>
[ 1 -eq 1 ] &amp;&amp; [ -n &quot;`echo true 1&gt;&amp;2`&quot; ] &nbsp; # true<br>
[ 1 -eq 2 ] &amp;&amp; [ -n &quot;`echo true 1&gt;&amp;2`&quot; ] &nbsp; # (no output)<br>
# ^^^^^^^ False condition. So far, everything as expected.<br>
# However ...<br>
[ 1 -eq 2 -a -n &quot;`echo true 1&gt;&amp;2`&quot; ] &nbsp; &nbsp; &nbsp; # true<br>
# ^^^^^^^ False condition. So, why &quot;true&quot; output?<br>
# Is it because both condition clauses within brackets evaluate?<br>
[[ 1 -eq 2 &amp;&amp; -n &quot;`echo true 1&gt;&amp;2`&quot; ]] &nbsp; &nbsp; # (no output)<br>
# No, that's not it.<br>
# Apparently &amp;&amp; and || &quot;short-circuit&quot; while -a and -o do not.<br>
<a href="abs-guides.html#83">Refer to Example 8-3, Example 27-17, and Example A-29 to see compound comparison operators in action.</a><br>
<b>7.4. Nested&nbsp;<i>if/then</i></b><b>&nbsp;Condition Tests</b><br>
Condition tests using the&nbsp;<i>if/then</i><a href="abs-guides.html#82">&nbsp;construct may be nested. The net result is equivalent to using the&nbsp;<i>&amp;&amp;<br></i></a>compound comparison operator.<br>
a=3<br>
Chapter 7. Tests<br>
70<br>
<hr>
<A name=77></a>Advanced Bash-Scripting Guide<br>
if [ &quot;$a&quot; -gt 0 ]<br>
then<br>
&nbsp; if [ &quot;$a&quot; -lt 5 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;The value of \&quot;a\&quot; lies somewhere between 0 and 5.&quot;<br>
&nbsp; fi<br>
fi<br>
# Same result as:<br>
if [ &quot;$a&quot; -gt 0 ] &amp;&amp; [ &quot;$a&quot; -lt 5 ]<br>
then<br>
&nbsp; echo &quot;The value of \&quot;a\&quot; lies somewhere between 0 and 5.&quot;<br>
fi<br>
<a href="abs-guides.html#543">Example 37-4 demonstrates a nested&nbsp;</a><i>if/then</i>&nbsp;condition test.<br>
<b>7.5. Testing Your Knowledge of Tests</b><br>
The systemwide&nbsp;xinitrc&nbsp;file can be used to launch the X server. This file contains quite a number of<i>&nbsp;if/then<br></i>tests. The following is excerpted from an &quot;ancient&quot; version of&nbsp;xinitrc&nbsp;(<i>Red Hat 7.1</i>, or thereabouts).<br>
if [ -f $HOME/.Xclients ]; then<br>
&nbsp; exec $HOME/.Xclients<br>
elif [ -f /etc/X11/xinit/Xclients ]; then<br>
&nbsp; exec /etc/X11/xinit/Xclients<br>
else<br>
&nbsp; &nbsp; &nbsp;# failsafe settings. &nbsp;Although we should never get here<br>
&nbsp; &nbsp; &nbsp;# (we provide fallbacks in Xclients as well) it can't hurt.<br>
&nbsp; &nbsp; &nbsp;xclock -geometry 100x100-5+5 &amp;<br>
&nbsp; &nbsp; &nbsp;xterm -geometry 80x50-50+150 &amp;<br>
&nbsp; &nbsp; &nbsp;if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;netscape /usr/share/doc/HTML/index.html &amp;<br>
&nbsp; &nbsp; &nbsp;fi<br>
fi<br>
Explain the<i>&nbsp;test</i>&nbsp;constructs in the above snippet, then examine an updated version of the file,<br>/etc/X11/xinit/xinitrc, and analyze the<i>&nbsp;if/then</i>&nbsp;test constructs there. You may need to refer ahead to<br><a href="abs-guides.html#246">the discussions of grep, sed, and regular expressions.</a><br>
Chapter 7. Tests<br>
71<br>
<hr>
<A name=78></a><IMG src="abs-guide-78_1.png"><br>
<b>Chapter 8. Operations and Related Topics</b><br>
<b>8.1. Operators</b><br>
<b>assignment</b><br>
<i>variable assignment</i><br>
Initializing or changing the value of a variable<br>
=<br>
All-purpose assignment operator, which works for both arithmetic and string assignments.<br>
var=27<br>
category=minerals &nbsp;# No spaces allowed after the &quot;=&quot;.<br>
<a href="abs-guides.html#72">Do not confuse the &quot;=&quot; assignment operator with the = test operator.</a><br>
# &nbsp; = &nbsp;as a test operator<br>
if [ &quot;$string1&quot; = &quot;$string2&quot; ]<br>
then<br>
&nbsp; &nbsp;command<br>
fi<br>
# &nbsp;if [ &quot;X$string1&quot; = &quot;X$string2&quot; ] is safer,<br>
#+ to prevent an error message should one of the variables be empty.<br>
# &nbsp;(The prepended &quot;X&quot; characters cancel out.)<br>
<b>arithmetic operators</b><br>
+<br>
plus<br>
-<br>
minus<br>
*<br>
multiplication<br>
/<br>
division<br>
**<br>
exponentiation<br>
# Bash, version 2.02, introduced the &quot;**&quot; exponentiation operator.<br>
let &quot;z=5**3&quot; &nbsp; &nbsp;# 5 * 5 * 5<br>
echo &quot;z = $z&quot; &nbsp; # z = 125<br>
%<br>
modulo, or mod (returns the<i>&nbsp;remainder</i>&nbsp;of an integer division operation)<br>
bash$&nbsp;<b>expr 5 % 3<br></b>2<br>
<i>5/3 = 1, with remainder 2</i><br>
Chapter 8. Operations and Related Topics<br>
72<br>
<hr>
<A name=79></a>Advanced Bash-Scripting Guide<br>
This operator finds use in, among other things, generating numbers within a specific range (see<br><a href="abs-guides.html#112">Example 9-11 and Example 9-15) and formatting program output (see Example 27-16 and Example<br></a><a href="abs-guides.html#576">A-6). It can even be used to generate prime numbers, (see Example A-15). Modulo turns up<br></a>surprisingly often in numerical recipes.<br>
<b>Example 8-1. Greatest common divisor</b><br>
#!/bin/bash<br>
# gcd.sh: greatest common divisor<br>
# &nbsp; &nbsp; &nbsp; &nbsp; Uses Euclid's algorithm<br>
# &nbsp;The &quot;greatest common divisor&quot; (gcd) of two integers<br>
#+ is the largest integer that will divide both, leaving no remainder.<br>
# &nbsp;Euclid's algorithm uses successive division.<br>
# &nbsp; &nbsp;In each pass,<br>
#+ &nbsp; &nbsp; &nbsp;dividend &lt;--- &nbsp;divisor<br>
#+ &nbsp; &nbsp; &nbsp;divisor &nbsp;&lt;--- &nbsp;remainder<br>
#+ &nbsp; until remainder = 0.<br>
# &nbsp; &nbsp;The gcd = dividend, on the final pass.<br>
#<br>
# &nbsp;For an excellent discussion of Euclid's algorithm, see<br>
#+ Jim Loy's site, http://www.jimloy.com/number/euclids.htm.<br>
# ------------------------------------------------------<br>
# Argument check<br>
ARGS=2<br>
E_BADARGS=85<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` first-number second-number&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
# ------------------------------------------------------<br>
gcd ()<br>
{<br>
&nbsp; dividend=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Arbitrary assignment.<br>
&nbsp; divisor=$2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#! It doesn't matter which of the two is larger.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Why not?<br>
&nbsp; remainder=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;If an uninitialized variable is used inside<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ test brackets, an error message results.<br>
&nbsp; until [ &quot;$remainder&quot; -eq 0 ]<br>
&nbsp; do &nbsp; &nbsp;# &nbsp;^^^^^^^^^^ &nbsp;Must be previously initialized!<br>
&nbsp; &nbsp; let &quot;remainder = $dividend % $divisor&quot;<br>
&nbsp; &nbsp; dividend=$divisor &nbsp; &nbsp; # Now repeat with 2 smallest numbers.<br>
&nbsp; &nbsp; divisor=$remainder<br>
&nbsp; done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Euclid's algorithm<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Last $dividend is the gcd.<br>
gcd $1 $2<br>
Chapter 8. Operations and Related Topics<br>
73<br>
<hr>
<A name=80></a>Advanced Bash-Scripting Guide<br>
echo; echo &quot;GCD of $1 and $2 = $dividend&quot;; echo<br>
# Exercises :<br>
# ---------<br>
# 1) Check command-line arguments to make sure they are integers,<br>
#+ &nbsp; and exit the script with an appropriate error message if not.<br>
# 2) Rewrite the gcd () function to use local variables.<br>
exit 0<br>
+=<br>
<i>plus-equal</i>&nbsp;(increment variable by a constant)&nbsp;[37]<br>
<b>let &quot;var += 5&quot;</b>&nbsp;results in&nbsp;<i>var</i>&nbsp;being incremented by&nbsp;5.<br>
-=<br>
<i>minus-equal</i>&nbsp;(decrement variable by a constant)<br>
*=<br>
<i>times-equal</i>&nbsp;(multiply variable by a constant)<br>
<b>let &quot;var *= 4&quot;</b>&nbsp;results in&nbsp;<i>var</i>&nbsp;being multiplied by&nbsp;4.<br>
/=<br>
<i>slash-equal</i>&nbsp;(divide variable by a constant)<br>
%=<br>
<i>mod-equal</i>&nbsp;(<i>remainder</i>&nbsp;of dividing variable by a constant)<br>
<a href="abs-guides.html#232"><i>Arithmetic operators often occur in an expr or let expression.</i></a><br>
<b>Example 8-2. Using Arithmetic Operations</b><br>
#!/bin/bash<br>
# Counting to 11 in 10 different ways.<br>
n=1; echo -n &quot;$n &quot;<br>
let &quot;n = $n + 1&quot; &nbsp; # let &quot;n = n + 1&quot; &nbsp;also works.<br>
echo -n &quot;$n &quot;<br>
: $((n = $n + 1))<br>
# &nbsp;&quot;:&quot; necessary because otherwise Bash attempts<br>
#+ to interpret &quot;$((n = $n + 1))&quot; as a command.<br>
echo -n &quot;$n &quot;<br>
(( n = n + 1 ))<br>
# &nbsp;A simpler alternative to the method above.<br>
# &nbsp;Thanks, David Lombard, for pointing this out.<br>
echo -n &quot;$n &quot;<br>
n=$(($n + 1))<br>
echo -n &quot;$n &quot;<br>
: $[ n = $n + 1 ]<br>
# &nbsp;&quot;:&quot; necessary because otherwise Bash attempts<br>
#+ to interpret &quot;$[ n = $n + 1 ]&quot; as a command.<br>
# &nbsp;Works even if &quot;n&quot; was initialized as a string.<br>
Chapter 8. Operations and Related Topics<br>
74<br>
<hr>
<A name=81></a><IMG src="abs-guide-81_1.png"><br>
<IMG src="abs-guide-81_2.png"><br>
Advanced Bash-Scripting Guide<br>
echo -n &quot;$n &quot;<br>
n=$[ $n + 1 ]<br>
# &nbsp;Works even if &quot;n&quot; was initialized as a string.<br>
#* Avoid this type of construct, since it is obsolete and nonportable.<br>
# &nbsp;Thanks, Stephane Chazelas.<br>
echo -n &quot;$n &quot;<br>
# Now for C-style increment operators.<br>
# Thanks, Frank Wang, for pointing this out.<br>
let &quot;n++&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# let &quot;++n&quot; &nbsp;also works.<br>
echo -n &quot;$n &quot;<br>
(( n++ )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (( ++n )) &nbsp;also works.<br>
echo -n &quot;$n &quot;<br>
: $(( n++ )) &nbsp; &nbsp; &nbsp; # : $(( ++n )) also works.<br>
echo -n &quot;$n &quot;<br>
: $[ n++ ] &nbsp; &nbsp; &nbsp; &nbsp; # : $[ ++n ] also works<br>
echo -n &quot;$n &quot;<br>
echo<br>
exit 0<br>
Integer variables in older versions of Bash were signed<i>&nbsp;long</i>&nbsp;(32-bit) integers, in the range of<br>-2147483648 to 2147483647. An operation that took a variable outside these limits gave an erroneous<br>result.<br>
echo $BASH_VERSION &nbsp; # 1.14<br>
a=2147483646<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp;# a = 2147483646<br>
let &quot;a+=1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Increment &quot;a&quot;.<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp;# a = 2147483647<br>
let &quot;a+=1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # increment &quot;a&quot; again, past the limit.<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp;# a = -2147483648<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp; &nbsp;ERROR: out of range,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# + &nbsp; &nbsp;and the leftmost bit, the sign bit,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# + &nbsp; &nbsp;has been set, making the result negative.<br>
As of version &gt;= 2.05b, Bash supports 64-bit integers.<br>
Bash does not understand floating point arithmetic. It treats numbers containing a decimal point as<br>strings.<br>
a=1.5<br>
let &quot;b = $a + 1.3&quot; &nbsp;# Error.<br>
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error token is &quot;.5 + 1.3&quot;)<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; # b=1<br>
<a href="abs-guides.html#297">Use bc in scripts that that need floating point calculations or math library functions.</a><br>
Chapter 8. Operations and Related Topics<br>
75<br>
<hr>
<A name=82></a><IMG src="abs-guide-82_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>bitwise operators.</b>&nbsp;The bitwise operators seldom make an appearance in shell scripts. Their chief use seems to<br><a href="abs-guides.html#461">be manipulating and testing values read from ports or sockets. &quot;Bit flipping&quot; is more relevant to compiled<br></a>languages, such as C and C++, which provide direct access to system hardware. However, see<i>&nbsp;vladz's<br></i>ingenious use of bitwise operators in his<i>&nbsp;base64.sh</i><a href="abs-guides.html#754">&nbsp;(Example A-54) script.</a><br>
<b>bitwise operators</b><br>
&lt;&lt;<br>
bitwise left shift (multiplies by&nbsp;2&nbsp;for each shift position)<br>
&lt;&lt;=<br>
<i>left-shift-equal</i><br>
<b>let &quot;var &lt;&lt;= 2&quot;</b>&nbsp;results in&nbsp;<i>var</i>&nbsp;left-shifted&nbsp;2&nbsp;bits (multiplied by&nbsp;4)<br>
&gt;&gt;<br>
bitwise right shift (divides by&nbsp;2&nbsp;for each shift position)<br>
&gt;&gt;=<br>
<i>right-shift-equal</i>&nbsp;(inverse of &lt;&lt;=)<br>
&amp;<br>
bitwise AND<br>
&amp;=<br>
bitwise<i>&nbsp;AND-equal</i><br>
|<br>
bitwise OR<br>
|=<br>
bitwise<i>&nbsp;OR-equal</i><br>
~<br>
bitwise NOT<br>
^<br>
bitwise XOR<br>
^=<br>
bitwise<i>&nbsp;XOR-equal</i><br>
<b>logical (boolean) operators</b><br>
!<br>
NOT<br>
if [ ! -f $FILENAME ]<br>
then<br>
&nbsp; ...<br>
&amp;&amp;<br>
AND<br>
if [ $condition1 ] &amp;&amp; [ $condition2 ]<br>
# &nbsp;Same as: &nbsp;if [ $condition1 -a $condition2 ]<br>
# &nbsp;Returns true if both condition1 and condition2 hold true...<br>
if [[ $condition1 &amp;&amp; $condition2 ]] &nbsp; &nbsp;# Also works.<br>
# &nbsp;Note that &amp;&amp; operator not permitted&nbsp;<i>inside brackets</i><br>
#+ of [ ... ] construct.<br>
<a href="abs-guides.html#424">&amp;&amp; may also be used, depending on context, in an and list to concatenate commands.</a><br>
Chapter 8. Operations and Related Topics<br>
76<br>
<hr>
<A name=83></a><IMG src="abs-guide-83_1.png"><br>
Advanced Bash-Scripting Guide<br>
||<br>
OR<br>
if [ $condition1 ] || [ $condition2 ]<br>
# Same as: &nbsp;if [ $condition1 -o $condition2 ]<br>
# Returns true if either condition1 or condition2 holds true...<br>
if [[ $condition1 || $condition2 ]] &nbsp; &nbsp;# Also works.<br>
# &nbsp;Note that || operator not permitted&nbsp;<i>inside brackets</i><br>
#+ of a [ ... ] construct.<br>
<a href="abs-guides.html#57">Bash tests the exit status of each statement linked with a logical operator.</a><br>
<b>Example 8-3. Compound Condition Tests Using &amp;&amp; and ||</b><br>
#!/bin/bash<br>
a=24<br>
b=47<br>
if [ &quot;$a&quot; -eq 24 ] &amp;&amp; [ &quot;$b&quot; -eq 47 ]<br>
then<br>
&nbsp; echo &quot;Test #1 succeeds.&quot;<br>
else<br>
&nbsp; echo &quot;Test #1 fails.&quot;<br>
fi<br>
# ERROR: &nbsp; if [ &quot;$a&quot; -eq 24 &amp;&amp; &quot;$b&quot; -eq 47 ]<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; attempts to execute &nbsp;' [ &quot;$a&quot; -eq 24 '<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; and fails to finding matching ']'.<br>
#<br>
# &nbsp;Note: &nbsp;if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]] &nbsp;works.<br>
# &nbsp;The double-bracket if-test is more flexible<br>
#+ than the single-bracket version. &nbsp; &nbsp; &nbsp;&nbsp;<br>
# &nbsp; &nbsp;(The &quot;&amp;&amp;&quot; has a different meaning in line 17 than in line 6.)<br>
# &nbsp; &nbsp;Thanks, Stephane Chazelas, for pointing this out.<br>
if [ &quot;$a&quot; -eq 98 ] || [ &quot;$b&quot; -eq 47 ]<br>
then<br>
&nbsp; echo &quot;Test #2 succeeds.&quot;<br>
else<br>
&nbsp; echo &quot;Test #2 fails.&quot;<br>
fi<br>
# &nbsp;The -a and -o options provide<br>
#+ an alternative compound condition test.<br>
# &nbsp;Thanks to Patrick Callahan for pointing this out.<br>
if [ &quot;$a&quot; -eq 24 -a &quot;$b&quot; -eq 47 ]<br>
then<br>
&nbsp; echo &quot;Test #3 succeeds.&quot;<br>
else<br>
&nbsp; echo &quot;Test #3 fails.&quot;<br>
fi<br>
Chapter 8. Operations and Related Topics<br>
77<br>
<hr>
<A name=84></a>Advanced Bash-Scripting Guide<br>
if [ &quot;$a&quot; -eq 98 -o &quot;$b&quot; -eq 47 ]<br>
then<br>
&nbsp; echo &quot;Test #4 succeeds.&quot;<br>
else<br>
&nbsp; echo &quot;Test #4 fails.&quot;<br>
fi<br>
a=rhino<br>
b=crocodile<br>
if [ &quot;$a&quot; = rhino ] &amp;&amp; [ &quot;$b&quot; = crocodile ]<br>
then<br>
&nbsp; echo &quot;Test #5 succeeds.&quot;<br>
else<br>
&nbsp; echo &quot;Test #5 fails.&quot;<br>
fi<br>
exit 0<br>
The &amp;&amp; and || operators also find use in an arithmetic context.<br>
bash$&nbsp;<b>echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))<br></b>1 0 1 0<br>
<b>miscellaneous operators</b><br>
,<br>
Comma operator<br>
The<b>&nbsp;comma operator</b>&nbsp;chains together two or more arithmetic operations. All the operations are<br>evaluated (with possible<i>&nbsp;side effects</i>.&nbsp;[38]<br>
let &quot;t1 = ((5 + 3, 7 - 1, 15 - 4))&quot;<br>
echo &quot;t1 = $t1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^ &nbsp;# t1 = 11<br>
# Here t1 is set to the result of the last operation. Why?<br>
let &quot;t2 = ((a = 9, 15 / 3))&quot; &nbsp; &nbsp; &nbsp;# Set &quot;a&quot; and calculate &quot;t2&quot;.<br>
echo &quot;t2 = $t2 &nbsp; &nbsp;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp; # t2 = 5 &nbsp; &nbsp;a = 9<br>
<a href="abs-guides.html#144">The comma operator finds use mainly in for loops. See Example 11-12.</a><br>
<b>8.2. Numerical Constants</b><br>
A shell script interprets a number as decimal (base 10), unless that number has a special prefix or notation. A<br>number preceded by a&nbsp;<i>0</i>&nbsp;is&nbsp;<i>octal</i>&nbsp;(base 8). A number preceded by&nbsp;<i>0x</i>&nbsp;is&nbsp;<i>hexadecimal</i>&nbsp;(base 16). A<br>number with an embedded&nbsp;<i>#</i>&nbsp;evaluates as&nbsp;<i>BASE#NUMBER</i>&nbsp;(with range and notational restrictions).<br>
<b>Example 8-4. Representation of numerical constants</b><br>
#!/bin/bash<br>
# numbers.sh: Representation of numbers in different bases.<br>
# Decimal: the default<br>
let &quot;dec = 32&quot;<br>
echo &quot;decimal number = $dec&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 32<br>
Chapter 8. Operations and Related Topics<br>
78<br>
<hr>
<A name=85></a>Advanced Bash-Scripting Guide<br>
# Nothing out of the ordinary here.<br>
# Octal: numbers preceded by '0' (zero)<br>
let &quot;oct = 032&quot;<br>
echo &quot;octal number = $oct&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 26<br>
# Expresses result in decimal.<br>
# --------- ------ -- -------<br>
# Hexadecimal: numbers preceded by '0x' or '0X'<br>
let &quot;hex = 0x32&quot;<br>
echo &quot;hexadecimal number = $hex&quot; &nbsp; &nbsp; &nbsp; &nbsp; # 50<br>
echo $((0x9abc)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 39612<br>
# &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;^^ &nbsp; double-parentheses arithmetic expansion/evaluation<br>
# Expresses result in decimal.<br>
# Other bases: BASE#NUMBER<br>
# BASE between 2 and 64.<br>
# NUMBER must use symbols within the BASE range, see below.<br>
let &quot;bin = 2#111100111001101&quot;<br>
echo &quot;binary number = $bin&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 31181<br>
let &quot;b32 = 32#77&quot;<br>
echo &quot;base-32 number = $b32&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 231<br>
let &quot;b64 = 64#@_&quot;<br>
echo &quot;base-64 number = $b64&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 4031<br>
# This notation only works for a limited range (2 - 64) of ASCII characters.<br>
# 10 digits + 26 lowercase characters + 26 uppercase characters + @ + _<br>
echo<br>
echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1295 170 44822 3375<br>
# &nbsp;Important note:<br>
# &nbsp;--------------<br>
# &nbsp;Using a digit out of range of the specified base notation<br>
#+ gives an error message.<br>
let &quot;bad_oct = 081&quot;<br>
# (Partial) error message output:<br>
# &nbsp;bad_oct = 081: value too great for base (error token is &quot;081&quot;)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Octal numbers use only digits in the range 0 - 7.<br>
exit $? &nbsp; # Exit value = 1 (error)<br>
# Thanks, Rich Bartell and Stephane Chazelas, for clarification.<br>
Chapter 8. Operations and Related Topics<br>
79<br>
<hr>
<A name=86></a>Advanced Bash-Scripting Guide<br>
<b>8.3. The Double-Parentheses Construct</b><br>
<a href="abs-guides.html#198">Similar to the let command, the</a><b>&nbsp;(( ... ))</b>&nbsp;construct permits arithmetic expansion and evaluation. In its simplest<br>form,&nbsp;<b>a=$(( 5 + 3 ))</b>&nbsp;would set&nbsp;<b>a</b>&nbsp;to&nbsp;<b>5 + 3</b>, or&nbsp;<b>8</b>. However, this double-parentheses construct is also a<br>mechanism for allowing C-style manipulation of variables in Bash, for example,&nbsp;(( var++ )).<br>
<b>Example 8-5. C-style manipulation of variables</b><br>
#!/bin/bash<br>
# c-vars.sh<br>
# Manipulating a variable, C-style, using the (( ... )) construct.<br>
echo<br>
(( a = 23 )) &nbsp;# &nbsp;Setting a value, C-style,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ with spaces on both sides of the &quot;=&quot;.<br>
echo &quot;a (initial value) = $a&quot; &nbsp; # 23<br>
(( a++ )) &nbsp; &nbsp; # &nbsp;Post-increment 'a', C-style.<br>
echo &quot;a (after a++) = $a&quot; &nbsp; &nbsp; &nbsp; # 24<br>
(( a-- )) &nbsp; &nbsp; # &nbsp;Post-decrement 'a', C-style.<br>
echo &quot;a (after a--) = $a&quot; &nbsp; &nbsp; &nbsp; # 23<br>
(( ++a )) &nbsp; &nbsp; # &nbsp;Pre-increment 'a', C-style.<br>
echo &quot;a (after ++a) = $a&quot; &nbsp; &nbsp; &nbsp; # 24<br>
(( --a )) &nbsp; &nbsp; # &nbsp;Pre-decrement 'a', C-style.<br>
echo &quot;a (after --a) = $a&quot; &nbsp; &nbsp; &nbsp; # 23<br>
echo<br>
########################################################<br>
# &nbsp;Note that, as in C, pre- and post-decrement operators<br>
#+ have different side-effects.<br>
n=1; let --n &amp;&amp; echo &quot;True&quot; || echo &quot;False&quot; &nbsp;# False<br>
n=1; let n-- &amp;&amp; echo &quot;True&quot; || echo &quot;False&quot; &nbsp;# True<br>
# &nbsp;Thanks, Jeroen Domburg.<br>
########################################################<br>
echo<br>
(( t = a&lt;45?7:11 )) &nbsp; # C-style trinary operator.<br>
# &nbsp; &nbsp; &nbsp; ^ &nbsp;^ ^<br>
echo &quot;If a &lt; 45, then t = 7, else t = 11.&quot; &nbsp;# a = 23<br>
echo &quot;t = $t &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# t = 7<br>
echo<br>
# -----------------<br>
# Easter Egg alert!<br>
Chapter 8. Operations and Related Topics<br>
80<br>
<hr>
<A name=87></a>Advanced Bash-Scripting Guide<br>
# -----------------<br>
# &nbsp;Chet Ramey seems to have snuck a bunch of undocumented C-style<br>
#+ constructs into Bash (actually adapted from ksh, pretty much).<br>
# &nbsp;In the Bash docs, Ramey calls (( ... )) shell arithmetic,<br>
#+ but it goes far beyond that.<br>
# &nbsp;Sorry, Chet, the secret is out.<br>
# See also &quot;for&quot; and &quot;while&quot; loops using the (( ... )) construct.<br>
# These work only with version 2.04 or later of Bash.<br>
exit<br>
<a href="abs-guides.html#151">See also Example 11-12 and Example 8-4.</a><br>
<b>8.4. Operator Precedence</b><br>
In a script, operations execute in order of<i>&nbsp;precedence</i>: the higher precedence operations execute<i>&nbsp;before</i>&nbsp;the<br>lower precedence ones.&nbsp;[39]<br>
<b>Table 8-1. Operator Precedence</b><br>
<b>Operator</b><br>
<b>Meaning</b><br>
<b>Comments</b><br>
<b>HIGHEST PRECEDENCE</b><br>
var++ var--<br>
post-increment, post-decrement<br>
<a href="abs-guides.html#533">C-style operators</a><br>
++var --var<br>
pre-increment, pre-decrement<br>
! ~<br>
<a href="abs-guides.html#18">negation</a><br>
logical / bitwise, inverts sense of<br>following operator<br>
**<br>
<a href="abs-guides.html#78">exponentiation</a><br>
<a href="abs-guides.html#78">arithmetic operation</a><br>
* / %<br>
multiplication, division, modulo<br>
arithmetic operation<br>
+ -<br>
addition, subtraction<br>
arithmetic operation<br>
&lt;&lt; &gt;&gt;<br>
left, right shift<br>
<a href="abs-guides.html#82">bitwise</a><br>
-z -n<br>
<i>unary</i>&nbsp;comparison<br>
<a href="abs-guides.html#73">string is/is-not null</a><br>
-e -f -t -x, etc.<br>
<i>unary</i>&nbsp;comparison<br>
<a href="abs-guides.html#68">file-test</a><br>
&lt; -lt &gt; -gt &lt;= -le &gt;= -ge<br>
<i>compound</i>&nbsp;comparison<br>
string and integer<br>
-nt -ot -ef<br>
<i>compound</i>&nbsp;comparison<br>
file-test<br>
<a href="abs-guides.html#72">== -eq != -ne</a><br>
equality / inequality<br>
test operators, string and integer<br>
&amp;<br>
AND<br>
bitwise<br>
^<br>
XOR<br>
<i>exclusive</i>&nbsp;OR, bitwise<br>
|<br>
OR<br>
bitwise<br>
Chapter 8. Operations and Related Topics<br>
81<br>
<hr>
<A name=88></a>Advanced Bash-Scripting Guide<br>
&amp;&amp; -a<br>
AND<br>
<a href="abs-guides.html#82">logical,</a><i>&nbsp;compound</i>&nbsp;comparison<br>
|| -o<br>
OR<br>
logical,<i>&nbsp;compound</i>&nbsp;comparison<br>
?:<br>
<a href="abs-guides.html#19">trinary operator</a><br>
C-style<br>
=<br>
<a href="abs-guides.html#39">assignment</a><br>
(do not confuse with equality<br><i>test</i>)<br>
*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;=<br>
<a href="abs-guides.html#80">combination assignment</a><br>
times-equal, divide-equal,<br>mod-equal, etc.<br>
,<br>
<a href="abs-guides.html#84">comma</a><br>
links a sequence of operations<br>
<b>LOWEST PRECEDENCE</b><br>
In practice, all you really need to remember is the following:<br>
The &quot;My Dear Aunt Sally&quot; mantra (<br>
•&nbsp;<br>
<i>multiply, divide, add, subtract</i><a href="abs-guides.html#78">) for the familiar arithmetic</a><br>
<a href="abs-guides.html#78">operations.<br></a>The<br>
•&nbsp;<br>
<i>&nbsp;compound</i>&nbsp;logical operators,<b>&nbsp;&amp;&amp;</b>,<b>&nbsp;||</b>,<b>&nbsp;-a</b>, and<b>&nbsp;-o</b>&nbsp;have low precedence.<br>
The order of evaluation of equal-precedence operators is usually<br>
•&nbsp;<br>
<i>&nbsp;left-to-right</i>.<br>
Now, let's utilize our knowledge of operator precedence to analyze a couple of lines from the<br>/etc/init.d/functions file, as found in the<i>&nbsp;Fedora Core</i>&nbsp;Linux distro.<br>
while [ -n &quot;$remaining&quot; -a &quot;$retry&quot; -gt 0 ]; do<br>
# This looks rather daunting at first glance.<br>
# Separate the conditions:<br>
while [ -n &quot;$remaining&quot; -a &quot;$retry&quot; -gt 0 ]; do<br>
# &nbsp; &nbsp; &nbsp; --condition 1-- ^^ --condition 2-<br>
# &nbsp;If variable &quot;$remaining&quot; is not zero length<br>
#+ &nbsp; &nbsp; &nbsp;AND (-a)<br>
#+ variable &quot;$retry&quot; is greater-than zero<br>
#+ then<br>
#+ the [ expresion-within-condition-brackets ] returns success (0)<br>
#+ and the while-loop executes an iteration.<br>
# &nbsp;==============================================================<br>
# &nbsp;Evaluate &quot;condition 1&quot; and &quot;condition 2&quot; ***before***<br>
#+ ANDing them. Why? Because the AND (-a) has a lower precedence<br>
#+ than the -n and -gt operators,<br>
#+ and therefore gets evaluated *last*.<br>
#################################################################<br>
if [ -f /etc/sysconfig/i18n -a -z &quot;${NOLOCALE:-}&quot; ] ; then<br>
# Again, separate the conditions:<br>
if [ -f /etc/sysconfig/i18n -a -z &quot;${NOLOCALE:-}&quot; ] ; then<br>
# &nbsp; &nbsp;--condition 1--------- ^^ --condition 2-----<br>
# &nbsp;If file &quot;/etc/sysconfig/i18n&quot; exists<br>
#+ &nbsp; &nbsp; &nbsp;AND (-a)<br>
#+ variable $NOLOCALE is zero length<br>
#+ then<br>
Chapter 8. Operations and Related Topics<br>
82<br>
<hr>
<A name=89></a><IMG src="abs-guide-89_1.png"><br>
Advanced Bash-Scripting Guide<br>
#+ the [ test-expresion-within-condition-brackets ] returns success (0)<br>
#+ and the commands following execute.<br>
#<br>
# &nbsp;As before, the AND (-a) gets evaluated *last*<br>
#+ because it has the lowest precedence of the operators within<br>
#+ the test brackets.<br>
# &nbsp;==============================================================<br>
# &nbsp;Note:<br>
# &nbsp;${NOLOCALE:-} is a parameter expansion that seems redundant.<br>
# &nbsp;But, if $NOLOCALE has not been declared, it gets set to *null*,<br>
#+ in effect declaring it.<br>
# &nbsp;This makes a difference in some contexts.<br>
To avoid confusion or error in a complex sequence of test operators, break up the sequence into<br>bracketed sections.<br>
if [ &quot;$v1&quot; -gt &quot;$v2&quot; &nbsp;-o &nbsp;&quot;$v1&quot; -lt &quot;$v2&quot; &nbsp;-a &nbsp;-e &quot;$filename&quot; ]<br>
# Unclear what's going on here...<br>
if [[ &quot;$v1&quot; -gt &quot;$v2&quot; ]] || [[ &quot;$v1&quot; -lt &quot;$v2&quot; ]] &amp;&amp; [[ -e &quot;$filename&quot; ]]<br>
# Much better -- the condition tests are grouped in logical sections.<br>
Chapter 8. Operations and Related Topics<br>
83<br>
<hr>
<A name=90></a><b>Part 3. Beyond the Basics</b><br>
<b>Table of Contents<br></b><a href="abs-guides.html#91">9. Another Look at Variables</a><br>
<a href="abs-guides.html#91">9.1. Internal Variables<br></a><a href="abs-guides.html#110">9.2. Typing variables:<b>&nbsp;declare</b>&nbsp;or<b>&nbsp;typeset<br></b></a><a href="abs-guides.html#112">9.3. $RANDOM: generate random integer</a><br>
<a href="abs-guides.html#125">10. Manipulating Variables</a><br>
<a href="abs-guides.html#125">10.1. Manipulating Strings<br></a><a href="abs-guides.html#133">10.2. Parameter Substitution</a><br>
<a href="abs-guides.html#144">11. Loops and Branches</a><br>
<a href="abs-guides.html#144">11.1. Loops<br></a><a href="abs-guides.html#157">11.2. Nested Loops<br></a><a href="abs-guides.html#158">11.3. Loop Control<br></a><a href="abs-guides.html#162">11.4. Testing and Branching</a><br>
<a href="abs-guides.html#170">12. Command Substitution<br></a><a href="abs-guides.html#176">13. Arithmetic Expansion<br></a><a href="abs-guides.html#177">14. Recess Time</a><br>
Part 3. Beyond the Basics<br>
84<br>
<hr>
<A name=91></a><b>Chapter 9. Another Look at Variables</b><br>
Used properly, variables can add power and flexibility to scripts. This requires learning their subtleties and<br>nuances.<br>
<b>9.1. Internal Variables</b><br>
<a href="abs-guides.html#186"><i>Builtin variables:</i></a><br>
variables affecting bash script behavior<br>
$BASH<br>
The path to the<i>&nbsp;Bash</i>&nbsp;binary itself<br>
bash$&nbsp;<b>echo $BASH<br></b>/bin/bash<br>
$BASH_ENV<br>
<a href="abs-guides.html#41">An environmental variable pointing to a Bash startup file to be read when a script is invoked</a><br>
$BASH_SUBSHELL<br>
<a href="abs-guides.html#387">A variable indicating the subshell level. This is a new addition to Bash, version 3.</a><br>
<a href="abs-guides.html#388">See Example 21-1 for usage.</a><br>
$BASHPID<br>
<i>Process ID</i><a href="abs-guides.html#109">&nbsp;of the current instance of Bash. This is not the same as the $$ variable, but it often gives<br></a>the same result.<br>
bash4$&nbsp;<b>echo $$<br></b>11015<br>
bash4$&nbsp;<b>echo $BASHPID<br></b>11015<br>
bash4$&nbsp;<b>ps ax | grep bash4<br></b>11015 pts/2 &nbsp; &nbsp;R &nbsp; &nbsp; &nbsp;0:00 bash4<br>
But ...<br>
#!/bin/bash4<br>
echo &quot;\$\$ outside of subshell = $$&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 9602<br>
echo &quot;\$BASH_SUBSHELL &nbsp;outside of subshell = $BASH_SUBSHELL&quot; &nbsp; &nbsp; &nbsp;# 0<br>
echo &quot;\$BASHPID outside of subshell = $BASHPID&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 9602<br>
echo<br>
( echo &quot;\$\$ inside of subshell = $$&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 9602<br>
&nbsp; echo &quot;\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL&quot; &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; echo &quot;\$BASHPID inside of subshell = $BASHPID&quot; ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 9603<br>
&nbsp; # Note that $$ returns PID of parent process.<br>
$BASH_VERSINFO[n]<br>
<a href="abs-guides.html#427">A 6-element array containing version information about the installed release of Bash. This is similar<br></a>to&nbsp;$BASH_VERSION, below, but a bit more detailed.<br>
Chapter 9. Another Look at Variables<br>
85<br>
<hr>
<A name=92></a><IMG src="abs-guide-92_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Bash version info:<br>
for n in 0 1 2 3 4 5<br>
do<br>
&nbsp; echo &quot;BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}&quot;<br>
done &nbsp;<br>
# BASH_VERSINFO[0] = 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Major version no.<br>
# BASH_VERSINFO[1] = 00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Minor version no.<br>
# BASH_VERSINFO[2] = 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Patch level.<br>
# BASH_VERSINFO[3] = 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Build version.<br>
# BASH_VERSINFO[4] = release &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Release status.<br>
# BASH_VERSINFO[5] = i386-redhat-linux-gnu &nbsp;# Architecture<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (same as $MACHTYPE).<br>
$BASH_VERSION<br>
The version of Bash installed on the system<br>
bash$&nbsp;<b>echo $BASH_VERSION<br></b>3.2.25(1)-release<br>
tcsh%&nbsp;<b>echo $BASH_VERSION<br></b>BASH_VERSION: Undefined variable.<br>
<a href="abs-guides.html#103">Checking $BASH_VERSION is a good method of determining which shell is running. $SHELL does<br></a>not necessarily give the correct answer.<br>
$CDPATH<br>
<a href="abs-guides.html#196">A colon-separated list of search paths available to the cd command, similar in function to the $PATH<br></a>variable for binaries. The&nbsp;$CDPATH&nbsp;variable may be set in the local&nbsp;<a href="abs-guides.html#804">~/.bashrc&nbsp;file.</a><br>
bash$&nbsp;<b>cd bash-doc<br></b>bash: cd: bash-doc: No such file or directory<br>
bash$&nbsp;<b>CDPATH=/usr/share/doc<br></b>bash$&nbsp;<b>cd bash-doc<br></b>/usr/share/doc/bash-doc<br>
bash$&nbsp;<b>echo $PWD<br></b>/usr/share/doc/bash-doc<br>
$DIRSTACK<br>
The top value in the directory stack&nbsp;<a href="abs-guides.html#197">[40] (affected by pushd and popd)</a><br>
<a href="abs-guides.html#197">This builtin variable corresponds to the dirs command, however</a><b>&nbsp;dirs</b>&nbsp;shows the entire contents of the<br>directory stack.<br>
$EDITOR<br>
The default editor invoked by a script, usually<b>&nbsp;vi</b>&nbsp;or<b>&nbsp;emacs</b>.<br>
$EUID<br>
&quot;effective&quot; user ID number<br>
<a href="abs-guides.html#323">Identification number of whatever identity the current user has assumed, perhaps by means of su.</a><br>
The&nbsp;$EUID<a href="abs-guides.html#103">&nbsp;is not necessarily the same as the $UID.</a><br>
Chapter 9. Another Look at Variables<br>
86<br>
<hr>
<A name=93></a>Advanced Bash-Scripting Guide<br>
$FUNCNAME<br>
Name of the current function<br>
xyz23 ()<br>
{<br>
&nbsp; echo &quot;$FUNCNAME now executing.&quot; &nbsp;# xyz23 now executing.<br>
}<br>
xyz23<br>
echo &quot;FUNCNAME = $FUNCNAME&quot; &nbsp; &nbsp; &nbsp; &nbsp;# FUNCNAME =<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Null value outside a function.<br>
<a href="abs-guides.html#747">See also Example A-50.</a><br>
$GLOBIGNORE<br>
<a href="abs-guides.html#358">A list of filename patterns to be excluded from matching in globbing.</a><br>
$GROUPS<br>
Groups current user belongs to<br>
<a href="abs-guides.html#793">This is a listing (array) of the group id numbers for current user, as recorded in&nbsp;/etc/passwd&nbsp;and<br></a>/etc/group.<br>
root#&nbsp;<b>echo $GROUPS<br></b>0<br>
root#&nbsp;<b>echo ${GROUPS[1]}<br></b>1<br>
root#&nbsp;<b>echo ${GROUPS[5]}<br></b>6<br>
$HOME<br>
Home directory of the user, usually&nbsp;/home/username<a href="abs-guides.html#136">&nbsp;(see Example 10-7)</a><br>
$HOSTNAME<br>
<a href="abs-guides.html#333">The hostname command assigns the system host name at bootup in an init script. However, the<br></a>gethostname()&nbsp;function sets the Bash internal variable&nbsp;$HOSTNAME<a href="abs-guides.html#136">. See also Example 10-7.</a><br>
$HOSTTYPE<br>
host type<br>
<a href="abs-guides.html#96">Like $MACHTYPE, identifies the system hardware.</a><br>
bash$&nbsp;<b>echo $HOSTTYPE<br></b>i686<br>
$IFS<br>
internal field separator<br>
<a href="abs-guides.html#35">This variable determines how Bash recognizes fields, or word boundaries, when it interprets character<br></a>strings.<br>
<a href="abs-guides.html#34">$IFS defaults to whitespace (space, tab, and newline), but may be changed, for example, to parse a<br></a><a href="abs-guides.html#104">comma-separated data file. Note that $* uses the first character held in&nbsp;</a>$IFS<a href="abs-guides.html#48">. See Example 5-1.</a><br>
Chapter 9. Another Look at Variables<br>
87<br>
<hr>
<A name=94></a><IMG src="abs-guide-94_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>echo &quot;$IFS&quot;</b><br>
(With $IFS set to default, a blank line displays.)<br>
bash$&nbsp;<b>echo &quot;$IFS&quot; | cat -vte</b><br>
^I$<br>
&nbsp;$<br>
(Show whitespace: here a single space, ^I [horizontal tab],<br>
&nbsp; and newline, and display &quot;$&quot; at end-of-line.)<br>
bash$&nbsp;<b>bash -c 'set w x y z; IFS=&quot;:-;&quot;; echo &quot;$*&quot;'<br></b>w:x:y:z<br>
(Read commands from string and assign any arguments to pos params.)<br>
$IFS&nbsp;does not handle whitespace the same as it does other characters.<br>
<b>Example 9-1. $IFS and whitespace</b><br>
#!/bin/bash<br>
# ifs.sh<br>
var1=&quot;a+b+c&quot;<br>
var2=&quot;d-e-f&quot;<br>
var3=&quot;g,h,i&quot;<br>
IFS=+<br>
# The plus sign will be interpreted as a separator.<br>
echo $var1 &nbsp; &nbsp; # a b c<br>
echo $var2 &nbsp; &nbsp; # d-e-f<br>
echo $var3 &nbsp; &nbsp; # g,h,i<br>
echo<br>
IFS=&quot;-&quot;<br>
# The plus sign reverts to default interpretation.<br>
# The minus sign will be interpreted as a separator.<br>
echo $var1 &nbsp; &nbsp; # a+b+c<br>
echo $var2 &nbsp; &nbsp; # d e f<br>
echo $var3 &nbsp; &nbsp; # g,h,i<br>
echo<br>
IFS=&quot;,&quot;<br>
# The comma will be interpreted as a separator.<br>
# The minus sign reverts to default interpretation.<br>
echo $var1 &nbsp; &nbsp; # a+b+c<br>
echo $var2 &nbsp; &nbsp; # d-e-f<br>
echo $var3 &nbsp; &nbsp; # g h i<br>
echo<br>
IFS=&quot; &quot;<br>
# The space character will be interpreted as a separator.<br>
# The comma reverts to default interpretation.<br>
Chapter 9. Another Look at Variables<br>
88<br>
<hr>
<A name=95></a>Advanced Bash-Scripting Guide<br>
echo $var1 &nbsp; &nbsp; # a+b+c<br>
echo $var2 &nbsp; &nbsp; # d-e-f<br>
echo $var3 &nbsp; &nbsp; # g,h,i<br>
# ======================================================== #<br>
# However ...<br>
# $IFS treats whitespace differently than other characters.<br>
output_args_one_per_line()<br>
{<br>
&nbsp; for arg<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;[$arg]&quot;<br>
&nbsp; done # &nbsp;^ &nbsp; &nbsp;^ &nbsp; Embed within brackets, for your viewing pleasure.<br>
}<br>
echo; echo &quot;IFS=\&quot; \&quot;&quot;<br>
echo &quot;-------&quot;<br>
IFS=&quot; &quot;<br>
var=&quot; a &nbsp;b c &nbsp; &quot;<br>
# &nbsp; &nbsp;^ ^^ &nbsp; ^^^<br>
output_args_one_per_line $var &nbsp;# output_args_one_per_line `echo &quot; a &nbsp;b c &nbsp; &quot;`<br>
# [a]<br>
# [b]<br>
# [c]<br>
echo; echo &quot;IFS=:&quot;<br>
echo &quot;-----&quot;<br>
IFS=:<br>
var=&quot;:a::b:c:::&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Same pattern as above,<br>
# &nbsp; &nbsp;^ ^^ &nbsp; ^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ but substituting &quot;:&quot; for &quot; &quot; &nbsp;...<br>
output_args_one_per_line $var<br>
# []<br>
# [a]<br>
# []<br>
# [b]<br>
# [c]<br>
# []<br>
# []<br>
# Note &quot;empty&quot; brackets.<br>
# The same thing happens with the &quot;FS&quot; field separator in awk.<br>
echo<br>
exit<br>
(Many thanks, Stéphane Chazelas, for clarification and above examples.)<br>
<a href="abs-guides.html#282">See also Example 16-41, Example 11-7, and Example 19-14 for instructive examples of using&nbsp;</a>$IFS.<br>
$IGNOREEOF<br>
Ignore EOF: how many end-of-files (control-D) the shell will ignore before logging out.<br>
$LC_COLLATE<br>
<a href="abs-guides.html#804">Often set in the&nbsp;.bashrc&nbsp;or&nbsp;</a>/etc/profile&nbsp;files, this variable controls collation order in filename<br>expansion and pattern matching. If mishandled,&nbsp;LC_COLLATE&nbsp;can cause unexpected results in<br><a href="abs-guides.html#358">filename globbing.</a><br>
Chapter 9. Another Look at Variables<br>
89<br>
<hr>
<A name=96></a><IMG src="abs-guide-96_1.png"><br>
<IMG src="abs-guide-96_2.png"><br>
Advanced Bash-Scripting Guide<br>
As of version 2.05 of Bash, filename globbing no longer distinguishes between<br>lowercase and uppercase letters in a character range between brackets. For example,<b>&nbsp;ls<br>[A-M]*</b>&nbsp;would match both&nbsp;File1.txt&nbsp;and&nbsp;file1.txt. To revert to the customary<br>behavior of bracket matching, set&nbsp;LC_COLLATE&nbsp;to&nbsp;C&nbsp;by an&nbsp;<b>export<br>LC_COLLATE=C</b>&nbsp;in&nbsp;/etc/profile&nbsp;and/or&nbsp;~/.bashrc.<br>
$LC_CTYPE<br>
<a href="abs-guides.html#358">This internal variable controls character interpretation in globbing and pattern matching.</a><br>
$LINENO<br>
This variable is the line number of the shell script in which this variable appears. It has significance<br>only within the script in which it appears, and is chiefly useful for debugging purposes.<br>
# *** BEGIN DEBUG BLOCK ***<br>
last_cmd_arg=$_ &nbsp;# Save it.<br>
echo &quot;At line number $LINENO, variable \&quot;v1\&quot; = $v1&quot;<br>
echo &quot;Last command argument processed = $last_cmd_arg&quot;<br>
# *** END DEBUG BLOCK ***<br>
$MACHTYPE<br>
machine type<br>
Identifies the system hardware.<br>
bash$&nbsp;<b>echo $MACHTYPE<br></b>i686<br>
$OLDPWD<br>
Old working directory (&quot;OLD-Print-Working-Directory&quot;, previous directory you were in).<br>
$OSTYPE<br>
operating system type<br>
bash$&nbsp;<b>echo $OSTYPE<br></b>linux<br>
$PATH<br>
Path to binaries, usually&nbsp;/usr/bin/,&nbsp;/usr/X11R6/bin/,&nbsp;/usr/local/bin, etc.<br>
When given a command, the shell automatically does a hash table search on the directories listed in<br>the<i>&nbsp;path</i><a href="abs-guides.html#41">&nbsp;for the executable. The path is stored in the environmental variable,&nbsp;</a>$PATH, a list of<br>directories, separated by colons. Normally, the system stores the&nbsp;$PATH&nbsp;definition in<br>/etc/profile&nbsp;and/or&nbsp;<a href="abs-guides.html#804">~/.bashrc</a><a href="abs-guides.html#793">&nbsp;(see Appendix G).</a><br>
bash$&nbsp;<b>echo $PATH<br></b>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin<br>
<b>PATH=${PATH}:/opt/bin</b>&nbsp;appends the&nbsp;/opt/bin&nbsp;directory to the current path. In a script, it<br>may be expedient to temporarily add a directory to the path in this way. When the script exits, this<br>restores the original&nbsp;$PATH&nbsp;(a child process, such as a script, may not change the environment of the<br>parent process, the shell).<br>
The current &quot;working directory&quot;,&nbsp;./, is usually omitted from the&nbsp;$PATH&nbsp;as a security<br>measure.<br>
$PIPESTATUS<br>
<a href="abs-guides.html#427">Array variable holding exit status(es) of last executed</a><i>&nbsp;foreground</i><a href="abs-guides.html#24">&nbsp;pipe.</a><br>
Chapter 9. Another Look at Variables<br>
90<br>
<hr>
<A name=97></a><IMG src="abs-guide-97_1.png"><br>
<IMG src="abs-guide-97_2.png"><br>
<IMG src="abs-guide-97_3.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>echo $PIPESTATUS<br></b>0<br>
bash$&nbsp;<b>ls -al | bogus_command<br></b>bash: bogus_command: command not found<br>
bash$&nbsp;<b>echo ${PIPESTATUS[1]}<br></b>127<br>
bash$&nbsp;<b>ls -al | bogus_command<br></b>bash: bogus_command: command not found<br>
bash$&nbsp;<b>echo $?<br></b>127<br>
The members of the&nbsp;$PIPESTATUS&nbsp;array hold the exit status of each respective command executed<br>in a pipe.&nbsp;$PIPESTATUS[0]&nbsp;holds the exit status of the first command in the pipe,<br>$PIPESTATUS[1]&nbsp;the exit status of the second command, and so on.<br>
The&nbsp;$PIPESTATUS&nbsp;variable may contain an erroneous 0 value in a login shell (in<br>releases prior to 3.0 of Bash).<br>
tcsh%&nbsp;<b>bash</b><br>
bash$&nbsp;<b>who | grep nobody | sort<br></b>bash$&nbsp;<b>echo ${PIPESTATUS[*]}<br></b>0<br>
The above lines contained in a script would produce the expected&nbsp;0 1 0&nbsp;output.<br>
Thank you, Wayne Pollock for pointing this out and supplying the above example.<br>
The&nbsp;$PIPESTATUS&nbsp;variable gives unexpected results in some contexts.<br>
bash$&nbsp;<b>echo $BASH_VERSION<br></b>3.00.14(1)-release<br>
bash$&nbsp;<b>$ ls | bogus_command | wc<br></b>bash: bogus_command: command not found<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0<br>
bash$&nbsp;<b>echo ${PIPESTATUS[@]}<br></b>141 127 0<br>
<a href="abs-guides.html#220">Chet Ramey attributes the above output to the behavior of ls. If</a><i>&nbsp;ls</i>&nbsp;writes to a<i>&nbsp;pipe<br></i>whose output is not read, then&nbsp;<i>SIGPIPE</i><a href="abs-guides.html#57">&nbsp;kills it, and its exit status is 141. Otherwise<br></a><a href="abs-guides.html#254">its exit status is 0, as expected. This likewise is the case for tr.</a><br>
$PIPESTATUS&nbsp;is a &quot;volatile&quot; variable. It needs to be captured immediately after the<br>pipe in question, before any other command intervenes.<br>
bash$&nbsp;<b>$ ls | bogus_command | wc<br></b>bash: bogus_command: command not found<br>
&nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0<br>
bash$&nbsp;<b>echo ${PIPESTATUS[@]}<br></b>0 127 0<br>
Chapter 9. Another Look at Variables<br>
91<br>
<hr>
<A name=98></a><IMG src="abs-guide-98_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>echo ${PIPESTATUS[@]}<br></b>0<br>
<a href="abs-guides.html#547">The pipefail option may be useful in cases where&nbsp;</a>$PIPESTATUS&nbsp;does not give the<br>desired information.<br>
$PPID<br>
The&nbsp;$PPID&nbsp;of a process is the process ID (pid) of its parent process.&nbsp;[41]<br>
<a href="abs-guides.html#336">Compare this with the pidof command.</a><br>
$PROMPT_COMMAND<br>
A variable holding a command to be executed just before the primary prompt,&nbsp;$PS1&nbsp;is to be<br>displayed.<br>
$PS1<br>
This is the main prompt, seen at the command-line.<br>
$PS2<br>
The secondary prompt, seen when additional input is expected. It displays as &quot;&gt;&quot;.<br>
$PS3<br>
<a href="abs-guides.html#167">The tertiary prompt, displayed in a select loop (see Example 11-29).</a><br>
$PS4<br>
The quartenary prompt, shown at the beginning of each line of output when invoking a script with the<br><a href="abs-guides.html#487">-x option. It displays as &quot;+&quot;.</a><br>
$PWD<br>
Working directory (directory you are in at the time)<br>
<a href="abs-guides.html#197">This is the analog to the pwd builtin command.</a><br>
#!/bin/bash<br>
E_WRONG_DIRECTORY=65<br>
clear # Clear the screen.<br>
TargetDirectory=/home/bozo/projects/GreatAmericanNovel<br>
cd $TargetDirectory<br>
echo &quot;Deleting stale files in $TargetDirectory.&quot;<br>
if [ &quot;$PWD&quot; != &quot;$TargetDirectory&quot; ]<br>
then &nbsp; &nbsp;# Keep from wiping out wrong directory by accident.<br>
&nbsp; echo &quot;Wrong directory!&quot;<br>
&nbsp; echo &quot;In $PWD, rather than $TargetDirectory!&quot;<br>
&nbsp; echo &quot;Bailing out!&quot;<br>
&nbsp; exit $E_WRONG_DIRECTORY<br>
fi &nbsp;<br>
rm -rf *<br>
rm .[A-Za-z0-9]* &nbsp; &nbsp;# Delete dotfiles.<br>
# rm -f .[^.]* ..?* &nbsp; to remove filenames beginning with multiple dots.<br>
# (shopt -s dotglob; rm -f *) &nbsp; will also work.<br>
# Thanks, S.C. for pointing this out.<br>
# &nbsp;A filename (`basename`) may contain all characters in the 0 - 255 range,<br>
#+ except &quot;/&quot;.<br>
# &nbsp;Deleting files beginning with weird characters, such as -<br>
Chapter 9. Another Look at Variables<br>
92<br>
<hr>
<A name=99></a>Advanced Bash-Scripting Guide<br>
#+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)<br>
echo<br>
ls -al &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Any files left?<br>
echo &quot;Done.&quot;<br>
echo &quot;Old files deleted in $TargetDirectory.&quot;<br>
echo<br>
# Various other operations here, as necessary.<br>
exit $?<br>
$REPLY<br>
<a href="abs-guides.html#190">The default value when a variable is not supplied to read. Also applicable to select menus, but only<br></a>supplies the item number of the variable chosen, not the value of the variable itself.<br>
#!/bin/bash<br>
# reply.sh<br>
# REPLY is the default value for a 'read' command.<br>
echo<br>
echo -n &quot;What is your favorite vegetable? &quot;<br>
read<br>
echo &quot;Your favorite vegetable is $REPLY.&quot;<br>
# &nbsp;REPLY holds the value of last &quot;read&quot; if and only if<br>
#+ no variable supplied.<br>
echo<br>
echo -n &quot;What is your favorite fruit? &quot;<br>
read fruit<br>
echo &quot;Your favorite fruit is $fruit.&quot;<br>
echo &quot;but...&quot;<br>
echo &quot;Value of \$REPLY is still $REPLY.&quot;<br>
# &nbsp;$REPLY is still set to its previous value because<br>
#+ the variable $fruit absorbed the new &quot;read&quot; value.<br>
echo<br>
exit 0<br>
$SECONDS<br>
The number of seconds the script has been running.<br>
#!/bin/bash<br>
TIME_LIMIT=10<br>
INTERVAL=1<br>
echo<br>
echo &quot;Hit Control-C to exit before $TIME_LIMIT seconds.&quot;<br>
echo<br>
while [ &quot;$SECONDS&quot; -le &quot;$TIME_LIMIT&quot; ]<br>
do<br>
&nbsp; if [ &quot;$SECONDS&quot; -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; units=second<br>
&nbsp; else &nbsp;<br>
&nbsp; &nbsp; units=seconds<br>
&nbsp; fi<br>
Chapter 9. Another Look at Variables<br>
93<br>
<hr>
<A name=100></a><IMG src="abs-guide-100_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;This script has been running $SECONDS $units.&quot;<br>
&nbsp; # &nbsp;On a slow or overburdened machine, the script may skip a count<br>
&nbsp; #+ every once in a while.<br>
&nbsp; sleep $INTERVAL<br>
done<br>
echo -e &quot;\a&quot; &nbsp;# Beep!<br>
exit 0<br>
$SHELLOPTS<br>
<a href="abs-guides.html#487">The list of enabled shell options, a readonly variable.</a><br>
bash$&nbsp;<b>echo $SHELLOPTS<br></b>braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs<br>
$SHLVL<br>
Shell level, how deeply Bash is nested.&nbsp;[42] If, at the command-line, $SHLVL is 1, then in a script it<br>will increment to 2.<br>
<a href="abs-guides.html#389">This variable is&nbsp;<i>&nbsp;not</i>&nbsp;affected by subshells. Use $BASH_SUBSHELL when you need<br></a>an indication of subshell nesting.<br>
$TMOUT<br>
If the&nbsp;<i>$TMOUT</i>&nbsp;environmental variable is set to a non-zero value&nbsp;time, then the shell prompt will<br>time out after&nbsp;$time&nbsp;seconds. This will cause a logout.<br>
As of version 2.05b of Bash, it is now possible to use&nbsp;<i>$TMOUT</i><a href="abs-guides.html#190">&nbsp;in a script in combination with read.</a><br>
# Works in scripts for Bash, versions 2.05b and later.<br>
TMOUT=3 &nbsp; &nbsp;# Prompt times out at three seconds.<br>
echo &quot;What is your favorite song?&quot;<br>
echo &quot;Quickly now, you only have $TMOUT seconds to answer!&quot;<br>
read song<br>
if [ -z &quot;$song&quot; ]<br>
then<br>
&nbsp; song=&quot;(no answer)&quot;<br>
&nbsp; # Default response.<br>
fi<br>
echo &quot;Your favorite song is $song.&quot;<br>
There are other, more complex, ways of implementing timed input in a script. One alternative is to set<br>up a timing loop to signal the script when it times out. This also requires a signal handling routine to<br><a href="abs-guides.html#479">trap (see Example 32-5) the interrupt generated by the timing loop (whew!).</a><br>
<b>Example 9-2. Timed Input</b><br>
#!/bin/bash<br>
# timed-input.sh<br>
# TMOUT=3 &nbsp; &nbsp;Also works, as of newer versions of Bash.<br>
Chapter 9. Another Look at Variables<br>
94<br>
<hr>
<A name=101></a>Advanced Bash-Scripting Guide<br>
TIMER_INTERRUPT=14<br>
TIMELIMIT=3 &nbsp;# Three seconds in this instance.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# May be set to different value.<br>
PrintAnswer()<br>
{<br>
&nbsp; if [ &quot;$answer&quot; = TIMEOUT ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo $answer<br>
&nbsp; else &nbsp; &nbsp; &nbsp; # Don't want to mix up the two instances.&nbsp;<br>
&nbsp; &nbsp; echo &quot;Your favorite veggie is $answer&quot;<br>
&nbsp; &nbsp; kill $! &nbsp;# &nbsp;Kills no-longer-needed TimerOn function<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ running in background.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;$! is PID of last job running in background.<br>
&nbsp; fi<br>
} &nbsp;<br>
TimerOn()<br>
{<br>
&nbsp; sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;<br>
&nbsp; # Waits 3 seconds, then sends sigalarm to script.<br>
} &nbsp;<br>
Int14Vector()<br>
{<br>
&nbsp; answer=&quot;TIMEOUT&quot;<br>
&nbsp; PrintAnswer<br>
&nbsp; exit $TIMER_INTERRUPT<br>
} &nbsp;<br>
trap Int14Vector $TIMER_INTERRUPT<br>
# Timer interrupt (14) subverted for our purposes.<br>
echo &quot;What is your favorite vegetable &quot;<br>
TimerOn<br>
read answer<br>
PrintAnswer<br>
# &nbsp;Admittedly, this is a kludgy implementation of timed input.<br>
# &nbsp;However, the &quot;-t&quot; option to &quot;read&quot; simplifies this task.<br>
# &nbsp;See the &quot;t-out.sh&quot; script.<br>
# &nbsp;However, what about timing not just single user input,<br>
#+ but an entire script?<br>
# &nbsp;If you need something really elegant ...<br>
#+ consider writing the application in C or C++,<br>
#+ using appropriate library functions, such as 'alarm' and 'setitimer.'<br>
exit 0<br>
<a href="abs-guides.html#325">An alternative is using stty.</a><br>
<b>Example 9-3. Once more, timed input</b><br>
#!/bin/bash<br>
Chapter 9. Another Look at Variables<br>
95<br>
<hr>
<A name=102></a>Advanced Bash-Scripting Guide<br>
# timeout.sh<br>
# &nbsp;Written by Stephane Chazelas,<br>
#+ and modified by the document author.<br>
INTERVAL=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# timeout interval<br>
timedout_read() {<br>
&nbsp; timeout=$1<br>
&nbsp; varname=$2<br>
&nbsp; old_tty_settings=`stty -g`<br>
&nbsp; stty -icanon min 0 time ${timeout}0<br>
&nbsp; eval read $varname &nbsp; &nbsp; &nbsp;# or just &nbsp;read $varname<br>
&nbsp; stty &quot;$old_tty_settings&quot;<br>
&nbsp; # See man page for &quot;stty.&quot;<br>
}<br>
echo; echo -n &quot;What's your name? Quick! &quot;<br>
timedout_read $INTERVAL your_name<br>
# &nbsp;This may not work on every terminal type.<br>
# &nbsp;The maximum timeout depends on the terminal.<br>
#+ (it is often 25.5 seconds).<br>
echo<br>
if [ ! -z &quot;$your_name&quot; ] &nbsp;# If name input before timeout ...<br>
then<br>
&nbsp; echo &quot;Your name is $your_name.&quot;<br>
else<br>
&nbsp; echo &quot;Timed out.&quot;<br>
fi<br>
echo<br>
# The behavior of this script differs somewhat from &quot;timed-input.sh.&quot;<br>
# At each keystroke, the counter resets.<br>
exit 0<br>
Perhaps the simplest method is using the&nbsp;-t<a href="abs-guides.html#190">&nbsp;option to read.</a><br>
<b>Example 9-4. Timed<i>&nbsp;read</i></b><br>
#!/bin/bash<br>
# t-out.sh<br>
# Inspired by a suggestion from &quot;syngin seven&quot; (thanks).<br>
TIMELIMIT=4 &nbsp; &nbsp; &nbsp; &nbsp; # 4 seconds<br>
read -t $TIMELIMIT variable &lt;&amp;1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^<br>
# &nbsp;In this instance, &quot;&lt;&amp;1&quot; is needed for Bash 1.x and 2.x,<br>
# &nbsp;but unnecessary for Bash 3.x.<br>
echo<br>
if [ -z &quot;$variable&quot; ] &nbsp;# Is null?<br>
then<br>
&nbsp; echo &quot;Timed out, variable still unset.&quot;<br>
Chapter 9. Another Look at Variables<br>
96<br>
<hr>
<A name=103></a><IMG src="abs-guide-103_1.png"><br>
Advanced Bash-Scripting Guide<br>
else &nbsp;<br>
&nbsp; echo &quot;variable = $variable&quot;<br>
fi &nbsp;<br>
exit 0<br>
$UID<br>
User ID number<br>
Current user's user identification number, as recorded in&nbsp;<a href="abs-guides.html#793">/etc/passwd</a><br>
<a href="abs-guides.html#323">This is the current user's real id, even if she has temporarily assumed another identity through su.<br></a>$UID&nbsp;is a readonly variable, not subject to change from the command line or within a script, and is<br><a href="abs-guides.html#321">the counterpart to the id builtin.</a><br>
<b>Example 9-5. Am I root?</b><br>
#!/bin/bash<br>
# am-i-root.sh: &nbsp; Am I root or not?<br>
ROOT_UID=0 &nbsp; # Root has $UID 0.<br>
if [ &quot;$UID&quot; -eq &quot;$ROOT_UID&quot; ] &nbsp;# Will the real &quot;root&quot; please stand up?<br>
then<br>
&nbsp; echo &quot;You are root.&quot;<br>
else<br>
&nbsp; echo &quot;You are just an ordinary user (but mom loves you just the same).&quot;<br>
fi<br>
exit 0<br>
# ============================================================= #<br>
# Code below will not execute, because the script already exited.<br>
# An alternate method of getting to the root of matters:<br>
ROOTUSER_NAME=root<br>
username=`id -nu` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Or... &nbsp; username=`whoami`<br>
if [ &quot;$username&quot; = &quot;$ROOTUSER_NAME&quot; ]<br>
then<br>
&nbsp; echo &quot;Rooty, toot, toot. You are root.&quot;<br>
else<br>
&nbsp; echo &quot;You are just a regular fella.&quot;<br>
fi<br>
<a href="abs-guides.html#9">See also Example 2-3.</a><br>
The variables&nbsp;$ENV,&nbsp;$LOGNAME,&nbsp;$MAIL,&nbsp;$TERM,&nbsp;$USER, and&nbsp;$USERNAME&nbsp;are<i>&nbsp;not<br></i><a href="abs-guides.html#186">Bash builtins. These are, however, often set as environmental variables in one of the<br></a><a href="abs-guides.html#793">Bash startup files.&nbsp;</a>$SHELL, the name of the user's login shell, may be set from<br>/etc/passwd&nbsp;or in an &quot;init&quot; script, and it is likewise not a Bash builtin.<br>
tcsh%&nbsp;<b>echo $LOGNAME<br></b>bozo<br>
tcsh%&nbsp;<b>echo $SHELL<br></b>/bin/tcsh<br>
Chapter 9. Another Look at Variables<br>
97<br>
<hr>
<A name=104></a><IMG src="abs-guide-104_1.png"><br>
<IMG src="abs-guide-104_2.png"><br>
Advanced Bash-Scripting Guide<br>
tcsh%&nbsp;<b>echo $TERM<br></b>rxvt<br>
bash$&nbsp;<b>echo $LOGNAME<br></b>bozo<br>
bash$&nbsp;<b>echo $SHELL<br></b>/bin/tcsh<br>
bash$&nbsp;<b>echo $TERM<br></b>rxvt<br>
<b>Positional Parameters</b><br>
$0,&nbsp;$1,&nbsp;$2, etc.<br>
<a href="abs-guides.html#203">Positional parameters, passed from command line to script, passed to a function, or set to a variable<br></a><a href="abs-guides.html#42">(see Example 4-5 and Example 15-16)</a><br>
$#<br>
Number of command-line arguments&nbsp;<a href="abs-guides.html#504">[43] or positional parameters (see Example 36-2)</a><br>
$*<br>
All of the positional parameters, seen as a single word<br>
&quot;$*&quot; must be quoted.<br>
$@<br>
Same as $*, but each parameter is a quoted string, that is, the parameters are passed on intact, without<br>interpretation or expansion. This means, among other things, that each parameter in the argument list<br>is seen as a separate word.<br>
Of course, &quot;$@&quot; should be quoted.<br>
<b>Example 9-6.<i>&nbsp;arglist</i></b><b>: Listing arguments with $* and $@</b><br>
#!/bin/bash<br>
# arglist.sh<br>
# Invoke this script with several arguments, such as &quot;one two three&quot;.<br>
E_BADARGS=65<br>
if [ ! -n &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` argument1 argument2 etc.&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
echo<br>
index=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Initialize count.<br>
echo &quot;Listing args with \&quot;\$*\&quot;:&quot;<br>
for arg in &quot;$*&quot; &nbsp;# Doesn't work properly if &quot;$*&quot; isn't quoted.<br>
do<br>
&nbsp; echo &quot;Arg #$index = $arg&quot;<br>
&nbsp; let &quot;index+=1&quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $* sees all arguments as single word.&nbsp;<br>
echo &quot;Entire arg list seen as single word.&quot;<br>
echo<br>
Chapter 9. Another Look at Variables<br>
98<br>
<hr>
<A name=105></a><IMG src="abs-guide-105_1.png"><br>
Advanced Bash-Scripting Guide<br>
index=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reset count.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# What happens if you forget to do this?<br>
echo &quot;Listing args with \&quot;\$@\&quot;:&quot;<br>
for arg in &quot;$@&quot;<br>
do<br>
&nbsp; echo &quot;Arg #$index = $arg&quot;<br>
&nbsp; let &quot;index+=1&quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $@ sees arguments as separate words.&nbsp;<br>
echo &quot;Arg list seen as separate words.&quot;<br>
echo<br>
index=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reset count.<br>
echo &quot;Listing args with \$* (unquoted):&quot;<br>
for arg in $*<br>
do<br>
&nbsp; echo &quot;Arg #$index = $arg&quot;<br>
&nbsp; let &quot;index+=1&quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unquoted $* sees arguments as separate words.&nbsp;<br>
echo &quot;Arg list seen as separate words.&quot;<br>
exit 0<br>
Following a<b>&nbsp;shift</b>, the&nbsp;$@&nbsp;holds the remaining command-line parameters, lacking the previous&nbsp;$1,<br>which was lost.<br>
#!/bin/bash<br>
# Invoke with ./scriptname 1 2 3 4 5<br>
echo &quot;$@&quot; &nbsp; &nbsp;# 1 2 3 4 5<br>
shift<br>
echo &quot;$@&quot; &nbsp; &nbsp;# 2 3 4 5<br>
shift<br>
echo &quot;$@&quot; &nbsp; &nbsp;# 3 4 5<br>
# Each &quot;shift&quot; loses parameter $1.<br>
# &quot;$@&quot; then contains the remaining parameters.<br>
The&nbsp;$@&nbsp;special parameter finds use as a tool for filtering input into shell scripts. The<b>&nbsp;cat &quot;$@&quot;<br></b>construction accepts input to a script either from&nbsp;stdin&nbsp;or from files given as parameters to the<br><a href="abs-guides.html#257">script. See Example 16-24 and Example 16-25.</a><br>
The&nbsp;$*&nbsp;and&nbsp;$@&nbsp;parameters sometimes display inconsistent and puzzling behavior,<br><a href="abs-guides.html#93">depending on the setting of $IFS.</a><br>
<b>Example 9-7. Inconsistent&nbsp;$*&nbsp;and&nbsp;$@&nbsp;behavior</b><br>
#!/bin/bash<br>
# &nbsp;Erratic behavior of the &quot;$*&quot; and &quot;$@&quot; internal Bash variables,<br>
#+ depending on whether they are quoted or not.<br>
# &nbsp;Inconsistent handling of word splitting and linefeeds.<br>
set -- &quot;First one&quot; &quot;second&quot; &quot;third:one&quot; &quot;&quot; &quot;Fifth: :one&quot;<br>
# Setting the script arguments, $1, $2, etc.<br>
echo<br>
Chapter 9. Another Look at Variables<br>
99<br>
<hr>
<A name=106></a>Advanced Bash-Scripting Guide<br>
echo 'IFS unchanged, using &quot;$*&quot;'<br>
c=0<br>
for i in &quot;$*&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # quoted<br>
do echo &quot;$((c+=1)): [$i]&quot; &nbsp; # This line remains the same in every instance.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Echo args.<br>
done<br>
echo ---<br>
echo 'IFS unchanged, using $*'<br>
c=0<br>
for i in $* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # unquoted<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS unchanged, using &quot;$@&quot;'<br>
c=0<br>
for i in &quot;$@&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS unchanged, using $@'<br>
c=0<br>
for i in $@<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
IFS=:<br>
echo 'IFS=&quot;:&quot;, using &quot;$*&quot;'<br>
c=0<br>
for i in &quot;$*&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using $*'<br>
c=0<br>
for i in $*<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
var=$*<br>
echo 'IFS=&quot;:&quot;, using &quot;$var&quot; (var=$*)'<br>
c=0<br>
for i in &quot;$var&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using $var (var=$*)'<br>
c=0<br>
for i in $var<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
var=&quot;$*&quot;<br>
echo 'IFS=&quot;:&quot;, using $var (var=&quot;$*&quot;)'<br>
Chapter 9. Another Look at Variables<br>
100<br>
<hr>
<A name=107></a>Advanced Bash-Scripting Guide<br>
c=0<br>
for i in $var<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using &quot;$var&quot; (var=&quot;$*&quot;)'<br>
c=0<br>
for i in &quot;$var&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using &quot;$@&quot;'<br>
c=0<br>
for i in &quot;$@&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using $@'<br>
c=0<br>
for i in $@<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
var=$@<br>
echo 'IFS=&quot;:&quot;, using $var (var=$@)'<br>
c=0<br>
for i in $var<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using &quot;$var&quot; (var=$@)'<br>
c=0<br>
for i in &quot;$var&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
var=&quot;$@&quot;<br>
echo 'IFS=&quot;:&quot;, using &quot;$var&quot; (var=&quot;$@&quot;)'<br>
c=0<br>
for i in &quot;$var&quot;<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo ---<br>
echo 'IFS=&quot;:&quot;, using $var (var=&quot;$@&quot;)'<br>
c=0<br>
for i in $var<br>
do echo &quot;$((c+=1)): [$i]&quot;<br>
done<br>
echo<br>
# Try this script with ksh or zsh -y.<br>
exit 0<br>
Chapter 9. Another Look at Variables<br>
101<br>
<hr>
<A name=108></a><IMG src="abs-guide-108_1.png"><br>
<IMG src="abs-guide-108_2.png"><br>
Advanced Bash-Scripting Guide<br>
# This example script by Stephane Chazelas,<br>
# and slightly modified by the document author.<br>
The<b>&nbsp;$@</b>&nbsp;and<b>&nbsp;$*</b>&nbsp;parameters differ only when between double quotes.<br>
<b>Example 9-8.&nbsp;$*&nbsp;and&nbsp;$@&nbsp;when&nbsp;$IFS&nbsp;is empty</b><br>
#!/bin/bash<br>
# &nbsp;If $IFS set, but empty,<br>
#+ then &quot;$*&quot; and &quot;$@&quot; do not echo positional params as expected.<br>
mecho () &nbsp; &nbsp; &nbsp; # Echo positional parameters.<br>
{<br>
echo &quot;$1,$2,$3&quot;;<br>
}<br>
IFS=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; # Set, but empty.<br>
set a b c &nbsp; &nbsp; &nbsp;# Positional parameters.<br>
mecho &quot;$*&quot; &nbsp; &nbsp; # abc,,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
mecho $* &nbsp; &nbsp; &nbsp; # a,b,c<br>
mecho $@ &nbsp; &nbsp; &nbsp; # a,b,c<br>
mecho &quot;$@&quot; &nbsp; &nbsp; # a,b,c<br>
# &nbsp;The behavior of $* and $@ when $IFS is empty depends<br>
#+ on which Bash or sh version being run.<br>
# &nbsp;It is therefore inadvisable to depend on this &quot;feature&quot; in a script.<br>
# Thanks, Stephane Chazelas.<br>
exit<br>
<b>Other Special Parameters</b><br>
$-<br>
<a href="abs-guides.html#203">Flags passed to script (using set). See Example 15-16.</a><br>
This was originally a<i>&nbsp;ksh</i>&nbsp;construct adopted into Bash, and unfortunately it does not<br>seem to work reliably in Bash scripts. One possible use for it is to have a script<br><a href="abs-guides.html#503">self-test whether it is interactive.</a><br>
$!<br>
<a href="abs-guides.html#882">PID (process ID) of last job run in background</a><br>
LOG=$0.log<br>
COMMAND1=&quot;sleep 100&quot;<br>
echo &quot;Logging PIDs background commands for script: $0&quot; &gt;&gt; &quot;$LOG&quot;<br>
# So they can be monitored, and killed as necessary.<br>
echo &gt;&gt; &quot;$LOG&quot;<br>
# Logging commands.<br>
Chapter 9. Another Look at Variables<br>
102<br>
<hr>
<A name=109></a>Advanced Bash-Scripting Guide<br>
echo -n &quot;PID of \&quot;$COMMAND1\&quot;: &nbsp;&quot; &gt;&gt; &quot;$LOG&quot;<br>
${COMMAND1} &amp;<br>
echo $! &gt;&gt; &quot;$LOG&quot;<br>
# PID of &quot;sleep 100&quot;: &nbsp;1506<br>
# Thank you, Jacques Lederer, for suggesting this.<br>
Using&nbsp;$!&nbsp;for job control:<br>
possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval 'kill -9 $!' &amp;&gt; /dev/null; }<br>
# Forces completion of an ill-behaved program.<br>
# Useful, for example, in init scripts.<br>
# Thank you, Sylvain Fourmanoit, for this creative use of the &quot;!&quot; variable.<br>
Or, alternately:<br>
# This example by Matthew Sage.<br>
# Used with permission.<br>
TIMEOUT=30 &nbsp; # Timeout value in seconds<br>
count=0<br>
possibly_hanging_job &amp; {<br>
&nbsp; &nbsp; &nbsp; &nbsp; while ((count &lt; TIMEOUT )); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eval '[ ! -d &quot;/proc/$!&quot; ] &amp;&amp; ((count = TIMEOUT))'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # /proc is where information about running processes is found.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;-d&quot; tests whether it exists (whether directory exists).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # So, we're waiting for the job in question to show up.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((count++))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval '[ -d &quot;/proc/$!&quot; ] &amp;&amp; kill -15 $!'<br>
&nbsp; &nbsp; &nbsp; &nbsp; # If the hanging job is running, kill it.<br>
}<br>
$_<br>
Special variable set to final argument of previous command executed.<br>
<b>Example 9-9. Underscore variable</b><br>
#!/bin/bash<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;/bin/bash<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Just called /bin/bash to run the script.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Note that this will vary according to<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ how the script is invoked.<br>
du &gt;/dev/null &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;So no output from command.<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;du<br>
ls -al &gt;/dev/null &nbsp; &nbsp;# &nbsp;So no output from command.<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;-al &nbsp;(last argument)<br>
:<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;:<br>
$?<br>
<a href="abs-guides.html#57">Exit status of a command, function, or the script itself (see Example 24-7)</a><br>
$$<br>
Chapter 9. Another Look at Variables<br>
103<br>
<hr>
<A name=110></a>Advanced Bash-Scripting Guide<br>
Process ID (<i>PID</i>) of the script itself.&nbsp;[44] The&nbsp;$$&nbsp;variable often finds use in scripts to construct<br><a href="abs-guides.html#480">&quot;unique&quot; temp file names (see Example 32-6, Example 16-31, and Example 15-27). This is usually<br></a><a href="abs-guides.html#279">simpler than invoking mktemp.</a><br>
<b>9.2. Typing variables: declare or typeset</b><br>
The<i>&nbsp;declare</i>&nbsp;or<i>&nbsp;typeset</i><a href="abs-guides.html#186">&nbsp;builtins, which are exact synonyms, permit modifying the properties of variables. This<br></a>is a very weak form of the<i>&nbsp;typing&nbsp;</i>[45] available in certain programming languages. The<i>&nbsp;declare</i>&nbsp;command is<br>specific to version 2 or later of Bash. The<i>&nbsp;typeset</i>&nbsp;command also works in ksh scripts.<br>
<b>declare/typeset options</b><br>
-r&nbsp;<i>readonly</i><br>
(<b>declare -r var1</b>&nbsp;works the same as&nbsp;<b>readonly var1</b>)<br>
This is the rough equivalent of the<b>&nbsp;C</b><i>&nbsp;const</i>&nbsp;type qualifier. An attempt to change the value of a<br><i>readonly</i>&nbsp;variable fails with an error message.<br>
declare -r var1=1<br>
echo &quot;var1 = $var1&quot; &nbsp; # var1 = 1<br>
(( var1++ )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# x.sh: line 4: var1: readonly variable<br>
-i&nbsp;<i>integer</i><br>
declare -i number<br>
# The script will treat subsequent occurrences of &quot;number&quot; as an integer. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
number=3<br>
echo &quot;Number = $number&quot; &nbsp; &nbsp; # Number = 3<br>
number=three<br>
echo &quot;Number = $number&quot; &nbsp; &nbsp; # Number = 0<br>
# Tries to evaluate the string &quot;three&quot; as an integer.<br>
<a href="abs-guides.html#232">Certain arithmetic operations are permitted for declared integer variables without the need for expr or<br></a><a href="abs-guides.html#198">let.</a><br>
n=6/3<br>
echo &quot;n = $n&quot; &nbsp; &nbsp; &nbsp; # n = 6/3<br>
declare -i n<br>
n=6/3<br>
echo &quot;n = $n&quot; &nbsp; &nbsp; &nbsp; # n = 2<br>
-a&nbsp;<i>array</i><br>
declare -a indices<br>
The variable&nbsp;<i>indices</i><a href="abs-guides.html#427">&nbsp;will be treated as an array.</a><br>
-f&nbsp;<i>function(s)</i><br>
declare -f<br>
A&nbsp;<b>declare -f</b><a href="abs-guides.html#399">&nbsp;line with no arguments in a script causes a listing of all the functions previously<br></a>defined in that script.<br>
Chapter 9. Another Look at Variables<br>
104<br>
<hr>
<A name=111></a><IMG src="abs-guide-111_1.png"><br>
Advanced Bash-Scripting Guide<br>
declare -f function_name<br>
A&nbsp;<b>declare -f function_name</b>&nbsp;in a script lists just the function named.<br>
<a href="abs-guides.html#206">-x export</a><br>
declare -x var3<br>
This declares a variable as available for exporting outside the environment of the script itself.<br>
-x var=$value<br>
declare -x var3=373<br>
The<b>&nbsp;declare</b>&nbsp;command permits assigning a value to a variable in the same statement as setting its<br>properties.<br>
<b>Example 9-10. Using<i>&nbsp;declare</i></b><b>&nbsp;to type variables</b><br>
#!/bin/bash<br>
func1 ()<br>
{<br>
&nbsp; echo This is a function.<br>
}<br>
declare -f &nbsp; &nbsp; &nbsp; &nbsp;# Lists the function above.<br>
echo<br>
declare -i var1 &nbsp; # var1 is an integer.<br>
var1=2367<br>
echo &quot;var1 declared as $var1&quot;<br>
var1=var1+1 &nbsp; &nbsp; &nbsp; # Integer declaration eliminates the need for 'let'.<br>
echo &quot;var1 incremented by 1 is $var1.&quot;<br>
# Attempt to change variable declared as integer.<br>
echo &quot;Attempting to change var1 to floating point value, 2367.1.&quot;<br>
var1=2367.1 &nbsp; &nbsp; &nbsp; # Results in error message, with no change to variable.<br>
echo &quot;var1 is still $var1&quot;<br>
echo<br>
declare -r var2=13.36 &nbsp; &nbsp; &nbsp; &nbsp; # 'declare' permits setting a variable property<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and simultaneously assigning it a value.<br>
echo &quot;var2 declared as $var2&quot; # Attempt to change readonly variable.<br>
var2=13.37 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Generates error message, and exit from script.<br>
echo &quot;var2 is still $var2&quot; &nbsp; &nbsp;# This line will not execute.<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Script will not exit here.<br>
Using the<i>&nbsp;declare</i><a href="abs-guides.html#389">&nbsp;builtin restricts the scope of a variable.</a><br>
foo ()<br>
{<br>
FOO=&quot;bar&quot;<br>
}<br>
bar ()<br>
{<br>
foo<br>
Chapter 9. Another Look at Variables<br>
105<br>
<hr>
<A name=112></a>Advanced Bash-Scripting Guide<br>
echo $FOO<br>
}<br>
bar &nbsp; # Prints bar.<br>
However . . .<br>
foo (){<br>
declare FOO=&quot;bar&quot;<br>
}<br>
bar ()<br>
{<br>
foo<br>
echo $FOO<br>
}<br>
bar &nbsp;# Prints nothing.<br>
# Thank you, Michael Iatrou, for pointing this out.<br>
<b>9.2.1. Another use for<i>&nbsp;declare</i></b><br>
The<i>&nbsp;declare</i><a href="abs-guides.html#41">&nbsp;command can be helpful in identifying variables, environmental or otherwise. This can be<br></a><a href="abs-guides.html#427">especially useful with arrays.</a><br>
bash$&nbsp;<b>declare | grep HOME<br></b>HOME=/home/bozo<br>
bash$&nbsp;<b>zzy=68<br></b>bash$&nbsp;<b>declare | grep zzy<br></b>zzy=68<br>
bash$&nbsp;<b>Colors=([0]=&quot;purple&quot; [1]=&quot;reddish-orange&quot; [2]=&quot;light green&quot;)<br></b>bash$&nbsp;<b>echo ${Colors[@]}<br></b>purple reddish-orange light green<br>
bash$&nbsp;<b>declare | grep Colors<br></b>Colors=([0]=&quot;purple&quot; [1]=&quot;reddish-orange&quot; [2]=&quot;light green&quot;)<br>
<b>9.3. $RANDOM: generate random integer</b><br>
<i>Anyone who attempts to generate random<br>numbers by deterministic means is, of course,<br>living in a state of sin.</i><br>
<i>--John von Neumann</i><br>
$RANDOM<a href="abs-guides.html#399">&nbsp;is an internal Bash function (not a constant) that returns a</a><i>&nbsp;pseudorandom&nbsp;</i>[46] integer in the range 0<br>- 32767. It should&nbsp;<i>not</i>&nbsp;be used to generate an encryption key.<br>
<b>Example 9-11. Generating random numbers</b><br>
Chapter 9. Another Look at Variables<br>
106<br>
<hr>
<A name=113></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# $RANDOM returns a different random integer at each invocation.<br>
# Nominal range: 0 - 32767 (signed 16-bit integer).<br>
MAXCOUNT=10<br>
count=1<br>
echo<br>
echo &quot;$MAXCOUNT random numbers:&quot;<br>
echo &quot;-----------------&quot;<br>
while [ &quot;$count&quot; -le $MAXCOUNT ] &nbsp; &nbsp; &nbsp;# Generate 10 ($MAXCOUNT) random integers.<br>
do<br>
&nbsp; number=$RANDOM<br>
&nbsp; echo $number<br>
&nbsp; let &quot;count += 1&quot; &nbsp;# Increment count.<br>
done<br>
echo &quot;-----------------&quot;<br>
# If you need a random int within a certain range, use the 'modulo' operator.<br>
# This returns the remainder of a division operation.<br>
RANGE=500<br>
echo<br>
number=$RANDOM<br>
let &quot;number %= $RANGE&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
echo &quot;Random number less than $RANGE &nbsp;--- &nbsp;$number&quot;<br>
echo<br>
# &nbsp;If you need a random integer greater than a lower bound,<br>
#+ then set up a test to discard all numbers below that.<br>
FLOOR=200<br>
number=0 &nbsp; #initialize<br>
while [ &quot;$number&quot; -le $FLOOR ]<br>
do<br>
&nbsp; number=$RANDOM<br>
done<br>
echo &quot;Random number greater than $FLOOR --- &nbsp;$number&quot;<br>
echo<br>
&nbsp; &nbsp;# Let's examine a simple alternative to the above loop, namely<br>
&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; let &quot;number = $RANDOM + $FLOOR&quot;<br>
&nbsp; &nbsp;# That would eliminate the while-loop and run faster.<br>
&nbsp; &nbsp;# But, there might be a problem with that. What is it?<br>
# Combine above two techniques to retrieve random number between two limits.<br>
number=0 &nbsp; #initialize<br>
while [ &quot;$number&quot; -le $FLOOR ]<br>
do<br>
&nbsp; number=$RANDOM<br>
&nbsp; let &quot;number %= $RANGE&quot; &nbsp;# Scales $number down within $RANGE.<br>
done<br>
Chapter 9. Another Look at Variables<br>
107<br>
<hr>
<A name=114></a>Advanced Bash-Scripting Guide<br>
echo &quot;Random number between $FLOOR and $RANGE --- &nbsp;$number&quot;<br>
echo<br>
# Generate binary choice, that is, &quot;true&quot; or &quot;false&quot; value.<br>
BINARY=2<br>
T=1<br>
number=$RANDOM<br>
let &quot;number %= $BINARY&quot;<br>
# &nbsp;Note that &nbsp; &nbsp;let &quot;number &gt;&gt;= 14&quot; &nbsp; &nbsp;gives a better random distribution<br>
#+ (right shifts out everything except last binary digit).<br>
if [ &quot;$number&quot; -eq $T ]<br>
then<br>
&nbsp; echo &quot;TRUE&quot;<br>
else<br>
&nbsp; echo &quot;FALSE&quot;<br>
fi &nbsp;<br>
echo<br>
# Generate a toss of the dice.<br>
SPOTS=6 &nbsp; # Modulo 6 gives range 0 - 5.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Incrementing by 1 gives desired range of 1 - 6.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Thanks, Paulo Marcel Coelho Aragao, for the simplification.<br>
die1=0<br>
die2=0<br>
# Would it be better to just set SPOTS=7 and not add 1? Why or why not?<br>
# Tosses each die separately, and so gives correct odds.<br>
&nbsp; &nbsp; let &quot;die1 = $RANDOM % $SPOTS +1&quot; # Roll first one.<br>
&nbsp; &nbsp; let &quot;die2 = $RANDOM % $SPOTS +1&quot; # Roll second one.<br>
&nbsp; &nbsp; # &nbsp;Which arithmetic operation, above, has greater precedence --<br>
&nbsp; &nbsp; #+ modulo (%) or addition (+)?<br>
let &quot;throw = $die1 + $die2&quot;<br>
echo &quot;Throw of the dice = $throw&quot;<br>
echo<br>
exit 0<br>
<b>Example 9-12. Picking a random card from a deck</b><br>
#!/bin/bash<br>
# pick-card.sh<br>
# This is an example of choosing random elements of an array.<br>
# Pick a card, any card.<br>
Suites=&quot;Clubs<br>
Diamonds<br>
Hearts<br>
Spades&quot;<br>
Chapter 9. Another Look at Variables<br>
108<br>
<hr>
<A name=115></a>Advanced Bash-Scripting Guide<br>
Denominations=&quot;2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
Jack<br>
Queen<br>
King<br>
Ace&quot;<br>
# Note variables spread over multiple lines.<br>
suite=($Suites) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Read into array variable.<br>
denomination=($Denominations)<br>
num_suites=${#suite[*]} &nbsp; &nbsp; &nbsp; &nbsp;# Count how many elements.<br>
num_denominations=${#denomination[*]}<br>
echo -n &quot;${denomination[$((RANDOM%num_denominations))]} of &quot;<br>
echo ${suite[$((RANDOM%num_suites))]}<br>
# $bozo sh pick-cards.sh<br>
# Jack of Clubs<br>
# Thank you, &quot;jipe,&quot; for pointing out this use of $RANDOM.<br>
exit 0<br>
<b>Example 9-13. Brownian Motion Simulation</b><br>
#!/bin/bash<br>
# brownian.sh<br>
# Author: Mendel Cooper<br>
# Reldate: 10/26/07<br>
# License: GPL3<br>
# &nbsp;----------------------------------------------------------------<br>
# &nbsp;This script models Brownian motion:<br>
#+ the random wanderings of tiny particles in a fluid,<br>
#+ as they are buffeted by random currents and collisions.<br>
#+ This is colloquially known as the &quot;Drunkard's Walk.&quot;<br>
# &nbsp;It can also be considered as a stripped-down simulation of a<br>
#+ Galton Board, a slanted board with a pattern of pegs,<br>
#+ down which rolls a succession of marbles, one at a time.<br>
#+ At the bottom is a row of slots or catch basins in which<br>
#+ the marbles come to rest at the end of their journey.<br>
# &nbsp;Think of it as a kind of bare-bones Pachinko game.<br>
# &nbsp;As you see by running the script,<br>
#+ most of the marbles cluster around the center slot.<br>
#+ This is consistent with the expected binomial distribution.<br>
# &nbsp;As a Galton Board simulation, the script<br>
#+ disregards such parameters as<br>
#+ board tilt-angle, rolling friction of the marbles,<br>
Chapter 9. Another Look at Variables<br>
109<br>
<hr>
<A name=116></a>Advanced Bash-Scripting Guide<br>
#+ angles of impact, and elasticity of the pegs.<br>
# &nbsp;To what extent does this affect the accuracy of the simulation?<br>
# &nbsp;----------------------------------------------------------------<br>
PASSES=500 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Number of particle interactions / marbles.<br>
ROWS=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Number of &quot;collisions&quot; (or horiz. peg rows).<br>
RANGE=3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;0 - 2 output range from $RANDOM.<br>
POS=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Left/right position.<br>
RANDOM=$$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Seeds the random number generator from PID<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ of script.<br>
declare -a Slots &nbsp; &nbsp; &nbsp;# Array holding cumulative results of passes.<br>
NUMSLOTS=21 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Number of slots at bottom of board.<br>
Initialize_Slots () { # Zero out all elements of the array.<br>
for i in $( seq $NUMSLOTS )<br>
do<br>
&nbsp; Slots[$i]=0<br>
done<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Blank line at beginning of run.<br>
&nbsp; }<br>
Show_Slots () {<br>
echo; echo<br>
echo -n &quot; &quot;<br>
for i in $( seq $NUMSLOTS ) &nbsp; # Pretty-print array elements.<br>
do<br>
&nbsp; printf &quot;%3d&quot; ${Slots[$i]} &nbsp; # Allot three spaces per result.<br>
done<br>
echo # Row of slots:<br>
echo &quot; |__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|__|&quot;<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;||&quot;<br>
echo # &nbsp;Note that if the count within any particular slot exceeds 99,<br>
&nbsp; &nbsp; &nbsp;#+ it messes up the display.<br>
&nbsp; &nbsp; &nbsp;# &nbsp;Running only(!) 500 passes usually avoids this.<br>
&nbsp; }<br>
Move () { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Move one unit right / left, or stay put.<br>
&nbsp; Move=$RANDOM &nbsp; &nbsp; &nbsp; &nbsp; # How random is $RANDOM? Well, let's see ...<br>
&nbsp; let &quot;Move %= RANGE&quot; &nbsp;# Normalize into range of 0 - 2.<br>
&nbsp; case &quot;$Move&quot; in<br>
&nbsp; &nbsp; 0 ) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Do nothing, i.e., stay in place.<br>
&nbsp; &nbsp; 1 ) ((POS--));; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Left.<br>
&nbsp; &nbsp; 2 ) ((POS++));; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Right.<br>
&nbsp; &nbsp; * ) echo -n &quot;Error &quot;;; &nbsp; # Anomaly! (Should never occur.)<br>
&nbsp; esac<br>
&nbsp; }<br>
Play () { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Single pass (inner loop).<br>
i=0<br>
while [ &quot;$i&quot; -lt &quot;$ROWS&quot; ] &nbsp; # One event per row.<br>
do<br>
&nbsp; Move<br>
&nbsp; ((i++));<br>
done<br>
Chapter 9. Another Look at Variables<br>
110<br>
<hr>
<A name=117></a>Advanced Bash-Scripting Guide<br>
SHIFT=11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why 11, and not 10?<br>
let &quot;POS += $SHIFT&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Shift &quot;zero position&quot; to center.<br>
(( Slots[$POS]++ )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# DEBUG: echo $POS<br>
# echo -n &quot;$POS &quot;<br>
&nbsp; }<br>
Run () { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Outer loop.<br>
p=0<br>
while [ &quot;$p&quot; -lt &quot;$PASSES&quot; ]<br>
do<br>
&nbsp; Play<br>
&nbsp; (( p++ ))<br>
&nbsp; POS=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reset to zero. Why?<br>
done<br>
&nbsp; }<br>
# --------------<br>
# main ()<br>
Initialize_Slots<br>
Run<br>
Show_Slots<br>
# --------------<br>
exit $?<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;1) Show the results in a vertical bar graph, or as an alternative,<br>
#+ &nbsp; &nbsp;a scattergram.<br>
# &nbsp;2) Alter the script to use /dev/urandom instead of $RANDOM.<br>
# &nbsp; &nbsp; Will this make the results more random?<br>
# &nbsp;3) Provide some sort of &quot;animation&quot; or graphic output<br>
# &nbsp; &nbsp; for each marble played.<br>
<i>Jipe</i>&nbsp;points out a set of techniques for generating random numbers within a range.<br>
# &nbsp;Generate random number between 6 and 30.<br>
&nbsp; &nbsp;rnumber=$((RANDOM%25+6)) &nbsp; &nbsp;&nbsp;<br>
# &nbsp;Generate random number in the same 6 - 30 range,<br>
#+ but the number must be evenly divisible by 3.<br>
&nbsp; &nbsp;rnumber=$(((RANDOM%30/3+1)*3))<br>
# &nbsp;Note that this will not work all the time.<br>
# &nbsp;It fails if $RANDOM%30 returns 0.<br>
# &nbsp;Frank Wang suggests the following alternative:<br>
&nbsp; &nbsp;rnumber=$(( RANDOM%27/3*3+6 ))<br>
<i>Bill Gradwohl</i>&nbsp;came up with an improved formula that works for positive numbers.<br>
rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))<br>
Here Bill presents a versatile function that returns a random number between two specified values.<br>
<b>Example 9-14. Random between values</b><br>
Chapter 9. Another Look at Variables<br>
111<br>
<hr>
<A name=118></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# random-between.sh<br>
# Random number between two specified values.&nbsp;<br>
# Script by Bill Gradwohl, with minor modifications by the document author.<br>
# Corrections in lines 187 and 189 by Anthony Le Clezio.<br>
# Used with permission.<br>
randomBetween() {<br>
&nbsp; &nbsp;# &nbsp;Generates a positive or negative random number<br>
&nbsp; &nbsp;#+ between $min and $max<br>
&nbsp; &nbsp;#+ and divisible by $divisibleBy.<br>
&nbsp; &nbsp;# &nbsp;Gives a &quot;reasonably random&quot; distribution of return values.<br>
&nbsp; &nbsp;#<br>
&nbsp; &nbsp;# &nbsp;Bill Gradwohl - Oct 1, 2003<br>
&nbsp; &nbsp;syntax() {<br>
&nbsp; &nbsp;# Function embedded within function.<br>
&nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;Syntax: randomBetween [min] [max] [multiple]&quot;<br>
&nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;Expects up to 3 passed parameters, &quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;but all are completely optional.&quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;min is the minimum value&quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;max is the maximum value&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;multiple specifies that the answer must be &quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp; &quot;a multiple of this value.&quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot; &nbsp; &nbsp;i.e. answer must be evenly divisible by this number.&quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;If any value is missing, defaults area supplied as: 0 32767 1&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;Successful completion returns 0, &quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp; &quot;unsuccessful completion returns&quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;function syntax and 1.&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;The answer is returned in the global variable &quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;randomBetweenAnswer&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;Negative values for any passed parameter are &quot;<br>
&nbsp; &nbsp; &nbsp; echo &nbsp; &nbsp;&quot;handled correctly.&quot;<br>
&nbsp; &nbsp;}<br>
&nbsp; &nbsp;local min=${1:-0}<br>
&nbsp; &nbsp;local max=${2:-32767}<br>
&nbsp; &nbsp;local divisibleBy=${3:-1}<br>
&nbsp; &nbsp;# Default values assigned, in case parameters not passed to function.<br>
&nbsp; &nbsp;local x<br>
&nbsp; &nbsp;local spread<br>
&nbsp; &nbsp;# Let's make sure the divisibleBy value is positive.<br>
&nbsp; &nbsp;[ ${divisibleBy} -lt 0 ] &amp;&amp; divisibleBy=$((0-divisibleBy))<br>
&nbsp; &nbsp;# Sanity check.<br>
&nbsp; &nbsp;if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o &nbsp;${min} -eq ${max} ]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; syntax<br>
&nbsp; &nbsp; &nbsp; return 1<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;# See if the min and max are reversed.<br>
&nbsp; &nbsp;if [ ${min} -gt ${max} ]; then<br>
&nbsp; &nbsp; &nbsp; # Swap them.<br>
&nbsp; &nbsp; &nbsp; x=${min}<br>
&nbsp; &nbsp; &nbsp; min=${max}<br>
&nbsp; &nbsp; &nbsp; max=${x}<br>
Chapter 9. Another Look at Variables<br>
112<br>
<hr>
<A name=119></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;# &nbsp;If min is itself not evenly divisible by $divisibleBy,<br>
&nbsp; &nbsp;#+ then fix the min to be within range.<br>
&nbsp; &nbsp;if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; if [ ${min} -lt 0 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min=$((min/divisibleBy*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min=$((((min/divisibleBy)+1)*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;# &nbsp;If max is itself not evenly divisible by $divisibleBy,<br>
&nbsp; &nbsp;#+ then fix the max to be within range.<br>
&nbsp; &nbsp;if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; if [ ${max} -lt 0 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max=$((((max/divisibleBy)-1)*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max=$((max/divisibleBy*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;# &nbsp;---------------------------------------------------------------------<br>
&nbsp; &nbsp;# &nbsp;Now, to do the real work.<br>
&nbsp; &nbsp;# &nbsp;Note that to get a proper distribution for the end points,<br>
&nbsp; &nbsp;#+ the range of random values has to be allowed to go between<br>
&nbsp; &nbsp;#+ 0 and abs(max-min)+divisibleBy, not just abs(max-min)+1.<br>
&nbsp; &nbsp;# &nbsp;The slight increase will produce the proper distribution for the<br>
&nbsp; &nbsp;#+ end points.<br>
&nbsp; &nbsp;# &nbsp;Changing the formula to use abs(max-min)+1 will still produce<br>
&nbsp; &nbsp;#+ correct answers, but the randomness of those answers is faulty in<br>
&nbsp; &nbsp;#+ that the number of times the end points ($min and $max) are returned<br>
&nbsp; &nbsp;#+ is considerably lower than when the correct formula is used.<br>
&nbsp; &nbsp;# &nbsp;---------------------------------------------------------------------<br>
&nbsp; &nbsp;spread=$((max-min))<br>
&nbsp; &nbsp;# &nbsp;Omair Eshkenazi points out that this test is unnecessary,<br>
&nbsp; &nbsp;#+ since max and min have already been switched around.<br>
&nbsp; &nbsp;[ ${spread} -lt 0 ] &amp;&amp; spread=$((0-spread))<br>
&nbsp; &nbsp;let spread+=divisibleBy<br>
&nbsp; &nbsp;randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min)) &nbsp;&nbsp;<br>
&nbsp; &nbsp;return 0<br>
&nbsp; &nbsp;# &nbsp;However, Paulo Marcel Coelho Aragao points out that<br>
&nbsp; &nbsp;#+ when $max and $min are not divisible by $divisibleBy,<br>
&nbsp; &nbsp;#+ the formula fails.<br>
&nbsp; &nbsp;#<br>
&nbsp; &nbsp;# &nbsp;He suggests instead the following formula:<br>
&nbsp; &nbsp;# &nbsp; &nbsp;rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))<br>
}<br>
# Let's test the function.<br>
min=-14<br>
max=20<br>
divisibleBy=3<br>
Chapter 9. Another Look at Variables<br>
113<br>
<hr>
<A name=120></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Generate an array of expected answers and check to make sure we get<br>
#+ at least one of each answer if we loop long enough.<br>
declare -a answer<br>
minimum=${min}<br>
maximum=${max}<br>
&nbsp; &nbsp;if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; if [ ${minimum} -lt 0 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minimum=$((minimum/divisibleBy*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minimum=$((((minimum/divisibleBy)+1)*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;# &nbsp;If max is itself not evenly divisible by $divisibleBy,<br>
&nbsp; &nbsp;#+ then fix the max to be within range.<br>
&nbsp; &nbsp;if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; if [ ${maximum} -lt 0 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;maximum=$((((maximum/divisibleBy)-1)*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;maximum=$((maximum/divisibleBy*divisibleBy))<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp;fi<br>
# &nbsp;We need to generate only positive array subscripts,<br>
#+ so we need a displacement that that will guarantee<br>
#+ positive results.<br>
disp=$((0-minimum))<br>
for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br>
&nbsp; &nbsp;answer[i+disp]=0<br>
done<br>
# Now loop a large number of times to see what we get.<br>
loopIt=1000 &nbsp; # &nbsp;The script author suggests 100000,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ but that takes a good long while.<br>
for ((i=0; i&lt;${loopIt}; ++i)); do<br>
&nbsp; &nbsp;# &nbsp;Note that we are specifying min and max in reversed order here to<br>
&nbsp; &nbsp;#+ make the function correct for this case.<br>
&nbsp; &nbsp;randomBetween ${max} ${min} ${divisibleBy}<br>
&nbsp; &nbsp;# Report an error if an answer is unexpected.<br>
&nbsp; &nbsp;[ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] \<br>
&nbsp; &nbsp;&amp;&amp; echo MIN or MAX error - ${randomBetweenAnswer}!<br>
&nbsp; &nbsp;[ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] \<br>
&nbsp; &nbsp;&amp;&amp; echo DIVISIBLE BY error - ${randomBetweenAnswer}!<br>
&nbsp; &nbsp;# Store the answer away statistically.<br>
&nbsp; &nbsp;answer[randomBetweenAnswer+disp]=$((answer[randomBetweenAnswer+disp]+1))<br>
done<br>
# Let's check the results<br>
Chapter 9. Another Look at Variables<br>
114<br>
<hr>
<A name=121></a>Advanced Bash-Scripting Guide<br>
for ((i=${minimum}; i&lt;=${maximum}; i+=divisibleBy)); do<br>
&nbsp; &nbsp;[ ${answer[i+disp]} -eq 0 ] \<br>
&nbsp; &nbsp;&amp;&amp; echo &quot;We never got an answer of $i.&quot; \<br>
&nbsp; &nbsp;|| echo &quot;${i} occurred ${answer[i+disp]} times.&quot;<br>
done<br>
exit 0<br>
Just how random is&nbsp;$RANDOM? The best way to test this is to write a script that tracks the distribution of<br>&quot;random&quot; numbers generated by&nbsp;$RANDOM. Let's roll a&nbsp;$RANDOM&nbsp;die a few times . . .<br>
<b>Example 9-15. Rolling a single die with RANDOM</b><br>
#!/bin/bash<br>
# How random is RANDOM?<br>
RANDOM=$$ &nbsp; &nbsp; &nbsp; # Reseed the random number generator using script process ID.<br>
PIPS=6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# A die has 6 pips.<br>
MAXTHROWS=600 &nbsp; # Increase this if you have nothing better to do with your time.<br>
throw=0 &nbsp; &nbsp; &nbsp; &nbsp; # Throw count.<br>
ones=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Must initialize counts to zero,<br>
twos=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ since an uninitialized variable is null, not zero.<br>
threes=0<br>
fours=0<br>
fives=0<br>
sixes=0<br>
print_result ()<br>
{<br>
echo<br>
echo &quot;ones = &nbsp; $ones&quot;<br>
echo &quot;twos = &nbsp; $twos&quot;<br>
echo &quot;threes = $threes&quot;<br>
echo &quot;fours = &nbsp;$fours&quot;<br>
echo &quot;fives = &nbsp;$fives&quot;<br>
echo &quot;sixes = &nbsp;$sixes&quot;<br>
echo<br>
}<br>
update_count()<br>
{<br>
case &quot;$1&quot; in<br>
&nbsp; 0) let &quot;ones += 1&quot;;; &nbsp; # Since die has no &quot;zero&quot;, this corresponds to 1.<br>
&nbsp; 1) let &quot;twos += 1&quot;;; &nbsp; # And this to 2, etc.<br>
&nbsp; 2) let &quot;threes += 1&quot;;;<br>
&nbsp; 3) let &quot;fours += 1&quot;;;<br>
&nbsp; 4) let &quot;fives += 1&quot;;;<br>
&nbsp; 5) let &quot;sixes += 1&quot;;;<br>
esac<br>
}<br>
echo<br>
while [ &quot;$throw&quot; -lt &quot;$MAXTHROWS&quot; ]<br>
do<br>
&nbsp; let &quot;die1 = RANDOM % $PIPS&quot;<br>
Chapter 9. Another Look at Variables<br>
115<br>
<hr>
<A name=122></a>Advanced Bash-Scripting Guide<br>
&nbsp; update_count $die1<br>
&nbsp; let &quot;throw += 1&quot;<br>
done &nbsp;<br>
print_result<br>
exit 0<br>
# &nbsp;The scores should distribute fairly evenly, assuming RANDOM is fairly random.<br>
# &nbsp;With $MAXTHROWS at 600, all should cluster around 100, plus-or-minus 20 or so.<br>
#<br>
# &nbsp;Keep in mind that RANDOM is a pseudorandom generator,<br>
#+ and not a spectacularly good one at that.<br>
# &nbsp;Randomness is a deep and complex subject.<br>
# &nbsp;Sufficiently long &quot;random&quot; sequences may exhibit<br>
#+ chaotic and other &quot;non-random&quot; behavior.<br>
# Exercise (easy):<br>
# ---------------<br>
# Rewrite this script to flip a coin 1000 times.<br>
# Choices are &quot;HEADS&quot; and &quot;TAILS&quot;.<br>
As we have seen in the last example, it is best to<i>&nbsp;reseed</i>&nbsp;the&nbsp;<i>RANDOM</i>&nbsp;generator each time it is invoked. Using<br>the same seed for&nbsp;<i>RANDOM</i>&nbsp;repeats the same series of numbers.&nbsp;[47] (This mirrors the behavior of the<br><i>random()</i>&nbsp;function in<i>&nbsp;C</i>.)<br>
<b>Example 9-16. Reseeding RANDOM</b><br>
#!/bin/bash<br>
# seeding-random.sh: Seeding the RANDOM variable.<br>
MAXCOUNT=25 &nbsp; &nbsp; &nbsp; # How many numbers to generate.<br>
random_numbers ()<br>
{<br>
count=0<br>
while [ &quot;$count&quot; -lt &quot;$MAXCOUNT&quot; ]<br>
do<br>
&nbsp; number=$RANDOM<br>
&nbsp; echo -n &quot;$number &quot;<br>
&nbsp; let &quot;count += 1&quot;<br>
done &nbsp;<br>
}<br>
echo; echo<br>
RANDOM=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Setting RANDOM seeds the random number generator.<br>
random_numbers<br>
echo; echo<br>
RANDOM=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Same seed for RANDOM...<br>
random_numbers &nbsp; &nbsp;# ...reproduces the exact same number series.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # When is it useful to duplicate a &quot;random&quot; number series?<br>
echo; echo<br>
RANDOM=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Trying again, but with a different seed...<br>
Chapter 9. Another Look at Variables<br>
116<br>
<hr>
<A name=123></a><IMG src="abs-guide-123_1.png"><br>
Advanced Bash-Scripting Guide<br>
random_numbers &nbsp; &nbsp;# gives a different number series.<br>
echo; echo<br>
# RANDOM=$$ &nbsp;seeds RANDOM from process id of script.<br>
# It is also possible to seed RANDOM from 'time' or 'date' commands.<br>
# Getting fancy...<br>
SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')<br>
# &nbsp;Pseudo-random output fetched<br>
#+ from /dev/urandom (system pseudo-random device-file),<br>
#+ then converted to line of printable (octal) numbers by &quot;od&quot;,<br>
#+ finally &quot;awk&quot; retrieves just one number for SEED.<br>
RANDOM=$SEED<br>
random_numbers<br>
echo; echo<br>
exit 0<br>
The&nbsp;/dev/urandom&nbsp;pseudo-device file provides a method of generating much more &quot;random&quot;<br>pseudorandom numbers than the&nbsp;$RANDOM&nbsp;variable.&nbsp;<b>dd if=/dev/urandom of=targetfile<br>bs=1 count=XX</b>&nbsp;creates a file of well-scattered pseudorandom numbers. However, assigning these<br><a href="abs-guides.html#317">numbers to a variable in a script requires a workaround, such as filtering through od (as in above<br></a><a href="abs-guides.html#244">example, Example 16-14, and Example A-36), or even piping to md5sum (see Example 36-14).</a><br>
There are also other ways to generate pseudorandom numbers in a script.<b>&nbsp;Awk</b>&nbsp;provides a convenient<br>means of doing this.<br>
<a href="abs-guides.html#784"><b>Example 9-17. Pseudorandom numbers, using awk</b></a><br>
#!/bin/bash<br>
# random2.sh: Returns a pseudorandom number in the range 0 - 1.<br>
# Uses the awk rand() function.<br>
AWKSCRIPT=' { srand(); print rand() } '<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Command(s) / parameters passed to awk<br>
# Note that srand() reseeds awk's random number generator.<br>
echo -n &quot;Random number between 0 and 1 = &quot;<br>
echo | awk &quot;$AWKSCRIPT&quot;<br>
# What happens if you leave out the 'echo'?<br>
exit 0<br>
# Exercises:<br>
# ---------<br>
# 1) Using a loop construct, print out 10 different random numbers.<br>
# &nbsp; &nbsp; &nbsp;(Hint: you must reseed the &quot;srand()&quot; function with a different seed<br>
#+ &nbsp; &nbsp; in each pass through the loop. What happens if you fail to do this?)<br>
# 2) Using an integer multiplier as a scaling factor, generate random numbers&nbsp;<br>
Chapter 9. Another Look at Variables<br>
117<br>
<hr>
<A name=124></a>Advanced Bash-Scripting Guide<br>
#+ &nbsp; in the range between 10 and 100.<br>
# 3) Same as exercise #2, above, but generate random integers this time.<br>
<a href="abs-guides.html#236">The date command also lends itself to generating pseudorandom integer sequences.</a><br>
Chapter 9. Another Look at Variables<br>
118<br>
<hr>
<A name=125></a><b>Chapter 10. Manipulating Variables</b><br>
<b>10.1. Manipulating Strings</b><br>
Bash supports a surprising number of string manipulation operations. Unfortunately, these tools lack a unified<br><a href="abs-guides.html#133">focus. Some are a subset of parameter substitution, and others fall under the functionality of the UNIX expr<br></a>command. This results in inconsistent command syntax and overlap of functionality, not to mention<br>confusion.<br>
<b>String Length</b><br>
${#string}<br>expr length $string<br>
These are the equivalent of<i>&nbsp;strlen()</i>&nbsp;in<i>&nbsp;C</i>.<br>
expr &quot;$string&quot; : '.*'<br>
stringZ=abcABC123ABCabc<br>
echo ${#stringZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 15<br>
echo `expr length $stringZ` &nbsp; &nbsp; &nbsp;# 15<br>
echo `expr &quot;$stringZ&quot; : '.*'` &nbsp; &nbsp;# 15<br>
<b>Example 10-1. Inserting a blank line between paragraphs in a text file</b><br>
#!/bin/bash<br>
# paragraph-space.sh<br>
# Ver. 2.0, Reldate 05Aug08<br>
# Inserts a blank line between paragraphs of a single-spaced text file.<br>
# Usage: $0 &lt;FILENAME<br>
MINLEN=60 &nbsp; &nbsp; &nbsp; &nbsp;# May need to change this value.<br>
# &nbsp;Assume lines shorter than $MINLEN characters ending in a period<br>
#+ terminate a paragraph. See exercises at end of script.<br>
while read line &nbsp;# For as many lines as the input file has...<br>
do<br>
&nbsp; echo &quot;$line&quot; &nbsp; # Output the line itself.<br>
&nbsp; len=${#line}<br>
&nbsp; if [[ &quot;$len&quot; -lt &quot;$MINLEN&quot; &amp;&amp; &quot;$line&quot; =~ \[*\.\] ]]<br>
&nbsp; &nbsp; then echo &nbsp; &nbsp;# &nbsp;Add a blank line immediately<br>
&nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ after short line terminated by a period.<br>
done<br>
exit<br>
# Exercises:<br>
# ---------<br>
# &nbsp;1) The script usually inserts a blank line at the end<br>
#+ &nbsp; &nbsp;of the target file. Fix this.<br>
# &nbsp;2) Line 17 only considers periods as sentence terminators.<br>
# &nbsp; &nbsp; Modify this to include other common end-of-sentence characters,<br>
Chapter 10. Manipulating Variables<br>
119<br>
<hr>
<A name=126></a>Advanced Bash-Scripting Guide<br>
#+ &nbsp; &nbsp;such as ?, !, and &quot;.<br>
<b>Length of Matching Substring at Beginning of String</b><br>
expr match &quot;$string&quot; '$substring'<br>
<i>$substring</i><a href="abs-guides.html#354">&nbsp;is a regular expression.</a><br>
expr &quot;$string&quot; : '$substring'<br>
<i>$substring</i>&nbsp;is a regular expression.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; |------|<br>
# &nbsp; &nbsp; &nbsp; 12345678<br>
echo `expr match &quot;$stringZ&quot; 'abc[A-Z]*.2'` &nbsp; # 8<br>
echo `expr &quot;$stringZ&quot; : 'abc[A-Z]*.2'` &nbsp; &nbsp; &nbsp; # 8<br>
<b>Index</b><br>
expr index $string $substring<br>
Numerical position in $string of first character in $substring that matches.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; 123456 ...<br>
echo `expr index &quot;$stringZ&quot; C12` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 6<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# C position.<br>
echo `expr index &quot;$stringZ&quot; 1c` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 3<br>
# 'c' (in #3 position) matches before '1'.<br>
This is the near equivalent of<i>&nbsp;strchr()</i>&nbsp;in<i>&nbsp;C</i>.<br>
<b>Substring Extraction</b><br>
${string:position}<br>
Extracts substring from&nbsp;<i>$string</i>&nbsp;at&nbsp;<i>$position</i>.<br>
If the&nbsp;$string<a href="abs-guides.html#104">&nbsp;parameter is &quot;*&quot; or &quot;@&quot;, then this extracts the positional parameters,&nbsp;</a>[48] starting at<br>$position.<br>
${string:position:length}<br>
Extracts&nbsp;<i>$length</i>&nbsp;characters of substring from&nbsp;<i>$string</i>&nbsp;at&nbsp;<i>$position</i>.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; 0123456789.....<br>
# &nbsp; &nbsp; &nbsp; 0-based indexing.<br>
echo ${stringZ:0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# abcABC123ABCabc<br>
echo ${stringZ:1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# bcABC123ABCabc<br>
echo ${stringZ:7} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 23ABCabc<br>
echo ${stringZ:7:3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 23A<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Three characters of substring.<br>
# Is it possible to index from the right end of the string?<br>
Chapter 10. Manipulating Variables<br>
120<br>
<hr>
<A name=127></a>Advanced Bash-Scripting Guide<br>
echo ${stringZ:-4} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabc<br>
# Defaults to full string, as in ${parameter:-default}.<br>
# However . . .<br>
echo ${stringZ:(-4)} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Cabc&nbsp;<br>
echo ${stringZ: -4} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Cabc<br>
# Now, it works.<br>
# Parentheses or added space &quot;escape&quot; the position parameter.<br>
# Thank you, Dan Jacobson, for pointing this out.<br>
The<i>&nbsp;position</i>&nbsp;and<i>&nbsp;length</i>&nbsp;arguments can be &quot;parameterized,&quot; that is, represented as a variable, rather<br>than as a numerical constant.<br>
<b>Example 10-2. Generating an 8-character &quot;random&quot; string</b><br>
#!/bin/bash<br>
# rand-string.sh<br>
# Generating an 8-character &quot;random&quot; string.<br>
if [ -n &quot;$1&quot; ] &nbsp;# &nbsp;If command-line argument present,<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then set start-string to it.<br>
&nbsp; str0=&quot;$1&quot;<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Else use PID of script as start-string.<br>
&nbsp; str0=&quot;$$&quot;<br>
fi<br>
POS=2 &nbsp;# Starting from position 2 in the string.<br>
LEN=8 &nbsp;# Extract eight characters.<br>
str1=$( echo &quot;$str0&quot; | md5sum | md5sum )<br>
# Doubly scramble: &nbsp; &nbsp; ^^^^^^ &nbsp; ^^^^^^<br>
randstring=&quot;${str1:$POS:$LEN}&quot;<br>
# Can parameterize ^^^^ ^^^^<br>
echo &quot;$randstring&quot;<br>
exit $?<br>
# bozo$ ./rand-string.sh my-password<br>
# 1bdd88c4<br>
# &nbsp;No, this is is not recommended<br>
#+ as a method of generating hack-proof passwords.<br>
If the&nbsp;$string&nbsp;parameter is &quot;*&quot; or &quot;@&quot;, then this extracts a maximum of&nbsp;$length&nbsp;positional<br>parameters, starting at&nbsp;$position.<br>
echo ${*:2} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Echoes second and following positional parameters.<br>
echo ${@:2} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Same as above.<br>
echo ${*:2:3} &nbsp; &nbsp; &nbsp; &nbsp;# Echoes three positional parameters, starting at second.<br>
expr substr $string $position $length<br>
Extracts&nbsp;<i>$length</i>&nbsp;characters from&nbsp;<i>$string</i>&nbsp;starting at&nbsp;<i>$position</i>.<br>
stringZ=abcABC123ABCabc<br>
Chapter 10. Manipulating Variables<br>
121<br>
<hr>
<A name=128></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; 123456789......<br>
# &nbsp; &nbsp; &nbsp; 1-based indexing.<br>
echo `expr substr $stringZ 1 2` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ab<br>
echo `expr substr $stringZ 4 3` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ABC<br>
expr match &quot;$string&quot; '\($substring\)'<br>
Extracts&nbsp;<i>$substring</i>&nbsp;at beginning of&nbsp;<i>$string</i>, where&nbsp;<i>$substring</i><a href="abs-guides.html#354">&nbsp;is a regular expression.</a><br>
expr &quot;$string&quot; : '\($substring\)'<br>
Extracts&nbsp;<i>$substring</i>&nbsp;at beginning of&nbsp;<i>$string</i>, where&nbsp;<i>$substring</i>&nbsp;is a regular expression.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; ======= &nbsp; &nbsp;&nbsp;<br>
echo `expr match &quot;$stringZ&quot; '\(.[b-c]*[A-Z]..[0-9]\)'` &nbsp; # abcABC1<br>
echo `expr &quot;$stringZ&quot; : '\(.[b-c]*[A-Z]..[0-9]\)'` &nbsp; &nbsp; &nbsp; # abcABC1<br>
echo `expr &quot;$stringZ&quot; : '\(.......\)'` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC1<br>
# All of the above forms give an identical result.<br>
expr match &quot;$string&quot; '.*\($substring\)'<br>
Extracts&nbsp;<i>$substring</i>&nbsp;at<i>&nbsp;end</i>&nbsp;of&nbsp;<i>$string</i>, where&nbsp;<i>$substring</i>&nbsp;is a regular expression.<br>
expr &quot;$string&quot; : '.*\($substring\)'<br>
Extracts&nbsp;<i>$substring</i>&nbsp;at<i>&nbsp;end</i>&nbsp;of&nbsp;<i>$string</i>, where&nbsp;<i>$substring</i>&nbsp;is a regular expression.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;======<br>
echo `expr match &quot;$stringZ&quot; '.*\([A-C][A-C][A-C][a-c]*\)'` &nbsp; &nbsp;# ABCabc<br>
echo `expr &quot;$stringZ&quot; : '.*\(......\)'` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ABCabc<br>
<b>Substring Removal</b><br>
${string#substring}<br>
Deletes shortest match of&nbsp;<i>$substring</i>&nbsp;from<i>&nbsp;front</i>&nbsp;of&nbsp;<i>$string</i>.<br>
${string##substring}<br>
Deletes longest match of&nbsp;<i>$substring</i>&nbsp;from<i>&nbsp;front</i>&nbsp;of&nbsp;<i>$string</i>.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; |----| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shortest<br>
# &nbsp; &nbsp; &nbsp; |----------| &nbsp; &nbsp;longest<br>
echo ${stringZ#a*C} &nbsp; &nbsp; &nbsp;# 123ABCabc<br>
# Strip out shortest match between 'a' and 'C'.<br>
echo ${stringZ##a*C} &nbsp; &nbsp; # abc<br>
# Strip out longest match between 'a' and 'C'.<br>
# You can parameterize the substrings.<br>
X='a*C'<br>
echo ${stringZ#$X} &nbsp; &nbsp; &nbsp;# 123ABCabc<br>
echo ${stringZ##$X} &nbsp; &nbsp; # abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # As above.<br>
${string%substring}<br>
Deletes shortest match of&nbsp;<i>$substring</i>&nbsp;from<i>&nbsp;back</i>&nbsp;of&nbsp;<i>$string</i>.<br>
Chapter 10. Manipulating Variables<br>
122<br>
<hr>
<A name=129></a>Advanced Bash-Scripting Guide<br>
For example:<br>
# Rename all filenames in $PWD with &quot;TXT&quot; suffix to a &quot;txt&quot; suffix.<br>
# For example, &quot;file1.TXT&quot; becomes &quot;file1.txt&quot; . . .<br>
SUFF=TXT<br>
suff=txt<br>
for i in $(ls *.$SUFF)<br>
do<br>
&nbsp; mv -f $i ${i%.$SUFF}.$suff<br>
&nbsp; # &nbsp;Leave unchanged everything *except* the shortest pattern match<br>
&nbsp; #+ starting from the right-hand-side of the variable $i . . .<br>
done ### This could be condensed into a &quot;one-liner&quot; if desired.<br>
# Thank you, Rory Winston.<br>
${string%%substring}<br>
Deletes longest match of&nbsp;<i>$substring</i>&nbsp;from<i>&nbsp;back</i>&nbsp;of&nbsp;<i>$string</i>.<br>
stringZ=abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|| &nbsp; &nbsp; shortest<br>
# &nbsp; &nbsp; &nbsp; &nbsp;|------------| &nbsp; &nbsp; longest<br>
echo ${stringZ%b*c} &nbsp; &nbsp; &nbsp;# abcABC123ABCa<br>
# Strip out shortest match between 'b' and 'c', from back of $stringZ.<br>
echo ${stringZ%%b*c} &nbsp; &nbsp; # a<br>
# Strip out longest match between 'b' and 'c', from back of $stringZ.<br>
This operator is useful for generating filenames.<br>
<b>Example 10-3. Converting graphic file formats, with filename change</b><br>
#!/bin/bash<br>
# &nbsp;cvt.sh:<br>
# &nbsp;Converts all the MacPaint image files in a directory to &quot;pbm&quot; format.<br>
# &nbsp;Uses the &quot;macptopbm&quot; binary from the &quot;netpbm&quot; package,<br>
#+ which is maintained by Brian Henderson (bryanh@giraffe-data.com).<br>
# &nbsp;Netpbm is a standard part of most Linux distros.<br>
OPERATION=macptopbm<br>
SUFFIX=pbm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# New filename suffix.&nbsp;<br>
if [ -n &quot;$1&quot; ]<br>
then<br>
&nbsp; directory=$1 &nbsp; &nbsp; &nbsp;# If directory name given as a script argument...<br>
else<br>
&nbsp; directory=$PWD &nbsp; &nbsp;# Otherwise use current working directory.<br>
fi &nbsp;<br>
# &nbsp;Assumes all files in the target directory are MacPaint image files,<br>
#+ with a &quot;.mac&quot; filename suffix.<br>
for file in $directory/* &nbsp; &nbsp;# Filename globbing.<br>
do<br>
&nbsp; filename=${file%.*c} &nbsp; &nbsp; &nbsp;# &nbsp;Strip &quot;.mac&quot; suffix off filename<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ ('.*c' matches everything<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ between '.' and 'c', inclusive).<br>
Chapter 10. Manipulating Variables<br>
123<br>
<hr>
<A name=130></a>Advanced Bash-Scripting Guide<br>
&nbsp; $OPERATION $file &gt; &quot;$filename.$SUFFIX&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Redirect conversion to new filename.<br>
&nbsp; rm -f $file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Delete original files after converting. &nbsp;&nbsp;<br>
&nbsp; echo &quot;$filename.$SUFFIX&quot; &nbsp;# Log what is happening to stdout.<br>
done<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# &nbsp;As it stands, this script converts *all* the files in the current<br>
#+ working directory.<br>
# &nbsp;Modify it to work *only* on files with a &quot;.mac&quot; suffix.<br>
<b>Example 10-4. Converting streaming audio files to<i>&nbsp;ogg</i></b><br>
#!/bin/bash<br>
# ra2ogg.sh: Convert streaming audio files (*.ra) to ogg.<br>
# Uses the &quot;mplayer&quot; media player program:<br>
# &nbsp; &nbsp; &nbsp;http://www.mplayerhq.hu/homepage<br>
# Uses the &quot;ogg&quot; library and &quot;oggenc&quot;:<br>
# &nbsp; &nbsp; &nbsp;http://www.xiph.org/<br>
#<br>
# This script may need appropriate codecs installed, such as sipr.so ...<br>
# Possibly also the compat-libstdc++ package.<br>
OFILEPREF=${1%%ra} &nbsp; &nbsp; &nbsp;# Strip off the &quot;ra&quot; suffix.<br>
OFILESUFF=wav &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Suffix for wav file.<br>
OUTFILE=&quot;$OFILEPREF&quot;&quot;$OFILESUFF&quot;<br>
E_NOARGS=85<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Must specify a filename to convert.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` [filename]&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi<br>
##########################################################################<br>
mplayer &quot;$1&quot; -ao pcm:file=$OUTFILE<br>
oggenc &quot;$OUTFILE&quot; &nbsp;# Correct file extension automatically added by oggenc.<br>
##########################################################################<br>
rm &quot;$OUTFILE&quot; &nbsp; &nbsp; &nbsp;# Delete intermediate *.wav file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If you want to keep it, comment out above line.<br>
exit $?<br>
# &nbsp;Note:<br>
# &nbsp;----<br>
# &nbsp;On a Website, simply clicking on a *.ram streaming audio file<br>
#+ usually only downloads the URL of the actual *.ra audio file.<br>
# &nbsp;You can then use &quot;wget&quot; or something similar<br>
#+ to download the *.ra file itself.<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;As is, this script converts only *.ra filenames.<br>
Chapter 10. Manipulating Variables<br>
124<br>
<hr>
<A name=131></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Add flexibility by permitting use of *.ram and other filenames.<br>
#<br>
# &nbsp;If you're really ambitious, expand the script<br>
#+ to do automatic downloads and conversions of streaming audio files.<br>
# &nbsp;Given a URL, batch download streaming audio files (using &quot;wget&quot;)<br>
#+ and convert them on the fly.<br>
<a href="abs-guides.html#309">A simple emulation of getopt using substring-extraction constructs.</a><br>
<b>Example 10-5. Emulating<i>&nbsp;getopt</i></b><br>
#!/bin/bash<br>
# getopt-simple.sh<br>
# Author: Chris Morgan<br>
# Used in the ABS Guide with permission.<br>
getopt_simple()<br>
{<br>
&nbsp; &nbsp; echo &quot;getopt_simple()&quot;<br>
&nbsp; &nbsp; echo &quot;Parameters are '$*'&quot;<br>
&nbsp; &nbsp; until [ -z &quot;$1&quot; ]<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; echo &quot;Processing parameter of: '$1'&quot;<br>
&nbsp; &nbsp; &nbsp; if [ ${1:0:1} = '/' ]<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp=${1:1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Strip off leading '/' . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parameter=${tmp%%=*} &nbsp; &nbsp; # Extract name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value=${tmp##*=} &nbsp; &nbsp; &nbsp; &nbsp; # Extract value.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Parameter: '$parameter', value: '$value'&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eval $parameter=$value<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; done<br>
}<br>
# Pass all options to getopt_simple().<br>
getopt_simple $*<br>
echo &quot;test is '$test'&quot;<br>
echo &quot;test2 is '$test2'&quot;<br>
exit 0 &nbsp;# See also, UseGetOpt.sh, a modified versio of this script.<br>
---<br>
sh getopt_example.sh /test=value1 /test2=value2<br>
Parameters are '/test=value1 /test2=value2'<br>
Processing parameter of: '/test=value1'<br>
Parameter: 'test', value: 'value1'<br>
Processing parameter of: '/test2=value2'<br>
Parameter: 'test2', value: 'value2'<br>
test is 'value1'<br>
test2 is 'value2'<br>
<b>Substring Replacement</b><br>
Chapter 10. Manipulating Variables<br>
125<br>
<hr>
<A name=132></a>Advanced Bash-Scripting Guide<br>
${string/substring/replacement}<br>
Replace first<i>&nbsp;match</i>&nbsp;of&nbsp;<i>$substring</i>&nbsp;with&nbsp;<i>$replacement</i>.&nbsp;[49]<br>
${string//substring/replacement}<br>
Replace all matches of&nbsp;<i>$substring</i>&nbsp;with&nbsp;<i>$replacement</i>.<br>
stringZ=abcABC123ABCabc<br>
echo ${stringZ/abc/xyz} &nbsp; &nbsp; &nbsp; # xyzABC123ABCabc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Replaces first match of 'abc' with 'xyz'.<br>
echo ${stringZ//abc/xyz} &nbsp; &nbsp; &nbsp;# xyzABC123ABCxyz<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Replaces all matches of 'abc' with # 'xyz'.<br>
echo &nbsp;---------------<br>
echo &quot;$stringZ&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabc<br>
echo &nbsp;---------------<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The string itself is not altered!<br>
# Can the match and replacement strings be parameterized?<br>
match=abc<br>
repl=000<br>
echo ${stringZ/$match/$repl} &nbsp;# 000ABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; ^^^<br>
echo ${stringZ//$match/$repl} # 000ABC123ABC000<br>
# Yes! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp;^^^ &nbsp; &nbsp; &nbsp; &nbsp; ^^^<br>
echo<br>
# What happens if no $replacement string is supplied?<br>
echo ${stringZ/abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ABC123ABCabc<br>
echo ${stringZ//abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ABC123ABC<br>
# A simple deletion takes place.<br>
${string/#substring/replacement}<br>
If&nbsp;<i>$substring</i>&nbsp;matches<i>&nbsp;front</i>&nbsp;end of&nbsp;<i>$string</i>, substitute&nbsp;<i>$replacement</i>&nbsp;for&nbsp;<i>$substring</i>.<br>
${string/%substring/replacement}<br>
If&nbsp;<i>$substring</i>&nbsp;matches<i>&nbsp;back</i>&nbsp;end of&nbsp;<i>$string</i>, substitute&nbsp;<i>$replacement</i>&nbsp;for&nbsp;<i>$substring</i>.<br>
stringZ=abcABC123ABCabc<br>
echo ${stringZ/#abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# XYZABC123ABCabc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Replaces front-end match of 'abc' with 'XYZ'.<br>
echo ${stringZ/%abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# abcABC123ABCXYZ<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Replaces back-end match of 'abc' with 'XYZ'.<br>
<b>10.1.1. Manipulating strings using awk</b><br>
<a href="abs-guides.html#784">A Bash script may invoke the string manipulation facilities of awk as an alternative to using its built-in<br></a>operations.<br>
<b>Example 10-6. Alternate ways of extracting and locating substrings</b><br>
#!/bin/bash<br>
# substring-extraction.sh<br>
Chapter 10. Manipulating Variables<br>
126<br>
<hr>
<A name=133></a>Advanced Bash-Scripting Guide<br>
String=23skidoo1<br>
# &nbsp; &nbsp; &nbsp;012345678 &nbsp; &nbsp;Bash<br>
# &nbsp; &nbsp; &nbsp;123456789 &nbsp; &nbsp;awk<br>
# Note different string indexing system:<br>
# Bash numbers first character of string as 0.<br>
# Awk &nbsp;numbers first character of string as 1.<br>
echo ${String:2:4} # position 3 (0-1-2), 4 characters long<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# skid<br>
# The awk equivalent of ${string:pos:length} is substr(string,pos,length).<br>
echo | awk '<br>
{ print substr(&quot;'&quot;${String}&quot;'&quot;,3,4) &nbsp; &nbsp; &nbsp;# skid<br>
}<br>
'<br>
# &nbsp;Piping an empty &quot;echo&quot; to awk gives it dummy input,<br>
#+ and thus makes it unnecessary to supply a filename.<br>
echo &quot;----&quot;<br>
# And likewise:<br>
echo | awk '<br>
{ print index(&quot;'&quot;${String}&quot;'&quot;, &quot;skid&quot;) &nbsp; &nbsp; &nbsp;# 3<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (skid starts at position 3)<br>
' &nbsp; # The awk equivalent of &quot;expr index&quot; ...<br>
exit 0<br>
<b>10.1.2. Further Reference</b><br>
<a href="abs-guides.html#133">For more on string manipulation in scripts, refer to Section 10.2 and the relevant section of the expr command<br></a>listing.<br>
Script examples:<br>
<a href="abs-guides.html#233">Example 16-9</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#138">Example 10-9</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#139">Example 10-10</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#140">Example 10-11</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#142">Example 10-13</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#697">Example A-36</a><br>
6.&nbsp;<br>
<a href="abs-guides.html#709">Example A-41</a><br>
7.&nbsp;<br>
<b>10.2. Parameter Substitution</b><br>
<b>Manipulating and/or expanding variables</b><br>
<b>${parameter}</b><br>
Same as&nbsp;<i>$parameter</i>, i.e., value of the variable&nbsp;<i>parameter</i>. In certain contexts, only the less<br>ambiguous&nbsp;<i>${parameter}</i>&nbsp;form works.<br>
May be used for concatenating variables with strings.<br>
Chapter 10. Manipulating Variables<br>
127<br>
<hr>
<A name=134></a><IMG src="abs-guide-134_1.png"><br>
Advanced Bash-Scripting Guide<br>
your_id=${USER}-on-${HOSTNAME}<br>
echo &quot;$your_id&quot;<br>
#<br>
echo &quot;Old \$PATH = $PATH&quot;<br>
PATH=${PATH}:/opt/bin &nbsp;# Add /opt/bin to $PATH for duration of script.<br>
echo &quot;New \$PATH = $PATH&quot;<br>
<b>${parameter-default}</b>,&nbsp;<b>${parameter:-default}</b><br>
If parameter not set, use default.<br>
var1=1<br>
var2=2<br>
# var3 is unset.<br>
echo ${var1-$var2} &nbsp; # 1<br>
echo ${var3-$var2} &nbsp; # 2<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Note the $ prefix.<br>
echo ${username-`whoami`}<br>
# Echoes the result of `whoami`, if variable $username is still unset.<br>
<i>${parameter-default}</i>&nbsp;and&nbsp;<i>${parameter:-default}</i>&nbsp;are almost<br>equivalent. The extra : makes a difference only when&nbsp;<i>parameter</i>&nbsp;has been declared,<br>but is null.<br>
#!/bin/bash<br>
# param-sub.sh<br>
# &nbsp;Whether a variable has been declared<br>
#+ affects triggering of the default option<br>
#+ even if the variable is null.<br>
username0=<br>
echo &quot;username0 has been declared, but is set to null.&quot;<br>
echo &quot;username0 = ${username0-`whoami`}&quot;<br>
# Will not echo.<br>
echo<br>
echo username1 has not been declared.<br>
echo &quot;username1 = ${username1-`whoami`}&quot;<br>
# Will echo.<br>
username2=<br>
echo &quot;username2 has been declared, but is set to null.&quot;<br>
echo &quot;username2 = ${username2:-`whoami`}&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
# Will echo because of :- rather than just - in condition test.<br>
# Compare to first instance, above.<br>
#<br>
# Once again:<br>
variable=<br>
# variable has been declared, but is set to null.<br>
Chapter 10. Manipulating Variables<br>
128<br>
<hr>
<A name=135></a>Advanced Bash-Scripting Guide<br>
echo &quot;${variable-0}&quot; &nbsp; &nbsp;# (no output)<br>
echo &quot;${variable:-1}&quot; &nbsp; # 1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
unset variable<br>
echo &quot;${variable-2}&quot; &nbsp; &nbsp;# 2<br>
echo &quot;${variable:-3}&quot; &nbsp; # 3<br>
exit 0<br>
The<i>&nbsp;default parameter</i>&nbsp;construct finds use in providing &quot;missing&quot; command-line arguments in scripts.<br>
DEFAULT_FILENAME=generic.data<br>
filename=${1:-$DEFAULT_FILENAME}<br>
# &nbsp;If not otherwise specified, the following command block operates<br>
#+ on the file &quot;generic.data&quot;.<br>
# &nbsp;Begin-Command-Block<br>
# &nbsp;...<br>
# &nbsp;...<br>
# &nbsp;...<br>
# &nbsp;End-Command-Block<br>
# &nbsp;From &quot;hanoi2.bash&quot; example:<br>
DISKS=${1:-E_NOPARAM} &nbsp; # Must specify how many disks.<br>
# &nbsp;Set $DISKS to $1 command-line-parameter,<br>
#+ or to $E_NOPARAM if that is unset.<br>
<a href="abs-guides.html#29">See also Example 3-4, Example 31-2, and Example A-6.</a><br>
<a href="abs-guides.html#425">Compare this method with using an<i>&nbsp;and list</i>&nbsp;to supply a default command-line argument.</a><br>
<b>${parameter=default}</b>,&nbsp;<b>${parameter:=default}</b><br>
If parameter not set, set it to<i>&nbsp;default</i>.<br>
Both forms nearly equivalent. The : makes a difference only when&nbsp;$parameter&nbsp;has been declared<br>and is null,&nbsp;[50] as above.<br>
echo ${var=abc} &nbsp; # abc<br>
echo ${var=xyz} &nbsp; # abc<br>
# $var had already been set to abc, so it did not change.<br>
<b>${parameter+alt_value}</b>,&nbsp;<b>${parameter:+alt_value}</b><br>
If parameter set, use&nbsp;<b>alt_value</b>, else use null string.<br>
Both forms nearly equivalent. The : makes a difference only when&nbsp;<i>parameter</i>&nbsp;has been declared<br>and is null, see below.<br>
echo &quot;###### \${parameter+alt_value} ########&quot;<br>
echo<br>
a=${param1+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a =<br>
param2=<br>
a=${param2+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a = xyz<br>
Chapter 10. Manipulating Variables<br>
129<br>
<hr>
<A name=136></a>Advanced Bash-Scripting Guide<br>
param3=123<br>
a=${param3+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a = xyz<br>
echo<br>
echo &quot;###### \${parameter:+alt_value} ########&quot;<br>
echo<br>
a=${param4:+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a =<br>
param5=<br>
a=${param5:+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a =<br>
# Different result from &nbsp; a=${param5+xyz}<br>
param6=123<br>
a=${param6:+xyz}<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# a = xyz<br>
<b>${parameter?err_msg}</b>,&nbsp;<b>${parameter:?err_msg}</b><br>
If parameter set, use it, else print<i>&nbsp;err_msg</i>&nbsp;and<i>&nbsp;abort the script</i><a href="abs-guides.html#57">&nbsp;with an exit status of 1.</a><br>
Both forms nearly equivalent. The : makes a difference only when&nbsp;<i>parameter</i>&nbsp;has been declared<br>and is null, as above.<br>
<b>Example 10-7. Using parameter substitution and error messages</b><br>
#!/bin/bash<br>
# &nbsp;Check some of the system's environmental variables.<br>
# &nbsp;This is good preventative maintenance.<br>
# &nbsp;If, for example, $USER, the name of the person at the console, is not set,<br>
#+ the machine will not recognize you.<br>
: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}<br>
&nbsp; echo<br>
&nbsp; echo &quot;Name of the machine is $HOSTNAME.&quot;<br>
&nbsp; echo &quot;You are $USER.&quot;<br>
&nbsp; echo &quot;Your home directory is $HOME.&quot;<br>
&nbsp; echo &quot;Your mail INBOX is located in $MAIL.&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;If you are reading this message,&quot;<br>
&nbsp; echo &quot;critical environmental variables have been set.&quot;<br>
&nbsp; echo<br>
&nbsp; echo<br>
# ------------------------------------------------------<br>
# &nbsp;The ${variablename?} construction can also check<br>
#+ for variables set within the script.<br>
ThisVariable=Value-of-ThisVariable<br>
# &nbsp;Note, by the way, that string variables may be set<br>
#+ to characters disallowed in their names.<br>
: ${ThisVariable?}<br>
echo &quot;Value of ThisVariable is $ThisVariable&quot;.<br>
echo; echo<br>
Chapter 10. Manipulating Variables<br>
130<br>
<hr>
<A name=137></a><IMG src="abs-guide-137_1.png"><br>
Advanced Bash-Scripting Guide<br>
: ${ZZXy23AB?&quot;ZZXy23AB has not been set.&quot;}<br>
# &nbsp;Since ZZXy23AB has not been set,<br>
#+ then the script terminates with an error message.<br>
# You can specify the error message.<br>
# : ${variablename?&quot;ERROR MESSAGE&quot;}<br>
# Same result with: &nbsp; dummy_variable=${ZZXy23AB?}<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummy_variable=${ZZXy23AB?&quot;ZXy23AB has not been set.&quot;}<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ${ZZXy23AB?} &gt;/dev/null<br>
# &nbsp;Compare these methods of checking whether a variable has been set<br>
#+ with &quot;set -u&quot; . . .<br>
echo &quot;You will not see this message, because script already terminated.&quot;<br>
HERE=0<br>
exit $HERE &nbsp; # Will NOT exit here.<br>
# In fact, this script will return an exit status (echo $?) of 1.<br>
<b>Example 10-8. Parameter substitution and &quot;usage&quot; messages</b><br>
#!/bin/bash<br>
# usage-message.sh<br>
: ${1?&quot;Usage: $0 ARGUMENT&quot;}<br>
# &nbsp;Script exits here if command-line parameter absent,<br>
#+ with following error message.<br>
# &nbsp; &nbsp;usage-message.sh: 1: Usage: usage-message.sh ARGUMENT<br>
echo &quot;These two lines echo only if command-line parameter given.&quot;<br>
echo &quot;command-line parameter = \&quot;$1\&quot;&quot;<br>
exit 0 &nbsp;# Will exit here only if command-line parameter present.<br>
# Check the exit status, both with and without command-line parameter.<br>
# If command-line parameter present, then &quot;$?&quot; is 0.<br>
# If not, then &quot;$?&quot; is 1.<br>
<b>Parameter substitution and/or expansion.&nbsp;</b>The following expressions are the complement to the<b>&nbsp;match&nbsp;</b><i>in<br></i><b>expr</b><a href="abs-guides.html#233">&nbsp;string operations (see Example 16-9). These particular ones are used mostly in parsing file path names.</a><br>
<b>Variable length / Substring removal</b><br>
<b>${#var}</b><br>
<b>String length</b>&nbsp;(number of characters in&nbsp;$var<a href="abs-guides.html#427">). For an array,</a><b>&nbsp;${#array}</b>&nbsp;is the length of the first<br>element in the array.<br>
Exceptions:<br>
◊&nbsp;<br>
<b>${#*}</b>&nbsp;and<b>&nbsp;${#@}</b>&nbsp;give the<i>&nbsp;number of positional parameters</i>.<br>
Chapter 10. Manipulating Variables<br>
131<br>
<hr>
<A name=138></a>Advanced Bash-Scripting Guide<br>
For an array,<br>
◊&nbsp;<br>
<b>&nbsp;${#array[*]}</b>&nbsp;and<b>&nbsp;${#array[@]}</b>&nbsp;give the number of elements in<br>
the array.<br>
<b>Example 10-9. Length of a variable</b><br>
#!/bin/bash<br>
# length.sh<br>
E_NO_ARGS=65<br>
if [ $# -eq 0 ] &nbsp;# Must have command-line args to demo script.<br>
then<br>
&nbsp; echo &quot;Please invoke this script with one or more command-line arguments.&quot;<br>
&nbsp; exit $E_NO_ARGS<br>
fi &nbsp;<br>
var01=abcdEFGH28ij<br>
echo &quot;var01 = ${var01}&quot;<br>
echo &quot;Length of var01 = ${#var01}&quot;<br>
# Now, let's try embedding a space.<br>
var02=&quot;abcd EFGH28ij&quot;<br>
echo &quot;var02 = ${var02}&quot;<br>
echo &quot;Length of var02 = ${#var02}&quot;<br>
echo &quot;Number of command-line arguments passed to script = ${#@}&quot;<br>
echo &quot;Number of command-line arguments passed to script = ${#*}&quot;<br>
exit 0<br>
<b>${var#Pattern}</b>,&nbsp;<b>${var##Pattern}</b><br>
<b>${var#Pattern}</b>&nbsp;Remove from&nbsp;$var&nbsp;the<i>&nbsp;shortest</i>&nbsp;part of&nbsp;$Pattern&nbsp;that matches the&nbsp;<i>front end<br></i>of&nbsp;$var.<br>
<b>${var##Pattern}</b>&nbsp;Remove from&nbsp;$var&nbsp;the<i>&nbsp;longest</i>&nbsp;part of&nbsp;$Pattern&nbsp;that matches the&nbsp;<i>front end<br></i>of&nbsp;$var.<br>
<a href="abs-guides.html#577">A usage illustration from Example A-7:</a><br>
# Function from &quot;days-between.sh&quot; example.<br>
# Strips leading zero(s) from argument passed.<br>
strip_leading_zero () # &nbsp;Strip possible leading zero(s)<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ from argument passed.<br>
&nbsp; return=${1#0} &nbsp; &nbsp; &nbsp; # &nbsp;The &quot;1&quot; refers to &quot;$1&quot; -- passed arg.<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;The &quot;0&quot; is what to remove from &quot;$1&quot; -- strips zeros.<br>
Manfred Schwarb's more elaborate variation of the above:<br>
strip_leading_zero2 () # Strip possible leading zero(s), since otherwise<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Bash will interpret such numbers as octal values.<br>
&nbsp; shopt -s extglob &nbsp; &nbsp; # Turn on extended globbing.<br>
&nbsp; local val=${1##+(0)} # Use local variable, longest matching series of 0's.<br>
&nbsp; shopt -u extglob &nbsp; &nbsp; # Turn off extended globbing.<br>
&nbsp; _strip_leading_zero2=${val:-0}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If input was 0, return 0 instead of &quot;&quot;.<br>
}<br>
Another usage illustration:<br>
Chapter 10. Manipulating Variables<br>
132<br>
<hr>
<A name=139></a>Advanced Bash-Scripting Guide<br>
echo `basename $PWD` &nbsp; &nbsp; &nbsp; &nbsp;# Basename of current working directory.<br>
echo &quot;${PWD##*/}&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Basename of current working directory.<br>
echo<br>
echo `basename $0` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Name of script.<br>
echo $0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Name of script.<br>
echo &quot;${0##*/}&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Name of script.<br>
echo<br>
filename=test.data<br>
echo &quot;${filename##*.}&quot; &nbsp; &nbsp; &nbsp;# data<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Extension of filename.<br>
<b>${var%Pattern}</b>,&nbsp;<b>${var%%Pattern}</b><br>
<b>${var%Pattern}</b>&nbsp;Remove from&nbsp;$var&nbsp;the<i>&nbsp;shortest</i>&nbsp;part of&nbsp;$Pattern&nbsp;that matches the&nbsp;<i>back end<br></i>of&nbsp;$var.<br>
<b>${var%%Pattern}</b>&nbsp;Remove from&nbsp;$var&nbsp;the<i>&nbsp;longest</i>&nbsp;part of&nbsp;$Pattern&nbsp;that matches the&nbsp;<i>back end<br></i>of&nbsp;$var.<br>
<a href="abs-guides.html#541">Version 2 of Bash added additional options.</a><br>
<b>Example 10-10. Pattern matching in parameter substitution</b><br>
#!/bin/bash<br>
# patt-matching.sh<br>
# Pattern matching &nbsp;using the # ## % %% parameter substitution operators.<br>
var1=abcd12345abc6789<br>
pattern1=a*c &nbsp;# * (wild card) matches everything between a - c.<br>
echo<br>
echo &quot;var1 = $var1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcd12345abc6789<br>
echo &quot;var1 = ${var1}&quot; &nbsp; &nbsp; &nbsp; &nbsp; # abcd12345abc6789<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (alternate form)<br>
echo &quot;Number of characters in ${var1} = ${#var1}&quot;<br>
echo<br>
echo &quot;pattern1 = $pattern1&quot; &nbsp; # a*c &nbsp;(everything between 'a' and 'c')<br>
echo &quot;--------------&quot;<br>
echo '${var1#$pattern1} &nbsp;=' &quot;${var1#$pattern1}&quot; &nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; d12345abc6789<br>
# Shortest possible match, strips out first 3 characters &nbsp;abcd12345abc6789<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |-|<br>
echo '${var1##$pattern1} =' &quot;${var1##$pattern1}&quot; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6789 &nbsp; &nbsp; &nbsp;<br>
# Longest possible match, strips out first 12 characters &nbsp;abcd12345abc6789<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|----------|<br>
echo; echo; echo<br>
pattern2=b*9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# everything between 'b' and '9'<br>
echo &quot;var1 = $var1&quot; &nbsp; &nbsp; # Still &nbsp;abcd12345abc6789<br>
echo<br>
echo &quot;pattern2 = $pattern2&quot;<br>
echo &quot;--------------&quot;<br>
echo '${var1%pattern2} &nbsp;=' &quot;${var1%$pattern2}&quot; &nbsp; &nbsp; # &nbsp; &nbsp; abcd12345a<br>
# Shortest possible match, strips out last 6 characters &nbsp;abcd12345abc6789<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |----|<br>
echo '${var1%%pattern2} =' &quot;${var1%%$pattern2}&quot; &nbsp; &nbsp;# &nbsp; &nbsp; a<br>
Chapter 10. Manipulating Variables<br>
133<br>
<hr>
<A name=140></a>Advanced Bash-Scripting Guide<br>
# Longest possible match, strips out last 12 characters &nbsp;abcd12345abc6789<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |-------------|<br>
# Remember, # and ## work from the left end (beginning) of string,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; % and %% work from the right end.<br>
echo<br>
exit 0<br>
<b>Example 10-11. Renaming file extensions:</b><br>
#!/bin/bash<br>
# rfe.sh: Renaming file extensions.<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; rfe old_extension new_extension<br>
#<br>
# Example:<br>
# To rename all *.gif files in working directory to *.jpg,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rfe gif jpg<br>
E_BADARGS=65<br>
case $# in<br>
&nbsp; 0|1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The vertical bar means &quot;or&quot; in this context.<br>
&nbsp; echo &quot;Usage: `basename $0` old_file_suffix new_file_suffix&quot;<br>
&nbsp; exit $E_BADARGS &nbsp;# If 0 or 1 arg, then bail out.<br>
&nbsp; ;;<br>
esac<br>
for filename in *.$1<br>
# Traverse list of files ending with 1st argument.<br>
do<br>
&nbsp; mv $filename ${filename%$1}$2<br>
&nbsp; # &nbsp;Strip off part of filename matching 1st argument,<br>
&nbsp; #+ then append 2nd argument.<br>
done<br>
exit 0<br>
<b>Variable expansion / Substring replacement</b><br>
These constructs have been adopted from<i>&nbsp;ksh</i>.<br>
<b>${var:pos}</b><br>
Variable&nbsp;<i>var</i>&nbsp;expanded, starting from offset&nbsp;<i>pos</i>.<br>
<b>${var:pos:len}</b><br>
Expansion to a max of&nbsp;<i>len</i>&nbsp;characters of variable&nbsp;<i>var</i>, from offset&nbsp;<i>pos</i><a href="abs-guides.html#591">. See Example A-13 for an<br></a>example of the creative use of this operator.<br>
<b>${var/Pattern/Replacement}</b><br>
First match of&nbsp;<i>Pattern</i>, within&nbsp;<i>var</i>&nbsp;replaced with&nbsp;<i>Replacement</i>.<br>
If&nbsp;<i>Replacement</i>&nbsp;is omitted, then the first match of&nbsp;<i>Pattern</i>&nbsp;is replaced by<i>&nbsp;nothing</i>, that is,<br>deleted.<br>
<b>${var//Pattern/Replacement}</b><br>
<b>Global replacement.&nbsp;</b>&nbsp;All matches of&nbsp;<i>Pattern</i>, within&nbsp;<i>var</i>&nbsp;replaced with&nbsp;<i>Replacement</i>.<br>
Chapter 10. Manipulating Variables<br>
134<br>
<hr>
<A name=141></a>Advanced Bash-Scripting Guide<br>
As above, if&nbsp;<i>Replacement</i>&nbsp;is omitted, then all occurrences of&nbsp;<i>Pattern</i>&nbsp;are replaced by<i>&nbsp;nothing</i>,<br>that is, deleted.<br>
<b>Example 10-12. Using pattern matching to parse arbitrary strings</b><br>
#!/bin/bash<br>
var1=abcd-1234-defg<br>
echo &quot;var1 = $var1&quot;<br>
t=${var1#*-*}<br>
echo &quot;var1 (with everything, up to and including first - stripped out) = $t&quot;<br>
# &nbsp;t=${var1#*-} &nbsp;works just the same,<br>
#+ since # matches the shortest string,<br>
#+ and * matches everything preceding, including an empty string.<br>
# (Thanks, Stephane Chazelas, for pointing this out.)<br>
t=${var1##*-*}<br>
echo &quot;If var1 contains a \&quot;-\&quot;, returns empty string... &nbsp; var1 = $t&quot;<br>
t=${var1%*-*}<br>
echo &quot;var1 (with everything from the last - on stripped out) = $t&quot;<br>
echo<br>
# -------------------------------------------<br>
path_name=/home/bozo/ideas/thoughts.for.today<br>
# -------------------------------------------<br>
echo &quot;path_name = $path_name&quot;<br>
t=${path_name##/*/}<br>
echo &quot;path_name, stripped of prefixes = $t&quot;<br>
# Same effect as &nbsp; t=`basename $path_name` in this particular case.<br>
# &nbsp;t=${path_name%/}; t=${t##*/} &nbsp; is a more general solution,<br>
#+ but still fails sometimes.<br>
# &nbsp;If $path_name ends with a newline, then `basename $path_name` will not work,<br>
#+ but the above expression will.<br>
# (Thanks, S.C.)<br>
t=${path_name%/*.*}<br>
# Same effect as &nbsp; t=`dirname $path_name`<br>
echo &quot;path_name, stripped of suffixes = $t&quot;<br>
# These will fail in some cases, such as &quot;../&quot;, &quot;/foo////&quot;, # &quot;foo/&quot;, &quot;/&quot;.<br>
# &nbsp;Removing suffixes, especially when the basename has no suffix,<br>
#+ but the dirname does, also complicates matters.<br>
# (Thanks, S.C.)<br>
echo<br>
t=${path_name:11}<br>
echo &quot;$path_name, with first 11 chars stripped off = $t&quot;<br>
t=${path_name:11:5}<br>
echo &quot;$path_name, with first 11 chars stripped off, length 5 = $t&quot;<br>
echo<br>
t=${path_name/bozo/clown}<br>
echo &quot;$path_name with \&quot;bozo\&quot; replaced &nbsp;by \&quot;clown\&quot; = $t&quot;<br>
t=${path_name/today/}<br>
echo &quot;$path_name with \&quot;today\&quot; deleted = $t&quot;<br>
Chapter 10. Manipulating Variables<br>
135<br>
<hr>
<A name=142></a>Advanced Bash-Scripting Guide<br>
t=${path_name//o/O}<br>
echo &quot;$path_name with all o's capitalized = $t&quot;<br>
t=${path_name//o/}<br>
echo &quot;$path_name with all o's deleted = $t&quot;<br>
exit 0<br>
<b>${var/#Pattern/Replacement}</b><br>
If<i>&nbsp;prefix</i>&nbsp;of&nbsp;<i>var</i>&nbsp;matches&nbsp;<i>Pattern</i>, then substitute&nbsp;<i>Replacement</i>&nbsp;for&nbsp;<i>Pattern</i>.<br>
<b>${var/%Pattern/Replacement}</b><br>
If<i>&nbsp;suffix</i>&nbsp;of&nbsp;<i>var</i>&nbsp;matches&nbsp;<i>Pattern</i>, then substitute&nbsp;<i>Replacement</i>&nbsp;for&nbsp;<i>Pattern</i>.<br>
<b>Example 10-13. Matching patterns at prefix or suffix of string</b><br>
#!/bin/bash<br>
# var-match.sh:<br>
# Demo of pattern replacement at prefix / suffix of string.<br>
v0=abc1234zip1234abc &nbsp; &nbsp;# Original variable.<br>
echo &quot;v0 = $v0&quot; &nbsp; &nbsp; &nbsp; &nbsp; # abc1234zip1234abc<br>
echo<br>
# Match at prefix (beginning) of string.<br>
v1=${v0/#abc/ABCDEF} &nbsp; &nbsp;# abc1234zip1234abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # |-|<br>
echo &quot;v1 = $v1&quot; &nbsp; &nbsp; &nbsp; &nbsp; # ABCDEF1234zip1234abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # |----|<br>
# Match at suffix (end) of string.<br>
v2=${v0/%abc/ABCDEF} &nbsp; &nbsp;# abc1234zip123abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|-|<br>
echo &quot;v2 = $v2&quot; &nbsp; &nbsp; &nbsp; &nbsp; # abc1234zip1234ABCDEF<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |----|<br>
echo<br>
# &nbsp;----------------------------------------------------<br>
# &nbsp;Must match at beginning / end of string,<br>
#+ otherwise no replacement results.<br>
# &nbsp;----------------------------------------------------<br>
v3=${v0/#123/000} &nbsp; &nbsp; &nbsp; # Matches, but not at beginning.<br>
echo &quot;v3 = $v3&quot; &nbsp; &nbsp; &nbsp; &nbsp; # abc1234zip1234abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NO REPLACEMENT.<br>
v4=${v0/%123/000} &nbsp; &nbsp; &nbsp; # Matches, but not at end.<br>
echo &quot;v4 = $v4&quot; &nbsp; &nbsp; &nbsp; &nbsp; # abc1234zip1234abc<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NO REPLACEMENT.<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
<b>${!varprefix*}</b>,&nbsp;<b>${!varprefix@}</b><br>
Matches<i>&nbsp;names</i>&nbsp;of all previously declared variables beginning with&nbsp;<i>varprefix</i>.<br>
# This is a variation on indirect reference, but with a * or @.<br>
# Bash, version 2.04, adds this feature.<br>
xyz23=whatever<br>
xyz24=<br>
a=${!xyz*} &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Expands to *names* of declared variables<br>
# ^ ^ &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + beginning with &quot;xyz&quot;.<br>
Chapter 10. Manipulating Variables<br>
136<br>
<hr>
<A name=143></a>Advanced Bash-Scripting Guide<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# &nbsp;a = xyz23 xyz24<br>
a=${!xyz@} &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Same as above.<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp;# &nbsp;a = xyz23 xyz24<br>
echo &quot;---&quot;<br>
abc23=something_else<br>
b=${!abc*}<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp;# &nbsp;b = abc23<br>
c=${!b} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Now, the more familiar type of indirect reference.<br>
echo $c &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;something_else<br>
Chapter 10. Manipulating Variables<br>
137<br>
<hr>
<A name=144></a><IMG src="abs-guide-144_1.png"><br>
<b>Chapter 11. Loops and Branches</b><br>
<i>What needs this iteration, woman?</i><br>
<i>--Shakespeare,&nbsp;Othello</i><br>
Operations on code blocks are the key to structured and organized shell scripts. Looping and branching<br>constructs provide the tools for accomplishing this.<br>
<b>11.1. Loops</b><br>
A<i>&nbsp;loop</i>&nbsp;is a block of code that<i>&nbsp;iterates&nbsp;</i>[51] a list of commands as long as the<i>&nbsp;loop control condition</i>&nbsp;is true.<br>
<b>for loops</b><br>
<b>for&nbsp;<i>arg</i></b><b>&nbsp;in&nbsp;<i>[list]</i></b><br>
This is the basic looping construct. It differs significantly from its<i>&nbsp;C</i>&nbsp;counterpart.<br>
<b>for&nbsp;</b><i>arg</i>&nbsp;in [<i>list</i>]<br>do<br><i>&nbsp;command(s)</i>...<br>done<br>
During each pass through the loop,&nbsp;<i>arg</i>&nbsp;takes on the value of each successive variable<br>in the&nbsp;<i>list</i>.<br>
for arg in &quot;$var1&quot; &quot;$var2&quot; &quot;$var3&quot; ... &quot;$varN&quot; &nbsp;<br>
# In pass 1 of the loop, arg = $var1 &nbsp; &nbsp; &nbsp; &nbsp;<br>
# In pass 2 of the loop, arg = $var2 &nbsp; &nbsp; &nbsp; &nbsp;<br>
# In pass 3 of the loop, arg = $var3 &nbsp; &nbsp; &nbsp; &nbsp;<br>
# ...<br>
# In pass N of the loop, arg = $varN<br>
# Arguments in [list] quoted to prevent possible word splitting.<br>
The argument&nbsp;<i>list</i><a href="abs-guides.html#18">&nbsp;may contain wild cards.</a><br>
If<i>&nbsp;do</i>&nbsp;is on same line as<i>&nbsp;for</i>, there needs to be a semicolon after list.<br>
<b>for&nbsp;</b><i>arg</i>&nbsp;in [<i>list</i>] ; do<br>
<b>Example 11-1. Simple<i>&nbsp;for</i></b><b>&nbsp;loops</b><br>
#!/bin/bash<br>
# Listing the planets.<br>
for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto<br>
do<br>
&nbsp; echo $planet &nbsp;# Each planet on a separate line.<br>
Chapter 11. Loops and Branches<br>
138<br>
<hr>
<A name=145></a>Advanced Bash-Scripting Guide<br>
done<br>
echo; echo<br>
for planet in &quot;Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto&quot;<br>
&nbsp; &nbsp; # All planets on same line.<br>
&nbsp; &nbsp; # Entire 'list' enclosed in quotes creates a single variable.<br>
&nbsp; &nbsp; # Why? Whitespace incorporated into the variable.<br>
do<br>
&nbsp; echo $planet<br>
done<br>
echo; echo &quot;Whoops! Pluto is no longer a planet!&quot;<br>
exit 0<br>
Each&nbsp;<b>[list]</b>&nbsp;element may contain multiple parameters. This is useful when processing parameters<br><a href="abs-guides.html#203">in groups. In such cases, use the set command (see Example 15-16) to force parsing of each&nbsp;</a><b>[list]<br></b>element and assignment of each component to the positional parameters.<br>
<b>Example 11-2.<i>&nbsp;for</i></b><b>&nbsp;loop with two parameters in each [list] element</b><br>
#!/bin/bash<br>
# Planets revisited.<br>
# Associate the name of each planet with its distance from the sun.<br>
for planet in &quot;Mercury 36&quot; &quot;Venus 67&quot; &quot;Earth 93&quot; &nbsp;&quot;Mars 142&quot; &quot;Jupiter 483&quot;<br>
do<br>
&nbsp; set -- $planet &nbsp;# &nbsp;Parses variable &quot;planet&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and sets positional parameters.<br>
&nbsp; # &nbsp;The &quot;--&quot; prevents nasty surprises if $planet is null or<br>
&nbsp; #+ begins with a dash.<br>
&nbsp; # &nbsp;May need to save original positional parameters,<br>
&nbsp; #+ since they get overwritten.<br>
&nbsp; # &nbsp;One way of doing this is to use an array,<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; original_params=(&quot;$@&quot;)<br>
&nbsp; echo &quot;$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$2,000,000 miles from the sun&quot;<br>
&nbsp; #-------two &nbsp;tabs---concatenate zeroes onto parameter $2<br>
done<br>
# (Thanks, S.C., for additional clarification.)<br>
exit 0<br>
A variable may supply the&nbsp;<b>[list]</b>&nbsp;in a<i>&nbsp;for loop</i>.<br>
<b>Example 11-3.<i>&nbsp;Fileinfo:</i></b><b>&nbsp;operating on a file list contained in a variable</b><br>
#!/bin/bash<br>
# fileinfo.sh<br>
FILES=&quot;/usr/sbin/accept<br>
/usr/sbin/pwck<br>
Chapter 11. Loops and Branches<br>
139<br>
<hr>
<A name=146></a>Advanced Bash-Scripting Guide<br>
/usr/sbin/chroot<br>
/usr/bin/fakefile<br>
/sbin/badblocks<br>
/sbin/ypbind&quot; &nbsp; &nbsp; # List of files you are curious about.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Threw in a dummy file, /usr/bin/fakefile.<br>
echo<br>
for file in $FILES<br>
do<br>
&nbsp; if [ ! -e &quot;$file&quot; ] &nbsp; &nbsp; &nbsp; # Check if file exists.<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$file does not exist.&quot;; echo<br>
&nbsp; &nbsp; continue &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# On to next.<br>
&nbsp; &nbsp;fi<br>
&nbsp; ls -l $file | awk '{ print $8 &quot; &nbsp; &nbsp; &nbsp; &nbsp; file size: &quot; $5 }' &nbsp;# Print 2 fields.<br>
&nbsp; whatis `basename $file` &nbsp; # File info.<br>
&nbsp; # Note that the whatis database needs to have been set up for this to work.<br>
&nbsp; # To do this, as root run /usr/bin/makewhatis.<br>
&nbsp; echo<br>
done &nbsp;<br>
exit 0<br>
If the&nbsp;<b>[list]</b>&nbsp;in a<i>&nbsp;for loop</i><a href="abs-guides.html#358">&nbsp;contains wild cards (* and ?) used in filename expansion, then globbing<br></a>takes place.<br>
<b>Example 11-4. Operating on files with a<i>&nbsp;for</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# list-glob.sh: Generating [list] in a for-loop, using &quot;globbing&quot;<br>
echo<br>
for file in *<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp;Bash performs filename expansion<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on expressions that globbing recognizes.<br>
do<br>
&nbsp; ls -l &quot;$file&quot; &nbsp;# Lists all files in $PWD (current directory).<br>
&nbsp; # &nbsp;Recall that the wild card character &quot;*&quot; matches every filename,<br>
&nbsp; #+ however, in &quot;globbing,&quot; it doesn't match dot-files.<br>
&nbsp; # &nbsp;If the pattern matches no file, it is expanded to itself.<br>
&nbsp; # &nbsp;To prevent this, set the nullglob option<br>
&nbsp; #+ &nbsp; (shopt -s nullglob).<br>
&nbsp; # &nbsp;Thanks, S.C.<br>
done<br>
echo; echo<br>
for file in [jx]*<br>
do<br>
&nbsp; rm -f $file &nbsp; &nbsp;# Removes only files beginning with &quot;j&quot; or &quot;x&quot; in $PWD.<br>
&nbsp; echo &quot;Removed file \&quot;$file\&quot;&quot;.<br>
done<br>
echo<br>
Chapter 11. Loops and Branches<br>
140<br>
<hr>
<A name=147></a>Advanced Bash-Scripting Guide<br>
exit 0<br>
Omitting the&nbsp;<b>in [list]</b>&nbsp;part of a<i>&nbsp;for loop</i><a href="abs-guides.html#104">&nbsp;causes the loop to operate on $@ -- the &nbsp;positional<br>parameters. A particularly clever illustration of this is Example A-15. See also Example 15-17.</a><br>
<b>Example 11-5. Missing&nbsp;in [list]&nbsp;in a<i>&nbsp;for</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# &nbsp;Invoke this script both with and without arguments,<br>
#+ and see what happens.<br>
for a<br>
do<br>
&nbsp;echo -n &quot;$a &quot;<br>
done<br>
# &nbsp;The 'in list' missing, therefore the loop operates on '$@'<br>
#+ (command-line argument list, including whitespace).<br>
echo<br>
exit 0<br>
<a href="abs-guides.html#170">It is possible to use command substitution to generate the&nbsp;</a><b>[list]</b>&nbsp;in a<i>&nbsp;for loop</i><a href="abs-guides.html#307">. See also Example<br>16-54, Example 11-10 and Example 16-48.</a><br>
<b>Example 11-6. Generating the&nbsp;[list]&nbsp;in a<i>&nbsp;for</i></b><b>&nbsp;loop with command substitution</b><br>
#!/bin/bash<br>
# &nbsp;for-loopcmd.sh: for-loop with [list]<br>
#+ generated by command substitution.<br>
NUMBERS=&quot;9 7 3 8 37.53&quot;<br>
for number in `echo $NUMBERS` &nbsp;# for number in 9 7 3 8 37.53<br>
do<br>
&nbsp; echo -n &quot;$number &quot;<br>
done<br>
echo&nbsp;<br>
exit 0<br>
Here is a somewhat more complex example of using command substitution to create the&nbsp;<b>[list]</b>.<br>
<b>Example 11-7. A<i>&nbsp;grep</i></b><b>&nbsp;replacement for binary files</b><br>
#!/bin/bash<br>
# bin-grep.sh: Locates matching strings in a binary file.<br>
# A &quot;grep&quot; replacement for binary files.<br>
# Similar effect to &quot;grep -a&quot;<br>
E_BADARGS=65<br>
Chapter 11. Loops and Branches<br>
141<br>
<hr>
<A name=148></a>Advanced Bash-Scripting Guide<br>
E_NOFILE=66<br>
if [ $# -ne 2 ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` search_string filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ ! -f &quot;$2&quot; ]<br>
then<br>
&nbsp; echo &quot;File \&quot;$2\&quot; does not exist.&quot;<br>
&nbsp; exit $E_NOFILE<br>
fi &nbsp;<br>
IFS=$'\012' &nbsp; &nbsp; &nbsp; # Per suggestion of Anton Filippov.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # was: &nbsp;IFS=&quot;\n&quot;<br>
for word in $( strings &quot;$2&quot; | grep &quot;$1&quot; )<br>
# The &quot;strings&quot; command lists strings in binary files.<br>
# Output then piped to &quot;grep&quot;, which tests for desired string.<br>
do<br>
&nbsp; echo $word<br>
done<br>
# As S.C. points out, lines 23 - 30 could be replaced with the simpler<br>
# &nbsp; &nbsp;strings &quot;$2&quot; | grep &quot;$1&quot; | tr -s &quot;$IFS&quot; '[\n*]'<br>
# &nbsp;Try something like &nbsp;&quot;./bin-grep.sh mem /bin/ls&quot;<br>
#+ to exercise this script.<br>
exit 0<br>
More of the same.<br>
<b>Example 11-8. Listing all users on the system</b><br>
#!/bin/bash<br>
# userlist.sh<br>
PASSWORD_FILE=/etc/passwd<br>
n=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # User number<br>
for name in $(awk 'BEGIN{FS=&quot;:&quot;}{print $1}' &lt; &quot;$PASSWORD_FILE&quot; )<br>
# Field separator = : &nbsp; &nbsp;^^^^^^<br>
# Print first field &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^<br>
# Get input from password file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^^^<br>
do<br>
&nbsp; echo &quot;USER #$n = $name&quot;<br>
&nbsp; let &quot;n += 1&quot;<br>
done &nbsp;<br>
# USER #1 = root<br>
# USER #2 = bin<br>
# USER #3 = daemon<br>
# ...<br>
# USER #30 = bozo<br>
exit $?<br>
Chapter 11. Loops and Branches<br>
142<br>
<hr>
<A name=149></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Discussion:<br>
# &nbsp;----------<br>
# &nbsp;How is it that an ordinary user, or a script run by same,<br>
#+ can read /etc/passwd? (Hint: Check the /etc/passwd file permissions.)<br>
# &nbsp;Isn't this a security hole? Why or why not?<br>
Yet another example of the&nbsp;<b>[list]</b>&nbsp;resulting from command substitution.<br>
<b>Example 11-9. Checking all the binaries in a directory for authorship</b><br>
#!/bin/bash<br>
# findstring.sh:<br>
# Find a particular string in the binaries in a specified directory.<br>
directory=/usr/bin/<br>
fstring=&quot;Free Software Foundation&quot; &nbsp;# See which files come from the FSF.<br>
for file in $( find $directory -type f -name '*' | sort )<br>
do<br>
&nbsp; strings -f $file | grep &quot;$fstring&quot; | sed -e &quot;s%$directory%%&quot;<br>
&nbsp; # &nbsp;In the &quot;sed&quot; expression,<br>
&nbsp; #+ it is necessary to substitute for the normal &quot;/&quot; delimiter<br>
&nbsp; #+ because &quot;/&quot; happens to be one of the characters filtered out.<br>
&nbsp; # &nbsp;Failure to do so gives an error message. (Try it.)<br>
done &nbsp;<br>
exit $?<br>
# &nbsp;Exercise (easy):<br>
# &nbsp;---------------<br>
# &nbsp;Convert this script to take command-line parameters<br>
#+ for $directory and $fstring.<br>
A final example of&nbsp;<b>[list]</b><a href="abs-guides.html#399">&nbsp;/ command substitution, but this time the &quot;command&quot; is a function.</a><br>
generate_list ()<br>
{<br>
&nbsp; echo &quot;one two three&quot;<br>
}<br>
for word in $(generate_list) &nbsp;# Let &quot;word&quot; grab output of function.<br>
do<br>
&nbsp; echo &quot;$word&quot;<br>
done<br>
# one<br>
# two<br>
# three<br>
The output of a<i>&nbsp;for loop</i>&nbsp;may be piped to a command or commands.<br>
<b>Example 11-10. Listing the<i>&nbsp;symbolic links</i></b><b>&nbsp;in a directory</b><br>
#!/bin/bash<br>
# symlinks.sh: Lists symbolic links in a directory.<br>
directory=${1-`pwd`}<br>
Chapter 11. Loops and Branches<br>
143<br>
<hr>
<A name=150></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Defaults to current working directory,<br>
#+ if not otherwise specified.<br>
# &nbsp;Equivalent to code block below.<br>
# ----------------------------------------------------------<br>
# ARGS=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Expect one command-line argument.<br>
#<br>
# if [ $# -ne &quot;$ARGS&quot; ] &nbsp;# If not 1 arg...<br>
# then<br>
# &nbsp; directory=`pwd` &nbsp; &nbsp; &nbsp;# current working directory<br>
# else<br>
# &nbsp; directory=$1<br>
# fi<br>
# ----------------------------------------------------------<br>
echo &quot;symbolic links in directory \&quot;$directory\&quot;&quot;<br>
for file in &quot;$( find $directory -type l )&quot; &nbsp; # -type l = symbolic links<br>
do<br>
&nbsp; echo &quot;$file&quot;<br>
done | sort &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Otherwise file list is unsorted.<br>
# &nbsp;Strictly speaking, a loop isn't really necessary here,<br>
#+ since the output of the &quot;find&quot; command is expanded into a single word.<br>
# &nbsp;However, it's easy to understand and illustrative this way.<br>
# &nbsp;As Dominik 'Aeneas' Schnitzer points out,<br>
#+ failing to quote &nbsp;$( find $directory -type l )<br>
#+ will choke on filenames with embedded whitespace.<br>
# &nbsp;containing whitespace.&nbsp;<br>
exit 0<br>
# --------------------------------------------------------<br>
# Jean Helou proposes the following alternative:<br>
echo &quot;symbolic links in directory \&quot;$directory\&quot;&quot;<br>
# Backup of the current IFS. One can never be too cautious.<br>
OLDIFS=$IFS<br>
IFS=:<br>
for file in $(find $directory -type l -printf &quot;%p$IFS&quot;)<br>
do &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^^^<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$file&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;done|sort<br>
# And, James &quot;Mike&quot; Conley suggests modifying Helou's code thusly:<br>
OLDIFS=$IFS<br>
IFS='' # Null IFS means no word breaks<br>
for file in $( find $directory -type l )<br>
do<br>
&nbsp; echo $file<br>
&nbsp; done | sort<br>
# &nbsp;This works in the &quot;pathological&quot; case of a directory name having<br>
#+ an embedded colon.<br>
# &nbsp;&quot;This also fixes the pathological case of the directory name having<br>
#+ &nbsp;a colon (or space in earlier example) as well.&quot;<br>
The&nbsp;stdout<a href="abs-guides.html#374">&nbsp;of a loop may be redirected to a file, as this slight modification to the previous example<br></a>shows.<br>
Chapter 11. Loops and Branches<br>
144<br>
<hr>
<A name=151></a>Advanced Bash-Scripting Guide<br>
<b>Example 11-11. Symbolic links in a directory, saved to a file</b><br>
#!/bin/bash<br>
# symlinks.sh: Lists symbolic links in a directory.<br>
OUTFILE=symlinks.list &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # save file<br>
directory=${1-`pwd`}<br>
# &nbsp;Defaults to current working directory,<br>
#+ if not otherwise specified.<br>
echo &quot;symbolic links in directory \&quot;$directory\&quot;&quot; &gt; &quot;$OUTFILE&quot;<br>
echo &quot;---------------------------&quot; &gt;&gt; &quot;$OUTFILE&quot;<br>
for file in &quot;$( find $directory -type l )&quot; &nbsp; &nbsp;# -type l = symbolic links<br>
do<br>
&nbsp; echo &quot;$file&quot;<br>
done | sort &gt;&gt; &quot;$OUTFILE&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # stdout of loop<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redirected to save file.<br>
exit 0<br>
There is an alternative syntax to a<i>&nbsp;for loop</i>&nbsp;that will look very familiar to C programmers. This<br><a href="abs-guides.html#86">requires double parentheses.</a><br>
<b>Example 11-12. A C-style<i>&nbsp;for</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# Multiple ways to count up to 10.<br>
echo<br>
# Standard syntax.<br>
for a in 1 2 3 4 5 6 7 8 9 10<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp;<br>
echo; echo<br>
# +==========================================+<br>
# Using &quot;seq&quot; ...<br>
for a in `seq 10`<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp;<br>
echo; echo<br>
# +==========================================+<br>
# Using brace expansion ...<br>
# Bash, version 3+.<br>
for a in {1..10}<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp;<br>
Chapter 11. Loops and Branches<br>
145<br>
<hr>
<A name=152></a>Advanced Bash-Scripting Guide<br>
echo; echo<br>
# +==========================================+<br>
# Now, let's do the same, using C-like syntax.<br>
LIMIT=10<br>
for ((a=1; a &lt;= LIMIT ; a++)) &nbsp;# Double parentheses, and &quot;LIMIT&quot; with no &quot;$&quot;.<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # A construct borrowed from 'ksh93'.<br>
echo; echo<br>
# +=========================================================================+<br>
# Let's use the C &quot;comma operator&quot; to increment two variables simultaneously.<br>
for ((a=1, b=1; a &lt;= LIMIT ; a++, b++))<br>
do &nbsp;# The comma chains together operations.<br>
&nbsp; echo -n &quot;$a-$b &quot;<br>
done<br>
echo; echo<br>
exit 0<br>
<a href="abs-guides.html#451">See also Example 27-16, Example 27-17, and Example A-6.</a><br>
---<br>
Now, a<i>&nbsp;for loop</i>&nbsp;used in a &quot;real-life&quot; context.<br>
<b>Example 11-13. Using<i>&nbsp;efax</i></b><b>&nbsp;in batch mode</b><br>
#!/bin/bash<br>
# Faxing (must have 'efax' package installed).<br>
EXPECTED_ARGS=2<br>
E_BADARGS=85<br>
MODEM_PORT=&quot;/dev/ttyS2&quot; &nbsp; # May be different on your machine.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^ &nbsp; &nbsp; &nbsp;PCMCIA modem card default port.<br>
if [ $# -ne $EXPECTED_ARGS ]<br>
# Check for proper number of command-line args.<br>
then<br>
&nbsp; &nbsp;echo &quot;Usage: `basename $0` phone# text-file&quot;<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi<br>
if [ ! -f &quot;$2&quot; ]<br>
then<br>
&nbsp; echo &quot;File $2 is not a text file.&quot;<br>
&nbsp; # &nbsp; &nbsp; File is not a regular file, or does not exist.<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
Chapter 11. Loops and Branches<br>
146<br>
<hr>
<A name=153></a>Advanced Bash-Scripting Guide<br>
fax make $2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Create fax-formatted files from text files.<br>
for file in $(ls $2.0*) &nbsp;# &nbsp;Concatenate the converted files.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Uses wild card (filename &quot;globbing&quot;)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ in variable list.<br>
do<br>
&nbsp; fil=&quot;$fil $file&quot;<br>
done &nbsp;<br>
efax -d &quot;$MODEM_PORT&quot; &nbsp;-t &quot;T$1&quot; $fil &nbsp; # Finally, do the work.<br>
# Trying adding &nbsp;-o1 &nbsp;if above line fails.<br>
# &nbsp;As S.C. points out, the for-loop can be eliminated with<br>
# &nbsp; &nbsp; efax -d /dev/ttyS2 -o1 -t &quot;T$1&quot; $2.0*<br>
#+ but it's not quite as instructive [grin].<br>
exit $? &nbsp; # Also, efax sends diagnostic messages to stdout.<br>
<b>while</b><br>
This construct tests for a condition at the top of a loop, and keeps looping as long as that condition is<br><a href="abs-guides.html#57">true (returns a 0 exit status). In contrast to a for loop, a</a><i>&nbsp;while loop</i>&nbsp;finds use in situations where the<br>number of loop repetitions is not known beforehand.<br>
<b>while</b>&nbsp;[<i>&nbsp;condition</i>&nbsp;]<br>do<br><i>&nbsp;command(s)</i>...<br>done<br>
The bracket construct in a<i>&nbsp;while loop</i><a href="abs-guides.html#60">&nbsp;is nothing more than our old friend, the test brackets used in an<br></a><i>if/then</i>&nbsp;test. In fact, a<i>&nbsp;while loop</i><a href="abs-guides.html#65">&nbsp;can legally use the more versatile double-brackets construct (while [[<br></a>condition ]]).<br>
<a href="abs-guides.html#144">As is the case with<i>&nbsp;for loops</i>, placing the</a><i>&nbsp;do</i>&nbsp;on the same line as the condition test requires a<br>semicolon.<br>
<b>while</b>&nbsp;[<i>&nbsp;condition</i>&nbsp;] ; do<br>
Note that the<i>&nbsp;test brackets</i><a href="abs-guides.html#156">&nbsp;are<i>&nbsp;not</i>&nbsp;mandatory in a</a><i>&nbsp;while</i><a href="abs-guides.html#208">&nbsp;loop. See, for example, the getopts construct.</a><br>
<b>Example 11-14. Simple<i>&nbsp;while</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
var0=0<br>
LIMIT=10<br>
while [ &quot;$var0&quot; -lt &quot;$LIMIT&quot; ]<br>
# &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
# Spaces, because these are &quot;test-brackets&quot; . . .<br>
do<br>
&nbsp; echo -n &quot;$var0 &quot; &nbsp; &nbsp; &nbsp; &nbsp;# -n suppresses newline.<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Space, to separate printed out numbers.<br>
Chapter 11. Loops and Branches<br>
147<br>
<hr>
<A name=154></a>Advanced Bash-Scripting Guide<br>
&nbsp; var0=`expr $var0 + 1` &nbsp; # var0=$(($var0+1)) &nbsp;also works.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # var0=$((var0 + 1)) also works.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # let &quot;var0 += 1&quot; &nbsp; &nbsp;also works.<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Various other methods also work.<br>
echo<br>
exit 0<br>
<b>Example 11-15. Another<i>&nbsp;while</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Equivalent to:<br>
while [ &quot;$var1&quot; != &quot;end&quot; ] &nbsp; &nbsp; # while test &quot;$var1&quot; != &quot;end&quot;<br>
do<br>
&nbsp; echo &quot;Input variable #1 (end to exit) &quot;<br>
&nbsp; read var1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Not 'read $var1' (why?).<br>
&nbsp; echo &quot;variable #1 = $var1&quot; &nbsp; # Need quotes because of &quot;#&quot; . . .<br>
&nbsp; # If input is 'end', echoes it here.<br>
&nbsp; # Does not test for termination condition until top of loop.<br>
&nbsp; echo<br>
done &nbsp;<br>
exit 0<br>
A<i>&nbsp;while loop</i>&nbsp;may have multiple conditions. Only the final condition determines when the loop<br>terminates. This necessitates a slightly different loop syntax, however.<br>
<b>Example 11-16.<i>&nbsp;while</i></b><b>&nbsp;loop with multiple conditions</b><br>
#!/bin/bash<br>
var1=unset<br>
previous=$var1<br>
while echo &quot;previous-variable = $previous&quot;<br>
&nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; previous=$var1<br>
&nbsp; &nbsp; &nbsp; [ &quot;$var1&quot; != end ] # Keeps track of what $var1 was previously.<br>
&nbsp; &nbsp; &nbsp; # Four conditions on &quot;while&quot;, but only last one controls loop.<br>
&nbsp; &nbsp; &nbsp; # The *last* exit status is the one that counts.<br>
do<br>
echo &quot;Input variable #1 (end to exit) &quot;<br>
&nbsp; read var1<br>
&nbsp; echo &quot;variable #1 = $var1&quot;<br>
done &nbsp;<br>
# Try to figure out how this all works.<br>
# It's a wee bit tricky.<br>
exit 0<br>
As with a<i>&nbsp;for loop</i>, a<i>&nbsp;while loop</i>&nbsp;may employ C-style syntax by using the double-parentheses construct<br><a href="abs-guides.html#86">(see also Example 8-5).</a><br>
Chapter 11. Loops and Branches<br>
148<br>
<hr>
<A name=155></a>Advanced Bash-Scripting Guide<br>
<b>Example 11-17. C-style syntax in a<i>&nbsp;while</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# wh-loopc.sh: Count to 10 in a &quot;while&quot; loop.<br>
LIMIT=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 10 iterations.<br>
a=1<br>
while [ &quot;$a&quot; -le $LIMIT ]<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
&nbsp; let &quot;a+=1&quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No surprises, so far.<br>
echo; echo<br>
# +=================================================================+<br>
# Now, we'll repeat with C-like syntax.<br>
((a = 1)) &nbsp; &nbsp; &nbsp;# a=1<br>
# Double parentheses permit space when setting a variable, as in C.<br>
while (( a &lt;= LIMIT )) &nbsp; # &nbsp;Double parentheses,<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and no &quot;$&quot; preceding variables.<br>
&nbsp; echo -n &quot;$a &quot;<br>
&nbsp; ((a += 1)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # let &quot;a+=1&quot;<br>
&nbsp; # Yes, indeed.<br>
&nbsp; # Double parentheses permit incrementing a variable with C-like syntax.<br>
done<br>
echo<br>
# C and Java programmers can feel right at home in Bash.<br>
exit 0<br>
Inside its test brackets, a<i>&nbsp;while loop</i><a href="abs-guides.html#399">&nbsp;can call a function.</a><br>
t=0<br>
condition ()<br>
{<br>
&nbsp; ((t++))<br>
&nbsp; if [ $t -lt 5 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return 0 &nbsp;# true<br>
&nbsp; else<br>
&nbsp; &nbsp; return 1 &nbsp;# false<br>
&nbsp; fi<br>
}<br>
while condition<br>
# &nbsp; &nbsp; ^^^^^^^^^<br>
# &nbsp; &nbsp; Function call -- four loop iterations.<br>
do<br>
&nbsp; echo &quot;Still going: t = $t&quot;<br>
done<br>
# Still going: t = 1<br>
Chapter 11. Loops and Branches<br>
149<br>
<hr>
<A name=156></a><IMG src="abs-guide-156_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Still going: t = 2<br>
# Still going: t = 3<br>
# Still going: t = 4<br>
<a href="abs-guides.html#61">Similar to the if-test construct, a</a><i>&nbsp;while</i>&nbsp;loop can omit the test brackets.<br>
while condition<br>
do<br>
&nbsp; &nbsp;command(s) ...<br>
done<br>
<a href="abs-guides.html#190">By coupling the power of the read command with a</a><i>&nbsp;while loop</i><a href="abs-guides.html#195">, we get the handy while read construct,<br></a>useful for reading and parsing files.<br>
cat $filename | &nbsp; # Supply input from a file.<br>
while read line &nbsp; # As long as there is another line to read ...<br>
do<br>
&nbsp; ...<br>
done<br>
# =========== Snippet from &quot;sd.sh&quot; example script ========== #<br>
&nbsp; while read value &nbsp; # Read one data point at a time.<br>
&nbsp; do<br>
&nbsp; &nbsp; rt=$(echo &quot;scale=$SC; $rt + $value&quot; | bc)<br>
&nbsp; &nbsp; (( ct++ ))<br>
&nbsp; done<br>
&nbsp; am=$(echo &quot;scale=$SC; $rt / $ct&quot; | bc)<br>
&nbsp; echo $am; return $ct &nbsp; # This function &quot;returns&quot; TWO values!<br>
&nbsp; # &nbsp;Caution: This little trick will not work if $ct &gt; 255!<br>
&nbsp; # &nbsp;To handle a larger number of data points,<br>
&nbsp; #+ simply comment out the &quot;return $ct&quot; above.<br>
} &lt;&quot;$datafile&quot; &nbsp; # Feed in data file.<br>
A<i>&nbsp;while loop</i>&nbsp;may have its&nbsp;stdin<a href="abs-guides.html#380">&nbsp;redirected to a file by a &lt; at its end.</a><br>
A<i>&nbsp;while loop</i>&nbsp;may have its&nbsp;stdin<a href="abs-guides.html#195">&nbsp; supplied by a pipe.</a><br>
<b>until</b><br>
This construct tests for a condition at the top of a loop, and keeps looping as long as that condition is<br><i>false</i>&nbsp;(opposite of<i>&nbsp;while loop</i>).<br>
<b>until</b>&nbsp;[<i>&nbsp;condition-is-true</i>&nbsp;]<br>do<br><i>&nbsp;command(s)</i>...<br>done<br>
Note that an<i>&nbsp;until loop</i>&nbsp;tests for the terminating condition at the<i>&nbsp;top</i>&nbsp;of the loop, differing from a<br>similar construct in some programming languages.<br>
As is the case with<i>&nbsp;for loops</i>, placing the<i>&nbsp;do</i>&nbsp;on the same line as the condition test requires a<br>semicolon.<br>
Chapter 11. Loops and Branches<br>
150<br>
<hr>
<A name=157></a>Advanced Bash-Scripting Guide<br>
<b>until</b>&nbsp;[<i>&nbsp;condition-is-true</i>&nbsp;] ; do<br>
<b>Example 11-18.<i>&nbsp;until</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
END_CONDITION=end<br>
until [ &quot;$var1&quot; = &quot;$END_CONDITION&quot; ]<br>
# Tests condition here, at top of loop.<br>
do<br>
&nbsp; echo &quot;Input variable #1 &quot;<br>
&nbsp; echo &quot;($END_CONDITION to exit)&quot;<br>
&nbsp; read var1<br>
&nbsp; echo &quot;variable #1 = $var1&quot;<br>
&nbsp; echo<br>
done &nbsp;<br>
# ------------------------------------------- #<br>
# &nbsp;As with &quot;for&quot; and &quot;while&quot; loops,<br>
#+ an &quot;until&quot; loop permits C-like test constructs.<br>
LIMIT=10<br>
var=0<br>
until (( var &gt; LIMIT ))<br>
do &nbsp;# ^^ ^ &nbsp; &nbsp; ^ &nbsp; &nbsp; ^^ &nbsp; No brackets, no $ prefixing variables.<br>
&nbsp; echo -n &quot;$var &quot;<br>
&nbsp; (( var++ ))<br>
done &nbsp; &nbsp;# 0 1 2 3 4 5 6 7 8 9 10&nbsp;<br>
exit 0<br>
How to choose between a<i>&nbsp;for</i>&nbsp;loop or a<i>&nbsp;while</i>&nbsp;loop or<i>&nbsp;until</i>&nbsp;loop? In<b>&nbsp;C</b>, you would typically use a<i>&nbsp;for</i>&nbsp;loop<br>when the number of loop iterations is known beforehand. With<i>&nbsp;Bash</i>, however, the situation is fuzzier. The<br>Bash<i>&nbsp;for</i>&nbsp;loop is more loosely structured and more flexible than its equivalent in other languages. Therefore,<br>feel free to use whatever type of loop gets the job done in the simplest way.<br>
<b>11.2. Nested Loops</b><br>
A<i>&nbsp;nested loop</i>&nbsp;is a loop within a loop, an inner loop within the body of an outer one. How this works is that<br>the first pass of the outer loop triggers the inner loop, which executes to completion. Then the second pass of<br>the outer loop triggers the inner loop again. This repeats until the outer loop finishes. Of course, a<i>&nbsp;break<br></i>within either the inner or outer loop would interrupt this process.<br>
<b>Example 11-19. Nested Loop</b><br>
#!/bin/bash<br>
# nested-loop.sh: Nested &quot;for&quot; loops.<br>
outer=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set outer loop counter.<br>
Chapter 11. Loops and Branches<br>
151<br>
<hr>
<A name=158></a>Advanced Bash-Scripting Guide<br>
# Beginning of outer loop.<br>
for a in 1 2 3 4 5<br>
do<br>
&nbsp; echo &quot;Pass $outer in outer loop.&quot;<br>
&nbsp; echo &quot;---------------------&quot;<br>
&nbsp; inner=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reset inner loop counter.<br>
&nbsp; # ===============================================<br>
&nbsp; # Beginning of inner loop.<br>
&nbsp; for b in 1 2 3 4 5<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;Pass $inner in inner loop.&quot;<br>
&nbsp; &nbsp; let &quot;inner+=1&quot; &nbsp;# Increment inner loop counter.<br>
&nbsp; done<br>
&nbsp; # End of inner loop.<br>
&nbsp; # ===============================================<br>
&nbsp; let &quot;outer+=1&quot; &nbsp; &nbsp;# Increment outer loop counter.&nbsp;<br>
&nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Space between output blocks in pass of outer loop.<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
# End of outer loop.<br>
exit 0<br>
<a href="abs-guides.html#442">See Example 27-11 for an illustration of nested while loops, and Example 27-13 to see a while loop nested<br></a><a href="abs-guides.html#156">inside an until loop.</a><br>
<b>11.3. Loop Control</b><br>
<i>Tournez cent tours, tournez mille tours,</i><br>
<i>Tournez souvent et tournez toujours . . .</i><br>
<i>--Verlaine, &quot;Chevaux de bois&quot;</i><br>
<b>Commands affecting loop behavior</b><br>
<b>break</b>,<b>&nbsp;continue</b><br>
The<b>&nbsp;break</b>&nbsp;and<b>&nbsp;continue</b>&nbsp;loop control commands&nbsp;[52] correspond exactly to their counterparts in other<br>programming languages. The<b>&nbsp;break</b>&nbsp;command terminates the loop (<i>breaks</i>&nbsp;out of it), while<b>&nbsp;continue<br></b><a href="abs-guides.html#885">causes a jump to the next iteration of the loop, skipping all the remaining commands in that particular<br></a>loop cycle.<br>
<b>Example 11-20. Effects of<i>&nbsp;break</i></b><b>&nbsp;and continue in a loop</b><br>
#!/bin/bash<br>
LIMIT=19 &nbsp;# Upper limit<br>
echo<br>
echo &quot;Printing Numbers 1 through 20 (but not 3 and 11).&quot;<br>
a=0<br>
while [ $a -le &quot;$LIMIT&quot; ]<br>
Chapter 11. Loops and Branches<br>
152<br>
<hr>
<A name=159></a>Advanced Bash-Scripting Guide<br>
do<br>
&nbsp;a=$(($a+1))<br>
&nbsp;if [ &quot;$a&quot; -eq 3 ] || [ &quot;$a&quot; -eq 11 ] &nbsp;# Excludes 3 and 11.<br>
&nbsp;then<br>
&nbsp; &nbsp;continue &nbsp; &nbsp; &nbsp;# Skip rest of this particular loop iteration.<br>
&nbsp;fi<br>
&nbsp;echo -n &quot;$a &quot; &nbsp; # This will not execute for 3 and 11.<br>
done&nbsp;<br>
# Exercise:<br>
# Why does the loop print up to 20?<br>
echo; echo<br>
echo Printing Numbers 1 through 20, but something happens after 2.<br>
##################################################################<br>
# Same loop, but substituting 'break' for 'continue'.<br>
a=0<br>
while [ &quot;$a&quot; -le &quot;$LIMIT&quot; ]<br>
do<br>
&nbsp;a=$(($a+1))<br>
&nbsp;if [ &quot;$a&quot; -gt 2 ]<br>
&nbsp;then<br>
&nbsp; &nbsp;break &nbsp;# Skip entire rest of loop.<br>
&nbsp;fi<br>
&nbsp;echo -n &quot;$a &quot;<br>
done<br>
echo; echo; echo<br>
exit 0<br>
The<b>&nbsp;break</b>&nbsp;command may optionally take a parameter. A plain<b>&nbsp;break</b>&nbsp;terminates only the innermost<br>loop in which it is embedded, but a<b>&nbsp;break N</b>&nbsp;breaks out of&nbsp;<i>N</i>&nbsp;levels of loop.<br>
<b>Example 11-21. Breaking out of multiple loop levels</b><br>
#!/bin/bash<br>
# break-levels.sh: Breaking out of loops.<br>
# &quot;break N&quot; breaks out of N level loops.<br>
for outerloop in 1 2 3 4 5<br>
do<br>
&nbsp; echo -n &quot;Group $outerloop: &nbsp; &quot;<br>
&nbsp; # --------------------------------------------------------<br>
&nbsp; for innerloop in 1 2 3 4 5<br>
&nbsp; do<br>
&nbsp; &nbsp; echo -n &quot;$innerloop &quot;<br>
Chapter 11. Loops and Branches<br>
153<br>
<hr>
<A name=160></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; if [ &quot;$innerloop&quot; -eq 3 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; break &nbsp;# Try &nbsp; break 2 &nbsp; to see what happens.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (&quot;Breaks&quot; out of both inner and outer loops.)<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; # --------------------------------------------------------<br>
&nbsp; echo<br>
done &nbsp;<br>
echo<br>
exit 0<br>
The<b>&nbsp;continue</b>&nbsp;command, similar to<b>&nbsp;break</b>, optionally takes a parameter. A plain<b>&nbsp;continue</b>&nbsp;cuts short<br>the current iteration within its loop and begins the next. A<b>&nbsp;continue N</b>&nbsp;terminates all remaining<br>iterations at its loop level and continues with the next iteration at the loop,&nbsp;N&nbsp;levels above.<br>
<b>Example 11-22. Continuing at a higher loop level</b><br>
#!/bin/bash<br>
# The &quot;continue N&quot; command, continuing at the Nth level loop.<br>
for outer in I II III IV V &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # outer loop<br>
do<br>
&nbsp; echo; echo -n &quot;Group $outer: &quot;<br>
&nbsp; # --------------------------------------------------------------------<br>
&nbsp; for inner in 1 2 3 4 5 6 7 8 9 10 &nbsp;# inner loop<br>
&nbsp; do<br>
&nbsp; &nbsp; if [[ &quot;$inner&quot; -eq 7 &amp;&amp; &quot;$outer&quot; = &quot;III&quot; ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; continue 2 &nbsp;# Continue at loop on 2nd level, that is &quot;outer loop&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Replace above line with a simple &quot;continue&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # to see normal loop behavior.<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; &nbsp; echo -n &quot;$inner &quot; &nbsp;# 7 8 9 10 will not echo on &quot;Group III.&quot;<br>
&nbsp; done &nbsp;<br>
&nbsp; # --------------------------------------------------------------------<br>
done<br>
echo; echo<br>
# Exercise:<br>
# Come up with a meaningful use for &quot;continue N&quot; in a script.<br>
exit 0<br>
<b>Example 11-23. Using<i>&nbsp;continue N</i></b><b>&nbsp;in an actual task</b><br>
# Albert Reiner gives an example of how to use &quot;continue N&quot;:<br>
# ---------------------------------------------------------<br>
# &nbsp;Suppose I have a large number of jobs that need to be run, with<br>
#+ any data that is to be treated in files of a given name pattern<br>
Chapter 11. Loops and Branches<br>
154<br>
<hr>
<A name=161></a><IMG src="abs-guide-161_1.png"><br>
Advanced Bash-Scripting Guide<br>
#+ in a directory. There are several machines that access<br>
#+ this directory, and I want to distribute the work over these<br>
#+ different boxen.<br>
# &nbsp;Then I usually nohup something like the following on every box:<br>
while true<br>
do<br>
&nbsp; for n in .iso.*<br>
&nbsp; do<br>
&nbsp; &nbsp; [ &quot;$n&quot; = &quot;.iso.opts&quot; ] &amp;&amp; continue<br>
&nbsp; &nbsp; beta=${n#.iso.}<br>
&nbsp; &nbsp; [ -r .Iso.$beta ] &amp;&amp; continue<br>
&nbsp; &nbsp; [ -r .lock.$beta ] &amp;&amp; sleep 10 &amp;&amp; continue<br>
&nbsp; &nbsp; lockfile -r0 .lock.$beta || continue<br>
&nbsp; &nbsp; echo -n &quot;$beta: &quot; `date`<br>
&nbsp; &nbsp; run-isotherm $beta<br>
&nbsp; &nbsp; date<br>
&nbsp; &nbsp; ls -alF .Iso.$beta<br>
&nbsp; &nbsp; [ -r .Iso.$beta ] &amp;&amp; rm -f .lock.$beta<br>
&nbsp; &nbsp; continue 2<br>
&nbsp; done<br>
&nbsp; break<br>
done<br>
exit 0<br>
# &nbsp;The details, in particular the sleep N, are particular to my<br>
#+ application, but the general pattern is:<br>
while true<br>
do<br>
&nbsp; for job in {pattern}<br>
&nbsp; do<br>
&nbsp; &nbsp; {job already done or running} &amp;&amp; continue<br>
&nbsp; &nbsp; {mark job as running, do job, mark job as done}<br>
&nbsp; &nbsp; continue 2<br>
&nbsp; done<br>
&nbsp; break &nbsp; &nbsp; &nbsp; &nbsp;# Or something like `sleep 600' to avoid termination.<br>
done<br>
# &nbsp;This way the script will stop only when there are no more jobs to do<br>
#+ (including jobs that were added during runtime). Through the use<br>
#+ of appropriate lockfiles it can be run on several machines<br>
#+ concurrently without duplication of calculations [which run a couple<br>
#+ of hours in my case, so I really want to avoid this]. Also, as search<br>
#+ always starts again from the beginning, one can encode priorities in<br>
#+ the file names. Of course, one could also do this without `continue 2',<br>
#+ but then one would have to actually check whether or not some job<br>
#+ was done (so that we should immediately look for the next job) or not<br>
#+ (in which case we terminate or sleep for a long time before checking<br>
#+ for a new job).<br>
The<b>&nbsp;continue N</b>&nbsp;construct is difficult to understand and tricky to use in any<br>meaningful context. It is probably best avoided.<br>
Chapter 11. Loops and Branches<br>
155<br>
<hr>
<A name=162></a><IMG src="abs-guide-162_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>11.4. Testing and Branching</b><br>
The<b>&nbsp;case</b>&nbsp;and<b>&nbsp;select</b>&nbsp;constructs are technically not loops, since they do not iterate the execution of a code<br>block. Like loops, however, they direct program flow according to conditions at the top or bottom of the<br>block.<br>
<b>Controlling program flow in a code block</b><br>
<b>case (in) / esac</b><br>
The<b>&nbsp;case</b>&nbsp;construct is the shell scripting analog to&nbsp;<i>switch</i>&nbsp;in<b>&nbsp;C/C++</b>. It permits branching to one of a<br>number of code blocks, depending on condition tests. It serves as a kind of shorthand for multiple<br>if/then/else statements and is an appropriate tool for creating menus.<br>
<b>case</b>&nbsp;&quot;$<i>variable</i>&quot; in<br>
&nbsp;&quot;$<i>condition1</i>&quot; )<br>
<i>command</i>...<br>
&nbsp;;;<br>
&nbsp;&quot;$<i>condition2</i>&quot; )<br>
<i>command</i>...<br>
&nbsp;;;<br>
<b>esac</b><br>
Quoting the variables is not mandatory, since word splitting does not take<br>
◊&nbsp;<br>
place.<br>Each test line ends with a right paren<br>
◊&nbsp;<br>
<b>&nbsp;)</b>.&nbsp;[53]<br>
Each condition block ends with a<br>
◊&nbsp;<br>
<i>&nbsp;double</i>&nbsp;semicolon ;;.<br>
If a condition tests<br>
◊&nbsp;<br>
<i>&nbsp;true</i>, then the associated commands execute and the<b>&nbsp;case</b><br>
block terminates.<br>The entire<br>
◊&nbsp;<br>
<b>&nbsp;case</b>&nbsp;block ends with an<b>&nbsp;esac</b>&nbsp;(<i>case</i>&nbsp;spelled backwards).<br>
<b>Example 11-24. Using<i>&nbsp;case</i></b><br>
#!/bin/bash<br>
# Testing ranges of characters.<br>
echo; echo &quot;Hit a key, then hit return.&quot;<br>
read Keypress<br>
case &quot;$Keypress&quot; in<br>
&nbsp; [[:lower:]] &nbsp; ) echo &quot;Lowercase letter&quot;;;<br>
&nbsp; [[:upper:]] &nbsp; ) echo &quot;Uppercase letter&quot;;;<br>
&nbsp; [0-9] &nbsp; &nbsp; &nbsp; &nbsp; ) echo &quot;Digit&quot;;;<br>
&nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) echo &quot;Punctuation, whitespace, or other&quot;;;<br>
esac &nbsp; &nbsp; &nbsp;# &nbsp;Allows ranges of characters in [square brackets],<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ or POSIX ranges in [[double square brackets.<br>
# &nbsp;In the first version of this example,<br>
#+ the tests for lowercase and uppercase characters were<br>
Chapter 11. Loops and Branches<br>
156<br>
<hr>
<A name=163></a>Advanced Bash-Scripting Guide<br>
#+ [a-z] and [A-Z].<br>
# &nbsp;This no longer works in certain locales and/or Linux distros.<br>
# &nbsp;POSIX is more portable.<br>
# &nbsp;Thanks to Frank Wang for pointing this out.<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;As the script stands, it accepts a single keystroke, then terminates.<br>
# &nbsp;Change the script so it accepts repeated input,<br>
#+ reports on each keystroke, and terminates only when &quot;X&quot; is hit.<br>
# &nbsp;Hint: enclose everything in a &quot;while&quot; loop.<br>
exit 0<br>
<b>Example 11-25. Creating menus using<i>&nbsp;case</i></b><br>
#!/bin/bash<br>
# Crude address database<br>
clear # Clear the screen.<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Contact List&quot;<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;------- ----&quot;<br>
echo &quot;Choose one of the following persons:&quot;&nbsp;<br>
echo<br>
echo &quot;[E]vans, Roland&quot;<br>
echo &quot;[J]ones, Mildred&quot;<br>
echo &quot;[S]mith, Julie&quot;<br>
echo &quot;[Z]ane, Morris&quot;<br>
echo<br>
read person<br>
case &quot;$person&quot; in<br>
# Note variable is quoted.<br>
&nbsp; &quot;E&quot; | &quot;e&quot; )<br>
&nbsp; # Accept upper or lowercase input.<br>
&nbsp; echo<br>
&nbsp; echo &quot;Roland Evans&quot;<br>
&nbsp; echo &quot;4321 Flash Dr.&quot;<br>
&nbsp; echo &quot;Hardscrabble, CO 80753&quot;<br>
&nbsp; echo &quot;(303) 734-9874&quot;<br>
&nbsp; echo &quot;(303) 734-9892 fax&quot;<br>
&nbsp; echo &quot;revans@zzy.net&quot;<br>
&nbsp; echo &quot;Business partner &amp; old friend&quot;<br>
&nbsp; ;;<br>
# Note double semicolon to terminate each option.<br>
&nbsp; &quot;J&quot; | &quot;j&quot; )<br>
&nbsp; echo<br>
&nbsp; echo &quot;Mildred Jones&quot;<br>
&nbsp; echo &quot;249 E. 7th St., Apt. 19&quot;<br>
&nbsp; echo &quot;New York, NY 10009&quot;<br>
&nbsp; echo &quot;(212) 533-2814&quot;<br>
&nbsp; echo &quot;(212) 533-9972 fax&quot;<br>
&nbsp; echo &quot;milliej@loisaida.com&quot;<br>
&nbsp; echo &quot;Ex-girlfriend&quot;<br>
&nbsp; echo &quot;Birthday: Feb. 11&quot;<br>
&nbsp; ;;<br>
Chapter 11. Loops and Branches<br>
157<br>
<hr>
<A name=164></a>Advanced Bash-Scripting Guide<br>
# Add info for Smith &amp; Zane later.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * )<br>
&nbsp; &nbsp;# Default option. &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp;# Empty input (hitting RETURN) fits here, too.<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;echo &quot;Not yet in database.&quot;<br>
&nbsp; ;;<br>
esac<br>
echo<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Change the script so it accepts multiple inputs,<br>
#+ instead of terminating after displaying just one address.<br>
exit 0<br>
An exceptionally clever use of<b>&nbsp;case</b>&nbsp;involves testing for command-line parameters.<br>
#! /bin/bash<br>
case &quot;$1&quot; in<br>
&nbsp; &quot;&quot;) echo &quot;Usage: ${0##*/} &lt;filename&gt;&quot;; exit $E_PARAM;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No command-line parameters,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # or first parameter empty.<br>
# Note that ${0##*/} is ${var##pattern} param substitution.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Net result is $0.<br>
&nbsp; -*) FILENAME=./$1;; &nbsp; # &nbsp;If filename passed as argument ($1)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ starts with a dash,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ replace it with ./$1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ so further commands don't interpret it<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ as an option.<br>
&nbsp; * ) FILENAME=$1;; &nbsp; &nbsp; # Otherwise, $1.<br>
esac<br>
Here is an more straightforward example of command-line parameter handling:<br>
#! /bin/bash<br>
while [ $# -gt 0 ]; do &nbsp; &nbsp;# Until you run out of parameters . . .<br>
&nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; -d|--debug)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;-d&quot; or &quot;--debug&quot; parameter?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEBUG=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; -c|--conf)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONFFILE=&quot;$2&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ! -f $CONFFILE ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Error: Supplied file doesn't exist!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit $E_CONFFILE &nbsp; &nbsp; # File not found error.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; esac<br>
Chapter 11. Loops and Branches<br>
158<br>
<hr>
<A name=165></a>Advanced Bash-Scripting Guide<br>
&nbsp; shift &nbsp; &nbsp; &nbsp; # Check next set of parameters.<br>
done<br>
# &nbsp;From Stefano Falsetto's &quot;Log2Rot&quot; script,<br>
#+ part of his &quot;rottlog&quot; package.<br>
# &nbsp;Used with permission.<br>
<b>Example 11-26. Using<i>&nbsp;command substitution</i></b><b>&nbsp;to generate the<i>&nbsp;case</i></b><b>&nbsp;variable</b><br>
#!/bin/bash<br>
# case-cmd.sh: Using command substitution to generate a &quot;case&quot; variable.<br>
case $( arch ) in &nbsp; # $( arch ) returns machine architecture.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Equivalent to 'uname -m' ...<br>
&nbsp; i386 ) echo &quot;80386-based machine&quot;;;<br>
&nbsp; i486 ) echo &quot;80486-based machine&quot;;;<br>
&nbsp; i586 ) echo &quot;Pentium-based machine&quot;;;<br>
&nbsp; i686 ) echo &quot;Pentium2+-based machine&quot;;;<br>
&nbsp; * &nbsp; &nbsp;) echo &quot;Other type of machine&quot;;;<br>
esac<br>
exit 0<br>
A<b>&nbsp;case</b><a href="abs-guides.html#358">&nbsp;construct can filter strings for globbing patterns.</a><br>
<b>Example 11-27. Simple string matching</b><br>
#!/bin/bash<br>
# match-string.sh: Simple string matching.<br>
match_string ()<br>
{ # Exact string match.<br>
&nbsp; MATCH=0<br>
&nbsp; E_NOMATCH=90<br>
&nbsp; PARAMS=2 &nbsp; &nbsp; # Function requires 2 arguments.<br>
&nbsp; E_BAD_PARAMS=91<br>
&nbsp; [ $# -eq $PARAMS ] || return $E_BAD_PARAMS<br>
&nbsp; case &quot;$1&quot; in<br>
&nbsp; &quot;$2&quot;) return $MATCH;;<br>
&nbsp; * &nbsp; ) return $E_NOMATCH;;<br>
&nbsp; esac<br>
} &nbsp;<br>
a=one<br>
b=two<br>
c=three<br>
d=two<br>
match_string $a &nbsp; &nbsp; # wrong number of parameters<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 91<br>
match_string $a $b &nbsp;# no match<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 90<br>
Chapter 11. Loops and Branches<br>
159<br>
<hr>
<A name=166></a>Advanced Bash-Scripting Guide<br>
match_string $b $d &nbsp;# match<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
<b>Example 11-28. Checking for alphabetic input</b><br>
#!/bin/bash<br>
# isalpha.sh: Using a &quot;case&quot; structure to filter a string.<br>
SUCCESS=0<br>
FAILURE=-1<br>
isalpha () &nbsp;# Tests whether *first character* of input string is alphabetic.<br>
{<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No argument passed?<br>
then<br>
&nbsp; return $FAILURE<br>
fi<br>
case &quot;$1&quot; in<br>
&nbsp; [a-zA-Z]*) return $SUCCESS;; &nbsp;# Begins with a letter?<br>
&nbsp; * &nbsp; &nbsp; &nbsp; &nbsp;) return $FAILURE;;<br>
esac<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Compare this with &quot;isalpha ()&quot; function in C.<br>
isalpha2 () &nbsp; # Tests whether *entire string* is alphabetic.<br>
{<br>
&nbsp; [ $# -eq 1 ] || return $FAILURE<br>
&nbsp; case $1 in<br>
&nbsp; *[!a-zA-Z]*|&quot;&quot;) return $FAILURE;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*) return $SUCCESS;;<br>
&nbsp; esac<br>
}<br>
isdigit () &nbsp; &nbsp;# Tests whether *entire string* is numerical.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # In other words, tests for integer variable.<br>
&nbsp; [ $# -eq 1 ] || return $FAILURE<br>
&nbsp; case $1 in<br>
&nbsp; &nbsp; *[!0-9]*|&quot;&quot;) return $FAILURE;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) return $SUCCESS;;<br>
&nbsp; esac<br>
}<br>
check_var () &nbsp;# Front-end to isalpha ().<br>
{<br>
if isalpha &quot;$@&quot;<br>
then<br>
&nbsp; echo &quot;\&quot;$*\&quot; begins with an alpha character.&quot;<br>
&nbsp; if isalpha2 &quot;$@&quot;<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp;# No point in testing if first char is non-alpha.<br>
&nbsp; &nbsp; echo &quot;\&quot;$*\&quot; contains only alpha characters.&quot;<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;\&quot;$*\&quot; contains at least one non-alpha character.&quot;<br>
Chapter 11. Loops and Branches<br>
160<br>
<hr>
<A name=167></a>Advanced Bash-Scripting Guide<br>
&nbsp; fi &nbsp;<br>
else<br>
&nbsp; echo &quot;\&quot;$*\&quot; begins with a non-alpha character.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Also &quot;non-alpha&quot; if no argument passed.<br>
fi<br>
echo<br>
}<br>
digit_check () &nbsp;# Front-end to isdigit ().<br>
{<br>
if isdigit &quot;$@&quot;<br>
then<br>
&nbsp; echo &quot;\&quot;$*\&quot; contains only digits [0 - 9].&quot;<br>
else<br>
&nbsp; echo &quot;\&quot;$*\&quot; has at least one non-digit character.&quot;<br>
fi<br>
echo<br>
}<br>
a=23skidoo<br>
b=H3llo<br>
c=-What?<br>
d=What?<br>
e=`echo $b` &nbsp; # Command substitution.<br>
f=AbcDef<br>
g=27234<br>
h=27a34<br>
i=27.34<br>
check_var $a<br>
check_var $b<br>
check_var $c<br>
check_var $d<br>
check_var $e<br>
check_var $f<br>
check_var &nbsp; &nbsp; # No argument passed, so what happens?<br>
#<br>
digit_check $g<br>
digit_check $h<br>
digit_check $i<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp;# Script improved by S.C.<br>
# Exercise:<br>
# --------<br>
# &nbsp;Write an 'isfloat ()' function that tests for floating point numbers.<br>
# &nbsp;Hint: The function duplicates 'isdigit ()',<br>
#+ but adds a test for a mandatory decimal point.<br>
<b>select</b><br>
The<b>&nbsp;select</b>&nbsp;construct, adopted from the Korn Shell, is yet another tool for building menus.<br>
<b>select&nbsp;</b><i>variable</i>&nbsp;[in&nbsp;<i>list</i>]<br>do<br>
<i>command</i>...<br>
&nbsp;break<br>
Chapter 11. Loops and Branches<br>
161<br>
<hr>
<A name=168></a>Advanced Bash-Scripting Guide<br>
done<br>
This prompts the user to enter one of the choices presented in the variable list. Note that<b>&nbsp;select</b>&nbsp;uses<br>the&nbsp;$PS3&nbsp;prompt (#?&nbsp;) by default, but this may be changed.<br>
<b>Example 11-29. Creating menus using<i>&nbsp;select</i></b><br>
#!/bin/bash<br>
PS3='Choose your favorite vegetable: ' # Sets the prompt string.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Otherwise it defaults to #? .<br>
echo<br>
select vegetable in &quot;beans&quot; &quot;carrots&quot; &quot;potatoes&quot; &quot;onions&quot; &quot;rutabagas&quot;<br>
do<br>
&nbsp; echo<br>
&nbsp; echo &quot;Your favorite veggie is $vegetable.&quot;<br>
&nbsp; echo &quot;Yuck!&quot;<br>
&nbsp; echo<br>
&nbsp; break &nbsp;# What happens if there is no 'break' here?<br>
done<br>
exit<br>
# Exercise:<br>
# --------<br>
# &nbsp;Fix this script to accept user input not specified in<br>
#+ the &quot;select&quot; statement.<br>
# &nbsp;For example, if the user inputs &quot;peas,&quot;<br>
#+ the script would respond &quot;Sorry. That is not on the menu.&quot;<br>
If&nbsp;<b>in&nbsp;<i>list</i></b>&nbsp;is omitted, then<b>&nbsp;select</b>&nbsp;uses the list of command line arguments ($@) passed to the script<br>or the function containing the<b>&nbsp;select</b>&nbsp;construct.<br>
Compare this to the behavior of a<br>
<b>for&nbsp;</b><i>variable</i>&nbsp;[in&nbsp;<i>list</i>]<br>
construct with the&nbsp;<b>in&nbsp;<i>list</i></b>&nbsp;omitted.<br>
<b>Example 11-30. Creating menus using<i>&nbsp;select</i></b><b>&nbsp;in a function</b><br>
#!/bin/bash<br>
PS3='Choose your favorite vegetable: '<br>
echo<br>
choice_of()<br>
{<br>
select vegetable<br>
# [in list] omitted, so 'select' uses arguments passed to function.<br>
do<br>
&nbsp; echo<br>
&nbsp; echo &quot;Your favorite veggie is $vegetable.&quot;<br>
Chapter 11. Loops and Branches<br>
162<br>
<hr>
<A name=169></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Yuck!&quot;<br>
&nbsp; echo<br>
&nbsp; break<br>
done<br>
}<br>
choice_of beans rice carrots radishes tomatoes spinach<br>
# &nbsp; &nbsp; &nbsp; &nbsp; $1 &nbsp; &nbsp;$2 &nbsp; $3 &nbsp; &nbsp; &nbsp;$4 &nbsp; &nbsp; &nbsp; $5 &nbsp; &nbsp; &nbsp; $6<br>
# &nbsp; &nbsp; &nbsp; &nbsp; passed to choice_of() function<br>
exit 0<br>
<a href="abs-guides.html#542">See also Example 37-3.</a><br>
Chapter 11. Loops and Branches<br>
163<br>
<hr>
<A name=170></a><IMG src="abs-guide-170_1.png"><br>
<IMG src="abs-guide-170_2.png"><br>
<b>Chapter 12. Command Substitution</b><br>
<b>Command substitution</b>&nbsp;reassigns the output of a command&nbsp;[54] or even multiple commands; it literally plugs<br>the command output into another context.&nbsp;[55]<br>
The classic form of command substitution uses<i>&nbsp;backquotes</i>&nbsp;(`...`). Commands within backquotes (backticks)<br>generate command-line text.<br>
script_name=`basename $0`<br>
echo &quot;The name of this script is $script_name.&quot;<br>
<b>The output of commands can be used as arguments to another command, to set a variable, and even for<br><a href="abs-guides.html#144">generating the argument list in a for loop.</a></b><br>
rm `cat filename` &nbsp; #&nbsp;&quot;filename&quot;&nbsp;contains a list of files to delete.<br>
#<br>
# S. C. points out that &quot;arg list too long&quot; error might result.<br>
# Better is &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xargs rm -- &lt; filename&nbsp;<br>
# ( -- covers those cases where&nbsp;&quot;filename&quot;&nbsp;begins with a&nbsp;&quot;-&quot;&nbsp;)<br>
textfile_listing=`ls *.txt`<br>
# Variable contains names of all *.txt files in current working directory.<br>
echo $textfile_listing<br>
textfile_listing2=$(ls *.txt) &nbsp; # The alternative form of command substitution.<br>
echo $textfile_listing2<br>
# Same result.<br>
# A possible problem with putting a list of files into a single string<br>
# is that a newline may creep in.<br>
#<br>
# A safer way to assign a list of files to a parameter is with an array.<br>
# &nbsp; &nbsp; &nbsp;shopt -s nullglob &nbsp; &nbsp;# If no match, filename expands to nothing.<br>
# &nbsp; &nbsp; &nbsp;textfile_listing=( *.txt )<br>
#<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#387">Command substitution invokes a subshell.</a><br>
<a href="abs-guides.html#883">Command substitution may result in word splitting.</a><br>
COMMAND `echo a b` &nbsp; &nbsp; # 2 args: a and b<br>
COMMAND &quot;`echo a b`&quot; &nbsp; # 1 arg: &quot;a b&quot;<br>
COMMAND `echo` &nbsp; &nbsp; &nbsp; &nbsp; # no arg<br>
COMMAND &quot;`echo`&quot; &nbsp; &nbsp; &nbsp; # one empty arg<br>
# Thanks, S.C.<br>
Even when there is no word splitting, command substitution can remove trailing newlines.<br>
# cd &quot;`pwd`&quot; &nbsp;# This should always work.<br>
# However...<br>
Chapter 12. Command Substitution<br>
164<br>
<hr>
<A name=171></a><IMG src="abs-guide-171_1.png"><br>
Advanced Bash-Scripting Guide<br>
mkdir 'dir with trailing newline<br>
'<br>
cd 'dir with trailing newline<br>
'<br>
cd &quot;`pwd`&quot; &nbsp;# Error message:<br>
# bash: cd: /tmp/file with trailing newline: No such file or directory<br>
cd &quot;$PWD&quot; &nbsp; # Works fine.<br>
old_tty_setting=$(stty -g) &nbsp; # Save old terminal setting.<br>
echo &quot;Hit a key &quot;<br>
stty -icanon -echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Disable &quot;canonical&quot; mode for terminal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Also, disable *local* echo.<br>
key=$(dd bs=1 count=1 2&gt; /dev/null) &nbsp; # Using 'dd' to get a keypress.<br>
stty &quot;$old_tty_setting&quot; &nbsp; &nbsp; &nbsp;# Restore old setting.&nbsp;<br>
echo &quot;You hit ${#key} key.&quot; &nbsp;# ${#variable} = number of characters in $variable<br>
#<br>
# Hit any key except RETURN, and the output is &quot;You hit 1 key.&quot;<br>
# Hit RETURN, and it's &quot;You hit 0 key.&quot;<br>
# The newline gets eaten in the command substitution.<br>
#Code snippet by Stéphane Chazelas.<br>
Using<b>&nbsp;echo</b>&nbsp;to output an<i>&nbsp;unquoted</i>&nbsp;variable set with command substitution removes trailing newlines<br>characters from the output of the reassigned command(s). This can cause unpleasant surprises.<br>
dir_listing=`ls -l`<br>
echo $dir_listing &nbsp; &nbsp; # unquoted<br>
# Expecting a nicely ordered directory listing.<br>
# However, what you get is:<br>
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo<br>
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh<br>
# The newlines disappeared.<br>
echo &quot;$dir_listing&quot; &nbsp; # quoted<br>
# -rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp; 30 May 13 17:15 1.txt<br>
# -rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp; 51 May 15 20:57 t2.sh<br>
# -rwxr-xr-x &nbsp; &nbsp;1 bozo &nbsp; &nbsp; &nbsp;217 Mar &nbsp;5 21:13 wi.sh<br>
<a href="abs-guides.html#374">Command substitution even permits setting a variable to the contents of a file, using either redirection or the<br></a><a href="abs-guides.html#221">cat command.</a><br>
variable1=`&lt;file1` &nbsp; &nbsp; &nbsp;# &nbsp;Set &quot;variable1&quot; to contents of &quot;file1&quot;.<br>
variable2=`cat file2` &nbsp; # &nbsp;Set &quot;variable2&quot; to contents of &quot;file2&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This, however, forks a new process,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ so the line of code executes slower than the above version.<br>
# &nbsp;Note that the variables may contain embedded whitespace,<br>
#+ or even (horrors), control characters.<br>
Chapter 12. Command Substitution<br>
165<br>
<hr>
<A name=172></a><IMG src="abs-guide-172_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp;It is not necessary to explicitly assign a variable.<br>
echo &quot;` &lt;$0`&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Echoes the script itself to stdout.<br>
# &nbsp;Excerpts from system file, /etc/rc.d/rc.sysinit<br>
#+ (on a Red Hat Linux installation)<br>
if [ -f /fsckoptions ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; fsckoptions=`cat /fsckoptions`<br>
...<br>
fi<br>
#<br>
#<br>
if [ -e &quot;/proc/ide/${disk[$device]}/media&quot; ] ; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hdmedia=`cat /proc/ide/${disk[$device]}/media`<br>
...<br>
fi<br>
#<br>
#<br>
if [ ! -n &quot;`uname -r | grep -- &quot;-&quot;`&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;ktag=&quot;`cat /proc/version`&quot;<br>
...<br>
fi<br>
#<br>
#<br>
if [ $usb = &quot;1&quot; ]; then<br>
&nbsp; &nbsp; sleep 5<br>
&nbsp; &nbsp; mouseoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=02&quot;`<br>
&nbsp; &nbsp; kbdoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=01&quot;`<br>
...<br>
fi<br>
Do not set a variable to the contents of a<i>&nbsp;long</i>&nbsp;text file unless you have a very good reason for doing so.<br>Do not set a variable to the contents of a<i>&nbsp;binary</i>&nbsp;file, even as a joke.<br>
<b>Example 12-1. Stupid script tricks</b><br>
#!/bin/bash<br>
# stupid-script-tricks.sh: Don't try this at home, folks.<br>
# From &quot;Stupid Script Tricks,&quot; Volume I.<br>
dangerous_variable=`cat /boot/vmlinuz` &nbsp; # The compressed Linux kernel itself.<br>
echo &quot;string-length of \$dangerous_variable = ${#dangerous_variable}&quot;<br>
# string-length of $dangerous_variable = 794151<br>
# (Does not give same count as 'wc -c /boot/vmlinuz'.)<br>
# echo &quot;$dangerous_variable&quot;<br>
# Don't try this! It would hang the script.<br>
# &nbsp;The document author is aware of no useful applications for<br>
#+ setting a variable to the contents of a binary file.<br>
exit 0<br>
Chapter 12. Command Substitution<br>
166<br>
<hr>
<A name=173></a>Advanced Bash-Scripting Guide<br>
Notice that a<i>&nbsp;buffer overrun</i>&nbsp;does not occur. This is one instance where an interpreted language, such as<br>Bash, provides more protection from programmer mistakes than a compiled language.<br>
<a href="abs-guides.html#144">Command substitution permits setting a variable to the output of a loop. The key to this is grabbing the output<br></a><a href="abs-guides.html#187">of an echo command within the loop.</a><br>
<b>Example 12-2. Generating a variable from a loop</b><br>
#!/bin/bash<br>
# csubloop.sh: Setting a variable to the output of a loop.<br>
variable1=`for i in 1 2 3 4 5<br>
do<br>
&nbsp; echo -n &quot;$i&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;The 'echo' command is critical<br>
done` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to command substitution here.<br>
echo &quot;variable1 = $variable1&quot; &nbsp;# variable1 = 12345<br>
i=0<br>
variable2=`while [ &quot;$i&quot; -lt 10 ]<br>
do<br>
&nbsp; echo -n &quot;$i&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Again, the necessary 'echo'.<br>
&nbsp; let &quot;i += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Increment.<br>
done`<br>
echo &quot;variable2 = $variable2&quot; &nbsp;# variable2 = 0123456789<br>
# &nbsp;Demonstrates that it's possible to embed a loop<br>
#+ within a variable declaration.<br>
exit 0<br>
Command substitution makes it possible to extend the toolset available to Bash. It is simply a matter of<br>writing a program or script that outputs to&nbsp;stdout&nbsp;(like a well-behaved UNIX tool should) and assigning<br>that output to a variable.<br>
#include &lt;stdio.h&gt;<br>
/* &nbsp;&quot;Hello, world.&quot; C program &nbsp;*/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
int main()<br>
{<br>
&nbsp; printf( &quot;Hello, world.\n&quot; );<br>
&nbsp; return (0);<br>
}<br>
bash$&nbsp;<b>gcc -o hello hello.c</b><br>
#!/bin/bash<br>
# hello.sh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
greeting=`./hello`<br>
echo $greeting<br>
Chapter 12. Command Substitution<br>
167<br>
<hr>
<A name=174></a><IMG src="abs-guide-174_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>sh hello.sh<br></b>Hello, world.<br>
The<b>&nbsp;$(...)</b>&nbsp;form has superseded backticks for command substitution.<br>
output=$(sed -n /&quot;$1&quot;/p $file) &nbsp; # From &quot;grp.sh&quot; &nbsp; &nbsp; &nbsp; &nbsp;example.<br>
# Setting a variable to the contents of a text file.<br>
File_contents1=$(cat $file1) &nbsp; &nbsp; &nbsp;<br>
File_contents2=$(&lt;$file2) &nbsp; &nbsp; &nbsp; &nbsp;# Bash permits this also.<br>
The<b>&nbsp;$(...)</b>&nbsp;form of command substitution treats a double backslash in a different way than<b>&nbsp;`...`</b>.<br>
bash$&nbsp;<b>echo `echo \\`</b><br>
bash$&nbsp;<b>echo $(echo \\)<br></b>\<br>
The<b>&nbsp;$(...)</b>&nbsp;form of command substitution permits nesting.&nbsp;[56]<br>
word_count=$( wc -w $(echo * | awk '{print $8}') )<br>
Or, for something a bit more elaborate . . .<br>
<b>Example 12-3. Finding anagrams</b><br>
#!/bin/bash<br>
# agram2.sh<br>
# Example of nested command substitution.<br>
# &nbsp;Uses &quot;anagram&quot; utility<br>
#+ that is part of the author's &quot;yawl&quot; word list package.<br>
# &nbsp;http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz<br>
# &nbsp;http://bash.webofcrafts.net/yawl-0.3.2.tar.gz<br>
E_NOARGS=66<br>
E_BADARG=67<br>
MINLEN=7<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage $0 LETTERSET&quot;<br>
&nbsp; exit $E_NOARGS &nbsp; &nbsp; &nbsp; &nbsp; # Script needs a command-line argument.<br>
elif [ ${#1} -lt $MINLEN ]<br>
then<br>
&nbsp; echo &quot;Argument must have at least $MINLEN letters.&quot;<br>
&nbsp; exit $E_BADARG<br>
fi<br>
FILTER='.......' &nbsp; &nbsp; &nbsp; &nbsp; # Must have at least 7 letters.<br>
# &nbsp; &nbsp; &nbsp; 1234567<br>
Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$( &nbsp; &nbsp; $( &nbsp;nested command sub. &nbsp; &nbsp;) )<br>
Chapter 12. Command Substitution<br>
168<br>
<hr>
<A name=175></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp;( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array assignment &nbsp; &nbsp; &nbsp; &nbsp; )<br>
echo<br>
echo &quot;${#Anagrams[*]} &nbsp;7+ letter anagrams found&quot;<br>
echo<br>
echo ${Anagrams[0]} &nbsp; &nbsp; &nbsp;# First anagram.<br>
echo ${Anagrams[1]} &nbsp; &nbsp; &nbsp;# Second anagram.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Etc.<br>
# echo &quot;${Anagrams[*]}&quot; &nbsp;# To list all the anagrams in a single line . . .<br>
# &nbsp;Look ahead to the &quot;Arrays&quot; chapter for enlightenment on<br>
#+ what's going on here.<br>
# See also the agram.sh script for an example of anagram finding.<br>
exit $?<br>
Examples of command substitution in shell scripts:<br>
<a href="abs-guides.html#147">Example 11-7</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#165">Example 11-26</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#122">Example 9-16</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#226">Example 16-3</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#256">Example 16-22</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#248">Example 16-17</a><br>
6.&nbsp;<br>
<a href="abs-guides.html#307">Example 16-54</a><br>
7.&nbsp;<br>
<a href="abs-guides.html#152">Example 11-13</a><br>
8.&nbsp;<br>
<a href="abs-guides.html#149">Example 11-10</a><br>
9.&nbsp;<br>
<a href="abs-guides.html#266">Example 16-32</a><br>
10.&nbsp;<br>
<a href="abs-guides.html#382">Example 20-8</a><br>
11.&nbsp;<br>
<a href="abs-guides.html#593">Example A-16</a><br>
12.&nbsp;<br>
<a href="abs-guides.html#465">Example 29-3</a><br>
13.&nbsp;<br>
<a href="abs-guides.html#297">Example 16-47</a><br>
14.&nbsp;<br>
<a href="abs-guides.html#299">Example 16-48</a><br>
15.&nbsp;<br>
<a href="abs-guides.html#301">Example 16-49</a><br>
16.&nbsp;<br>
Chapter 12. Command Substitution<br>
169<br>
<hr>
<A name=176></a><b>Chapter 13. Arithmetic Expansion</b><br>
Arithmetic expansion provides a powerful tool for performing (integer) arithmetic operations in scripts.<br>Translating a string into a numerical expression is relatively straightforward using<i>&nbsp;backticks</i>,<i>&nbsp;double<br>parentheses</i>, or<i>&nbsp;let</i>.<br>
<b>Variations</b><br>
<a href="abs-guides.html#170">Arithmetic expansion with backticks (often used in conjunction with expr)</a><br>
z=`expr $z + 3` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The 'expr' command performs the expansion.<br>
<a href="abs-guides.html#86">Arithmetic expansion with double parentheses, and using let</a><br>
The use of<i>&nbsp;backticks</i>&nbsp;(<i>backquotes</i>) in arithmetic expansion has been superseded by<i>&nbsp;double parentheses<br></i>--&nbsp;<b>((...))</b>&nbsp;and&nbsp;<b>$((...))</b><a href="abs-guides.html#198">&nbsp;-- and also by the very convenient let construction.</a><br>
z=$(($z+3))<br>
z=$((z+3)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Also correct.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Within double parentheses,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ parameter dereferencing<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ is optional.<br>
# $((EXPRESSION)) is arithmetic expansion. &nbsp;# &nbsp;Not to be confused with<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ command substitution.<br>
# You may also use operations within double parentheses without assignment.<br>
&nbsp; n=0<br>
&nbsp; echo &quot;n = $n&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # n = 0<br>
&nbsp; (( n += 1 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Increment.<br>
# (( $n += 1 )) is incorrect!<br>
&nbsp; echo &quot;n = $n&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # n = 1<br>
let z=z+3<br>
let &quot;z += 3&quot; &nbsp;# &nbsp;Quotes permit the use of spaces in variable assignment.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;The 'let' operator actually performs arithmetic evaluation,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ rather than expansion.<br>
Examples of arithmetic expansion in scripts:<br>
<a href="abs-guides.html#233">Example 16-9</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#153">Example 11-14</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#427">Example 27-1</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#442">Example 27-11</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#593">Example A-16</a><br>
5.&nbsp;<br>
Chapter 13. Arithmetic Expansion<br>
170<br>
<hr>
<A name=177></a><b>Chapter 14. Recess Time</b><br>
<i>This bizarre little intermission gives the reader a chance to relax and maybe laugh a bit.</i><br>
&nbsp; Fellow Linux user, greetings! You are reading something which<br>
&nbsp; will bring you luck and good fortune. Just e-mail a copy of<br>
&nbsp; this document to 10 of your friends. Before making the copies,<br>
&nbsp; send a 100-line Bash script to the first person on the list<br>
&nbsp; at the bottom of this letter. Then delete their name and add<br>
&nbsp; yours to the bottom of the list.<br>
&nbsp; Don't break the chain! Make the copies within 48 hours.<br>
&nbsp; Wilfred P. of Brooklyn failed to send out his ten copies and<br>
&nbsp; woke the next morning to find his job description changed<br>
&nbsp; to &quot;COBOL programmer.&quot; Howard L. of Newport News sent<br>
&nbsp; out his ten copies and within a month had enough hardware<br>
&nbsp; to build a 100-node Beowulf cluster dedicated to playing<br>
<i>Tuxracer</i>. Amelia V. of Chicago laughed at this letter<br>
&nbsp; and broke the chain. Shortly thereafter, a fire broke out<br>
&nbsp; in her terminal and she now spends her days writing<br>
&nbsp; documentation for MS Windows.<br>
&nbsp; Don't break the chain! &nbsp;Send out your ten copies today!<br>
<i>Courtesy 'NIX &quot;fortune cookies&quot;, with some alterations and many apologies</i><br>
Chapter 14. Recess Time<br>
171<br>
<hr>
<A name=178></a><b>Part 4. Commands</b><br>
Mastering the commands on your Linux machine is an indispensable prelude to writing effective shell scripts.<br>
This section covers the following commands:<br>
<a href="abs-guides.html#15">. (See also source)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#324">ac</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">adduser</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">agetty</a><br>
•&nbsp;<br>
<a href="abs-guides.html#252">agrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#263">ar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#328">arch</a><br>
•&nbsp;<br>
<a href="abs-guides.html#238">at</a><br>
•&nbsp;<br>
<a href="abs-guides.html#219">autoload</a><br>
•&nbsp;<br>
<a href="abs-guides.html#784">awk (See also Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#306"><b>&nbsp;awk</b>&nbsp;for math operations)</a><br>
<a href="abs-guides.html#345">badblocks</a><br>
•&nbsp;<br>
<a href="abs-guides.html#311">banner</a><br>
•&nbsp;<br>
<a href="abs-guides.html#274">basename</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">batch</a><br>
•&nbsp;<br>
<a href="abs-guides.html#297">bc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">bg</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">bind</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">bison</a><br>
•&nbsp;<br>
<a href="abs-guides.html#218">builtin</a><br>
•&nbsp;<br>
<a href="abs-guides.html#253">bzgrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">bzip2</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">cal</a><br>
•&nbsp;<br>
<a href="abs-guides.html#213">caller</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">cat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#196">cd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#224">chattr</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">chfn</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">chgrp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#341">chkconfig</a><br>
•&nbsp;<br>
<a href="abs-guides.html#223">chmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">chown</a><br>
•&nbsp;<br>
<a href="abs-guides.html#346">chroot</a><br>
•&nbsp;<br>
<a href="abs-guides.html#275">cksum</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">clear</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">clock</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">cmp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#259">col</a><br>
•&nbsp;<br>
<a href="abs-guides.html#259">colrm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#259">column</a><br>
•&nbsp;<br>
<a href="abs-guides.html#273">comm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#218">command</a><br>
•&nbsp;<br>
<a href="abs-guides.html#796">compgen</a><br>
•&nbsp;<br>
Part 4. Commands<br>
172<br>
<hr>
<A name=179></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#796">complete</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">compress</a><br>
•&nbsp;<br>
<a href="abs-guides.html#551">coproc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#222">cp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#263">cpio</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">cron</a><br>
•&nbsp;<br>
<a href="abs-guides.html#278">crypt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#274">csplit</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">cu</a><br>
•&nbsp;<br>
<a href="abs-guides.html#242">cut</a><br>
•&nbsp;<br>
<a href="abs-guides.html#236">date</a><br>
•&nbsp;<br>
<a href="abs-guides.html#304">dc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#313">dd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">debugfs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#110">declare</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">depmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#332">df</a><br>
•&nbsp;<br>
<a href="abs-guides.html#536">dialog</a><br>
•&nbsp;<br>
<a href="abs-guides.html#271">diff</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">diff3</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">diffstat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#281">dig</a><br>
•&nbsp;<br>
<a href="abs-guides.html#274">dirname</a><br>
•&nbsp;<br>
<a href="abs-guides.html#197">dirs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">disown</a><br>
•&nbsp;<br>
<a href="abs-guides.html#332">dmesg</a><br>
•&nbsp;<br>
<a href="abs-guides.html#320">doexec</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">dos2unix</a><br>
•&nbsp;<br>
<a href="abs-guides.html#331">du</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">dump</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">dumpe2fs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">e2fsck</a><br>
•&nbsp;<br>
<a href="abs-guides.html#187">echo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#251">egrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#218">enable</a><br>
•&nbsp;<br>
<a href="abs-guides.html#261">enscript</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">env</a><br>
•&nbsp;<br>
<a href="abs-guides.html#261">eqn</a><br>
•&nbsp;<br>
<a href="abs-guides.html#199">eval</a><br>
•&nbsp;<br>
<a href="abs-guides.html#212">exec</a><br>
•&nbsp;<br>
<a href="abs-guides.html#212">exit (Related topic: exit status)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#242">expand</a><br>
•&nbsp;<br>
<a href="abs-guides.html#206">export</a><br>
•&nbsp;<br>
<a href="abs-guides.html#232">expr</a><br>
•&nbsp;<br>
<a href="abs-guides.html#296">factor</a><br>
•&nbsp;<br>
<a href="abs-guides.html#214">false</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">fdformat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">fdisk</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">fg</a><br>
•&nbsp;<br>
<a href="abs-guides.html#251">fgrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">file</a><br>
•&nbsp;<br>
Part 4. Commands<br>
173<br>
<hr>
<A name=180></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#225">find</a><br>
•&nbsp;<br>
<a href="abs-guides.html#285">finger</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">flex</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">flock</a><br>
•&nbsp;<br>
<a href="abs-guides.html#258">fmt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#258">fold</a><br>
•&nbsp;<br>
<a href="abs-guides.html#331">free</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">fsck</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">ftp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#337">fuser</a><br>
•&nbsp;<br>
<a href="abs-guides.html#269">getfacl</a><br>
•&nbsp;<br>
<a href="abs-guides.html#309">getopt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#208">getopts</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">gettext</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">getty</a><br>
•&nbsp;<br>
<a href="abs-guides.html#342">gnome-mount</a><br>
•&nbsp;<br>
<a href="abs-guides.html#246">grep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#261">groff</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">groupmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">groups (Related topic: the $GROUPS variable)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">gs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">gzip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">halt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">hash</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">hdparm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#243">head</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">help</a><br>
•&nbsp;<br>
<a href="abs-guides.html#317">hexdump</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">host</a><br>
•&nbsp;<br>
<a href="abs-guides.html#333">hostid</a><br>
•&nbsp;<br>
<a href="abs-guides.html#333">hostname (Related topic: the $HOSTNAME variable)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">hwclock</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">iconv</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">id (Related topic: the $UID variable)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#339">ifconfig</a><br>
•&nbsp;<br>
<a href="abs-guides.html#225">info</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">infocmp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">init</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">insmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">install</a><br>
•&nbsp;<br>
<a href="abs-guides.html#340">ip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#281">ipcalc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#341">iptables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#340">iwconfig</a><br>
•&nbsp;<br>
<a href="abs-guides.html#215">jobs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#243">join</a><br>
•&nbsp;<br>
<a href="abs-guides.html#307">jot</a><br>
•&nbsp;<br>
<a href="abs-guides.html#217">kill</a><br>
•&nbsp;<br>
<a href="abs-guides.html#218">killall</a><br>
•&nbsp;<br>
<a href="abs-guides.html#324">last</a><br>
•&nbsp;<br>
<a href="abs-guides.html#328">lastcomm</a><br>
•&nbsp;<br>
Part 4. Commands<br>
174<br>
<hr>
<A name=181></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#328">lastlog</a><br>
•&nbsp;<br>
<a href="abs-guides.html#350">ldd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">less</a><br>
•&nbsp;<br>
<a href="abs-guides.html#198">let</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">lex</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">lid</a><br>
•&nbsp;<br>
<a href="abs-guides.html#224">ln</a><br>
•&nbsp;<br>
<a href="abs-guides.html#269">locate</a><br>
•&nbsp;<br>
<a href="abs-guides.html#346">lockfile</a><br>
•&nbsp;<br>
<a href="abs-guides.html#335">logger</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">logname</a><br>
•&nbsp;<br>
<a href="abs-guides.html#217">logout</a><br>
•&nbsp;<br>
<a href="abs-guides.html#335">logrotate</a><br>
•&nbsp;<br>
<a href="abs-guides.html#253">look</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">losetup</a><br>
•&nbsp;<br>
<a href="abs-guides.html#312">lp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#220">ls</a><br>
•&nbsp;<br>
<a href="abs-guides.html#331">lsdev</a><br>
•&nbsp;<br>
<a href="abs-guides.html#348">lsmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#329">lsof</a><br>
•&nbsp;<br>
<a href="abs-guides.html#345">lspci</a><br>
•&nbsp;<br>
<a href="abs-guides.html#345">lsusb</a><br>
•&nbsp;<br>
<a href="abs-guides.html#329">ltrace</a><br>
•&nbsp;<br>
<a href="abs-guides.html#288">lynx</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">lzcat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">lzma</a><br>
•&nbsp;<br>
<a href="abs-guides.html#319">m4</a><br>
•&nbsp;<br>
<a href="abs-guides.html#293">mail</a><br>
•&nbsp;<br>
<a href="abs-guides.html#294">mailstats</a><br>
•&nbsp;<br>
<a href="abs-guides.html#294">mailto</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">make</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">MAKEDEV</a><br>
•&nbsp;<br>
<a href="abs-guides.html#225">man</a><br>
•&nbsp;<br>
<a href="abs-guides.html#553">mapfile</a><br>
•&nbsp;<br>
<a href="abs-guides.html#318">mcookie</a><br>
•&nbsp;<br>
<a href="abs-guides.html#275">md5sum</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">merge</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">mesg</a><br>
•&nbsp;<br>
<a href="abs-guides.html#278">mimencode</a><br>
•&nbsp;<br>
<a href="abs-guides.html#346">mkbootdisk</a><br>
•&nbsp;<br>
<a href="abs-guides.html#223">mkdir</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">mke2fs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#312">mkfifo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#346">mkisofs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">mknod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">mkswap</a><br>
•&nbsp;<br>
<a href="abs-guides.html#279">mktemp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#278">mmencode</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">modinfo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">modprobe</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">more</a><br>
•&nbsp;<br>
Part 4. Commands<br>
175<br>
<hr>
<A name=182></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#342">mount</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">msgfmt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#222">mv</a><br>
•&nbsp;<br>
<a href="abs-guides.html#329">nc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#293">netconfig</a><br>
•&nbsp;<br>
<a href="abs-guides.html#340">netstat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#324">newgrp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">nice</a><br>
•&nbsp;<br>
<a href="abs-guides.html#259">nl</a><br>
•&nbsp;<br>
<a href="abs-guides.html#350">nm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#339">nmap</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">nohup</a><br>
•&nbsp;<br>
<a href="abs-guides.html#281">nslookup</a><br>
•&nbsp;<br>
<a href="abs-guides.html#317">objdump</a><br>
•&nbsp;<br>
<a href="abs-guides.html#317">od</a><br>
•&nbsp;<br>
<a href="abs-guides.html#278">openssl</a><br>
•&nbsp;<br>
<a href="abs-guides.html#323">passwd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#243">paste</a><br>
•&nbsp;<br>
<a href="abs-guides.html#271">patch (Related topic: diff)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#313">pathchk</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">pax</a><br>
•&nbsp;<br>
<a href="abs-guides.html#335">pgrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">pidof</a><br>
•&nbsp;<br>
<a href="abs-guides.html#285">ping</a><br>
•&nbsp;<br>
<a href="abs-guides.html#335">pkill</a><br>
•&nbsp;<br>
<a href="abs-guides.html#197">popd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">pr</a><br>
•&nbsp;<br>
<a href="abs-guides.html#312">printenv</a><br>
•&nbsp;<br>
<a href="abs-guides.html#188">printf</a><br>
•&nbsp;<br>
<a href="abs-guides.html#331">procinfo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#335">ps</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">pstree</a><br>
•&nbsp;<br>
<a href="abs-guides.html#280">ptx</a><br>
•&nbsp;<br>
<a href="abs-guides.html#197">pushd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#197">pwd (Related topic: the $PWD variable)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#348">quota</a><br>
•&nbsp;<br>
<a href="abs-guides.html#288">rcp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#348">rdev</a><br>
•&nbsp;<br>
<a href="abs-guides.html#350">rdist</a><br>
•&nbsp;<br>
<a href="abs-guides.html#190">read</a><br>
•&nbsp;<br>
<a href="abs-guides.html#334">readelf</a><br>
•&nbsp;<br>
<a href="abs-guides.html#270">readlink</a><br>
•&nbsp;<br>
<a href="abs-guides.html#208">readonly</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">reboot</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">recode</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">renice</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">reset</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">resize</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">restore</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">rev</a><br>
•&nbsp;<br>
<a href="abs-guides.html#288">rlogin</a><br>
•&nbsp;<br>
Part 4. Commands<br>
176<br>
<hr>
<A name=183></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#222">rm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#223">rmdir</a><br>
•&nbsp;<br>
<a href="abs-guides.html#349">rmmod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#341">route</a><br>
•&nbsp;<br>
<a href="abs-guides.html#263">rpm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#264">rpm2cpio</a><br>
•&nbsp;<br>
<a href="abs-guides.html#288">rsh</a><br>
•&nbsp;<br>
<a href="abs-guides.html#288">rsync</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">runlevel</a><br>
•&nbsp;<br>
<a href="abs-guides.html#310">run-parts</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">rx</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">rz</a><br>
•&nbsp;<br>
<a href="abs-guides.html#334">sar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#293">scp</a><br>
•&nbsp;<br>
<a href="abs-guides.html#296">script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">sdiff</a><br>
•&nbsp;<br>
<a href="abs-guides.html#781">sed</a><br>
•&nbsp;<br>
<a href="abs-guides.html#307">seq</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">service</a><br>
•&nbsp;<br>
<a href="abs-guides.html#203">set</a><br>
•&nbsp;<br>
<a href="abs-guides.html#269">setfacl</a><br>
•&nbsp;<br>
<a href="abs-guides.html#348">setquota</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">setserial</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">setterm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#275">sha1sum</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">shar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#213">shopt</a><br>
•&nbsp;<br>
<a href="abs-guides.html#279">shred</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">shutdown</a><br>
•&nbsp;<br>
<a href="abs-guides.html#334">size</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">skill</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">sleep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#269">slocate</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">snice</a><br>
•&nbsp;<br>
<a href="abs-guides.html#240">sort</a><br>
•&nbsp;<br>
<a href="abs-guides.html#210">source</a><br>
•&nbsp;<br>
<a href="abs-guides.html#320">sox</a><br>
•&nbsp;<br>
<a href="abs-guides.html#274">split</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">sq</a><br>
•&nbsp;<br>
<a href="abs-guides.html#292">ssh</a><br>
•&nbsp;<br>
<a href="abs-guides.html#332">stat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#329">strace</a><br>
•&nbsp;<br>
<a href="abs-guides.html#270">strings</a><br>
•&nbsp;<br>
<a href="abs-guides.html#350">strip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#325">stty</a><br>
•&nbsp;<br>
<a href="abs-guides.html#323">su</a><br>
•&nbsp;<br>
<a href="abs-guides.html#323">sudo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#275">sum</a><br>
•&nbsp;<br>
<a href="abs-guides.html#217">suspend</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">swapoff</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">swapon</a><br>
•&nbsp;<br>
Part 4. Commands<br>
177<br>
<hr>
<A name=184></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#286">sx</a><br>
•&nbsp;<br>
<a href="abs-guides.html#343">sync</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">sz</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">tac</a><br>
•&nbsp;<br>
<a href="abs-guides.html#245">tail</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">tar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#261">tbl</a><br>
•&nbsp;<br>
<a href="abs-guides.html#341">tcpdump</a><br>
•&nbsp;<br>
<a href="abs-guides.html#312">tee</a><br>
•&nbsp;<br>
<a href="abs-guides.html#338">telinit</a><br>
•&nbsp;<br>
<a href="abs-guides.html#287">telnet</a><br>
•&nbsp;<br>
<a href="abs-guides.html#260">Tex</a><br>
•&nbsp;<br>
<a href="abs-guides.html#261">texexec</a><br>
•&nbsp;<br>
<a href="abs-guides.html#238">time</a><br>
•&nbsp;<br>
<a href="abs-guides.html#217">times</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">tmpwatch</a><br>
•&nbsp;<br>
<a href="abs-guides.html#336">top</a><br>
•&nbsp;<br>
<a href="abs-guides.html#238">touch</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">tput</a><br>
•&nbsp;<br>
<a href="abs-guides.html#254">tr</a><br>
•&nbsp;<br>
<a href="abs-guides.html#285">traceroute</a><br>
•&nbsp;<br>
<a href="abs-guides.html#214">true</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">tset</a><br>
•&nbsp;<br>
<a href="abs-guides.html#240">tsort</a><br>
•&nbsp;<br>
<a href="abs-guides.html#324">tty</a><br>
•&nbsp;<br>
<a href="abs-guides.html#344">tune2fs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#214">type</a><br>
•&nbsp;<br>
<a href="abs-guides.html#110">typeset</a><br>
•&nbsp;<br>
<a href="abs-guides.html#347">ulimit</a><br>
•&nbsp;<br>
<a href="abs-guides.html#348">umask</a><br>
•&nbsp;<br>
<a href="abs-guides.html#342">umount</a><br>
•&nbsp;<br>
<a href="abs-guides.html#328">uname</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">unarc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">unarj</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">uncompress</a><br>
•&nbsp;<br>
<a href="abs-guides.html#242">unexpand</a><br>
•&nbsp;<br>
<a href="abs-guides.html#240">uniq</a><br>
•&nbsp;<br>
<a href="abs-guides.html#318">units</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">unlzma</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">unrar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#206">unset</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">unsq</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">unzip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#333">uptime</a><br>
•&nbsp;<br>
<a href="abs-guides.html#345">usbmodules</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">useradd</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">userdel</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">usermod</a><br>
•&nbsp;<br>
<a href="abs-guides.html#321">users</a><br>
•&nbsp;<br>
<a href="abs-guides.html#239">usleep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">uucp</a><br>
•&nbsp;<br>
Part 4. Commands<br>
178<br>
<hr>
<A name=185></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#278">uudecode</a><br>
•&nbsp;<br>
<a href="abs-guides.html#277">uuencode</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">uux</a><br>
•&nbsp;<br>
<a href="abs-guides.html#294">vacation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#269">vdir</a><br>
•&nbsp;<br>
<a href="abs-guides.html#333">vmstat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#286">vrfy</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">w</a><br>
•&nbsp;<br>
<a href="abs-guides.html#216">wait</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">wall</a><br>
•&nbsp;<br>
<a href="abs-guides.html#350">watch</a><br>
•&nbsp;<br>
<a href="abs-guides.html#254">wc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#287">wget</a><br>
•&nbsp;<br>
<a href="abs-guides.html#268">whatis</a><br>
•&nbsp;<br>
<a href="abs-guides.html#268">whereis</a><br>
•&nbsp;<br>
<a href="abs-guides.html#268">which</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">who</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">whoami</a><br>
•&nbsp;<br>
<a href="abs-guides.html#285">whois</a><br>
•&nbsp;<br>
<a href="abs-guides.html#293">write</a><br>
•&nbsp;<br>
<a href="abs-guides.html#228">xargs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">yacc</a><br>
•&nbsp;<br>
<a href="abs-guides.html#311">yes</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">zcat</a><br>
•&nbsp;<br>
<a href="abs-guides.html#272">zdiff</a><br>
•&nbsp;<br>
<a href="abs-guides.html#238">zdump</a><br>
•&nbsp;<br>
<a href="abs-guides.html#252">zegrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#252">zfgrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#252">zgrep</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">zip</a><br>
•&nbsp;<br>
<b>Table of Contents<br></b><a href="abs-guides.html#186">15. Internal Commands and Builtins</a><br>
<a href="abs-guides.html#215">15.1. Job Control Commands</a><br>
<a href="abs-guides.html#220">16. External Filters, Programs and Commands</a><br>
<a href="abs-guides.html#220">16.1. Basic Commands<br></a><a href="abs-guides.html#225">16.2. Complex Commands<br></a><a href="abs-guides.html#236">16.3. Time / Date Commands<br></a><a href="abs-guides.html#240">16.4. Text Processing Commands<br></a><a href="abs-guides.html#262">16.5. File and Archiving Commands<br></a><a href="abs-guides.html#280">16.6. Communications Commands<br></a><a href="abs-guides.html#295">16.7. Terminal Control Commands<br></a><a href="abs-guides.html#296">16.8. Math Commands<br></a><a href="abs-guides.html#307">16.9. Miscellaneous Commands</a><br>
<a href="abs-guides.html#321">17. System and Administrative Commands</a><br>
<a href="abs-guides.html#350">17.1. Analyzing a System Script</a><br>
Part 4. Commands<br>
179<br>
<hr>
<A name=186></a><b>Chapter 15. Internal Commands and Builtins</b><br>
A<i>&nbsp;builtin</i>&nbsp;is a<b>&nbsp;command</b>&nbsp;contained within the Bash tool set, literally<i>&nbsp;built in</i>. This is either for performance<br>reasons -- builtins execute faster than external commands, which usually require<i>&nbsp;forking off&nbsp;</i>[57] a separate<br>process -- or because a particular builtin needs direct access to the shell internals.<br>
When a command or the shell itself initiates (or<i>&nbsp;spawns</i>) a new subprocess to carry out a task, this is called<br><i>forking</i>. This new process is the<i>&nbsp;child</i>, and the process that<i>&nbsp;forked</i>&nbsp;it off is the<i>&nbsp;parent</i>. While the<i>&nbsp;child<br>process</i>&nbsp;is doing its work, the<i>&nbsp;parent process</i>&nbsp;is still executing.<br>
Note that while a<i>&nbsp;parent process</i>&nbsp;gets the<i>&nbsp;process ID</i>&nbsp;of the<i>&nbsp;child process</i>, and can thus pass arguments to it,<br><i>the reverse is not true</i><a href="abs-guides.html#494">. This can create problems that are subtle and hard to track down.</a><br>
<b>Example 15-1. A script that spawns multiple instances of itself</b><br>
#!/bin/bash<br>
# spawn.sh<br>
PIDS=$(pidof sh $0) &nbsp;# Process IDs of the various instances of this script.<br>
P_array=( $PIDS ) &nbsp; &nbsp;# Put them in an array (why?).<br>
echo $PIDS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Show process IDs of parent and child processes.<br>
let &quot;instances = ${#P_array[*]} - 1&quot; &nbsp;# Count elements, less 1.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why subtract 1?<br>
echo &quot;$instances instance(s) of this script running.&quot;<br>
echo &quot;[Hit Ctl-C to exit.]&quot;; echo<br>
sleep 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Wait.<br>
sh $0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Play it again, Sam.<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Not necessary; script will never get to here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Why not?<br>
# &nbsp;After exiting with a Ctl-C,<br>
#+ do all the spawned instances of the script die?<br>
# &nbsp;If so, why?<br>
# Note:<br>
# ----<br>
# Be careful not to run this script too long.<br>
# It will eventually eat up too many system resources.<br>
# &nbsp;Is having a script spawn multiple instances of itself<br>
#+ an advisable scripting technique.<br>
# &nbsp;Why or why not?<br>
Generally, a Bash<i>&nbsp;builtin</i>&nbsp;does not fork a subprocess when it executes within a script. An external system<br>command or filter in a script usually<i>&nbsp;will</i>&nbsp;fork a subprocess.<br>
A builtin may be a synonym to a system command of the same name, but Bash reimplements it internally. For<br>example, the Bash<b>&nbsp;echo</b>&nbsp;command is not the same as&nbsp;/bin/echo, although their behavior is almost<br>identical.<br>
Chapter 15. Internal Commands and Builtins<br>
180<br>
<hr>
<A name=187></a><IMG src="abs-guide-187_1.png"><br>
<IMG src="abs-guide-187_2.png"><br>
Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
echo &quot;This line uses the \&quot;echo\&quot; builtin.&quot;<br>
/bin/echo &quot;This line uses the /bin/echo system command.&quot;<br>
A<i>&nbsp;keyword</i>&nbsp;is a<i>&nbsp;reserved</i>&nbsp;word, token or operator. Keywords have a special meaning to the shell, and indeed<br>are the building blocks of the shell's syntax. As examples,<i>&nbsp;for</i>,<i>&nbsp;while</i>,<i>&nbsp;do</i>, and<i>&nbsp;!</i>&nbsp;are keywords. Similar to a<br><a href="abs-guides.html#186">builtin, a keyword is hard-coded into Bash, but unlike a</a><i>&nbsp;builtin</i>, a keyword is not in itself a command, but<i>&nbsp;a<br>subunit of a command construct</i>.&nbsp;[58]<br>
<b>I/O</b><br>
<b>echo</b><br>
prints (to&nbsp;stdout<a href="abs-guides.html#36">) an expression or variable (see Example 4-1).</a><br>
echo Hello<br>
echo $a<br>
An<b>&nbsp;echo</b>&nbsp;requires the&nbsp;-e<a href="abs-guides.html#50">&nbsp;option to print escaped characters. See Example 5-2.</a><br>
Normally, each<b>&nbsp;echo</b>&nbsp;command prints a terminal newline, but the&nbsp;-n&nbsp;option suppresses this.<br>
An<b>&nbsp;echo</b>&nbsp;can be used to feed a sequence of commands down a pipe.<br>
if echo &quot;$VAR&quot; | grep -q txt &nbsp; # if [[ $VAR = *txt* ]]<br>
then<br>
&nbsp; echo &quot;$VAR contains the substring sequence \&quot;txt\&quot;&quot;<br>
fi<br>
An<b>&nbsp;echo</b><a href="abs-guides.html#170">, in combination with command substitution can set a variable.</a><br>
<b>a=`echo &quot;HELLO&quot; | tr A-Z a-z`</b><br>
<a href="abs-guides.html#256">See also Example 16-22, Example 16-3, Example 16-47, and Example 16-48.</a><br>
Be aware that<b>&nbsp;echo `command`</b>&nbsp;deletes any linefeeds that the output of&nbsp;<i>command</i>&nbsp;generates.<br>
<a href="abs-guides.html#93">The $IFS (internal field separator) variable normally contains \n (linefeed) as one of its set of<br></a><a href="abs-guides.html#34">whitespace characters. Bash therefore splits the output of&nbsp;</a><i>command</i>&nbsp;at linefeeds into arguments to<br><b>echo</b>. Then<b>&nbsp;echo</b>&nbsp;outputs these arguments, separated by spaces.<br>
bash$&nbsp;<b>ls -l /usr/share/apps/kjezz/sounds<br></b>-rw-r--r-- &nbsp; &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; 1407 Nov &nbsp;7 &nbsp;2000 reflect.au<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;362 Nov &nbsp;7 &nbsp;2000 seconds.au<br>
bash$&nbsp;<b>echo `ls -l /usr/share/apps/kjezz/sounds`<br></b>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...<br>
<a href="abs-guides.html#187">So, how can we embed a linefeed within an echoed character string?</a><br>
# Embedding a linefeed?<br>
echo &quot;Why doesn't this string \n split on two lines?&quot;<br>
# Doesn't split.<br>
Chapter 15. Internal Commands and Builtins<br>
181<br>
<hr>
<A name=188></a><IMG src="abs-guide-188_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Let's try something else.<br>
echo<br>
echo $&quot;A line of text containing<br>
a linefeed.&quot;<br>
# Prints as two distinct lines (embedded linefeed).<br>
# But, is the &quot;$&quot; variable prefix really necessary?<br>
echo<br>
echo &quot;This string splits<br>
on two lines.&quot;<br>
# No, the &quot;$&quot; is not needed.<br>
echo<br>
echo &quot;---------------&quot;<br>
echo<br>
echo -n $&quot;Another line of text containing<br>
a linefeed.&quot;<br>
# Prints as two distinct lines (embedded linefeed).<br>
# Even the -n option fails to suppress the linefeed here.<br>
echo<br>
echo<br>
echo &quot;---------------&quot;<br>
echo<br>
echo<br>
# However, the following doesn't work as expected.<br>
# Why not? Hint: Assignment to a variable.<br>
string1=$&quot;Yet another line of text containing<br>
a linefeed (maybe).&quot;<br>
echo $string1<br>
# Yet another line of text containing a linefeed (maybe).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
# Linefeed becomes a space.<br>
# Thanks, Steve Parker, for pointing this out.<br>
This command is a shell builtin, and not the same as&nbsp;/bin/echo, although its<br>behavior is similar.<br>
bash$&nbsp;<b>type -a echo<br></b>echo is a shell builtin<br>
&nbsp;echo is /bin/echo<br>
<b>printf</b><br>
The<b>&nbsp;printf</b>, formatted print, command is an enhanced<b>&nbsp;echo</b>. It is a limited variant of the<i>&nbsp;C</i>&nbsp;language<br>printf()&nbsp;library function, and its syntax is somewhat different.<br>
<b>printf&nbsp;</b><i>format-string</i>...&nbsp;<i>parameter</i>...<br>
This is the Bash<i>&nbsp;builtin</i>&nbsp;version of the&nbsp;/bin/printf&nbsp;or&nbsp;/usr/bin/printf&nbsp;command. See the<br><b>printf</b><a href="abs-guides.html#225">&nbsp;manpage (of the system command) for in-depth coverage.</a><br>
Chapter 15. Internal Commands and Builtins<br>
182<br>
<hr>
<A name=189></a><IMG src="abs-guide-189_1.png"><br>
Advanced Bash-Scripting Guide<br>
Older versions of Bash may not support<b>&nbsp;printf</b>.<br>
<b>Example 15-2.<i>&nbsp;printf</i></b><b>&nbsp;in action</b><br>
#!/bin/bash<br>
# printf demo<br>
declare -r PI=3.14159265358979 &nbsp; &nbsp; # Read-only variable, i.e., a constant.<br>
declare -r DecimalConstant=31373<br>
Message1=&quot;Greetings,&quot;<br>
Message2=&quot;Earthling.&quot;<br>
echo<br>
printf &quot;Pi to 2 decimal places = %1.2f&quot; $PI<br>
echo<br>
printf &quot;Pi to 9 decimal places = %1.9f&quot; $PI &nbsp;# It even rounds off correctly.<br>
printf &quot;\n&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Prints a line feed,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Equivalent to 'echo' . . .<br>
printf &quot;Constant = \t%d\n&quot; $DecimalConstant &nbsp;# Inserts tab (\t).<br>
printf &quot;%s %s \n&quot; $Message1 $Message2<br>
echo<br>
# ==========================================#<br>
# Simulation of C function, sprintf().<br>
# Loading a variable with a formatted string.<br>
echo&nbsp;<br>
Pi12=$(printf &quot;%1.12f&quot; $PI)<br>
echo &quot;Pi to 12 decimal places = $Pi12&quot; &nbsp; &nbsp; &nbsp;# Roundoff error!<br>
Msg=`printf &quot;%s %s \n&quot; $Message1 $Message2`<br>
echo $Msg; echo $Msg<br>
# &nbsp;As it happens, the 'sprintf' function can now be accessed<br>
#+ as a loadable module to Bash,<br>
#+ but this is not portable.<br>
exit 0<br>
Formatting error messages is a useful application of<b>&nbsp;printf</b><br>
E_BADDIR=85<br>
var=nonexistent_directory<br>
error()<br>
{<br>
&nbsp; printf &quot;$@&quot; &gt;&amp;2<br>
&nbsp; # Formats positional params passed, and sends them to stderr.<br>
&nbsp; echo<br>
&nbsp; exit $E_BADDIR<br>
}<br>
cd $var || error $&quot;Can't cd to %s.&quot; &quot;$var&quot;<br>
Chapter 15. Internal Commands and Builtins<br>
183<br>
<hr>
<A name=190></a>Advanced Bash-Scripting Guide<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#528">See also Example 36-15.</a><br>
<b>read</b><br>
&quot;Reads&quot; the value of a variable from&nbsp;stdin, that is, interactively fetches input from the keyboard.<br>The&nbsp;-a&nbsp;option lets<b>&nbsp;read</b><a href="abs-guides.html#433">&nbsp;get array variables (see Example 27-6).</a><br>
<b>Example 15-3. Variable assignment, using<i>&nbsp;read</i></b><br>
#!/bin/bash<br>
# &quot;Reading&quot; variables.<br>
echo -n &quot;Enter the value of variable 'var1': &quot;<br>
# The -n option to echo suppresses newline.<br>
read var1<br>
# Note no '$' in front of var1, since it is being set.<br>
echo &quot;var1 = $var1&quot;<br>
echo<br>
# A single 'read' statement can set multiple variables.<br>
echo -n &quot;Enter the values of variables 'var2' and 'var3' &quot;<br>
echo =n &quot;(separated by a space or tab): &quot;<br>
read var2 var3<br>
echo &quot;var2 = $var2 &nbsp; &nbsp; &nbsp;var3 = $var3&quot;<br>
# &nbsp;If you input only one value,<br>
#+ the other variable(s) will remain unset (null).<br>
exit 0<br>
A<b>&nbsp;read</b><a href="abs-guides.html#99">&nbsp;without an associated variable assigns its input to the dedicated variable $REPLY.</a><br>
<b>Example 15-4. What happens when<i>&nbsp;read</i></b><b>&nbsp;has no variable</b><br>
#!/bin/bash<br>
# read-novar.sh<br>
echo<br>
# -------------------------- #<br>
echo -n &quot;Enter a value: &quot;<br>
read var<br>
echo &quot;\&quot;var\&quot; = &quot;$var&quot;&quot;<br>
# Everything as expected here.<br>
# -------------------------- #<br>
echo<br>
# ------------------------------------------------------------------- #<br>
echo -n &quot;Enter another value: &quot;<br>
read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;No variable supplied for 'read', therefore...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ Input to 'read' assigned to default variable, $REPLY.<br>
var=&quot;$REPLY&quot;<br>
echo &quot;\&quot;var\&quot; = &quot;$var&quot;&quot;<br>
# This is equivalent to the first code block.<br>
Chapter 15. Internal Commands and Builtins<br>
184<br>
<hr>
<A name=191></a>Advanced Bash-Scripting Guide<br>
# ------------------------------------------------------------------- #<br>
echo<br>
echo &quot;=========================&quot;<br>
echo<br>
# &nbsp;This example is similar to the &quot;reply.sh&quot; script.<br>
# &nbsp;However, this one shows that $REPLY is available<br>
#+ even after a 'read' to a variable in the conventional way.<br>
# ================================================================= #<br>
# &nbsp;In some instances, you might wish to discard the first value read.<br>
# &nbsp;In such cases, simply ignore the $REPLY variable.<br>
{ # Code block.<br>
read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Line 1, to be discarded.<br>
read line2 &nbsp; &nbsp; &nbsp;# Line 2, saved in variable.<br>
&nbsp; } &lt;$0<br>
echo &quot;Line 2 of this script is:&quot;<br>
echo &quot;$line2&quot; &nbsp; # &nbsp; # read-novar.sh<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; #!/bin/bash &nbsp;line discarded.<br>
# See also the soundcard-on.sh script.<br>
exit 0<br>
Normally, inputting a&nbsp;<b>\</b>&nbsp;suppresses a newline during input to a<b>&nbsp;read</b>. The&nbsp;-r&nbsp;option causes an<br>inputted&nbsp;<b>\</b>&nbsp;to be interpreted literally.<br>
<b>Example 15-5. Multi-line input to<i>&nbsp;read</i></b><br>
#!/bin/bash<br>
echo<br>
echo &quot;Enter a string terminated by a \\, then press &lt;ENTER&gt;.&quot;<br>
echo &quot;Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;.&quot;<br>
read var1 &nbsp; &nbsp; # The &quot;\&quot; suppresses the newline, when reading $var1.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; first line \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; second line<br>
echo &quot;var1 = $var1&quot;<br>
# &nbsp; &nbsp; var1 = first line second line<br>
# &nbsp;For each line terminated by a &quot;\&quot;<br>
#+ you get a prompt on the next line to continue feeding characters into var1.<br>
echo; echo<br>
echo &quot;Enter another string terminated by a \\ , then press &lt;ENTER&gt;.&quot;<br>
read -r var2 &nbsp;# The -r option causes the &quot;\&quot; to be read literally.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; first line \<br>
echo &quot;var2 = $var2&quot;<br>
# &nbsp; &nbsp; var2 = first line \<br>
Chapter 15. Internal Commands and Builtins<br>
185<br>
<hr>
<A name=192></a>Advanced Bash-Scripting Guide<br>
# Data entry terminates with the first &lt;ENTER&gt;.<br>
echo&nbsp;<br>
exit 0<br>
The<b>&nbsp;read</b>&nbsp;command has some interesting options that permit echoing a prompt and even reading<br>keystrokes without hitting<b>&nbsp;ENTER</b>.<br>
# Read a keypress without hitting ENTER.<br>
read -s -n1 -p &quot;Hit a key &quot; keypress<br>
echo; echo &quot;Keypress was &quot;\&quot;$keypress\&quot;&quot;.&quot;<br>
# -s option means do not echo input.<br>
# -n N option means accept only N characters of input.<br>
# -p option means echo the following prompt before reading input.<br>
# Using these options is tricky, since they need to be in the correct order.<br>
The&nbsp;-n&nbsp;option to<b>&nbsp;read</b>&nbsp;also allows detection of the<b>&nbsp;arrow keys</b>&nbsp;and certain of the other unusual keys.<br>
<b>Example 15-6. Detecting the arrow keys</b><br>
#!/bin/bash<br>
# arrow-detect.sh: Detects the arrow keys, and a few more.<br>
# Thank you, Sandro Magi, for showing me how.<br>
# --------------------------------------------<br>
# Character codes generated by the keypresses.<br>
arrowup='\[A'<br>
arrowdown='\[B'<br>
arrowrt='\[C'<br>
arrowleft='\[D'<br>
insert='\[2'<br>
delete='\[3'<br>
# --------------------------------------------<br>
SUCCESS=0<br>
OTHER=65<br>
echo -n &quot;Press a key... &nbsp;&quot;<br>
# May need to also press ENTER if a key not listed above pressed.<br>
read -n3 key &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Read 3 characters.<br>
echo -n &quot;$key&quot; | grep &quot;$arrowup&quot; &nbsp;#Check if character code detected.<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;Up-arrow key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
echo -n &quot;$key&quot; | grep &quot;$arrowdown&quot;<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;Down-arrow key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
Chapter 15. Internal Commands and Builtins<br>
186<br>
<hr>
<A name=193></a>Advanced Bash-Scripting Guide<br>
echo -n &quot;$key&quot; | grep &quot;$arrowrt&quot;<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;Right-arrow key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
echo -n &quot;$key&quot; | grep &quot;$arrowleft&quot;<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;Left-arrow key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
echo -n &quot;$key&quot; | grep &quot;$insert&quot;<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;\&quot;Insert\&quot; key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
echo -n &quot;$key&quot; | grep &quot;$delete&quot;<br>
if [ &quot;$?&quot; -eq $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;\&quot;Delete\&quot; key pressed.&quot;<br>
&nbsp; exit $SUCCESS<br>
fi<br>
echo &quot; Some other key pressed.&quot;<br>
exit $OTHER<br>
# ========================================= #<br>
# &nbsp;Mark Alexander came up with a simplified<br>
#+ version of the above script (Thank you!).<br>
# &nbsp;It eliminates the need for grep.<br>
#!/bin/bash<br>
&nbsp; uparrow=$'\x1b[A'<br>
&nbsp; downarrow=$'\x1b[B'<br>
&nbsp; leftarrow=$'\x1b[D'<br>
&nbsp; rightarrow=$'\x1b[C'<br>
&nbsp; read -s -n3 -p &quot;Hit an arrow key: &quot; x<br>
&nbsp; case &quot;$x&quot; in<br>
&nbsp; $uparrow)<br>
&nbsp; &nbsp; &nbsp;echo &quot;You pressed up-arrow&quot;<br>
&nbsp; &nbsp; &nbsp;;;<br>
&nbsp; $downarrow)<br>
&nbsp; &nbsp; &nbsp;echo &quot;You pressed down-arrow&quot;<br>
&nbsp; &nbsp; &nbsp;;;<br>
&nbsp; $leftarrow)<br>
&nbsp; &nbsp; &nbsp;echo &quot;You pressed left-arrow&quot;<br>
&nbsp; &nbsp; &nbsp;;;<br>
&nbsp; $rightarrow)<br>
&nbsp; &nbsp; &nbsp;echo &quot;You pressed right-arrow&quot;<br>
&nbsp; &nbsp; &nbsp;;;<br>
Chapter 15. Internal Commands and Builtins<br>
187<br>
<hr>
<A name=194></a><IMG src="abs-guide-194_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; esac<br>
exit $?<br>
# ========================================= #<br>
# Antonio Macchi has a simpler alternative.<br>
#!/bin/bash<br>
while true<br>
do<br>
&nbsp; read -sn1 a<br>
&nbsp; test &quot;$a&quot; == `echo -en &quot;\e&quot;` || continue<br>
&nbsp; read -sn1 a<br>
&nbsp; test &quot;$a&quot; == &quot;[&quot; || continue<br>
&nbsp; read -sn1 a<br>
&nbsp; case &quot;$a&quot; in<br>
&nbsp; &nbsp; A) &nbsp;echo &quot;up&quot;;;<br>
&nbsp; &nbsp; B) &nbsp;echo &quot;down&quot;;;<br>
&nbsp; &nbsp; C) &nbsp;echo &quot;right&quot;;;<br>
&nbsp; &nbsp; D) &nbsp;echo &quot;left&quot;;;<br>
&nbsp; esac<br>
done<br>
# ========================================= #<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;1) Add detection of the &quot;Home,&quot; &quot;End,&quot; &quot;PgUp,&quot; and &quot;PgDn&quot; keys.<br>
The&nbsp;-n&nbsp;option to<b>&nbsp;read</b>&nbsp;will not detect the<b>&nbsp;ENTER</b>&nbsp;(newline) key.<br>
The&nbsp;-t&nbsp;option to<b>&nbsp;read</b><a href="abs-guides.html#102">&nbsp;permits timed input (see Example 9-4 and Example A-41).</a><br>
The&nbsp;-u<a href="abs-guides.html#374">&nbsp;option takes the file descriptor of the target file.</a><br>
The<b>&nbsp;read</b><a href="abs-guides.html#374">&nbsp;command may also &quot;read&quot; its variable value from a file redirected to&nbsp;</a>stdin. If the file<br>contains more than one line, only the first line is assigned to the variable. If<b>&nbsp;read</b>&nbsp;has more than one<br><a href="abs-guides.html#34">parameter, then each of these variables gets assigned a successive whitespace-delineated string.<br></a>Caution!<br>
<b>Example 15-7. Using<i>&nbsp;read</i></b><a href="abs-guides.html#374"><b>&nbsp;with file redirection</b></a><br>
#!/bin/bash<br>
read var1 &lt;data-file<br>
echo &quot;var1 = $var1&quot;<br>
# var1 set to the entire first line of the input file &quot;data-file&quot;<br>
read var2 var3 &lt;data-file<br>
echo &quot;var2 = $var2 &nbsp; var3 = $var3&quot;<br>
# Note non-intuitive behavior of &quot;read&quot; here.<br>
# 1) Rewinds back to the beginning of input file.<br>
# 2) Each variable is now set to a corresponding string,<br>
# &nbsp; &nbsp;separated by whitespace, rather than to an entire line of text.<br>
Chapter 15. Internal Commands and Builtins<br>
188<br>
<hr>
<A name=195></a><IMG src="abs-guide-195_1.png"><br>
Advanced Bash-Scripting Guide<br>
# 3) The final variable gets the remainder of the line.<br>
# 4) If there are more variables to be set than whitespace-terminated strings<br>
# &nbsp; &nbsp;on the first line of the file, then the excess variables remain empty.<br>
echo &quot;------------------------------------------------&quot;<br>
# How to resolve the above problem with a loop:<br>
while read line<br>
do<br>
&nbsp; echo &quot;$line&quot;<br>
done &lt;data-file<br>
# Thanks, Heiner Steven for pointing this out.<br>
echo &quot;------------------------------------------------&quot;<br>
# Use $IFS (Internal Field Separator variable) to split a line of input to<br>
# &quot;read&quot;, if you do not want the default to be whitespace.<br>
echo &quot;List of all users:&quot;<br>
OIFS=$IFS; IFS=: &nbsp; &nbsp; &nbsp; # /etc/passwd uses &quot;:&quot; for field separator.<br>
while read name passwd uid gid fullname ignore<br>
do<br>
&nbsp; echo &quot;$name ($fullname)&quot;<br>
done &lt;/etc/passwd &nbsp; # I/O redirection.<br>
IFS=$OIFS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Restore original $IFS.<br>
# This code snippet also by Heiner Steven.<br>
# &nbsp;Setting the $IFS variable within the loop itself<br>
#+ eliminates the need for storing the original $IFS<br>
#+ in a temporary variable.<br>
# &nbsp;Thanks, Dim Segebart, for pointing this out.<br>
echo &quot;------------------------------------------------&quot;<br>
echo &quot;List of all users:&quot;<br>
while IFS=: read name passwd uid gid fullname ignore<br>
do<br>
&nbsp; echo &quot;$name ($fullname)&quot;<br>
done &lt;/etc/passwd &nbsp; # I/O redirection.<br>
echo<br>
echo &quot;\$IFS still $IFS&quot;<br>
exit 0<br>
<a href="abs-guides.html#24">Piping output to a</a><i>&nbsp;read</i><a href="abs-guides.html#187">, using echo to set variables will fail.</a><br>
<a href="abs-guides.html#221">Yet, piping the output of cat<i>&nbsp;seems</i></a>&nbsp;to work.<br>
cat file1 file2 |<br>
while read line<br>
do<br>
echo $line<br>
done<br>
However, as Bjön Eriksson shows:<br>
Chapter 15. Internal Commands and Builtins<br>
189<br>
<hr>
<A name=196></a><IMG src="abs-guide-196_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>Example 15-8. Problems reading from a pipe</b><br>
#!/bin/sh<br>
# readpipe.sh<br>
# This example contributed by Bjon Eriksson.<br>
### shopt -s lastpipe<br>
last=&quot;(null)&quot;<br>
cat $0 |<br>
while read line<br>
do<br>
&nbsp; &nbsp; echo &quot;{$line}&quot;<br>
&nbsp; &nbsp; last=$line<br>
done<br>
echo<br>
echo &quot;++++++++++++++++++++++&quot;<br>
printf &quot;\nAll done, last: $last\n&quot; # &nbsp;The output of this line<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ changes if you uncomment line 5.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;(Bash, version -ge 4.2 required.)<br>
exit 0 &nbsp;# End of code.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # (Partial) output of script follows.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # The 'echo' supplies extra brackets.<br>
#############################################<br>
./readpipe.sh&nbsp;<br>
{#!/bin/sh}<br>
{last=&quot;(null)&quot;}<br>
{cat $0 |}<br>
{while read line}<br>
{do}<br>
{echo &quot;{$line}&quot;}<br>
{last=$line}<br>
{done}<br>
{printf &quot;nAll done, last: $lastn&quot;}<br>
All done, last: (null)<br>
The variable (last) is set within the loop/subshell<br>
but its value does not persist outside the loop.<br>
The<i>&nbsp;gendiff</i>&nbsp;script, usually found in&nbsp;/usr/bin&nbsp;on many Linux distros, pipes the<br><a href="abs-guides.html#225">output of find to a</a><i>&nbsp;while read</i>&nbsp;construct.<br>
find $1 \( -name &quot;*$2&quot; -o -name &quot;.*$2&quot; \) -print |<br>
while read f; do<br>
. . .<br>
It is possible to<i>&nbsp;paste</i>&nbsp;text into the input field of a<i>&nbsp;read</i>&nbsp;(but<i>&nbsp;not</i>&nbsp;multiple lines!). See<br><a href="abs-guides.html#700">Example A-38.</a><br>
<b>Filesystem</b><br>
<b>cd</b><br>
Chapter 15. Internal Commands and Builtins<br>
190<br>
<hr>
<A name=197></a><IMG src="abs-guide-197_1.png"><br>
Advanced Bash-Scripting Guide<br>
The familiar<b>&nbsp;cd</b>&nbsp;change directory command finds use in scripts where execution of a command<br>requires being in a specified directory.<br>
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)<br>
<a href="abs-guides.html#27">[from the previously cited example by Alan Cox]</a><br>
The&nbsp;-P&nbsp;(physical) option to<b>&nbsp;cd</b>&nbsp;causes it to ignore symbolic links.<br>
<b>cd -</b><a href="abs-guides.html#96">&nbsp;changes to $OLDPWD, the previous working directory.</a><br>
The<b>&nbsp;cd</b>&nbsp;command does not function as expected when presented with two forward<br>slashes.<br>
bash$&nbsp;<b>cd //<br></b>bash$&nbsp;<b>pwd<br></b>//<br>
The output should, of course, be&nbsp;/. This is a problem both from the command-line and<br>in a script.<br>
<b>pwd</b><br>
<a href="abs-guides.html#197">Print Working Directory. This gives the user's (or script's) current directory (see Example 15-9). The<br></a><a href="abs-guides.html#98">effect is identical to reading the value of the builtin variable $PWD.</a><br>
<b>pushd</b>,<b>&nbsp;popd</b>,<b>&nbsp;dirs</b><br>
This command set is a mechanism for bookmarking working directories, a means of moving back and<br><a href="abs-guides.html#884">forth through directories in an orderly manner. A pushdown stack is used to keep track of directory<br></a>names. Options allow various manipulations of the directory stack.<br>
<b>pushd dir-name</b>&nbsp;pushes the path&nbsp;<i>dir-name</i>&nbsp;onto the directory stack and simultaneously<br>changes the current working directory to&nbsp;<i>dir-name</i><br>
<b>popd</b>&nbsp;removes (pops) the top directory path name off the directory stack and simultaneously changes<br>the current working directory to that directory popped from the stack.<br>
<b>dirs</b><a href="abs-guides.html#92">&nbsp;lists the contents of the directory stack (compare this with the $DIRSTACK variable). A<br></a>successful<b>&nbsp;pushd</b>&nbsp;or<b>&nbsp;popd</b>&nbsp;will automatically invoke<b>&nbsp;dirs</b>.<br>
Scripts that require various changes to the current working directory without hard-coding the<br>directory name changes can make good use of these commands. Note that the implicit&nbsp;$DIRSTACK<br>array variable, accessible from within a script, holds the contents of the directory stack.<br>
<b>Example 15-9. Changing the current working directory</b><br>
#!/bin/bash<br>
dir1=/usr/local<br>
dir2=/var/spool<br>
pushd $dir1<br>
# Will do an automatic 'dirs' (list directory stack to stdout).<br>
echo &quot;Now in directory `pwd`.&quot; # Uses back-quoted 'pwd'.<br>
Chapter 15. Internal Commands and Builtins<br>
191<br>
<hr>
<A name=198></a>Advanced Bash-Scripting Guide<br>
# Now, do some stuff in directory 'dir1'.<br>
pushd $dir2<br>
echo &quot;Now in directory `pwd`.&quot;<br>
# Now, do some stuff in directory 'dir2'.<br>
echo &quot;The top entry in the DIRSTACK array is $DIRSTACK.&quot;<br>
popd<br>
echo &quot;Now back in directory `pwd`.&quot;<br>
# Now, do some more stuff in directory 'dir1'.<br>
popd<br>
echo &quot;Now back in original working directory `pwd`.&quot;<br>
exit 0<br>
# What happens if you don't 'popd' -- then exit the script?<br>
# Which directory do you end up in? Why?<br>
<b>Variables</b><br>
<b>let</b><br>
The<b>&nbsp;let</b>&nbsp;command carries out<i>&nbsp;arithmetic</i>&nbsp;operations on variables.&nbsp;[59] In many cases, it functions as a<br><a href="abs-guides.html#232">less complex version of expr.</a><br>
<b>Example 15-10. Letting<i>&nbsp;let</i></b><b>&nbsp;do arithmetic.</b><br>
#!/bin/bash<br>
echo<br>
let a=11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Same as 'a=11'<br>
let a=a+5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Equivalent to &nbsp;let &quot;a = a + 5&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (Double quotes and spaces make it more readable.)<br>
echo &quot;11 + 5 = $a&quot; &nbsp;# 16<br>
let &quot;a &lt;&lt;= 3&quot; &nbsp; &nbsp; &nbsp; # Equivalent to &nbsp;let &quot;a = a &lt;&lt; 3&quot;<br>
echo &quot;\&quot;\$a\&quot; (=16) left-shifted 3 places = $a&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 128<br>
let &quot;a /= 4&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Equivalent to &nbsp;let &quot;a = a / 4&quot;<br>
echo &quot;128 / 4 = $a&quot; # 32<br>
let &quot;a -= 5&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Equivalent to &nbsp;let &quot;a = a - 5&quot;<br>
echo &quot;32 - 5 = $a&quot; &nbsp;# 27<br>
let &quot;a *= &nbsp;10&quot; &nbsp; &nbsp; &nbsp;# Equivalent to &nbsp;let &quot;a = a * 10&quot;<br>
echo &quot;27 * 10 = $a&quot; # 270<br>
let &quot;a %= 8&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Equivalent to &nbsp;let &quot;a = a % 8&quot;<br>
echo &quot;270 modulo 8 = $a &nbsp;(270 / 8 = 33, remainder $a)&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 6<br>
# Does &quot;let&quot; permit C-style operators?<br>
# Yes, just as the (( ... )) double-parentheses construct does.<br>
let a++ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # C-style (post) increment.<br>
echo &quot;6++ = $a&quot; &nbsp; &nbsp; # 6++ = 7<br>
let a-- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # C-style decrement.<br>
Chapter 15. Internal Commands and Builtins<br>
192<br>
<hr>
<A name=199></a><IMG src="abs-guide-199_1.png"><br>
<IMG src="abs-guide-199_2.png"><br>
Advanced Bash-Scripting Guide<br>
echo &quot;7-- = $a&quot; &nbsp; &nbsp; # 7-- = 6<br>
# Of course, ++a, etc., also allowed . . .<br>
echo<br>
# Trinary operator.<br>
# Note that $a is 6, see above.<br>
let &quot;t = a&lt;7?7:11&quot; &nbsp; # True<br>
echo $t &nbsp;# 7<br>
let a++<br>
let &quot;t = a&lt;7?7:11&quot; &nbsp; # False<br>
echo $t &nbsp;# &nbsp; &nbsp; 11<br>
exit<br>
The<i>&nbsp;let</i><a href="abs-guides.html#57">&nbsp;command can, in certain contexts, return an anomalous exit status.</a><br>
# Evgeniy Ivanov points out:<br>
var=0<br>
echo $? &nbsp; &nbsp; # 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # As expected.<br>
let var++<br>
echo $? &nbsp; &nbsp; # 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The command was successful, so why isn't $?=0 ???<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Anomaly!<br>
let var++<br>
echo $? &nbsp; &nbsp; # 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # As expected.<br>
# Likewise . . .<br>
let var=0<br>
echo $? &nbsp; &nbsp; # 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The command was successful, so why isn't $?=0 ???<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Anomaly!<br>
<b>eval</b><br>
<b>eval arg1 [arg2] ... [argN]</b><br>
Combines the arguments in an expression or list of expressions and&nbsp;<i>evaluates</i>&nbsp;them. Any variables<br>within the expression are expanded. The net result is to<b>&nbsp;convert a string into a command</b>.<br>
The<b>&nbsp;eval</b>&nbsp;command can be used for code generation from the command-line or within<br>a script.<br>
bash$&nbsp;<b>command_string=&quot;ps ax&quot;<br></b>bash$&nbsp;<b>process=&quot;ps ax&quot;<br></b>bash$&nbsp;<b>eval &quot;$command_string&quot; | grep &quot;$process&quot;<br></b>26973 pts/3 &nbsp; &nbsp;R+ &nbsp; &nbsp; 0:00 grep --color ps ax<br>
&nbsp;26974 pts/3 &nbsp; &nbsp;R+ &nbsp; &nbsp; 0:00 ps ax<br>
Each invocation of<i>&nbsp;eval</i>&nbsp;forces a re-<i>evaluation</i>&nbsp;of its arguments.<br>
Chapter 15. Internal Commands and Builtins<br>
193<br>
<hr>
<A name=200></a>Advanced Bash-Scripting Guide<br>
a='$b'<br>
b='$c'<br>
c=d<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $b<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # First level.<br>
eval echo $a &nbsp; &nbsp; &nbsp; &nbsp;# $c<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Second level.<br>
eval eval echo $a &nbsp; # d<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Third level.<br>
# Thank you, E. Choroba.<br>
<b>Example 15-11. Showing the effect of<i>&nbsp;eval</i></b><br>
#!/bin/bash<br>
# Exercising &quot;eval&quot; ...<br>
y=`eval ls -l` &nbsp;# &nbsp;Similar to y=`ls -l`<br>
echo $y &nbsp; &nbsp; &nbsp; &nbsp; #+ but linefeeds removed because &quot;echoed&quot; variable is unquoted.<br>
echo<br>
echo &quot;$y&quot; &nbsp; &nbsp; &nbsp; # &nbsp;Linefeeds preserved when variable is quoted.<br>
echo; echo<br>
y=`eval df` &nbsp; &nbsp; # &nbsp;Similar to y=`df`<br>
echo $y &nbsp; &nbsp; &nbsp; &nbsp; #+ but linefeeds removed.<br>
# &nbsp;When LF's not preserved, it may make it easier to parse output,<br>
#+ using utilities such as &quot;awk&quot;.<br>
echo<br>
echo &quot;===========================================================&quot;<br>
echo<br>
eval &quot;`seq 3 | sed -e 's/.*/echo var&amp;=ABCDEFGHIJ/'`&quot;<br>
# var1=ABCDEFGHIJ<br>
# var2=ABCDEFGHIJ<br>
# var3=ABCDEFGHIJ<br>
echo<br>
echo &quot;===========================================================&quot;<br>
echo<br>
# Now, showing how to do something useful with &quot;eval&quot; . . .<br>
# (Thank you, E. Choroba!)<br>
version=3.4 &nbsp; &nbsp; # &nbsp;Can we split the version into major and minor<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ part in one command?<br>
echo &quot;version = $version&quot;<br>
eval major=${version/./;minor=} &nbsp; &nbsp; # &nbsp;Replaces '.' in version by ';minor='<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;The substitution yields '3; minor=4'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ so eval does minor=4, major=3<br>
echo Major: $major, minor: $minor &nbsp; # &nbsp;Major: 3, minor: 4<br>
<b>Example 15-12. Using<i>&nbsp;eval</i></b><b>&nbsp;to select among variables</b><br>
Chapter 15. Internal Commands and Builtins<br>
194<br>
<hr>
<A name=201></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# arr-choice.sh<br>
# &nbsp;Passing arguments to a function to select<br>
#+ one particular variable out of a group.<br>
arr0=( 10 11 12 13 14 15 )<br>
arr1=( 20 21 22 23 24 25 )<br>
arr2=( 30 31 32 33 34 35 )<br>
# &nbsp; &nbsp; &nbsp; 0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 &nbsp; &nbsp; &nbsp;Element number (zero-indexed)<br>
choose_array ()<br>
{<br>
&nbsp; eval array_member=\${arr${array_number}[element_number]}<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^<br>
&nbsp; # &nbsp;Using eval to construct the name of a variable,<br>
&nbsp; #+ in this particular case, an array name.<br>
&nbsp; echo &quot;Element $element_number of array $array_number is $array_member&quot;<br>
} # &nbsp;Function can be rewritten to take parameters.<br>
array_number=0 &nbsp; &nbsp;# First array.<br>
element_number=3<br>
choose_array &nbsp; &nbsp; &nbsp;# 13<br>
array_number=2 &nbsp; &nbsp;# Third array.<br>
element_number=4<br>
choose_array &nbsp; &nbsp; &nbsp;# 34<br>
array_number=3 &nbsp; &nbsp;# Null array (arr3 not allocated).<br>
element_number=4<br>
choose_array &nbsp; &nbsp; &nbsp;# (null)<br>
# Thank you, Antonio Macchi, for pointing this out.<br>
<b>Example 15-13.<i>&nbsp;Echoing</i></b><b>&nbsp;the<i>&nbsp;command-line parameters</i></b><br>
#!/bin/bash<br>
# echo-params.sh<br>
# Call this script with a few command-line parameters.<br>
# For example:<br>
# &nbsp; &nbsp; sh echo-params.sh first second third fourth fifth<br>
params=$# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Number of command-line parameters.<br>
param=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Start at first command-line param.<br>
while [ &quot;$param&quot; -le &quot;$params&quot; ]<br>
do<br>
&nbsp; echo -n &quot;Command-line parameter &quot;<br>
&nbsp; echo -n \$$param &nbsp; &nbsp; # &nbsp;Gives only the *name* of variable.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;$1, $2, $3, etc.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Why?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;\$ escapes the first &quot;$&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ so it echoes literally,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ and $param dereferences &quot;$param&quot; . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ . . . as expected.<br>
&nbsp; echo -n &quot; = &quot;<br>
&nbsp; eval echo \$$param &nbsp; # &nbsp;Gives the *value* of variable.<br>
# ^^^^ &nbsp; &nbsp; &nbsp;^^^ &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;The &quot;eval&quot; forces the *evaluation*<br>
Chapter 15. Internal Commands and Builtins<br>
195<br>
<hr>
<A name=202></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ of \$$<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ as an indirect variable reference.<br>
(( param ++ )) &nbsp; &nbsp; &nbsp; &nbsp; # On to the next.<br>
done<br>
exit $?<br>
# =================================================<br>
$ sh echo-params.sh first second third fourth fifth<br>
Command-line parameter $1 = first<br>
Command-line parameter $2 = second<br>
Command-line parameter $3 = third<br>
Command-line parameter $4 = fourth<br>
Command-line parameter $5 = fifth<br>
<b>Example 15-14. Forcing a log-off</b><br>
#!/bin/bash<br>
# Killing ppp to force a log-off.<br>
# For dialup connection, of course.<br>
# Script should be run as root user.<br>
SERPORT=ttyS3<br>
# &nbsp;Depending on the hardware and even the kernel version,<br>
#+ the modem port on your machine may be different --<br>
#+ /dev/ttyS1 or /dev/ttyS2.<br>
killppp=&quot;eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -------- process ID of ppp ------- &nbsp;<br>
$killppp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This variable is now a command.<br>
# The following operations must be done as root user.<br>
chmod 666 /dev/$SERPORT &nbsp; &nbsp; &nbsp;# Restore r+w permissions, or else what?<br>
# &nbsp;Since doing a SIGKILL on ppp changed the permissions on the serial port,<br>
#+ we restore permissions to previous state.<br>
rm /var/lock/LCK..$SERPORT &nbsp; # Remove the serial port lock file. Why?<br>
exit $?<br>
# Exercises:<br>
# ---------<br>
# 1) Have script check whether root user is invoking it.<br>
# 2) Do a check on whether the process to be killed<br>
#+ &nbsp; is actually running before attempting to kill it. &nbsp;&nbsp;<br>
# 3) Write an alternate version of this script based on 'fuser':<br>
#+ &nbsp; &nbsp; &nbsp;if [ fuser -s /dev/modem ]; then . . .<br>
<b>Example 15-15. A version of<i>&nbsp;rot13</i></b><br>
#!/bin/bash<br>
# A version of &quot;rot13&quot; using 'eval'.<br>
# Compare to &quot;rot13.sh&quot; example.<br>
Chapter 15. Internal Commands and Builtins<br>
196<br>
<hr>
<A name=203></a><IMG src="abs-guide-203_1.png"><br>
Advanced Bash-Scripting Guide<br>
setvar_rot_13() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;rot13&quot; scrambling<br>
{<br>
&nbsp; local varname=$1 varvalue=$2<br>
&nbsp; eval $varname='$(echo &quot;$varvalue&quot; | tr a-z n-za-m)'<br>
}<br>
setvar_rot_13 var &quot;foobar&quot; &nbsp; # Run &quot;foobar&quot; through rot13.<br>
echo $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# sbbone<br>
setvar_rot_13 var &quot;$var&quot; &nbsp; &nbsp; # Run &quot;sbbone&quot; through rot13.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Back to original variable.<br>
echo $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# foobar<br>
# This example by Stephane Chazelas.<br>
# Modified by document author.<br>
exit 0<br>
<a href="abs-guides.html#751">Example A-53 uses</a><i>&nbsp;eval</i><a href="abs-guides.html#427">&nbsp;to convert array elements into a command list.</a><br>
The<i>&nbsp;eval</i><a href="abs-guides.html#456">&nbsp;command occurs in the older version of indirect referencing.</a><br>
eval var=\$$var<br>
The<b>&nbsp;eval</b>&nbsp;command can be risky, and normally should be avoided when there exists a<br>reasonable alternative. An&nbsp;<b>eval $COMMANDS</b>&nbsp;executes the contents of&nbsp;<i>COMMANDS</i>,<br>which may contain such unpleasant surprises as<b>&nbsp;rm -rf *</b>. Running an<b>&nbsp;eval</b>&nbsp;on<br>unfamiliar code written by persons unknown is living dangerously.<br>
<b>set</b><br>
The<b>&nbsp;set</b>&nbsp;command changes the value of internal script variables/options. One use for this is to toggle<br><a href="abs-guides.html#487">option flags which help determine the behavior of the script. Another application for it is to reset the<br></a><a href="abs-guides.html#104">positional parameters that a script sees as the result of a command (</a><b>set `command`</b>). The script<br><a href="abs-guides.html#35">can then parse the fields of the command output.</a><br>
<b>Example 15-16. Using<i>&nbsp;set</i></b><b>&nbsp;with positional parameters</b><br>
#!/bin/bash<br>
# ex34.sh<br>
# Script &quot;set-test&quot;<br>
# Invoke this script with three command-line parameters,<br>
# for example, &quot;sh ex34.sh one two three&quot;.<br>
echo<br>
echo &quot;Positional parameters before &nbsp;set \`uname -a\` :&quot;<br>
echo &quot;Command-line argument #1 = $1&quot;<br>
echo &quot;Command-line argument #2 = $2&quot;<br>
echo &quot;Command-line argument #3 = $3&quot;<br>
set `uname -a` # Sets the positional parameters to the output<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# of the command `uname -a`<br>
echo<br>
echo +++++<br>
Chapter 15. Internal Commands and Builtins<br>
197<br>
<hr>
<A name=204></a>Advanced Bash-Scripting Guide<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp;# +++++<br>
# Flags set in script.<br>
echo $- &nbsp; &nbsp; &nbsp; &nbsp;# hB<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Anomalous behavior?<br>
echo<br>
echo &quot;Positional parameters after &nbsp;set \`uname -a\` :&quot;<br>
# $1, $2, $3, etc. reinitialized to result of `uname -a`<br>
echo &quot;Field #1 of 'uname -a' = $1&quot;<br>
echo &quot;Field #2 of 'uname -a' = $2&quot;<br>
echo &quot;Field #3 of 'uname -a' = $3&quot;<br>
echo \#\#\#<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp;# ###<br>
echo<br>
exit 0<br>
More fun with positional parameters.<br>
<b>Example 15-17. Reversing the positional parameters</b><br>
#!/bin/bash<br>
# revposparams.sh: Reverse positional parameters.<br>
# Script by Dan Jacobson, with stylistic revisions by document author.<br>
set a\ b c d\ e;<br>
# &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; Spaces escaped&nbsp;<br>
# &nbsp; &nbsp; &nbsp; ^ ^ &nbsp; &nbsp; &nbsp; &nbsp;Spaces not escaped<br>
OIFS=$IFS; IFS=:;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; Saving old IFS and setting new one.<br>
echo<br>
until [ $# -eq 0 ]<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp; &nbsp;Step through positional parameters.<br>
&nbsp; echo &quot;### k0 = &quot;$k&quot;&quot; &nbsp; &nbsp; # Before<br>
&nbsp; k=$1:$k; &nbsp;# &nbsp; &nbsp; &nbsp;Append each pos param to loop variable.<br>
# &nbsp; &nbsp; ^<br>
&nbsp; echo &quot;### k = &quot;$k&quot;&quot; &nbsp; &nbsp; &nbsp;# After<br>
&nbsp; echo<br>
&nbsp; shift;<br>
done<br>
set $k &nbsp;# &nbsp;Set new positional parameters.<br>
echo -<br>
echo $# # &nbsp;Count of positional parameters.<br>
echo -<br>
echo<br>
for i &nbsp; # &nbsp;Omitting the &quot;in list&quot; sets the variable -- i --<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ to the positional parameters.<br>
do<br>
&nbsp; echo $i &nbsp;# Display new positional parameters.<br>
done<br>
IFS=$OIFS &nbsp;# Restore IFS.<br>
# &nbsp;Question:<br>
# &nbsp;Is it necessary to set an new IFS, internal field separator,<br>
#+ in order for this script to work properly?<br>
Chapter 15. Internal Commands and Builtins<br>
198<br>
<hr>
<A name=205></a>Advanced Bash-Scripting Guide<br>
# &nbsp;What happens if you don't? Try it.<br>
# &nbsp;And, why use the new IFS -- a colon -- in line 17,<br>
#+ to append to the loop variable?<br>
# &nbsp;What is the purpose of this?<br>
exit 0<br>
$ ./revposparams.sh<br>
### k0 =&nbsp;<br>
### k = a b<br>
### k0 = a b<br>
### k = c a b<br>
### k0 = c a b<br>
### k = d e c a b<br>
-<br>
3<br>
-<br>
d e<br>
c<br>
a b<br>
Invoking<b>&nbsp;set</b><a href="abs-guides.html#41">&nbsp;without any options or arguments simply lists all the environmental and other variables<br></a>that have been initialized.<br>
bash$&nbsp;<b>set<br></b>AUTHORCOPY=/home/bozo/posts<br>
&nbsp;BASH=/bin/bash<br>
&nbsp;BASH_VERSION=$'2.05.8(1)-release'<br>
&nbsp;...<br>
&nbsp;XAUTHORITY=/home/bozo/.Xauthority<br>
&nbsp;_=/etc/bashrc<br>
&nbsp;variable22=abc<br>
&nbsp;variable23=xzy<br>
Using<b>&nbsp;set</b>&nbsp;with the&nbsp;--&nbsp;option explicitly assigns the contents of a variable to the positional parameters.<br>If no variable follows the&nbsp;--&nbsp;it<i>&nbsp;unsets</i>&nbsp;the positional parameters.<br>
<b>Example 15-18. Reassigning the positional parameters</b><br>
#!/bin/bash<br>
variable=&quot;one two three four five&quot;<br>
set -- $variable<br>
# Sets positional parameters to the contents of &quot;$variable&quot;.<br>
first_param=$1<br>
second_param=$2<br>
shift; shift &nbsp; &nbsp; &nbsp; &nbsp;# Shift past first two positional params.<br>
# shift 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; also works.<br>
remaining_params=&quot;$*&quot;<br>
echo<br>
echo &quot;first parameter = $first_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # one<br>
Chapter 15. Internal Commands and Builtins<br>
199<br>
<hr>
<A name=206></a><IMG src="abs-guide-206_1.png"><br>
Advanced Bash-Scripting Guide<br>
echo &quot;second parameter = $second_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # two<br>
echo &quot;remaining parameters = $remaining_params&quot; &nbsp; # three four five<br>
echo; echo<br>
# Again.<br>
set -- $variable<br>
first_param=$1<br>
second_param=$2<br>
echo &quot;first parameter = $first_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # one<br>
echo &quot;second parameter = $second_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # two<br>
# ======================================================<br>
set --<br>
# Unsets positional parameters if no variable specified.<br>
first_param=$1<br>
second_param=$2<br>
echo &quot;first parameter = $first_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (null value)<br>
echo &quot;second parameter = $second_param&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (null value)<br>
exit 0<br>
<a href="abs-guides.html#145">See also Example 11-2 and Example 16-56.</a><br>
<b>unset</b><br>
The<b>&nbsp;unset</b>&nbsp;command deletes a shell variable, effectively setting it to<i>&nbsp;null</i>. Note that this command<br>does not affect positional parameters.<br>
bash$&nbsp;<b>unset PATH</b><br>
bash$&nbsp;<b>echo $PATH</b><br>
bash$&nbsp;<br>
<b>Example 15-19. &quot;Unsetting&quot; a variable</b><br>
#!/bin/bash<br>
# unset.sh: Unsetting a variable.<br>
variable=hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Initialized.<br>
echo &quot;variable = $variable&quot;<br>
unset variable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Unset.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;In this particular context,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ same effect as: &nbsp; variable=<br>
echo &quot;(unset) variable = $variable&quot; &nbsp;# &nbsp;$variable is null.<br>
if [ -z &quot;$variable&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Try a string-length test.<br>
then<br>
&nbsp; echo &quot;\$variable has zero length.&quot;<br>
fi<br>
exit 0<br>
In most contexts, an<i>&nbsp;undeclared</i>&nbsp;variable and one that has been<i>&nbsp;unset</i>&nbsp;are equivalent.<br><a href="abs-guides.html#134">However, the &nbsp;${parameter:-default} parameter substitution construct can distinguish<br></a>between the two.<br>
<b>export</b><br>
Chapter 15. Internal Commands and Builtins<br>
200<br>
<hr>
<A name=207></a><IMG src="abs-guide-207_1.png"><br>
<IMG src="abs-guide-207_2.png"><br>
Advanced Bash-Scripting Guide<br>
The<b>&nbsp;export&nbsp;</b>[60] command makes available variables to all child processes of the running script or<br>shell. One important use of the<b>&nbsp;export</b><a href="abs-guides.html#793">&nbsp;command is in startup files, to initialize and make accessible<br></a><a href="abs-guides.html#41">environmental variables to subsequent user processes.</a><br>
<a href="abs-guides.html#494">Unfortunately, &nbsp;there is no way to export variables back to the parent process, to the<br></a>process that called or invoked the script or shell.<br>
<b>Example 15-20. Using<i>&nbsp;export</i></b><b>&nbsp;to pass a variable to an embedded<i>&nbsp;awk</i></b><b>&nbsp;script</b><br>
#!/bin/bash<br>
# &nbsp;Yet another version of the &quot;column totaler&quot; script (col-totaler.sh)<br>
#+ that adds up a specified column (of numbers) in the target file.<br>
# &nbsp;This uses the environment to pass a script variable to 'awk' . . .<br>
#+ and places the awk script in a variable.<br>
ARGS=2<br>
E_WRONGARGS=85<br>
if [ $# -ne &quot;$ARGS&quot; ] # Check for proper number of command-line args.<br>
then<br>
&nbsp; &nbsp;echo &quot;Usage: `basename $0` filename column-number&quot;<br>
&nbsp; &nbsp;exit $E_WRONGARGS<br>
fi<br>
filename=$1<br>
column_number=$2<br>
#===== Same as original script, up to this point =====#<br>
export column_number<br>
# Export column number to environment, so it's available for retrieval.<br>
# -----------------------------------------------<br>
awkscript='{ total += $ENVIRON[&quot;column_number&quot;] }<br>
END { print total }'<br>
# Yes, a variable can hold an awk script.<br>
# -----------------------------------------------<br>
# Now, run the awk script.<br>
awk &quot;$awkscript&quot; &quot;$filename&quot;<br>
# Thanks, Stephane Chazelas.<br>
exit 0<br>
It is possible to initialize and export variables in the same operation, as in<b>&nbsp;export<br>var1=xxx</b>.<br>
However, as Greg Keraunen points out, in certain situations this may have a different<br>effect than setting a variable, then exporting it.<br>
bash$&nbsp;<b>export var=(a b); echo ${var[0]}<br></b>(a b)<br>
Chapter 15. Internal Commands and Builtins<br>
201<br>
<hr>
<A name=208></a><IMG src="abs-guide-208_1.png"><br>
<IMG src="abs-guide-208_2.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>var=(a b); export var; echo ${var[0]}<br></b>a<br>
<a href="abs-guides.html#817">A variable to be exported may require special treatment. See Example L-2.</a><br>
<b>declare</b>,<b>&nbsp;typeset</b><br>
<a href="abs-guides.html#110">The declare and typeset commands specify and/or restrict properties of variables.</a><br>
<b>readonly</b><br>
<a href="abs-guides.html#110">Same as declare -r, sets a variable as read-only, or, in effect, as a constant. Attempts to change the<br></a>variable fail with an error message. This is the shell analog of the<i>&nbsp;C</i>&nbsp;language<b>&nbsp;const</b>&nbsp;type qualifier.<br>
<b>getopts</b><br>
This powerful tool parses command-line arguments passed to the script. This is the Bash analog of the<br><a href="abs-guides.html#309">getopt external command and the</a><i>&nbsp;getopt</i>&nbsp;library function familiar to<i>&nbsp;C</i>&nbsp;programmers. It permits<br>passing and concatenating multiple options&nbsp;[61] and associated arguments to a script (for example<br><b>scriptname -abc -e /usr/local</b>).<br>
The<b>&nbsp;getopts</b>&nbsp;construct uses two implicit variables.&nbsp;$OPTIND&nbsp;is the argument pointer (<i>OPTion INDex</i>)<br>and&nbsp;$OPTARG&nbsp;(<i>OPTion ARGument</i>) the (optional) argument attached to an option. A colon following<br>the option name in the declaration tags that option as having an associated argument.<br>
A<b>&nbsp;getopts</b><a href="abs-guides.html#153">&nbsp;construct usually comes packaged in a while loop, which processes the options and<br></a>arguments one at a time, then increments the implicit&nbsp;$OPTIND&nbsp;variable to point to the next.<br>
The arguments passed from the command-line to the script must be preceded<br>
1.&nbsp;<br>
by a dash (-). It is the prefixed&nbsp;-&nbsp;that lets<b>&nbsp;getopts</b>&nbsp;recognize command-line<br>arguments as<i>&nbsp;options</i>. In fact,<b>&nbsp;getopts</b>&nbsp;will not process arguments without the<br>prefixed&nbsp;-, and will terminate option processing at the first argument<br>encountered lacking them.<br>The<br>
2.&nbsp;<br>
<b>&nbsp;getopts</b><a href="abs-guides.html#153">&nbsp;template differs slightly from the standard while loop, in that it</a><br>
lacks condition brackets.<br>The<br>
3.&nbsp;<br>
<b>&nbsp;getopts</b>&nbsp;construct is a highly functional replacement for the traditional<br>
<a href="abs-guides.html#309">getopt external command.</a><br>
while getopts &quot;:abcde:fg&quot; Option<br>
# Initial declaration.<br>
# a, b, c, d, e, f, and g are the options (flags) expected.<br>
# The : after option 'e' shows it will have an argument passed with it.<br>
do<br>
&nbsp; case $Option in<br>
&nbsp; &nbsp; a ) # Do something with variable 'a'.<br>
&nbsp; &nbsp; b ) # Do something with variable 'b'.<br>
&nbsp; &nbsp; ...<br>
&nbsp; &nbsp; e) &nbsp;# Do something with 'e', and also with $OPTARG,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # which is the associated argument passed with option 'e'.<br>
&nbsp; &nbsp; ...<br>
&nbsp; &nbsp; g ) # Do something with variable 'g'.<br>
&nbsp; esac<br>
done<br>
Chapter 15. Internal Commands and Builtins<br>
202<br>
<hr>
<A name=209></a>Advanced Bash-Scripting Guide<br>
shift $(($OPTIND - 1))<br>
# Move argument pointer to next.<br>
# All this is not nearly as complicated as it looks &lt;grin&gt;.<br>
<b>Example 15-21. Using<i>&nbsp;getopts</i></b><b>&nbsp;to read the options/arguments passed to a script</b><br>
#!/bin/bash<br>
# ex33.sh: Exercising getopts and OPTIND<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Script modified 10/09/03 at the suggestion of Bill Gradwohl.<br>
# Here we observe how 'getopts' processes command-line arguments to script.<br>
# The arguments are parsed as &quot;options&quot; (flags) and associated arguments.<br>
# Try invoking this script with:<br>
# &nbsp; 'scriptname -mn'<br>
# &nbsp; 'scriptname -oq qOption' (qOption can be some arbitrary string.)<br>
# &nbsp; 'scriptname -qXXX -r'<br>
#<br>
# &nbsp; 'scriptname -qr'<br>
#+ &nbsp; &nbsp; &nbsp;- Unexpected result, takes &quot;r&quot; as the argument to option &quot;q&quot;<br>
# &nbsp; 'scriptname -q -r'&nbsp;<br>
#+ &nbsp; &nbsp; &nbsp;- Unexpected result, same as above<br>
# &nbsp; 'scriptname -mnop -mnop' &nbsp;- Unexpected result<br>
# &nbsp; (OPTIND is unreliable at stating where an option came from.)<br>
#<br>
# &nbsp;If an option expects an argument (&quot;flag:&quot;), then it will grab<br>
#+ whatever is next on the command-line.<br>
NO_ARGS=0&nbsp;<br>
E_OPTERROR=85<br>
if [ $# -eq &quot;$NO_ARGS&quot; ] &nbsp; &nbsp;# Script invoked with no command-line args?<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` options (-mnopqrs)&quot;<br>
&nbsp; exit $E_OPTERROR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Exit and explain usage.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Usage: scriptname -options<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Note: dash (-) necessary<br>
fi &nbsp;<br>
while getopts &quot;:mnopq:rs&quot; Option<br>
do<br>
&nbsp; case $Option in<br>
&nbsp; &nbsp; m &nbsp; &nbsp; ) echo &quot;Scenario #1: option -m- &nbsp; [OPTIND=${OPTIND}]&quot;;;<br>
&nbsp; &nbsp; n | o ) echo &quot;Scenario #2: option -$Option- &nbsp; [OPTIND=${OPTIND}]&quot;;;<br>
&nbsp; &nbsp; p &nbsp; &nbsp; ) echo &quot;Scenario #3: option -p- &nbsp; [OPTIND=${OPTIND}]&quot;;;<br>
&nbsp; &nbsp; q &nbsp; &nbsp; ) echo &quot;Scenario #4: option -q-\<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with argument \&quot;$OPTARG\&quot; &nbsp; [OPTIND=${OPTIND}]&quot;;;<br>
&nbsp; &nbsp; # &nbsp;Note that option 'q' must have an associated argument,<br>
&nbsp; &nbsp; #+ otherwise it falls through to the default.<br>
&nbsp; &nbsp; r | s ) echo &quot;Scenario #5: option -$Option-&quot;;;<br>
&nbsp; &nbsp; * &nbsp; &nbsp; ) echo &quot;Unimplemented option chosen.&quot;;; &nbsp; # Default.<br>
&nbsp; esac<br>
done<br>
shift $(($OPTIND - 1))<br>
# &nbsp;Decrements the argument pointer so it points to next argument.<br>
# &nbsp;$1 now references the first non-option item supplied on the command-line<br>
#+ if one exists.<br>
Chapter 15. Internal Commands and Builtins<br>
203<br>
<hr>
<A name=210></a>Advanced Bash-Scripting Guide<br>
exit $?<br>
# &nbsp; As Bill Gradwohl states,<br>
# &nbsp;&quot;The getopts mechanism allows one to specify: &nbsp;scriptname -mnop -mnop<br>
#+ &nbsp;but there is no reliable way to differentiate what came<br>
#+ from where by using OPTIND.&quot;<br>
# &nbsp;There are, however, workarounds.<br>
<b>Script Behavior</b><br>
<b>source</b><a href="abs-guides.html#15">, . (dot command)</a><br>
This command, when invoked from the command-line, executes a script. Within a script, a&nbsp;<b>source<br>file-name</b>&nbsp;loads the file&nbsp;file-name.<i>&nbsp;Sourcing</i>&nbsp;a file (dot-command)<i>&nbsp;imports</i>&nbsp;code into the script,<br>appending to the script (same effect as the&nbsp;<b>#include</b>&nbsp;directive in a<i>&nbsp;C</i>&nbsp;program). The net result is the<br>same as if the &quot;sourced&quot; lines of code were physically present in the body of the script. This is useful<br>in situations when multiple scripts use a common data file or function library.<br>
<b>Example 15-22. &quot;Including&quot; a data file</b><br>
#!/bin/bash<br>
. data-file &nbsp; &nbsp;# Load a data file.<br>
# Same effect as &quot;source data-file&quot;, but more portable.<br>
# &nbsp;The file &quot;data-file&quot; must be present in current working directory,<br>
#+ since it is referred to by its 'basename'.<br>
# Now, reference some data from that file.<br>
echo &quot;variable1 (from data-file) = $variable1&quot;<br>
echo &quot;variable3 (from data-file) = $variable3&quot;<br>
let &quot;sum = $variable2 + $variable4&quot;<br>
echo &quot;Sum of variable2 + variable4 (from data-file) = $sum&quot;<br>
echo &quot;message1 (from data-file) is \&quot;$message1\&quot;&quot;<br>
# Note: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;escaped quotes<br>
print_message This is the message-print function in the data-file.<br>
exit 0<br>
File&nbsp;data-file<a href="abs-guides.html#210">&nbsp;for Example 15-22, above. Must be present in same directory.</a><br>
# This is a data file loaded by a script.<br>
# Files of this type may contain variables, functions, etc.<br>
# It may be loaded with a 'source' or '.' command by a shell script.<br>
# Let's initialize some variables.<br>
variable1=22<br>
variable2=474<br>
variable3=5<br>
variable4=97<br>
message1=&quot;Hello, how are you?&quot;<br>
message2=&quot;Enough for now. Goodbye.&quot;<br>
Chapter 15. Internal Commands and Builtins<br>
204<br>
<hr>
<A name=211></a>Advanced Bash-Scripting Guide<br>
print_message ()<br>
{<br>
# Echoes any message passed to it.<br>
&nbsp; if [ -z &quot;$1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return 1<br>
&nbsp; &nbsp; # Error, if argument missing.<br>
&nbsp; fi<br>
&nbsp; echo<br>
&nbsp; until [ -z &quot;$1&quot; ]<br>
&nbsp; do<br>
&nbsp; &nbsp; # Step through arguments passed to function.<br>
&nbsp; &nbsp; echo -n &quot;$1&quot;<br>
&nbsp; &nbsp; # Echo args one at a time, suppressing line feeds.<br>
&nbsp; &nbsp; echo -n &quot; &quot;<br>
&nbsp; &nbsp; # Insert spaces between words.<br>
&nbsp; &nbsp; shift<br>
&nbsp; &nbsp; # Next one.<br>
&nbsp; done &nbsp;<br>
&nbsp; echo<br>
&nbsp; return 0<br>
} &nbsp;<br>
If the<i>&nbsp;sourced</i>&nbsp;file is itself an executable script, then it will run, then return control to the script that<br>called it. A<i>&nbsp;sourced</i><a href="abs-guides.html#407">&nbsp;executable script may use a return for this purpose.</a><br>
Arguments may be (optionally) passed to the<i>&nbsp;sourced</i><a href="abs-guides.html#42">&nbsp;file as positional parameters.</a><br>
source $filename $arg1 arg2<br>
It is even possible for a script to<i>&nbsp;source</i>&nbsp;itself, though this does not seem to have any practical<br>applications.<br>
<b>Example 15-23. A (useless) script that sources itself</b><br>
#!/bin/bash<br>
# self-source.sh: a script sourcing itself &quot;recursively.&quot;<br>
# From &quot;Stupid Script Tricks,&quot; Volume II.<br>
MAXPASSCNT=100 &nbsp; &nbsp;# Maximum number of execution passes.<br>
echo -n &nbsp;&quot;$pass_count &nbsp;&quot;<br>
# &nbsp;At first execution pass, this just echoes two blank spaces,<br>
#+ since $pass_count still uninitialized.<br>
let &quot;pass_count += 1&quot;<br>
# &nbsp;Assumes the uninitialized variable $pass_count<br>
#+ can be incremented the first time around.<br>
# &nbsp;This works with Bash and pdksh, but<br>
#+ it relies on non-portable (and possibly dangerous) behavior.<br>
# &nbsp;Better would be to initialize $pass_count to 0 before incrementing.<br>
while [ &quot;$pass_count&quot; -le $MAXPASSCNT ]<br>
Chapter 15. Internal Commands and Builtins<br>
205<br>
<hr>
<A name=212></a><IMG src="abs-guide-212_1.png"><br>
<IMG src="abs-guide-212_2.png"><br>
Advanced Bash-Scripting Guide<br>
do<br>
&nbsp; . $0 &nbsp; # Script &quot;sources&quot; itself, rather than calling itself.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ./$0 (which would be true recursion) doesn't work here. Why?<br>
done &nbsp;<br>
# &nbsp;What occurs here is not actually recursion,<br>
#+ since the script effectively &quot;expands&quot; itself, i.e.,<br>
#+ generates a new section of code<br>
#+ with each pass through the 'while' loop',<br>
# &nbsp;with each 'source' in line 20.<br>
#<br>
# &nbsp;Of course, the script interprets each newly 'sourced' &quot;#!&quot; line<br>
#+ as a comment, and not as the start of a new script.<br>
echo<br>
exit 0 &nbsp; # The net effect is counting from 1 to 100.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Very impressive.<br>
# Exercise:<br>
# --------<br>
# Write a script that uses this trick to actually do something useful.<br>
<b>exit</b><br>
Unconditionally terminates a script.&nbsp;[62] The<b>&nbsp;exit</b>&nbsp;command may optionally take an integer argument,<br><a href="abs-guides.html#57">which is returned to the shell as the exit status of the script. It is good practice to end all but the<br></a>simplest scripts with an&nbsp;<b>exit 0</b>, indicating a successful run.<br>
If a script terminates with an<b>&nbsp;exit</b>&nbsp;lacking an argument, the exit status of the script is<br>the exit status of the last command executed in the script, not counting the<b>&nbsp;exit</b>. This is<br>equivalent to an<b>&nbsp;exit $?</b>.<br>
An<b>&nbsp;exit</b><a href="abs-guides.html#387">&nbsp;command may also be used to terminate a subshell.</a><br>
<b>exec</b><br>
This shell builtin replaces the current process with a specified command. Normally, when the shell<br><a href="abs-guides.html#186">encounters a command, it forks off a child process to actually execute the command. Using the</a><b>&nbsp;exec<br></b>builtin, the shell does not fork, and the command<i>&nbsp;exec</i>'ed replaces the shell. When used in a script,<br>therefore, it forces an exit from the script when the<b>&nbsp;exec</b>'ed command terminates.&nbsp;[63]<br>
<b>Example 15-24. Effects of<i>&nbsp;exec</i></b><br>
#!/bin/bash<br>
exec echo &quot;Exiting \&quot;$0\&quot;.&quot; &nbsp; # Exit from script here.<br>
# ----------------------------------<br>
# The following lines never execute.<br>
echo &quot;This echo will never echo.&quot;<br>
exit 99 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This script will not exit here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Check exit value after script terminates<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ with an 'echo $?'.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;It will *not* be 99.<br>
<b>Example 15-25. A script that<i>&nbsp;exec's</i></b><b>&nbsp;itself</b><br>
Chapter 15. Internal Commands and Builtins<br>
206<br>
<hr>
<A name=213></a><IMG src="abs-guide-213_1.png"><br>
Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# self-exec.sh<br>
# Note: Set permissions on this script to 555 or 755,<br>
# &nbsp; &nbsp; &nbsp; then call it with ./self-exec.sh or sh ./self-exec.sh.<br>
echo<br>
echo &quot;This line appears ONCE in the script, yet it keeps echoing.&quot;<br>
echo &quot;The PID of this instance of the script is still $$.&quot;<br>
# &nbsp; &nbsp; Demonstrates that a subshell is not forked off.<br>
echo &quot;==================== Hit Ctl-C to exit ====================&quot;<br>
sleep 1<br>
exec $0 &nbsp; # &nbsp;Spawns another instance of this same script<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ that replaces the previous one.<br>
echo &quot;This line will never echo!&quot; &nbsp;# Why not?<br>
exit 99 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Will not exit here!<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Exit code will not be 99!<br>
An<b>&nbsp;exec</b><a href="abs-guides.html#377">&nbsp;also serves to reassign file descriptors. For example,&nbsp;</a><b>exec &lt;zzz-file</b>&nbsp;replaces&nbsp;stdin<br>with the file&nbsp;zzz-file.<br>
The&nbsp;-exec<a href="abs-guides.html#225">&nbsp;option to find is&nbsp;</a><i>not</i>&nbsp;the same as the<b>&nbsp;exec</b>&nbsp;shell builtin.<br>
<b>shopt</b><br>
This command permits changing<i>&nbsp;shell options</i><a href="abs-guides.html#421">&nbsp;on the fly (see Example 25-1 and Example 25-2). It<br></a><a href="abs-guides.html#793">often appears in the Bash startup files, but also has its uses in scripts. Needs version 2 or later of Bash.</a><br>
shopt -s cdspell<br>
# Allows minor misspelling of directory names with 'cd'<br>
# Option -s sets, -u unsets.<br>
cd /hpme &nbsp;# Oops! Mistyped '/home'.<br>
pwd &nbsp; &nbsp; &nbsp; # /home<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The shell corrected the misspelling.<br>
<b>caller</b><br>
Putting a<b>&nbsp;caller</b><a href="abs-guides.html#399">&nbsp;command inside a function echoes to&nbsp;</a>stdout&nbsp;information about the<i>&nbsp;caller</i>&nbsp;of that<br>function.<br>
#!/bin/bash<br>
function1 ()<br>
{<br>
&nbsp; # Inside function1 ().<br>
&nbsp; caller 0 &nbsp; # Tell me about it.<br>
}<br>
function1 &nbsp; &nbsp;# Line 9 of script.<br>
# 9 main test.sh<br>
# ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Line number that the function was called from.<br>
# &nbsp; ^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Invoked from &quot;main&quot; part of script.<br>
# &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^ &nbsp; &nbsp;Name of calling script.<br>
caller 0 &nbsp; &nbsp; # Has no effect because it's not inside a function.<br>
Chapter 15. Internal Commands and Builtins<br>
207<br>
<hr>
<A name=214></a>Advanced Bash-Scripting Guide<br>
A<b>&nbsp;caller</b>&nbsp;command can also return<i>&nbsp;caller</i><a href="abs-guides.html#210">&nbsp;information from a script sourced within another script.<br></a>Analogous to a function, this is a &quot;subroutine call.&quot;<br>
You may find this command useful in debugging.<br>
<b>Commands</b><br>
<b>true</b><br>
<a href="abs-guides.html#57">A command that returns a successful (zero) exit status, but does nothing else.</a><br>
bash$&nbsp;<b>true<br></b>bash$&nbsp;<b>echo $?<br></b>0<br>
# Endless loop<br>
while true &nbsp; # alias for &quot;:&quot;<br>
do<br>
&nbsp; &nbsp;operation-1<br>
&nbsp; &nbsp;operation-2<br>
&nbsp; &nbsp;...<br>
&nbsp; &nbsp;operation-n<br>
&nbsp; &nbsp;# Need a way to break out of loop or script will hang.<br>
done<br>
<b>false</b><br>
<a href="abs-guides.html#57">A command that returns an unsuccessful exit status, but does nothing else.</a><br>
bash$&nbsp;<b>false<br></b>bash$&nbsp;<b>echo $?<br></b>1<br>
# Testing &quot;false&quot;&nbsp;<br>
if false<br>
then<br>
&nbsp; echo &quot;false evaluates \&quot;true\&quot;&quot;<br>
else<br>
&nbsp; echo &quot;false evaluates \&quot;false\&quot;&quot;<br>
fi<br>
# false evaluates &quot;false&quot;<br>
# Looping while &quot;false&quot; (null loop)<br>
while false<br>
do<br>
&nbsp; &nbsp;# The following code will not execute.<br>
&nbsp; &nbsp;operation-1<br>
&nbsp; &nbsp;operation-2<br>
&nbsp; &nbsp;...<br>
&nbsp; &nbsp;operation-n<br>
&nbsp; &nbsp;# Nothing happens!<br>
done &nbsp;&nbsp;<br>
<b>type [cmd]</b><br>
<a href="abs-guides.html#268">Similar to the which external command,</a><b>&nbsp;type cmd</b>&nbsp;identifies &quot;cmd.&quot; Unlike<b>&nbsp;which</b>,<b>&nbsp;type</b>&nbsp;is a Bash<br>builtin. The useful&nbsp;-a&nbsp;option to<b>&nbsp;type</b>&nbsp;identifies&nbsp;<i>keywords</i>&nbsp;and&nbsp;<i>builtins</i>, and also locates system<br>commands with identical names.<br>
Chapter 15. Internal Commands and Builtins<br>
208<br>
<hr>
<A name=215></a><IMG src="abs-guide-215_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>type '['<br></b>[ is a shell builtin<br>
bash$&nbsp;<b>type -a '['<br></b>[ is a shell builtin<br>
&nbsp;[ is /usr/bin/[<br>
bash$&nbsp;<b>type type<br></b>type is a shell builtin<br>
The<b>&nbsp;type</b><a href="abs-guides.html#23">&nbsp;command can be useful for testing whether a certain command exists.</a><br>
<b>hash [cmds]</b><br>
Records the<i>&nbsp;path</i>&nbsp;name of specified commands -- in the shell<i>&nbsp;hash table&nbsp;</i>[64] -- so the shell or script<br><a href="abs-guides.html#96">will not need to search the $PATH on subsequent calls to those commands. When</a><b>&nbsp;hash</b>&nbsp;is called with<br>no arguments, it simply lists the commands that have been hashed. The&nbsp;-r&nbsp;option resets the hash<br>table.<br>
<b>bind</b><br>
The<b>&nbsp;bind</b>&nbsp;builtin displays or modifies<i>&nbsp;readline&nbsp;</i>[65] key bindings.<br>
<b>help</b><br>
<a href="abs-guides.html#268">Gets a short usage summary of a shell builtin. This is the counterpart to whatis, but for builtins. The<br></a>display of<i>&nbsp;help</i><a href="abs-guides.html#549">&nbsp;information got a much-needed update in the version 4 release of Bash.</a><br>
bash$&nbsp;<b>help exit<br></b>exit: exit [n]<br>
&nbsp; &nbsp; Exit the shell with a status of N. &nbsp;If N is omitted, the exit status<br>
&nbsp; &nbsp; is that of the last command executed.<br>
<b>15.1. Job Control Commands</b><br>
Certain of the following job control commands take a<i>&nbsp;job identifier</i><a href="abs-guides.html#219">&nbsp;as an argument. See the table at end of the<br></a>chapter.<br>
<b>jobs</b><br>
Lists the jobs running in the background, giving the<i>&nbsp;job number</i><a href="abs-guides.html#335">. Not as useful as ps.</a><br>
It is all too easy to confuse<i>&nbsp;jobs</i>&nbsp;and<i>&nbsp;processes</i><a href="abs-guides.html#186">. Certain builtins, such as</a><b>&nbsp;kill</b>,<b>&nbsp;disown</b>,<br>and<b>&nbsp;wait</b><a href="abs-guides.html#215">&nbsp;accept either a job number or a process number as an argument. The fg, bg<br></a>and<b>&nbsp;jobs</b>&nbsp;commands accept only a job number.<br>
bash$&nbsp;<b>sleep 100 &amp;<br></b>[1] 1384<br>
bash $&nbsp;<b>jobs<br></b>[1]+ &nbsp;Running &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sleep 100 &amp;<br>
<a href="abs-guides.html#98">&quot;1&quot; is the job number (jobs are maintained by the current shell). &quot;1384&quot; is the PID or<br></a><i>process ID number</i>&nbsp;(processes are maintained by the system). To kill this job/process,<br>either a<b>&nbsp;kill %1</b>&nbsp;or a<b>&nbsp;kill 1384</b>&nbsp;works.<br>
<i>Thanks, S.C.</i><br>
<b>disown</b><br>
Remove job(s) from the shell's table of active jobs.<br>
<b>fg</b>,&nbsp;<b>bg</b><br>
Chapter 15. Internal Commands and Builtins<br>
209<br>
<hr>
<A name=216></a><IMG src="abs-guide-216_1.png"><br>
Advanced Bash-Scripting Guide<br>
The<b>&nbsp;fg</b>&nbsp;command switches a job running in the background into the foreground. The<b>&nbsp;bg</b>&nbsp;command<br>restarts a suspended job, and runs it in the background. If no job number is specified, then the<b>&nbsp;fg</b>&nbsp;or<b>&nbsp;bg<br></b>command acts upon the currently running job.<br>
<b>wait</b><br>
Suspend script execution until all jobs running in background have terminated, or until the job number<br><a href="abs-guides.html#57">or process ID specified as an option terminates. Returns the exit status of waited-for command.</a><br>
You may use the<b>&nbsp;wait</b>&nbsp;command to prevent a script from exiting before a background job finishes<br><a href="abs-guides.html#218">executing (this would create a dreaded orphan process).</a><br>
<b>Example 15-26. Waiting for a process to finish before proceeding</b><br>
#!/bin/bash<br>
ROOT_UID=0 &nbsp; # Only users with $UID 0 have root privileges.<br>
E_NOTROOT=65<br>
E_NOPARAMS=66<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo &quot;Must be root to run this script.&quot;<br>
&nbsp; # &quot;Run along kid, it's past your bedtime.&quot;<br>
&nbsp; exit $E_NOTROOT<br>
fi &nbsp;<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` find-string&quot;<br>
&nbsp; exit $E_NOPARAMS<br>
fi<br>
echo &quot;Updating 'locate' database...&quot;<br>
echo &quot;This may take a while.&quot;<br>
updatedb /usr &amp; &nbsp; &nbsp; # Must be run as root.<br>
wait<br>
# Don't run the rest of the script until 'updatedb' finished.<br>
# You want the the database updated before looking up the file name.<br>
locate $1<br>
# &nbsp;Without the 'wait' command, in the worse case scenario,<br>
#+ the script would exit while 'updatedb' was still running,<br>
#+ leaving it as an orphan process.<br>
exit 0<br>
Optionally,<b>&nbsp;wait</b>&nbsp;can take a<i>&nbsp;job identifier</i>&nbsp;as an argument, for example,&nbsp;<i>wait%1</i>&nbsp;or&nbsp;<i>wait $PPID</i>.<br><a href="abs-guides.html#219">[66] See the job id table.</a><br>
Within a script, running a command in the background with an ampersand (&amp;) may cause the script to hang until<br><b>ENTER</b>&nbsp;is hit. This seems to occur with commands that write to&nbsp;stdout. It can be a major annoyance.<br>
#!/bin/bash<br>
# test.sh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
Chapter 15. Internal Commands and Builtins<br>
210<br>
<hr>
<A name=217></a>Advanced Bash-Scripting Guide<br>
ls -l &amp;<br>
echo &quot;Done.&quot;<br>
bash$&nbsp;<b>./test.sh<br></b>Done.<br>
&nbsp;[bozo@localhost test-scripts]$ total 1<br>
&nbsp;-rwxr-xr-x &nbsp; &nbsp;1 bozo &nbsp; &nbsp; bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 34 Oct 11 15:09 test.sh<br>
&nbsp;_<br>
&nbsp; &nbsp; As Walter Brameld IV explains it:<br>
&nbsp; &nbsp; As far as I can tell, such scripts don't actually hang. It just<br>
&nbsp; &nbsp; seems that they do because the background command writes text to<br>
&nbsp; &nbsp; the console after the prompt. The user gets the impression that<br>
&nbsp; &nbsp; the prompt was never displayed. Here's the sequence of events:<br>
&nbsp; &nbsp; 1. Script launches background command.<br>
&nbsp; &nbsp; 2. Script exits.<br>
&nbsp; &nbsp; 3. Shell displays the prompt.<br>
&nbsp; &nbsp; 4. Background command continues running and writing text to the<br>
&nbsp; &nbsp; &nbsp; &nbsp;console.<br>
&nbsp; &nbsp; 5. Background command finishes.<br>
&nbsp; &nbsp; 6. User doesn't see a prompt at the bottom of the output, thinks script<br>
&nbsp; &nbsp; &nbsp; &nbsp;is hanging.<br>
Placing a<b>&nbsp;wait</b>&nbsp;after the background command seems to remedy this.<br>
#!/bin/bash<br>
# test.sh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
ls -l &amp;<br>
echo &quot;Done.&quot;<br>
wait<br>
bash$&nbsp;<b>./test.sh<br></b>Done.<br>
&nbsp;[bozo@localhost test-scripts]$ total 1<br>
&nbsp;-rwxr-xr-x &nbsp; &nbsp;1 bozo &nbsp; &nbsp; bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 34 Oct 11 15:09 test.sh<br>
<a href="abs-guides.html#374">Redirecting the output of the command to a file or even to&nbsp;</a>/dev/null&nbsp;also takes care of this problem.<br>
<b>suspend</b><br>
This has a similar effect to<b>&nbsp;Control</b>-<b>Z</b>, but it suspends the shell (the shell's parent process should<br>resume it at an appropriate time).<br>
<b>logout</b><br>
<a href="abs-guides.html#57">Exit a login shell, optionally specifying an exit status.</a><br>
<b>times</b><br>
Gives statistics on the system time elapsed when executing commands, in the following form:<br>
0m0.020s 0m0.020s<br>
This capability is of relatively limited value, since it is not common to profile and benchmark shell<br>scripts.<br>
<b>kill</b><br>
Forcibly terminate a process by sending it an appropriate<i>&nbsp;terminate</i><a href="abs-guides.html#336">&nbsp;signal (see Example 17-6).</a><br>
Chapter 15. Internal Commands and Builtins<br>
211<br>
<hr>
<A name=218></a><IMG src="abs-guide-218_1.png"><br>
<IMG src="abs-guide-218_2.png"><br>
<IMG src="abs-guide-218_3.png"><br>
Advanced Bash-Scripting Guide<br>
<b>Example 15-27. A script that kills itself</b><br>
#!/bin/bash<br>
# self-destruct.sh<br>
kill $$ &nbsp;# Script kills its own process here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Recall that &quot;$$&quot; is the script's PID.<br>
echo &quot;This line will not echo.&quot;<br>
# Instead, the shell sends a &quot;Terminated&quot; message to stdout.<br>
exit 0 &nbsp; # Normal exit? No!<br>
# &nbsp;After this script terminates prematurely,<br>
#+ what exit status does it return?<br>
#<br>
# sh self-destruct.sh<br>
# echo $?<br>
# 143<br>
#<br>
# 143 = 128 + 15<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TERM signal<br>
<b>kill -l</b><a href="abs-guides.html#479">&nbsp;lists all the signals (as does the file&nbsp;</a>/usr/include/asm/signal.h).<br>A&nbsp;<b>kill -9</b>&nbsp;is a<i>&nbsp;sure kill</i>, which will usually terminate a process that stubbornly<br>refuses to die with a plain<b>&nbsp;kill</b>. Sometimes, a&nbsp;<b>kill -15</b>&nbsp;works. A<i>&nbsp;zombie</i>&nbsp;process,<br><a href="abs-guides.html#186">that is, a child process that has terminated, but that the parent process has not (yet)<br></a>killed, cannot be killed by a logged-on user -- you can't kill something that is already<br>dead -- but<b>&nbsp;init</b>&nbsp;will generally clean it up sooner or later.<br>
<b>killall</b><br>
The<b>&nbsp;killall</b>&nbsp;command kills a running process by<i>&nbsp;name</i><a href="abs-guides.html#19">, rather than by process ID. If there are multiple<br></a>instances of a particular command running, then doing a<i>&nbsp;killall</i>&nbsp;on that command will terminate them<br><i>all</i>.<br>
This refers to the<b>&nbsp;killall</b>&nbsp;command in&nbsp;/usr/bin,<i>&nbsp;not</i><a href="abs-guides.html#350">&nbsp;the killall script in<br></a>/etc/rc.d/init.d.<br>
<b>command</b><br>
The<b>&nbsp;command</b>&nbsp;directive disables aliases and functions for the command immediately following it.<br>
bash$&nbsp;<b>command ls</b><br>
This is one of three shell directives that effect script command processing. The others<br><a href="abs-guides.html#218">are builtin and enable.</a><br>
<b>builtin</b><br>
Invoking<b>&nbsp;builtin BUILTIN_COMMAND</b>&nbsp;runs the command&nbsp;<i>BUILTIN_COMMAND</i>&nbsp;as a shell<br><a href="abs-guides.html#186">builtin, temporarily disabling both functions and external system commands with the same name.</a><br>
<b>enable</b><br>
This either enables or disables a shell builtin command. As an example,&nbsp;<i>enable -n kill</i>&nbsp;disables<br><a href="abs-guides.html#217">the shell builtin kill, so that when Bash subsequently encounters</a><i>&nbsp;kill</i>, it invokes the external command<br>/bin/kill.<br>
The&nbsp;-a&nbsp;option to<i>&nbsp;enable</i>&nbsp;lists all the shell builtins, indicating whether or not they are enabled. The&nbsp;-f<br>filename&nbsp;option lets<i>&nbsp;enable</i><a href="abs-guides.html#186">&nbsp;load a builtin as a shared library (DLL) module from a properly</a><br>
Chapter 15. Internal Commands and Builtins<br>
212<br>
<hr>
<A name=219></a>Advanced Bash-Scripting Guide<br>
compiled object file.&nbsp;[67].<br>
<b>autoload</b><br>
This is a port to Bash of the<i>&nbsp;ksh</i>&nbsp;autoloader. With<b>&nbsp;autoload</b>&nbsp;in place, a function with an<i>&nbsp;autoload<br></i>declaration will load from an external file at its first invocation.&nbsp;[68] This saves system resources.<br>
Note that<i>&nbsp;autoload</i>&nbsp;is not a part of the core Bash installation. It needs to be loaded in with&nbsp;<i>enable<br>-f</i>&nbsp;(see above).<br>
<b>Table 15-1. Job identifiers</b><br>
<b>Notation&nbsp;Meaning</b><br>
%N<br>
Job number [N]<br>
%S<br>
Invocation (command-line) of job begins with string<i>&nbsp;S</i><br>
%?S<br>
Invocation (command-line) of job contains within it string<i>&nbsp;S</i><br>
%%<br>
&quot;current&quot; job (last job stopped in foreground or started in background)<br>
%+<br>
&quot;current&quot; job (last job stopped in foreground or started in background)<br>
%-<br>
Last job<br>
$!<br>
Last background process<br>
Chapter 15. Internal Commands and Builtins<br>
213<br>
<hr>
<A name=220></a><IMG src="abs-guide-220_1.png"><br>
<b>Chapter 16. External Filters, Programs and<br>Commands</b><br>
Standard UNIX commands make shell scripts more versatile. The power of scripts comes from coupling<br>system commands and shell directives with simple programming constructs.<br>
<b>16.1. Basic Commands</b><br>
<b>The first commands a novice learns</b><br>
<b>ls</b><br>
The basic file &quot;list&quot; command. It is all too easy to underestimate the power of this humble command.<br>For example, using the&nbsp;-R, recursive option,<b>&nbsp;ls</b>&nbsp;provides a tree-like listing of a directory structure.<br>Other useful options are&nbsp;-S, sort listing by file size,&nbsp;-t, sort by file modification time,&nbsp;-b, show<br>escape characters, and&nbsp;-i<a href="abs-guides.html#227">, show file inodes (see Example 16-4).</a><br>
The<i>&nbsp;ls</i><a href="abs-guides.html#57">&nbsp;command returns a non-zero exit status when attempting to list a non-existent<br></a>file.<br>
bash$&nbsp;<b>ls abc<br></b>ls: abc: No such file or directory<br>
bash$&nbsp;<b>echo $?<br></b>2<br>
<b>Example 16-1. Using<i>&nbsp;ls</i></b><b>&nbsp;to create a table of contents for burning a CDR disk</b><br>
#!/bin/bash<br>
# ex40.sh (burn-cd.sh)<br>
# Script to automate burning a CDR.<br>
SPEED=10 &nbsp; &nbsp; &nbsp; &nbsp; # May use higher speed if your hardware supports it.<br>
IMAGEFILE=cdimage.iso<br>
CONTENTSFILE=contents<br>
# DEVICE=/dev/cdrom &nbsp; &nbsp; For older versions of cdrecord<br>
DEVICE=&quot;1,0,0&quot;<br>
DEFAULTDIR=/opt &nbsp;# This is the directory containing the data to be burned.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Make sure it exists.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Exercise: Add a test for this.<br>
# Uses Joerg Schilling's &quot;cdrecord&quot; package:<br>
# http://www.fokus.fhg.de/usr/schilling/cdrecord.html<br>
# &nbsp;If this script invoked as an ordinary user, may need to suid cdrecord<br>
#+ chmod u+s /usr/bin/cdrecord, as root.<br>
# &nbsp;Of course, this creates a security hole, though a relatively minor one.<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; IMAGE_DIRECTORY=$DEFAULTDIR<br>
&nbsp; # Default directory, if not specified on command-line.<br>
Chapter 16. External Filters, Programs and Commands<br>
214<br>
<hr>
<A name=221></a><IMG src="abs-guide-221_1.png"><br>
Advanced Bash-Scripting Guide<br>
else<br>
&nbsp; &nbsp; IMAGE_DIRECTORY=$1<br>
fi<br>
# Create a &quot;table of contents&quot; file.<br>
ls -lRF $IMAGE_DIRECTORY &gt; $IMAGE_DIRECTORY/$CONTENTSFILE<br>
# The &quot;l&quot; option gives a &quot;long&quot; file listing.<br>
# The &quot;R&quot; option makes the listing recursive.<br>
# The &quot;F&quot; option marks the file types (directories get a trailing /).<br>
echo &quot;Creating table of contents.&quot;<br>
# Create an image file preparatory to burning it onto the CDR.<br>
mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY<br>
echo &quot;Creating ISO9660 file system image ($IMAGEFILE).&quot;<br>
# Burn the CDR.<br>
echo &quot;Burning the disk.&quot;<br>
echo &quot;Please be patient, this will take a while.&quot;<br>
wodim -v -isosize dev=$DEVICE $IMAGEFILE<br>
# &nbsp;In newer Linux distros, the &quot;wodim&quot; utility assumes the<br>
#+ functionality of &quot;cdrecord.&quot;<br>
exitcode=$?<br>
echo &quot;Exit code = $exitcode&quot;<br>
exit $exitcode<br>
<b>cat</b>,<b>&nbsp;tac</b><br>
<b>cat</b>, an acronym for<i>&nbsp;concatenate</i>, lists a file to&nbsp;stdout. When combined with redirection (&gt; or &gt;&gt;), it<br>is commonly used to concatenate files.&nbsp;<br>
# Uses of 'cat'<br>
cat filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Lists the file.<br>
cat file.1 file.2 file.3 &gt; file.123 &nbsp; # Combines three files into one.<br>
The&nbsp;-n&nbsp;option to<b>&nbsp;cat</b>&nbsp;inserts consecutive numbers before all lines of the target file(s). The&nbsp;-b&nbsp;option<br>numbers only the non-blank lines. The&nbsp;-v&nbsp;option echoes nonprintable characters, using ^ notation.<br>The&nbsp;-s&nbsp;option squeezes multiple consecutive blank lines into a single blank line.<br>
<a href="abs-guides.html#259">See also Example 16-28 and Example 16-24.</a><br>
<a href="abs-guides.html#24">In a pipe, it may be more efficient to redirect the&nbsp;</a>stdin&nbsp;to a file, rather than to<b>&nbsp;cat<br></b>the file.<br>
cat filename | tr a-z A-Z<br>
tr a-z A-Z &lt; filename &nbsp; # &nbsp;Same effect, but starts one less process,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and also dispenses with the pipe.<br>
<b>tac</b>, is the inverse of<i>&nbsp;cat</i>, listing a file backwards from its end.<br>
<b>rev</b><br>
reverses each line of a file, and outputs to&nbsp;stdout. This does not have the same effect as<b>&nbsp;tac</b>, as it<br>preserves the order of the lines, but flips each one around (mirror image).<br>
bash$&nbsp;<b>cat file1.txt<br></b>This is line 1.<br>
&nbsp;This is line 2.<br>
bash$&nbsp;<b>tac file1.txt</b><br>
Chapter 16. External Filters, Programs and Commands<br>
215<br>
<hr>
<A name=222></a><IMG src="abs-guide-222_1.png"><br>
<IMG src="abs-guide-222_2.png"><br>
<IMG src="abs-guide-222_3.png"><br>
Advanced Bash-Scripting Guide<br>
This is line 2.<br>
&nbsp;This is line 1.<br>
bash$&nbsp;<b>rev file1.txt<br></b>.1 enil si sihT<br>
&nbsp;.2 enil si sihT<br>
<b>cp</b><br>
This is the file copy command.&nbsp;<b>cp file1 file2</b>&nbsp;copies&nbsp;file1&nbsp;to&nbsp;file2, overwriting&nbsp;file2&nbsp;if<br><a href="abs-guides.html#230">it already exists (see Example 16-6).</a><br>
Particularly useful are the&nbsp;-a&nbsp;archive flag (for copying an entire directory tree), the<br>-u&nbsp;update flag (which prevents overwriting identically-named newer files), and the<br>-r&nbsp;and&nbsp;-R&nbsp;recursive flags.<br>
cp -u source_dir/* dest_dir<br>
# &nbsp;&quot;Synchronize&quot; dest_dir to source_dir<br>
#+ &nbsp;by copying over all newer and not previously existing files.<br>
<b>mv</b><br>
This is the file<i>&nbsp;move</i>&nbsp;command. It is equivalent to a combination of<b>&nbsp;cp</b>&nbsp;and<b>&nbsp;rm</b>. It may be used to<br>move multiple files to a directory, or even to rename a directory. For some examples of using<b>&nbsp;mv</b>&nbsp;in a<br><a href="abs-guides.html#140">script, see Example 10-11 and Example A-2.</a><br>
When used in a non-interactive script,<b>&nbsp;mv</b>&nbsp;takes the&nbsp;-f&nbsp;(<i>force</i>) option to bypass user<br>input.<br>
When a directory is moved to a preexisting directory, it becomes a subdirectory of the<br>destination directory.<br>
bash$&nbsp;<b>mv source_directory target_directory</b><br>
bash$&nbsp;<b>ls -lF target_directory<br></b>total 1<br>
&nbsp;drwxrwxr-x &nbsp; &nbsp;2 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;1024 May 28 19:20 source_directory/<br>
<b>rm</b><br>
Delete (remove) a file or files. The&nbsp;-f&nbsp;option forces removal of even readonly files, and is useful for<br>bypassing user input in a script.<br>
The<i>&nbsp;rm</i>&nbsp;command will, by itself, fail to remove filenames beginning with a dash.<br>Why? Because<i>&nbsp;rm</i>&nbsp;sees a dash-prefixed filename as an<i>&nbsp;option</i>.<br>
bash$&nbsp;<b>rm -badname<br></b>rm: invalid option -- b<br>
&nbsp;Try `rm --help' for more information.<br>
One clever workaround is to precede the filename with a &quot; -- &quot; (the<i>&nbsp;end-of-options<br></i>flag).<br>
bash$&nbsp;<b>rm -- -badname</b><br>
Another method to is to preface the filename to be removed with a&nbsp;dot-slash&nbsp;.<br>
Chapter 16. External Filters, Programs and Commands<br>
216<br>
<hr>
<A name=223></a><IMG src="abs-guide-223_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>rm ./-badname</b><br>
When used with the recursive flag&nbsp;-r, this command removes files all the way down<br>the directory tree from the current directory. A careless<b>&nbsp;rm -rf *</b>&nbsp;can wipe out a big<br>chunk of a directory structure.<br>
<b>rmdir</b><br>
Remove directory. The directory must be empty of all files -- including &quot;invisible&quot;<i>&nbsp;dotfiles&nbsp;</i>[69] -- for<br>this command to succeed.<br>
<b>mkdir</b><br>
Make directory, creates a new directory. For example,&nbsp;<b>mkdir -p<br>project/programs/December</b>&nbsp;creates the named directory. The&nbsp;<i>-p</i>&nbsp;option automatically<br>creates any necessary parent directories.<br>
<b>chmod</b><br>
<a href="abs-guides.html#202">Changes the attributes of an existing file or directory (see Example 15-14).</a><br>
chmod +x filename<br>
# Makes &quot;filename&quot; executable for all users.<br>
chmod u+s filename<br>
# Sets &quot;suid&quot; bit on &quot;filename&quot; permissions.<br>
# An ordinary user may execute &quot;filename&quot; with same privileges as the file's owner.<br>
# (This does not apply to shell scripts.)<br>
chmod 644 filename<br>
# &nbsp;Makes &quot;filename&quot; readable/writable to owner, readable to others<br>
#+ (octal mode).<br>
chmod 444 filename<br>
# &nbsp;Makes &quot;filename&quot; read-only for all.<br>
# &nbsp;Modifying the file (for example, with a text editor)<br>
#+ not allowed for a user who does not own the file (except for root),<br>
#+ and even the file owner must force a file-save<br>
#+ if she modifies the file.<br>
# &nbsp;Same restrictions apply for deleting the file.<br>
chmod 1777 directory-name<br>
# &nbsp;Gives everyone read, write, and execute permission in directory,<br>
#+ however also sets the &quot;sticky bit&quot;.<br>
# &nbsp;This means that only the owner of the directory,<br>
#+ owner of the file, and, of course, root<br>
#+ can delete any particular file in that directory.<br>
chmod 111 directory-name<br>
# &nbsp;Gives everyone execute-only permission in a directory.<br>
# &nbsp;This means that you can execute and READ the files in that directory<br>
#+ (execute permission necessarily includes read permission<br>
#+ because you can't execute a file without being able to read it).<br>
# &nbsp;But you can't list the files or search for them with the &quot;find&quot; command.<br>
# &nbsp;These restrictions do not apply to root.<br>
chmod 000 directory-name<br>
# &nbsp;No permissions at all for that directory.<br>
# &nbsp;Can't read, write, or execute files in it.<br>
# &nbsp;Can't even list files in it or &quot;cd&quot; to it.<br>
# &nbsp;But, you can rename (mv) the directory<br>
#+ or delete it (rmdir) if it is empty.<br>
# &nbsp;You can even symlink to files in the directory,<br>
Chapter 16. External Filters, Programs and Commands<br>
217<br>
<hr>
<A name=224></a><IMG src="abs-guide-224_1.png"><br>
<IMG src="abs-guide-224_2.png"><br>
Advanced Bash-Scripting Guide<br>
#+ but you can't read, write, or execute the symlinks.<br>
# &nbsp;These restrictions do not apply to root.<br>
<b>chattr</b><br>
<b>Ch</b>ange file<b>&nbsp;attr</b>ibutes. This is analogous to<b>&nbsp;chmod</b>&nbsp;above, but with different options and a different<br>invocation syntax, and it works only on<i>&nbsp;ext2/ext3</i>&nbsp;filesystems.<br>
One particularly interesting<b>&nbsp;chattr</b>&nbsp;option is&nbsp;i. A<b>&nbsp;chattr +i&nbsp;filename</b>&nbsp;marks the file as immutable.<br>The file cannot be modified, linked to, or deleted,<i>&nbsp;not even by root</i>. This file attribute can be set or<br>removed only by<i>&nbsp;root</i>. In a similar fashion, the&nbsp;a&nbsp;option marks the file as append only.<br>
root#&nbsp;<b>chattr +i file1.txt</b><br>
root#&nbsp;<b>rm file1.txt</b><br>
rm: remove write-protected regular file `file1.txt'? y<br>
&nbsp;rm: cannot remove `file1.txt': Operation not permitted<br>
If a file has the&nbsp;s&nbsp;(secure) attribute set, then when it is deleted its block is overwritten with binary<br>zeroes.&nbsp;[70]<br>
If a file has the&nbsp;u&nbsp;(undelete) attribute set, then when it is deleted, its contents can still be retrieved<br>(undeleted).<br>
If a file has the&nbsp;c&nbsp;(compress) attribute set, then it will automatically be compressed on writes to disk,<br>and uncompressed on reads.<br>
The file attributes set with<b>&nbsp;chattr</b>&nbsp;do not show in a file listing (<b>ls -l</b>).<br>
<b>ln</b><br>
Creates links to pre-existings files. A &quot;link&quot; is a reference to a file, an alternate name for it. The<b>&nbsp;ln<br></b>command permits referencing the linked file by more than one name and is a superior alternative to<br><a href="abs-guides.html#44">aliasing (see Example 4-6).</a><br>
The<b>&nbsp;ln</b>&nbsp;creates only a reference, a pointer to the file only a few bytes in size.<br>
The<b>&nbsp;ln</b>&nbsp;command is most often used with the&nbsp;-s, symbolic or &quot;soft&quot; link flag. Advantages of using the<br>-s&nbsp;flag are that it permits linking across file systems or to directories.<br>
The syntax of the command is a bit tricky. For example:&nbsp;<b>ln -s oldfile newfile</b>&nbsp;links the<br>previously existing&nbsp;oldfile&nbsp;to the newly created link,&nbsp;newfile.<br>
If a file named&nbsp;newfile&nbsp;has previously existed, an error message will result.<br>
<b>Which type of link to use?</b><br>
As John Macdonald explains it:<br>
Both of these [types of links] provide a certain measure of dual reference -- if you edit the contents<br>of the file using any name, your changes will affect both the original name and either a hard or soft<br>
Chapter 16. External Filters, Programs and Commands<br>
218<br>
<hr>
<A name=225></a>Advanced Bash-Scripting Guide<br>
new name. The differences between them occurs when you work at a higher level. The advantage of<br>a hard link is that the new name is totally independent of the old name -- if you remove or rename<br>the old name, that does not affect the hard link, which continues to point to the data while it would<br>leave a soft link hanging pointing to the old name which is no longer there. The advantage of a soft<br>link is that it can refer to a different file system (since it is just a reference to a file name, not to<br>actual data). And, unlike a hard link, a symbolic link can refer to a directory.<br>
Links give the ability to invoke a script (or any other type of executable) with multiple names, and<br>having that script behave according to how it was invoked.<br>
<b>Example 16-2. Hello or Good-bye</b><br>
#!/bin/bash<br>
# hello.sh: Saying &quot;hello&quot; or &quot;goodbye&quot;<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;depending on how script is invoked.<br>
# Make a link in current working directory ($PWD) to this script:<br>
# &nbsp; &nbsp;ln -s hello.sh goodbye<br>
# Now, try invoking this script both ways:<br>
# ./hello.sh<br>
# ./goodbye<br>
HELLO_CALL=65<br>
GOODBYE_CALL=66<br>
if [ $0 = &quot;./goodbye&quot; ]<br>
then<br>
&nbsp; echo &quot;Good-bye!&quot;<br>
&nbsp; # Some other goodbye-type commands, as appropriate.<br>
&nbsp; exit $GOODBYE_CALL<br>
fi<br>
echo &quot;Hello!&quot;<br>
# Some other hello-type commands, as appropriate.<br>
exit $HELLO_CALL<br>
<b>man</b>,&nbsp;<b>info</b><br>
These commands access the manual and information pages on system commands and installed<br>utilities. When available, the<i>&nbsp;info</i>&nbsp;pages usually contain more detailed descriptions than do the<i>&nbsp;man<br></i>pages.<br>
There have been various attempts at &quot;automating&quot; the writing of<i>&nbsp;man pages</i>. For a script that makes a<br><a href="abs-guides.html#704">tentative first step in that direction, see Example A-39.</a><br>
<b>16.2. Complex Commands</b><br>
<b>Commands for more advanced users</b><br>
<b>find</b><br>
-exec&nbsp;<i>COMMAND</i>&nbsp;\;<br>
Chapter 16. External Filters, Programs and Commands<br>
219<br>
<hr>
<A name=226></a><IMG src="abs-guide-226_1.png"><br>
Advanced Bash-Scripting Guide<br>
Carries out&nbsp;<i>COMMAND</i>&nbsp;on each file that<b>&nbsp;find</b>&nbsp;matches. The command sequence terminates with ; (the<br><a href="abs-guides.html#49">&quot;;&quot; is escaped to make certain the shell passes it to</a><b>&nbsp;find</b>&nbsp;literally, without interpreting it as a special<br>character).<br>
bash$&nbsp;<b>find ~/ -name '*.txt'<br></b>/home/bozo/.kde/share/apps/karm/karmdata.txt<br>
&nbsp;/home/bozo/misc/irmeyc.txt<br>
&nbsp;/home/bozo/test-scripts/1.txt<br>
If&nbsp;<i>COMMAND</i>&nbsp;contains {}, then<b>&nbsp;find</b>&nbsp;substitutes the full path name of the selected file for &quot;{}&quot;.<br>
find ~/ -name 'core*' -exec rm {} \;<br>
# Removes all core dump files from user's home directory.<br>
find /home/bozo/projects -mtime -1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; Note minus sign!<br>
# &nbsp;Lists all files in /home/bozo/projects directory tree<br>
#+ that were modified within the last day (current_day - 1).<br>
#<br>
find /home/bozo/projects -mtime 1<br>
# &nbsp;Same as above, but modified *exactly* one day ago.<br>
#<br>
# &nbsp;mtime = last modification time of the target file<br>
# &nbsp;ctime = last status change time (via 'chmod' or otherwise)<br>
# &nbsp;atime = last access time<br>
DIR=/home/bozo/junk_files<br>
find &quot;$DIR&quot; -type f -atime +5 -exec rm {} \;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
# &nbsp;Curly brackets are placeholder for the path name output by &quot;find.&quot;<br>
#<br>
# &nbsp;Deletes all files in &quot;/home/bozo/junk_files&quot;<br>
#+ that have not been accessed in *at least* 5 days (plus sign ... +5).<br>
#<br>
# &nbsp;&quot;-type filetype&quot;, where<br>
# &nbsp;f = regular file<br>
# &nbsp;d = directory<br>
# &nbsp;l = symbolic link, etc.<br>
#<br>
# &nbsp;(The 'find' manpage and info page have complete option listings.)<br>
find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;<br>
# Finds all IP addresses (xxx.xxx.xxx.xxx) in /etc directory files.<br>
# There a few extraneous hits. Can they be filtered out?<br>
# Possibly by:<br>
find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \<br>
| grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'<br>
#<br>
# &nbsp;[:digit:] is one of the character classes<br>
#+ introduced with the POSIX 1003.2 standard.&nbsp;<br>
# Thanks, Stéphane Chazelas.&nbsp;<br>
The&nbsp;-exec&nbsp;option to<b>&nbsp;find</b><a href="abs-guides.html#212">&nbsp;should not be confused with the exec shell builtin.</a><br>
Chapter 16. External Filters, Programs and Commands<br>
220<br>
<hr>
<A name=227></a>Advanced Bash-Scripting Guide<br>
<b>Example 16-3.<i>&nbsp;Badname</i></b><b>, eliminate file names in current directory containing bad characters<br><a href="abs-guides.html#34">and whitespace.</a></b><br>
#!/bin/bash<br>
# badname.sh<br>
# Delete filenames in current directory containing bad characters.<br>
for filename in *<br>
do<br>
&nbsp; badname=`echo &quot;$filename&quot; | sed -n /[\+\{\;\&quot;\\\=\?~\(\)\&lt;\&gt;\&amp;\*\|\$]/p`<br>
# badname=`echo &quot;$filename&quot; | sed -n '/[+{;&quot;\=?~()&lt;&gt;&amp;*|$]/p'` &nbsp;also works.<br>
# Deletes files containing these nasties: &nbsp; &nbsp; + { ; &quot; \ = ? ~ ( ) &lt; &gt; &amp; * | $<br>
#<br>
&nbsp; rm $badname 2&gt;/dev/null<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^ Error messages deep-sixed.<br>
done<br>
# Now, take care of files containing all manner of whitespace.<br>
find . -name &quot;* *&quot; -exec rm -f {} \;<br>
# The path name of the file that _find_ finds replaces the &quot;{}&quot;.<br>
# The '\' ensures that the ';' is interpreted literally, as end of command.<br>
exit 0<br>
#---------------------------------------------------------------------<br>
# Commands below this line will not execute because of _exit_ command.<br>
# An alternative to the above script:<br>
find . -name '*[+{;&quot;\\=?~()&lt;&gt;&amp;*|$ ]*' -maxdepth 0 \<br>
-exec rm -f '{}' \;<br>
# &nbsp;The &quot;-maxdepth 0&quot; option ensures that _find_ will not search<br>
#+ subdirectories below $PWD.<br>
# (Thanks, S.C.)<br>
<b>Example 16-4. Deleting a file by its<i>&nbsp;inode</i></b><b>&nbsp;number</b><br>
#!/bin/bash<br>
# idelete.sh: Deleting a file by its inode number.<br>
# &nbsp;This is useful when a filename starts with an illegal character,<br>
#+ such as ? or -.<br>
ARGCOUNT=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Filename arg must be passed to script.<br>
E_WRONGARGS=70<br>
E_FILE_NOT_EXIST=71<br>
E_CHANGED_MIND=72<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi &nbsp;<br>
if [ ! -e &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;File \&quot;&quot;$1&quot;\&quot; does not exist.&quot;<br>
&nbsp; exit $E_FILE_NOT_EXIST<br>
fi &nbsp;<br>
Chapter 16. External Filters, Programs and Commands<br>
221<br>
<hr>
<A name=228></a>Advanced Bash-Scripting Guide<br>
inum=`ls -i | grep &quot;$1&quot; | awk '{print $1}'`<br>
# inum = inode (index node) number of file<br>
# -----------------------------------------------------------------------<br>
# Every file has an inode, a record that holds its physical address info.<br>
# -----------------------------------------------------------------------<br>
echo; echo -n &quot;Are you absolutely sure you want to delete \&quot;$1\&quot; (y/n)? &quot;<br>
# The '-v' option to 'rm' also asks this.<br>
read answer<br>
case &quot;$answer&quot; in<br>
[nN]) echo &quot;Changed your mind, huh?&quot;<br>
&nbsp; &nbsp; &nbsp; exit $E_CHANGED_MIND<br>
&nbsp; &nbsp; &nbsp; ;;<br>
*) &nbsp; &nbsp;echo &quot;Deleting file \&quot;$1\&quot;.&quot;;;<br>
esac<br>
find . -inum $inum -exec rm {} \;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
# &nbsp; &nbsp; &nbsp; &nbsp;Curly brackets are placeholder<br>
#+ &nbsp; &nbsp; &nbsp; for text output by &quot;find.&quot;<br>
echo &quot;File &quot;\&quot;$1&quot;\&quot; deleted!&quot;<br>
exit 0<br>
The<b>&nbsp;find</b>&nbsp;command also works without the&nbsp;-exec&nbsp;option.<br>
#!/bin/bash<br>
# &nbsp;Find suid root files.<br>
# &nbsp;A strange suid file might indicate a security hole,<br>
#+ or even a system intrusion.<br>
directory=&quot;/usr/sbin&quot;<br>
# Might also try /sbin, /bin, /usr/bin, /usr/local/bin, etc.<br>
permissions=&quot;+4000&quot; &nbsp;# suid root (dangerous!)<br>
for file in $( find &quot;$directory&quot; -perm &quot;$permissions&quot; )<br>
do<br>
&nbsp; ls -ltF --author &quot;$file&quot;<br>
done<br>
<a href="abs-guides.html#263">See Example 16-30, Example 3-4, and Example 11-9 for scripts using</a><b>&nbsp;find</b><a href="abs-guides.html#225">. Its manpage provides<br></a>more detail on this complex and powerful command.<br>
<b>xargs</b><br>
A filter for feeding arguments to a command, and also a tool for assembling the commands<br>themselves. It breaks a data stream into small enough chunks for filters and commands to process.<br><a href="abs-guides.html#170">Consider it as a powerful replacement for backquotes. In situations where command substitution fails<br></a>with a too many arguments error, substituting<b>&nbsp;xargs</b>&nbsp;often works.&nbsp;[71] Normally,<b>&nbsp;xargs</b>&nbsp;reads from<br>stdin&nbsp;or from a pipe, but it can also be given the output of a file.<br>
The default command for<b>&nbsp;xargs</b><a href="abs-guides.html#187">&nbsp;is echo. This means that input piped to</a><b>&nbsp;xargs</b>&nbsp;may have linefeeds and<br>other whitespace characters stripped out.<br>
bash$&nbsp;<b>ls -l<br></b>total 0<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 29 23:58 file1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 29 23:58 file2<br>
Chapter 16. External Filters, Programs and Commands<br>
222<br>
<hr>
<A name=229></a><IMG src="abs-guide-229_1.png"><br>
<IMG src="abs-guide-229_2.png"><br>
<IMG src="abs-guide-229_3.png"><br>
<IMG src="abs-guide-229_4.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>ls -l | xargs<br></b>total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan...<br>
bash$&nbsp;<b>find ~/mail -type f | xargs grep &quot;Linux&quot;<br></b>./misc:User-Agent: slrn/0.9.8.1 (Linux)<br>
&nbsp;./sent-mail-jul-2005: hosted by the Linux Documentation Project.<br>
&nbsp;./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)<br>
&nbsp;./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article<br>
&nbsp;./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem<br>
&nbsp;. . .<br>
<b>ls | xargs -p -l gzip</b><a href="abs-guides.html#265">&nbsp;gzips every file in current directory, one at a time, prompting before<br></a>each operation.<br>
Note that<i>&nbsp;xargs</i>&nbsp;processes the arguments passed to it sequentially,<i>&nbsp;one at a time</i>.<br>
bash$&nbsp;<b>find /usr/bin | xargs file<br></b>/usr/bin: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;directory<br>
&nbsp;/usr/bin/foomatic-ppd-options: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;perl script text executable<br>
&nbsp;. . .<br>
An interesting<i>&nbsp;xargs</i>&nbsp;option is&nbsp;-n&nbsp;<i>NN</i>, which limits to&nbsp;<i>NN</i>&nbsp;the number of arguments<br>passed.<br>
<b>ls | xargs -n 8 echo</b>&nbsp;lists the files in the current directory in&nbsp;8&nbsp;columns.<br>
Another useful option is&nbsp;-0, in combination with&nbsp;<b>find -print0</b>&nbsp;or&nbsp;<b>grep -lZ</b>.<br>This allows handling arguments containing whitespace or quotes.<br>
<b>find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs<br>-0 rm -f</b><br>
<b>grep -rliwZ GUI / | xargs -0 rm -f</b><br>
Either of the above will remove any file containing &quot;GUI&quot;.<i>&nbsp;(Thanks, S.C.)</i><br>
Or:<br>
cat /proc/&quot;$pid&quot;/&quot;$OPTION&quot; | xargs -0 echo<br>
# &nbsp;Formats output: &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^<br>
# &nbsp;From Han Holl's fixup of &quot;get-commandline.sh&quot;<br>
#+ script in &quot;/dev and /proc&quot; chapter.<br>
The&nbsp;-P&nbsp;option to<i>&nbsp;xargs</i>&nbsp;permits running processes in parallel. This speeds up<br>execution in a machine with a multicore CPU.<br>
#!/bin/bash<br>
ls *gif | xargs -t -n1 -P2 gif2png<br>
Chapter 16. External Filters, Programs and Commands<br>
223<br>
<hr>
<A name=230></a>Advanced Bash-Scripting Guide<br>
# Converts all the gif images in current directory to png.<br>
# Options:<br>
# =======<br>
# -t &nbsp; &nbsp;Print command to stderr.<br>
# -n1 &nbsp; At most 1 argument per command line.<br>
# -P2 &nbsp; Run up to 2 processes simultaneously.<br>
# Thank you, Roberto Polli, for the inspiration.<br>
<b>Example 16-5. Logfile: Using<i>&nbsp;xargs</i></b><b>&nbsp;to monitor system log</b><br>
#!/bin/bash<br>
# Generates a log file in current directory<br>
# from the tail end of /var/log/messages.<br>
# Note: /var/log/messages must be world readable<br>
# if this script invoked by an ordinary user.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; #root chmod 644 /var/log/messages<br>
LINES=5<br>
( date; uname -a ) &gt;&gt;logfile<br>
# Time and machine name<br>
echo ---------------------------------------------------------- &gt;&gt;logfile<br>
tail -n $LINES /var/log/messages | xargs | fmt -s &gt;&gt;logfile<br>
echo &gt;&gt;logfile<br>
echo &gt;&gt;logfile<br>
exit 0<br>
# &nbsp;Note:<br>
# &nbsp;----<br>
# &nbsp;As Frank Wang points out,<br>
#+ unmatched quotes (either single or double quotes) in the source file<br>
#+ may give xargs indigestion.<br>
#<br>
# &nbsp;He suggests the following substitution for line 15:<br>
# &nbsp;tail -n $LINES /var/log/messages | tr -d &quot;\&quot;'&quot; | xargs | fmt -s &gt;&gt;logfile<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Modify this script to track changes in /var/log/messages at intervals<br>
#+ of 20 minutes.<br>
# &nbsp;Hint: Use the &quot;watch&quot; command.&nbsp;<br>
<a href="abs-guides.html#226">As in<b>&nbsp;find</b></a>, a curly bracket pair serves as a placeholder for replacement text.<br>
<b>Example 16-6. Copying files in current directory to another</b><br>
#!/bin/bash<br>
# copydir.sh<br>
# &nbsp;Copy (verbose) all files in current directory ($PWD)<br>
#+ to directory specified on command-line.<br>
Chapter 16. External Filters, Programs and Commands<br>
224<br>
<hr>
<A name=231></a>Advanced Bash-Scripting Guide<br>
E_NOARGS=85<br>
if [ -z &quot;$1&quot; ] &nbsp; # Exit if no argument given.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` directory-to-copy-to&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi &nbsp;<br>
ls . | xargs -i -t cp ./{} $1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^ ^^ &nbsp; &nbsp; &nbsp;^^<br>
# &nbsp;-t is &quot;verbose&quot; (output command-line to stderr) option.<br>
# &nbsp;-i is &quot;replace strings&quot; option.<br>
# &nbsp;{} is a placeholder for output text.<br>
# &nbsp;This is similar to the use of a curly-bracket pair in &quot;find.&quot;<br>
#<br>
# &nbsp;List the files in current directory (ls .),<br>
#+ pass the output of &quot;ls&quot; as arguments to &quot;xargs&quot; (-i -t options),<br>
#+ then copy (cp) these arguments ({}) to new directory ($1). &nbsp;<br>
#<br>
# &nbsp;The net result is the exact equivalent of<br>
#+ &nbsp; cp * $1<br>
#+ unless any of the filenames has embedded &quot;whitespace&quot; characters.<br>
exit 0<br>
<b>Example 16-7. Killing processes by name</b><br>
#!/bin/bash<br>
# kill-byname.sh: Killing processes by name.<br>
# Compare this script with kill-process.sh.<br>
# &nbsp;For instance,<br>
#+ try &quot;./kill-byname.sh xterm&quot; --<br>
#+ and watch all the xterms on your desktop disappear.<br>
# &nbsp;Warning:<br>
# &nbsp;-------<br>
# &nbsp;This is a fairly dangerous script.<br>
# &nbsp;Running it carelessly (especially as root)<br>
#+ can cause data loss and other undesirable effects.<br>
E_BADARGS=66<br>
if test -z &quot;$1&quot; &nbsp;# No command-line arg supplied?<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` Process(es)_to_kill&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
PROCESS_NAME=&quot;$1&quot;<br>
ps ax | grep &quot;$PROCESS_NAME&quot; | awk '{print $1}' | xargs -i kill {} 2&amp;&gt;/dev/null<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;^^<br>
# ---------------------------------------------------------------<br>
# Notes:<br>
# -i is the &quot;replace strings&quot; option to xargs.<br>
# The curly brackets are the placeholder for the replacement.<br>
# 2&amp;&gt;/dev/null suppresses unwanted error messages.<br>
#<br>
Chapter 16. External Filters, Programs and Commands<br>
225<br>
<hr>
<A name=232></a>Advanced Bash-Scripting Guide<br>
# Can &nbsp;grep &quot;$PROCESS_NAME&quot; be replaced by pidof &quot;$PROCESS_NAME&quot;?<br>
# ---------------------------------------------------------------<br>
exit $?<br>
# &nbsp;The &quot;killall&quot; command has the same effect as this script,<br>
#+ but using it is not quite as educational.<br>
<b>Example 16-8. Word frequency analysis using<i>&nbsp;xargs</i></b><br>
#!/bin/bash<br>
# wf2.sh: Crude word frequency analysis on a text file.<br>
# Uses 'xargs' to decompose lines of text into single words.<br>
# Compare this example to the &quot;wf.sh&quot; script later on.<br>
# Check for input file on command-line.<br>
ARGS=1<br>
E_BADARGS=85<br>
E_NOFILE=86<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
# Correct number of arguments passed to script?<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ ! -f &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # Check if file exists.<br>
then<br>
&nbsp; echo &quot;File \&quot;$1\&quot; does not exist.&quot;<br>
&nbsp; exit $E_NOFILE<br>
fi<br>
#####################################################<br>
cat &quot;$1&quot; | xargs -n1 | \<br>
# &nbsp;List the file, one word per line.&nbsp;<br>
tr A-Z a-z | \<br>
# &nbsp;Shift characters to lowercase.<br>
sed -e 's/\.//g' &nbsp;-e 's/\,//g' -e 's/ /\<br>
/g' | \<br>
# &nbsp;Filter out periods and commas, and<br>
#+ change space between words to linefeed,<br>
sort | uniq -c | sort -nr<br>
# &nbsp;Finally remove duplicates, prefix occurrence count<br>
#+ and sort numerically.<br>
#####################################################<br>
# &nbsp;This does the same job as the &quot;wf.sh&quot; example,<br>
#+ but a bit more ponderously, and it runs more slowly (why?).<br>
exit $?<br>
<b>expr</b><br>
All-purpose expression evaluator: Concatenates and evaluates the arguments according to the<br>operation given (arguments must be separated by spaces). Operations may be arithmetic, comparison,<br>string, or logical.<br>
Chapter 16. External Filters, Programs and Commands<br>
226<br>
<hr>
<A name=233></a>Advanced Bash-Scripting Guide<br>
<b>expr 3 + 5</b><br>
returns&nbsp;8<br>
<b>expr 5 % 3</b><br>
returns 2<br>
<b>expr 1 / 0</b><br>
returns the error message, expr: division by zero<br>
Illegal arithmetic operations not allowed.<br>
<b>expr 5 \* 3</b><br>
returns 15<br>
The multiplication operator must be escaped when used in an arithmetic expression with<br><b>expr</b>.<br>
<b>y=`expr $y + 1`</b><br>
Increment a variable, with the same effect as&nbsp;<b>let y=y+1</b>&nbsp;and&nbsp;<b>y=$(($y+1))</b>. This is an<br><a href="abs-guides.html#176">example of arithmetic expansion.</a><br>
<b>z=`expr substr $string $position $length`</b><br>
Extract substring of $length characters, starting at $position.<br>
<b>Example 16-9. Using<i>&nbsp;expr</i></b><br>
#!/bin/bash<br>
# Demonstrating some of the uses of 'expr'<br>
# =======================================<br>
echo<br>
# Arithmetic Operators<br>
# ---------- ---------<br>
echo &quot;Arithmetic Operators&quot;<br>
echo<br>
a=`expr 5 + 3`<br>
echo &quot;5 + 3 = $a&quot;<br>
a=`expr $a + 1`<br>
echo<br>
echo &quot;a + 1 = $a&quot;<br>
echo &quot;(incrementing a variable)&quot;<br>
a=`expr 5 % 3`<br>
# modulo<br>
echo<br>
echo &quot;5 mod 3 = $a&quot;<br>
echo<br>
echo<br>
# Logical Operators<br>
# ------- ---------<br>
# &nbsp;Returns 1 if true, 0 if false,<br>
#+ opposite of normal Bash convention.<br>
echo &quot;Logical Operators&quot;<br>
echo<br>
Chapter 16. External Filters, Programs and Commands<br>
227<br>
<hr>
<A name=234></a>Advanced Bash-Scripting Guide<br>
x=24<br>
y=25<br>
b=`expr $x = $y` &nbsp; &nbsp; &nbsp; &nbsp; # Test equality.<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 &nbsp;( $x -ne $y )<br>
echo<br>
a=3<br>
b=`expr $a \&gt; 10`<br>
echo 'b=`expr $a \&gt; 10`, therefore...'<br>
echo &quot;If a &gt; 10, b = 0 (false)&quot;<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 &nbsp;( 3 ! -gt 10 )<br>
echo<br>
b=`expr $a \&lt; 10`<br>
echo &quot;If a &lt; 10, b = 1 (true)&quot;<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1 &nbsp;( 3 -lt 10 )<br>
echo<br>
# Note escaping of operators.<br>
b=`expr $a \&lt;= 3`<br>
echo &quot;If a &lt;= 3, b = 1 (true)&quot;<br>
echo &quot;b = $b&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1 &nbsp;( 3 -le 3 )<br>
# There is also a &quot;\&gt;=&quot; operator (greater than or equal to).<br>
echo<br>
echo<br>
# String Operators<br>
# ------ ---------<br>
echo &quot;String Operators&quot;<br>
echo<br>
a=1234zipper43231<br>
echo &quot;The string being operated upon is \&quot;$a\&quot;.&quot;<br>
# length: length of string<br>
b=`expr length $a`<br>
echo &quot;Length of \&quot;$a\&quot; is $b.&quot;<br>
# index: position of first character in substring<br>
# &nbsp; &nbsp; &nbsp; &nbsp;that matches a character in string<br>
b=`expr index $a 23`<br>
echo &quot;Numerical position of first \&quot;2\&quot; in \&quot;$a\&quot; is \&quot;$b\&quot;.&quot;<br>
# substr: extract substring, starting position &amp; length specified<br>
b=`expr substr $a 2 6`<br>
echo &quot;Substring of \&quot;$a\&quot;, starting at position 2,\<br>
and 6 chars long is \&quot;$b\&quot;.&quot;<br>
# &nbsp;The default behavior of the 'match' operations is to<br>
#+ search for the specified match at the BEGINNING of the string.<br>
#<br>
# &nbsp; &nbsp; &nbsp; Using Regular Expressions ...<br>
b=`expr match &quot;$a&quot; '[0-9]*'` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Numerical count.<br>
echo Number of digits at the beginning of \&quot;$a\&quot; is $b.<br>
b=`expr match &quot;$a&quot; '\([0-9]*\)'` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Note that escaped parentheses<br>
Chapter 16. External Filters, Programs and Commands<br>
228<br>
<hr>
<A name=235></a><IMG src="abs-guide-235_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == &nbsp; &nbsp; &nbsp;== &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ trigger substring match.<br>
echo &quot;The digits at the beginning of \&quot;$a\&quot; are \&quot;$b\&quot;.&quot;<br>
echo<br>
exit 0<br>
<a href="abs-guides.html#17">The : (<i>null</i>) operator can substitute for</a><b>&nbsp;match</b>. For example,&nbsp;<b>b=`expr $a : [0-9]*`</b>&nbsp;is<br>the exact equivalent of&nbsp;<b>b=`expr match $a [0-9]*`</b>&nbsp;in the above listing.<br>
#!/bin/bash<br>
echo<br>
echo &quot;String operations using \&quot;expr \$string : \&quot; construct&quot;<br>
echo &quot;===================================================&quot;<br>
echo<br>
a=1234zipper5FLIPPER43231<br>
echo &quot;The string being operated upon is \&quot;`expr &quot;$a&quot; : '\(.*\)'`\&quot;.&quot;<br>
# &nbsp; &nbsp; Escaped parentheses grouping operator. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;== &nbsp;==<br>
# &nbsp; &nbsp; &nbsp; ***************************<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Escaped parentheses<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match a substring<br>
# &nbsp; &nbsp; &nbsp; ***************************<br>
# &nbsp;If no escaped parentheses...<br>
#+ then 'expr' converts the string operand to an integer.<br>
echo &quot;Length of \&quot;$a\&quot; is `expr &quot;$a&quot; : '.*'`.&quot; &nbsp; # Length of string<br>
echo &quot;Number of digits at the beginning of \&quot;$a\&quot; is `expr &quot;$a&quot; : '[0-9]*'`.&quot;<br>
# ------------------------------------------------------------------------- #<br>
echo<br>
echo &quot;The digits at the beginning of \&quot;$a\&quot; are `expr &quot;$a&quot; : '\([0-9]*\)'`.&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == &nbsp; &nbsp; &nbsp;==<br>
echo &quot;The first 7 characters of \&quot;$a\&quot; are `expr &quot;$a&quot; : '\(.......\)'`.&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ===== &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;== &nbsp; &nbsp; &nbsp; ==<br>
# Again, escaped parentheses force a substring match.<br>
#<br>
echo &quot;The last 7 characters of \&quot;$a\&quot; are `expr &quot;$a&quot; : '.*\(.......\)'`.&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ==== &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;end of string operator &nbsp;^^<br>
# &nbsp;(actually means skip over one or more of any characters until specified<br>
#+ &nbsp;substring)<br>
echo<br>
exit 0<br>
The above script illustrates how<b>&nbsp;expr</b>&nbsp;uses the<i>&nbsp;escaped parentheses -- \( ... \) --</i>&nbsp;grouping operator in tandem<br><a href="abs-guides.html#354">with regular expression parsing to match a substring. Here is a another example, this time from &quot;real life.&quot;</a><br>
# Strip the whitespace from the beginning and end.<br>
LRFDATE=`expr &quot;$LRFDATE&quot; : '[[:space:]]*\(.*\)[[:space:]]*$'`<br>
Chapter 16. External Filters, Programs and Commands<br>
229<br>
<hr>
<A name=236></a>Advanced Bash-Scripting Guide<br>
# &nbsp;From Peter Knowles' &quot;booklistgen.sh&quot; script<br>
#+ for converting files to Sony Librie/PRS-50X format.<br>
# &nbsp;(http://booklistgensh.peterknowles.com)<br>
<a href="abs-guides.html#507">Perl, sed, and awk have far superior string parsing facilities. A short</a><b>&nbsp;sed</b>&nbsp;or<b>&nbsp;awk</b>&nbsp;&quot;subroutine&quot; within a script<br><a href="abs-guides.html#503">(see Section 36.2) is an attractive alternative to</a><b>&nbsp;expr</b>.<br>
<a href="abs-guides.html#125">See Section 10.1 for more on using</a><b>&nbsp;expr</b>&nbsp;in string operations.<br>
<b>16.3. Time / Date Commands</b><br>
<b>Time/date and timing</b><br>
<b>date</b><br>
Simply invoked,<b>&nbsp;date</b>&nbsp;prints the date and time to&nbsp;stdout. Where this command gets interesting is in<br>its formatting and parsing options.<br>
<b>Example 16-10. Using<i>&nbsp;date</i></b><br>
#!/bin/bash<br>
# Exercising the 'date' command<br>
echo &quot;The number of days since the year's beginning is `date +%j`.&quot;<br>
# Needs a leading '+' to invoke formatting.<br>
# %j gives day of year.<br>
echo &quot;The number of seconds elapsed since 01/01/1970 is `date +%s`.&quot;<br>
# &nbsp;%s yields number of seconds since &quot;UNIX epoch&quot; began,<br>
#+ but how is this useful?<br>
prefix=temp<br>
suffix=$(date +%s) &nbsp;# The &quot;+%s&quot; option to 'date' is GNU-specific.<br>
filename=$prefix.$suffix<br>
echo &quot;Temporary filename = $filename&quot;<br>
# &nbsp;It's great for creating &quot;unique and random&quot; temp filenames,<br>
#+ even better than using $$.<br>
# Read the 'date' man page for more formatting options.<br>
exit 0<br>
The&nbsp;-u&nbsp;option gives the UTC (Universal Coordinated Time).<br>
bash$&nbsp;<b>date<br></b>Fri Mar 29 21:07:39 MST 2002<br>
bash$&nbsp;<b>date -u<br></b>Sat Mar 30 04:07:42 UTC 2002<br>
This option facilitates calculating the time between different dates.<br>
<b>Example 16-11.<i>&nbsp;Date</i></b><b>&nbsp;calculations</b><br>
Chapter 16. External Filters, Programs and Commands<br>
230<br>
<hr>
<A name=237></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# date-calc.sh<br>
# Author: Nathan Coulter<br>
# Used in ABS Guide with permission (thanks!).<br>
MPHR=60 &nbsp; &nbsp;# Minutes per hour.<br>
HPD=24 &nbsp; &nbsp; # Hours per day.<br>
diff () {<br>
&nbsp; &nbsp; &nbsp; &nbsp; printf '%s' $(( $(date -u -d&quot;$TARGET&quot; +%s) -<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $(date -u -d&quot;$CURRENT&quot; +%s)))<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; %d = day of month.<br>
}<br>
CURRENT=$(date -u -d '2007-09-01 17:30:24' '+%F %T.%N %Z')<br>
TARGET=$(date -u -d'2007-12-25 12:30:00' '+%F %T.%N %Z')<br>
# %F = full date, %T = %H:%M:%S, %N = nanoseconds, %Z = time zone.<br>
printf '\nIn 2007, %s ' \<br>
&nbsp; &nbsp; &nbsp; &nbsp;&quot;$(date -d&quot;$CURRENT +<br>
&nbsp; &nbsp; &nbsp; &nbsp; $(( $(diff) /$MPHR /$MPHR /$HPD / 2 )) days&quot; '+%d %B')&quot;&nbsp;<br>
# &nbsp; &nbsp; &nbsp; %B = name of month &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ halfway<br>
printf 'was halfway between %s ' &quot;$(date -d&quot;$CURRENT&quot; '+%d %B')&quot;<br>
printf 'and %s\n' &quot;$(date -d&quot;$TARGET&quot; '+%d %B')&quot;<br>
printf '\nOn %s at %s, there were\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; $(date -u -d&quot;$CURRENT&quot; +%F) $(date -u -d&quot;$CURRENT&quot; +%T)<br>
DAYS=$(( $(diff) / $MPHR / $MPHR / $HPD ))<br>
CURRENT=$(date -d&quot;$CURRENT +$DAYS days&quot; '+%F %T.%N %Z')<br>
HOURS=$(( $(diff) / $MPHR / $MPHR ))<br>
CURRENT=$(date -d&quot;$CURRENT +$HOURS hours&quot; '+%F %T.%N %Z')<br>
MINUTES=$(( $(diff) / $MPHR ))<br>
CURRENT=$(date -d&quot;$CURRENT +$MINUTES minutes&quot; '+%F %T.%N %Z')<br>
printf '%s days, %s hours, ' &quot;$DAYS&quot; &quot;$HOURS&quot;<br>
printf '%s minutes, and %s seconds ' &quot;$MINUTES&quot; &quot;$(diff)&quot;<br>
printf 'until Christmas Dinner!\n\n'<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Rewrite the diff () function to accept passed parameters,<br>
#+ rather than using global variables.<br>
The<i>&nbsp;date</i>&nbsp;command has quite a number of<i>&nbsp;output</i>&nbsp;options. For example&nbsp;%N&nbsp;gives the nanosecond<br>portion of the current time. One interesting use for this is to generate random integers.<br>
date +%N | sed -e 's/000$//' -e 's/^0//'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br>
# &nbsp;Strip off leading and trailing zeroes, if present.<br>
# &nbsp;Length of generated integer depends on<br>
#+ how many zeroes stripped off.<br>
# 115281032<br>
# 63408725<br>
# 394504284<br>
There are many more options (try<b>&nbsp;man date</b>).<br>
date +%j<br>
# Echoes day of the year (days elapsed since January 1).<br>
Chapter 16. External Filters, Programs and Commands<br>
231<br>
<hr>
<A name=238></a><IMG src="abs-guide-238_1.png"><br>
<IMG src="abs-guide-238_2.png"><br>
<IMG src="abs-guide-238_3.png"><br>
Advanced Bash-Scripting Guide<br>
date +%k%M<br>
# Echoes hour and minute in 24-hour format, as a single digit string.<br>
# The 'TZ' parameter permits overriding the default time zone.<br>
date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Mon Mar 28 21:42:16 MST 2005<br>
TZ=EST date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Mon Mar 28 23:42:16 EST 2005<br>
# Thanks, Frank Kannemann and Pete Sjoberg, for the tip.<br>
SixDaysAgo=$(date --date='6 days ago')<br>
OneMonthAgo=$(date --date='1 month ago') &nbsp;# Four weeks back (not a month!)<br>
OneYearAgo=$(date --date='1 year ago')<br>
<a href="abs-guides.html#29">See also Example 3-4 and Example A-43.</a><br>
<b>zdump</b><br>
Time zone dump: echoes the time in a specified time zone.<br>
bash$&nbsp;<b>zdump EST<br></b>EST &nbsp;Tue Sep 18 22:09:22 2001 EST<br>
<b>time</b><br>
Outputs verbose timing statistics for executing a command.<br>
<b>time ls -l /</b>&nbsp;gives something like this:<br>
real &nbsp; &nbsp;0m0.067s<br>
&nbsp;user &nbsp; &nbsp;0m0.004s<br>
&nbsp;sys &nbsp; &nbsp; 0m0.005s<br>
<a href="abs-guides.html#217">See also the very similar times command in the previous section.</a><br>
<a href="abs-guides.html#541">As of version 2.0 of Bash,</a><b>&nbsp;time</b>&nbsp;became a shell reserved word, with slightly altered<br>behavior in a pipeline.<br>
<b>touch</b><br>
Utility for updating access/modification times of a file to current system time or other specified time,<br>but also useful for creating a new file. The command&nbsp;<b>touch zzz</b>&nbsp;will create a new file of zero<br>length, named&nbsp;zzz, assuming that&nbsp;zzz&nbsp;did not previously exist. Time-stamping empty files in this<br>way is useful for storing date information, for example in keeping track of modification times on a<br>project.<br>
The<b>&nbsp;touch</b>&nbsp;command is equivalent to&nbsp;<b>: &gt;&gt; newfile</b>&nbsp;or&nbsp;<b>&gt;&gt; newfile</b>&nbsp;(for<br>ordinary files).<br>
<a href="abs-guides.html#222">Before doing a cp -u (</a><i>copy/update</i>), use<b>&nbsp;touch</b>&nbsp;to update the time stamp of files you<br>don't wish overwritten.<br>
As an example, if the directory&nbsp;/home/bozo/tax_audit&nbsp;contains the files<br>spreadsheet-051606.data,&nbsp;spreadsheet-051706.data, and<br>spreadsheet-051806.data, then doing a<b>&nbsp;touch spreadsheet*.data</b>&nbsp;will protect<br>these files from being overwritten by files with the same names during a<b>&nbsp;cp -u<br>/home/bozo/financial_info/spreadsheet*data /home/bozo/tax_audit</b>.<br>
<b>at</b><br>
Chapter 16. External Filters, Programs and Commands<br>
232<br>
<hr>
<A name=239></a><IMG src="abs-guide-239_1.png"><br>
<IMG src="abs-guide-239_2.png"><br>
<IMG src="abs-guide-239_3.png"><br>
Advanced Bash-Scripting Guide<br>
The<b>&nbsp;at</b>&nbsp;job control command executes a given set of commands at a specified time. Superficially, it<br><a href="abs-guides.html#338">resembles cron, however,</a><b>&nbsp;at</b>&nbsp;is chiefly useful for one-time execution of a command set.<br>
<b>at 2pm January 15</b>&nbsp;prompts for a set of commands to execute at that time. These commands<br>should be shell-script compatible, since, for all practical purposes, the user is typing in an executable<br><a href="abs-guides.html#31">shell script a line at a time. Input terminates with a Ctl-D.</a><br>
Using either the&nbsp;-f&nbsp;option or input redirection (&lt;),<b>&nbsp;at</b>&nbsp;reads a command list from a file. This file is an<br>executable shell script, though it should, of course, be non-interactive. Particularly clever is including<br><a href="abs-guides.html#310">the run-parts command in the file to execute a different set of scripts.</a><br>
bash$&nbsp;<b>at 2:30 am Friday &lt; at-jobs.list<br></b>job 2 at 2000-10-27 02:30<br>
<b>batch</b><br>
The<b>&nbsp;batch</b>&nbsp;job control command is similar to<b>&nbsp;at</b>, but it runs a command list when the system load<br>drops below&nbsp;.8. Like<b>&nbsp;at</b>, it can read commands from a file with the&nbsp;-f&nbsp;option.<br>
The concept of<i>&nbsp;batch processing</i>&nbsp;dates back to the era of mainframe computers. It means running a<br>set of commands without user intervention.<br>
<b>cal</b><br>
Prints a neatly formatted monthly calendar to&nbsp;stdout. Will do current year or a large range of past<br>and future years.<br>
<b>sleep</b><br>
This is the shell equivalent of a<i>&nbsp;wait loop</i>. It pauses for a specified number of seconds, doing nothing.<br>It can be useful for timing or in processes running in the background, checking for a specific event<br><a href="abs-guides.html#480">every so often (polling), as in Example 32-6.</a><br>
sleep 3 &nbsp; &nbsp; # Pauses 3 seconds.<br>
The<b>&nbsp;sleep</b>&nbsp;command defaults to seconds, but minute, hours, or days may also be<br>specified.<br>
sleep 3 h &nbsp; # Pauses 3 hours!<br>
<a href="abs-guides.html#350">The watch command may be a better choice than</a><b>&nbsp;sleep</b>&nbsp;for running commands at<br>timed intervals.<br>
<b>usleep</b><br>
<i>Microsleep</i>&nbsp;(the<i>&nbsp;u</i>&nbsp;may be read as the Greek<i>&nbsp;mu</i>, or<i>&nbsp;micro-</i>&nbsp;prefix). This is the same as<b>&nbsp;sleep</b>, above,<br>but &quot;sleeps&quot; in microsecond intervals. It can be used for fine-grained timing, or for polling an ongoing<br>process at very frequent intervals.<br>
usleep 30 &nbsp; &nbsp; # Pauses 30 microseconds.<br>
This command is part of the Red Hat<i>&nbsp;initscripts / rc-scripts</i>&nbsp;package.<br>
The<b>&nbsp;usleep</b>&nbsp;command does not provide particularly accurate timing, and is therefore<br>unsuitable for critical timing loops.<br>
<b>hwclock</b>,&nbsp;<b>clock</b><br>
Chapter 16. External Filters, Programs and Commands<br>
233<br>
<hr>
<A name=240></a>Advanced Bash-Scripting Guide<br>
The<b>&nbsp;hwclock</b>&nbsp;command accesses or adjusts the machine's hardware clock. Some options require<i>&nbsp;root<br></i>privileges. The&nbsp;/etc/rc.d/rc.sysinit&nbsp;startup file uses<b>&nbsp;hwclock</b>&nbsp;to set the system time from<br>the hardware clock at bootup.<br>
The<b>&nbsp;clock</b>&nbsp;command is a synonym for<b>&nbsp;hwclock</b>.<br>
<b>16.4. Text Processing Commands</b><br>
<b>Commands affecting text and text files</b><br>
<b>sort</b><br>
File sort utility, often used as a filter in a pipe. This command sorts a<i>&nbsp;text stream</i>&nbsp;or file forwards or<br>backwards, or according to various keys or character positions. Using the&nbsp;-m&nbsp;option, it merges<br>presorted input files. The<i>&nbsp;info page</i><a href="abs-guides.html#149">&nbsp;lists its many capabilities and options. See Example 11-9,<br>Example 11-10, and Example A-8.</a><br>
<b>tsort</b><br>
<i>Topological sort</i>, reading in pairs of whitespace-separated strings and sorting according to input<br>patterns. The original purpose of<b>&nbsp;tsort</b>&nbsp;was to sort a list of dependencies for an obsolete version of the<br><i>ld</i>&nbsp;linker in an &quot;ancient&quot; version of UNIX.<br>
The results of a<i>&nbsp;tsort</i>&nbsp;will usually differ markedly from those of the standard<b>&nbsp;sort</b>&nbsp;command, above.<br>
<b>uniq</b><br>
<a href="abs-guides.html#240">This filter removes duplicate lines from a sorted file. It is often seen in a pipe coupled with sort.</a><br>
cat list-1 list-2 list-3 | sort | uniq &gt; final.list<br>
# Concatenates the list files,<br>
# sorts them,<br>
# removes duplicate lines,<br>
# and finally writes the result to an output file.<br>
The useful&nbsp;-c&nbsp;option prefixes each line of the input file with its number of occurrences.<br>
bash$&nbsp;<b>cat testfile<br></b>This line occurs only once.<br>
&nbsp;This line occurs twice.<br>
&nbsp;This line occurs twice.<br>
&nbsp;This line occurs three times.<br>
&nbsp;This line occurs three times.<br>
&nbsp;This line occurs three times.<br>
bash$&nbsp;<b>uniq -c testfile</b><br>
&nbsp; &nbsp; &nbsp;1 This line occurs only once.<br>
&nbsp; &nbsp; &nbsp; &nbsp;2 This line occurs twice.<br>
&nbsp; &nbsp; &nbsp; &nbsp;3 This line occurs three times.<br>
bash$&nbsp;<b>sort testfile | uniq -c | sort -nr</b><br>
&nbsp; &nbsp; &nbsp;3 This line occurs three times.<br>
&nbsp; &nbsp; &nbsp; &nbsp;2 This line occurs twice.<br>
&nbsp; &nbsp; &nbsp; &nbsp;1 This line occurs only once.<br>
The&nbsp;<b>sort INPUTFILE | uniq -c | sort -nr</b>&nbsp;command string produces a<i>&nbsp;frequency of<br>occurrence</i>&nbsp;listing on the&nbsp;INPUTFILE&nbsp;file (the&nbsp;-nr&nbsp;options to<b>&nbsp;sort</b>&nbsp;cause a reverse numerical sort).<br>This template finds use in analysis of log files and dictionary lists, and wherever the lexical structure<br>
Chapter 16. External Filters, Programs and Commands<br>
234<br>
<hr>
<A name=241></a>Advanced Bash-Scripting Guide<br>
of a document needs to be examined.<br>
<b>Example 16-12. Word Frequency Analysis</b><br>
#!/bin/bash<br>
# wf.sh: Crude word frequency analysis on a text file.<br>
# This is a more efficient version of the &quot;wf2.sh&quot; script.<br>
# Check for input file on command-line.<br>
ARGS=1<br>
E_BADARGS=85<br>
E_NOFILE=86<br>
if [ $# -ne &quot;$ARGS&quot; ] &nbsp;# Correct number of arguments passed to script?<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ ! -f &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # Check if file exists.<br>
then<br>
&nbsp; echo &quot;File \&quot;$1\&quot; does not exist.&quot;<br>
&nbsp; exit $E_NOFILE<br>
fi<br>
########################################################<br>
# main ()<br>
sed -e 's/\.//g' &nbsp;-e 's/\,//g' -e 's/ /\<br>
/g' &quot;$1&quot; | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =========================<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Frequency of occurrence<br>
# &nbsp;Filter out periods and commas, and<br>
#+ change space between words to linefeed,<br>
#+ then shift characters to lowercase, and<br>
#+ finally prefix occurrence count and sort numerically.<br>
# &nbsp;Arun Giridhar suggests modifying the above to:<br>
# &nbsp;. . . | sort | uniq -c | sort +1 [-f] | sort +0 -nr<br>
# &nbsp;This adds a secondary sort key, so instances of<br>
#+ equal occurrence are sorted alphabetically.<br>
# &nbsp;As he explains it:<br>
# &nbsp;&quot;This is effectively a radix sort, first on the<br>
#+ least significant column<br>
#+ (word or string, optionally case-insensitive)<br>
#+ and last on the most significant column (frequency).&quot;<br>
#<br>
# &nbsp;As Frank Wang explains, the above is equivalent to<br>
#+ &nbsp; &nbsp; &nbsp; . . . | sort | uniq -c | sort +0 -nr<br>
#+ and the following also works:<br>
#+ &nbsp; &nbsp; &nbsp; . . . | sort | uniq -c | sort -k1nr -k<br>
########################################################<br>
exit 0<br>
# Exercises:<br>
# ---------<br>
Chapter 16. External Filters, Programs and Commands<br>
235<br>
<hr>
<A name=242></a>Advanced Bash-Scripting Guide<br>
# 1) Add 'sed' commands to filter out other punctuation,<br>
#+ &nbsp; such as semicolons.<br>
# 2) Modify the script to also filter out multiple spaces and<br>
#+ &nbsp; other whitespace.<br>
bash$&nbsp;<b>cat testfile<br></b>This line occurs only once.<br>
&nbsp;This line occurs twice.<br>
&nbsp;This line occurs twice.<br>
&nbsp;This line occurs three times.<br>
&nbsp;This line occurs three times.<br>
&nbsp;This line occurs three times.<br>
bash$&nbsp;<b>./wf.sh testfile</b><br>
&nbsp; &nbsp; &nbsp;6 this<br>
&nbsp; &nbsp; &nbsp; &nbsp;6 occurs<br>
&nbsp; &nbsp; &nbsp; &nbsp;6 line<br>
&nbsp; &nbsp; &nbsp; &nbsp;3 times<br>
&nbsp; &nbsp; &nbsp; &nbsp;3 three<br>
&nbsp; &nbsp; &nbsp; &nbsp;2 twice<br>
&nbsp; &nbsp; &nbsp; &nbsp;1 only<br>
&nbsp; &nbsp; &nbsp; &nbsp;1 once<br>
<b>expand</b>,<b>&nbsp;unexpand</b><br>
The<b>&nbsp;expand</b><a href="abs-guides.html#24">&nbsp;filter converts tabs to spaces. It is often used in a pipe.</a><br>
The<b>&nbsp;unexpand</b>&nbsp;filter converts spaces to tabs. This reverses the effect of<b>&nbsp;expand</b>.<br>
<b>cut</b><br>
<a href="abs-guides.html#35">A tool for extracting fields from files. It is similar to the&nbsp;</a><b>print $N</b><a href="abs-guides.html#784">&nbsp;command set in awk, but more<br></a>limited. It may be simpler to use<i>&nbsp;cut</i>&nbsp;in a script than<i>&nbsp;awk</i>. Particularly important are the&nbsp;-d&nbsp;(delimiter)<br>and&nbsp;-f&nbsp;(field specifier) options.<br>
Using<b>&nbsp;cut</b>&nbsp;to obtain a listing of the mounted filesystems:<br>
cut -d ' ' -f1,2 /etc/mtab<br>
Using<b>&nbsp;cut</b>&nbsp;to list the OS and kernel version:<br>
uname -a | cut -d&quot; &quot; -f1,3,11,12<br>
Using<b>&nbsp;cut</b>&nbsp;to extract message headers from an e-mail folder:<br>
bash$&nbsp;<b>grep '^Subject:' read-messages | cut -c10-80<br></b>Re: Linux suitable for mission-critical apps?<br>
&nbsp;MAKE MILLIONS WORKING AT HOME!!!<br>
&nbsp;Spam complaint<br>
&nbsp;Re: Spam complaint<br>
Using<b>&nbsp;cut</b>&nbsp;to parse a file:<br>
# List all the users in /etc/passwd.<br>
FILENAME=/etc/passwd<br>
for user in $(cut -d: -f1 $FILENAME)<br>
do<br>
&nbsp; echo $user<br>
done<br>
Chapter 16. External Filters, Programs and Commands<br>
236<br>
<hr>
<A name=243></a><IMG src="abs-guide-243_1.png"><br>
<IMG src="abs-guide-243_2.png"><br>
Advanced Bash-Scripting Guide<br>
# Thanks, Oleg Philon for suggesting this.<br>
<b>cut -d ' ' -f2,3 filename</b>&nbsp;is equivalent to&nbsp;<b>awk -F'[ ]' '{ print $2, $3 }'<br>filename</b><br>
It is even possible to specify a linefeed as a delimiter. The trick is to actually embed a<br>linefeed (<b>RETURN</b>) in the command sequence.<br>
bash$&nbsp;<b>cut -d'<br>&nbsp;' -f3,7,19 testfile<br></b>This is line 3 of testfile.<br>
&nbsp;This is line 7 of testfile.<br>
&nbsp;This is line 19 of testfile.<br>
Thank you, Jaka Kranjc, for pointing this out.<br>
<a href="abs-guides.html#299">See also Example 16-48.</a><br>
<b>paste</b><br>
<a href="abs-guides.html#242">Tool for merging together different files into a single, multi-column file. In combination with cut,<br></a>useful for creating system log files.<br>
<b>join</b><br>
Consider this a special-purpose cousin of<b>&nbsp;paste</b>. This powerful utility allows merging two files in a<br>meaningful fashion, which essentially creates a simple version of a relational database.<br>
The<b>&nbsp;join</b>&nbsp;command operates on exactly two files, but pastes together only those lines with a common<br><a href="abs-guides.html#35">tagged field (usually a numerical label), and writes the result to&nbsp;</a>stdout. The files to be joined<br>should be sorted according to the tagged field for the matchups to work properly.<br>
File: 1.data<br>
100 Shoes<br>
200 Laces<br>
300 Socks<br>
File: 2.data<br>
100 $40.00<br>
200 $1.00<br>
300 $2.00<br>
bash$&nbsp;<b>join 1.data 2.data<br></b>File: 1.data 2.data<br>
&nbsp;100 Shoes $40.00<br>
&nbsp;200 Laces $1.00<br>
&nbsp;300 Socks $2.00<br>
The tagged field appears only once in the output.<br>
<b>head</b><br>
lists the beginning of a file to&nbsp;stdout. The default is&nbsp;10&nbsp;lines, but a different number can be<br>specified. The command has a number of interesting options.<br>
<b>Example 16-13. Which files are scripts?</b><br>
Chapter 16. External Filters, Programs and Commands<br>
237<br>
<hr>
<A name=244></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# script-detector.sh: Detects scripts within a directory.<br>
TESTCHARS=2 &nbsp; &nbsp;# Test first 2 characters.<br>
SHABANG='#!' &nbsp; # Scripts begin with a &quot;sha-bang.&quot;<br>
for file in * &nbsp;# Traverse all the files in current directory.<br>
do<br>
&nbsp; if [[ `head -c$TESTCHARS &quot;$file&quot;` = &quot;$SHABANG&quot; ]]<br>
&nbsp; # &nbsp; &nbsp; &nbsp;head -c2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#!<br>
&nbsp; # &nbsp;The '-c' option to &quot;head&quot; outputs a specified<br>
&nbsp; #+ number of characters, rather than lines (the default).<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;File \&quot;$file\&quot; is a script.&quot;<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;File \&quot;$file\&quot; is *not* a script.&quot;<br>
&nbsp; fi<br>
done<br>
exit 0<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;1) Modify this script to take as an optional argument<br>
#+ &nbsp; &nbsp;the directory to scan for scripts<br>
#+ &nbsp; &nbsp;(rather than just the current working directory).<br>
#<br>
# &nbsp;2) As it stands, this script gives &quot;false positives&quot; for<br>
#+ &nbsp; &nbsp;Perl, awk, and other scripting language scripts.<br>
# &nbsp; &nbsp; Correct this.<br>
<b>Example 16-14. Generating 10-digit random numbers</b><br>
#!/bin/bash<br>
# rnd.sh: Outputs a 10-digit random number<br>
# Script by Stephane Chazelas.<br>
head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'<br>
# =================================================================== #<br>
# Analysis<br>
# --------<br>
# head:<br>
# -c4 option takes first 4 bytes.<br>
# od:<br>
# -N4 option limits output to 4 bytes.<br>
# -tu4 option selects unsigned decimal format for output.<br>
# sed:&nbsp;<br>
# -n option, in combination with &quot;p&quot; flag to the &quot;s&quot; command,<br>
# outputs only matched lines.<br>
# The author of this script explains the action of 'sed', as follows.<br>
Chapter 16. External Filters, Programs and Commands<br>
238<br>
<hr>
<A name=245></a>Advanced Bash-Scripting Guide<br>
# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'<br>
# ----------------------------------&gt; |<br>
# Assume output up to &quot;sed&quot; --------&gt; |<br>
# is 0000000 1198195154\n<br>
# &nbsp;sed begins reading characters: 0000000 1198195154\n.<br>
# &nbsp;Here it finds a newline character,<br>
#+ so it is ready to process the first line (0000000 1198195154).<br>
# &nbsp;It looks at its &lt;range&gt;&lt;action&gt;s. The first and only one is<br>
# &nbsp; range &nbsp; &nbsp; action<br>
# &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; s/.* //p<br>
# &nbsp;The line number is in the range, so it executes the action:<br>
#+ tries to substitute the longest string ending with a space in the line<br>
# &nbsp;(&quot;0000000 &quot;) with nothing (//), and if it succeeds, prints the result<br>
# &nbsp;(&quot;p&quot; is a flag to the &quot;s&quot; command here, this is different<br>
#+ from the &quot;p&quot; command).<br>
# &nbsp;sed is now ready to continue reading its input. (Note that before<br>
#+ continuing, if -n option had not been passed, sed would have printed<br>
#+ the line once again).<br>
# &nbsp;Now, sed reads the remainder of the characters, and finds the<br>
#+ end of the file.<br>
# &nbsp;It is now ready to process its 2nd line (which is also numbered '$' as<br>
#+ it's the last one).<br>
# &nbsp;It sees it is not matched by any &lt;range&gt;, so its job is done.<br>
# &nbsp;In few word this sed commmand means:<br>
# &nbsp;&quot;On the first line only, remove any character up to the right-most space,<br>
#+ then print it.&quot;<br>
# A better way to do this would have been:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed -e 's/.* //;q'<br>
# Here, two &lt;range&gt;&lt;action&gt;s (could have been written<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed -e 's/.* //' -e q):<br>
# &nbsp; range &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;action<br>
# &nbsp; nothing (matches line) &nbsp; s/.* //<br>
# &nbsp; nothing (matches line) &nbsp; q (quit)<br>
# &nbsp;Here, sed only reads its first line of input.<br>
# &nbsp;It performs both actions, and prints the line (substituted) before<br>
#+ quitting (because of the &quot;q&quot; action) since the &quot;-n&quot; option is not passed.<br>
# =================================================================== #<br>
# An even simpler altenative to the above one-line script would be:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head -c4 /dev/urandom| od -An -tu4<br>
exit<br>
<a href="abs-guides.html#278">See also Example 16-39.</a><br>
<b>tail</b><br>
lists the (tail) end of a file to&nbsp;stdout. The default is&nbsp;10&nbsp;lines, but this can be changed with the&nbsp;-n<br>option. Commonly used to keep track of changes to a system logfile, using the&nbsp;-f&nbsp;option, which<br>outputs lines appended to the file.<br>
Chapter 16. External Filters, Programs and Commands<br>
239<br>
<hr>
<A name=246></a><IMG src="abs-guide-246_1.png"><br>
<IMG src="abs-guide-246_2.png"><br>
Advanced Bash-Scripting Guide<br>
<b>Example 16-15. Using<i>&nbsp;tail</i></b><b>&nbsp;to monitor the system log</b><br>
#!/bin/bash<br>
filename=sys.log<br>
cat /dev/null &gt; $filename; echo &quot;Creating / cleaning out file.&quot;<br>
# &nbsp;Creates file if it does not already exist,<br>
#+ and truncates it to zero length if it does.<br>
# &nbsp;: &gt; filename &nbsp; and &nbsp; &gt; filename also work.<br>
tail /var/log/messages &gt; $filename &nbsp;<br>
# /var/log/messages must have world read permission for this to work.<br>
echo &quot;$filename contains tail end of system log.&quot;<br>
exit 0<br>
<a href="abs-guides.html#24">To list a specific line of a text file, pipe the output of</a><b>&nbsp;head</b>&nbsp;to<b>&nbsp;tail -n 1</b>. For example<br><b>head -n 8 database.txt | tail -n 1</b>&nbsp;lists the 8th line of the file<br>database.txt.<br>
To set a variable to a given block of a text file:<br>
var=$(head -n $m $filename | tail -n $n)<br>
# filename = name of file<br>
# m = from beginning of file, number of lines to end of block<br>
# n = number of lines to set variable to (trim from end of block)<br>
Newer implementations of<b>&nbsp;tail</b>&nbsp;deprecate the older<b>&nbsp;tail -$LINES filename</b>&nbsp;usage. The<br>standard<b>&nbsp;tail -n $LINES filename</b>&nbsp;is correct.<br>
<a href="abs-guides.html#230">See also Example 16-5, Example 16-39 and Example 32-6.</a><br>
<b>grep</b><br>
<a href="abs-guides.html#354">A multi-purpose file search tool that uses Regular Expressions. It was originally a command/filter in<br></a>the venerable<b>&nbsp;ed</b>&nbsp;line editor:&nbsp;<b>g/re/p</b>&nbsp;--<i>&nbsp;global - regular expression - print</i>.<br>
<b>grep&nbsp;</b><i>pattern</i>&nbsp;[<i>file</i>...]<br>
Search the target file(s) for occurrences of&nbsp;<i>pattern</i>, where&nbsp;<i>pattern</i>&nbsp;may be literal text or a<br>Regular Expression.<br>
bash$&nbsp;<b>grep '[rst]ystem.$' osinfo.txt<br></b>The GPL governs the distribution of the Linux operating system.<br>
If no target file(s) specified,<b>&nbsp;grep</b>&nbsp;works as a filter on&nbsp;stdout<a href="abs-guides.html#24">, as in a pipe.</a><br>
bash$&nbsp;<b>ps ax | grep clock<br></b>765 tty1 &nbsp; &nbsp; S &nbsp; &nbsp; &nbsp;0:00 xclock<br>
&nbsp;901 pts/1 &nbsp; &nbsp;S &nbsp; &nbsp; &nbsp;0:00 grep clock<br>
The&nbsp;-i&nbsp;option causes a case-insensitive search.<br>
The&nbsp;-w&nbsp;option matches only whole words.<br>
Chapter 16. External Filters, Programs and Commands<br>
240<br>
<hr>
<A name=247></a>Advanced Bash-Scripting Guide<br>
The&nbsp;-l&nbsp;option lists only the files in which matches were found, but not the matching lines.<br>
The&nbsp;-r&nbsp;(recursive) option searches files in the current working directory and all subdirectories below<br>it.<br>
The&nbsp;-n&nbsp;option lists the matching lines, together with line numbers.<br>
bash$&nbsp;<b>grep -n Linux osinfo.txt<br></b>2:This is a file containing information about Linux.<br>
&nbsp;6:The GPL governs the distribution of the Linux operating system.<br>
The&nbsp;-v&nbsp;(or&nbsp;--invert-match) option<i>&nbsp;filters out</i>&nbsp;matches.<br>
grep pattern1 *.txt | grep -v pattern2<br>
# Matches all lines in &quot;*.txt&quot; files containing &quot;pattern1&quot;,<br>
# but ***not*** &quot;pattern2&quot;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
The&nbsp;-c&nbsp;(--count) option gives a numerical count of matches, rather than actually listing the<br>matches.<br>
grep -c txt *.sgml &nbsp; # (number of occurrences of &quot;txt&quot; in &quot;*.sgml&quot; files)<br>
# &nbsp; grep -cz .<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ dot<br>
# means count (-c) zero-separated (-z) items matching &quot;.&quot;<br>
# that is, non-empty ones (containing at least 1 character).<br>
#&nbsp;<br>
printf 'a b\nc &nbsp;d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz . &nbsp; &nbsp; # 3<br>
printf 'a b\nc &nbsp;d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$' &nbsp; # 5<br>
printf 'a b\nc &nbsp;d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^' &nbsp; # 5<br>
#<br>
printf 'a b\nc &nbsp;d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$' &nbsp; &nbsp;# 9<br>
# By default, newline chars (\n) separate items to match.&nbsp;<br>
# Note that the -z option is GNU &quot;grep&quot; specific.<br>
# Thanks, S.C.<br>
The&nbsp;--color&nbsp;(or&nbsp;--colour) option marks the matching string in color (on the console or in an<br><i>xterm</i>&nbsp;window). Since<i>&nbsp;grep</i>&nbsp;prints out each entire line containing the matching pattern, this lets you<br>see exactly<i>&nbsp;what</i>&nbsp;is being matched. See also the&nbsp;-o&nbsp;option, which shows only the matching portion of<br>the line(s).<br>
<b>Example 16-16. Printing out the<i>&nbsp;From</i></b><b>&nbsp;lines in stored e-mail messages</b><br>
#!/bin/bash<br>
# from.sh<br>
# &nbsp;Emulates the useful &quot;from&quot; utility in Solaris, BSD, etc.<br>
# &nbsp;Echoes the &quot;From&quot; header line in all messages<br>
#+ in your e-mail directory.<br>
MAILDIR=~/mail/* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;No quoting of variable. Why?<br>
# Maybe check if exists $MAILDIR . . . if [ -d $MAILDIR ] . . .<br>
Chapter 16. External Filters, Programs and Commands<br>
241<br>
<hr>
<A name=248></a><IMG src="abs-guide-248_1.png"><br>
Advanced Bash-Scripting Guide<br>
GREP_OPTS=&quot;-H -A 5 --color&quot; &nbsp; &nbsp;# &nbsp;Show file, plus extra context lines<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ and display &quot;From&quot; in color.<br>
TARGETSTR=&quot;^From&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;From&quot; at beginning of line.<br>
for file in $MAILDIR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;No quoting of variable.<br>
do<br>
&nbsp; grep $GREP_OPTS &quot;$TARGETSTR&quot; &quot;$file&quot;<br>
&nbsp; # &nbsp; &nbsp;^^^^^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Again, do not quote this variable.<br>
&nbsp; echo<br>
done<br>
exit $?<br>
# &nbsp;You might wish to pipe the output of this script to 'more'<br>
#+ or redirect it to a file . . .<br>
When invoked with more than one target file given,<b>&nbsp;grep</b>&nbsp;specifies which file contains matches.<br>
bash$&nbsp;<b>grep Linux osinfo.txt misc.txt<br></b>osinfo.txt:This is a file containing information about Linux.<br>
&nbsp;osinfo.txt:The GPL governs the distribution of the Linux operating system.<br>
&nbsp;misc.txt:The Linux operating system is steadily gaining in popularity.<br>
To force<b>&nbsp;grep</b>&nbsp;to show the filename when searching only one target file, simply give<br>/dev/null&nbsp;as the second file.<br>
bash$&nbsp;<b>grep Linux osinfo.txt /dev/null<br></b>osinfo.txt:This is a file containing information about Linux.<br>
&nbsp;osinfo.txt:The GPL governs the distribution of the Linux operating system.<br>
If there is a successful match,<b>&nbsp;grep</b><a href="abs-guides.html#57">&nbsp;returns an exit status of 0, which makes it useful in a condition test<br></a>in a script, especially in combination with the&nbsp;-q&nbsp;option to suppress output.<br>
SUCCESS=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# if grep lookup succeeds<br>
word=Linux<br>
filename=data.file<br>
grep -q &quot;$word&quot; &quot;$filename&quot; &nbsp; &nbsp;# &nbsp;The &quot;-q&quot; option<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ causes nothing to echo to stdout.<br>
if [ $? -eq $SUCCESS ]<br>
# if grep -q &quot;$word&quot; &quot;$filename&quot; &nbsp; can replace lines 5 - 7.<br>
then<br>
&nbsp; echo &quot;$word found in $filename&quot;<br>
else<br>
&nbsp; echo &quot;$word not found in $filename&quot;<br>
fi<br>
<a href="abs-guides.html#480">Example 32-6 demonstrates how to use</a><b>&nbsp;grep</b>&nbsp;to search for a word pattern in a system logfile.<br>
<b>Example 16-17. Emulating<i>&nbsp;grep</i></b><b>&nbsp;in a script</b><br>
#!/bin/bash<br>
# grp.sh: Rudimentary reimplementation of grep.<br>
E_BADARGS=85<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp;# Check for argument to script.<br>
then<br>
Chapter 16. External Filters, Programs and Commands<br>
242<br>
<hr>
<A name=249></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Usage: `basename $0` pattern&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
echo<br>
for file in * &nbsp; &nbsp; # Traverse all files in $PWD.<br>
do<br>
&nbsp; output=$(sed -n /&quot;$1&quot;/p $file) &nbsp;# Command substitution.<br>
&nbsp; if [ ! -z &quot;$output&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # What happens if &quot;$output&quot; is not quoted?<br>
&nbsp; then<br>
&nbsp; &nbsp; echo -n &quot;$file: &quot;<br>
&nbsp; &nbsp; echo &quot;$output&quot;<br>
&nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;sed -ne &quot;/$1/s|^|${file}: |p&quot; &nbsp;is equivalent to above.<br>
&nbsp; echo<br>
done &nbsp;<br>
echo<br>
exit 0<br>
# Exercises:<br>
# ---------<br>
# 1) Add newlines to output, if more than one match in any given file.<br>
# 2) Add features.<br>
How can<b>&nbsp;grep</b>&nbsp;search for two (or more) separate patterns? What if you want<b>&nbsp;grep</b>&nbsp;to display all lines<br>in a file or files that contain both &quot;pattern1&quot;<i>&nbsp;and</i>&nbsp;&quot;pattern2&quot;?<br>
<a href="abs-guides.html#24">One method is to pipe the result of</a><b>&nbsp;grep pattern1</b>&nbsp;to<b>&nbsp;grep pattern2</b>.<br>
For example, given the following file:<br>
# Filename: tstfile<br>
This is a sample file.<br>
This is an ordinary text file.<br>
This file does not contain any unusual text.<br>
This file is not unusual.<br>
Here is some text.<br>
Now, let's search this file for lines containing<i>&nbsp;both</i>&nbsp;&quot;file&quot; and &quot;text&quot; . . .<br>
bash$&nbsp;<b>grep file tstfile<br></b># Filename: tstfile<br>
&nbsp;This is a sample file.<br>
&nbsp;This is an ordinary text file.<br>
&nbsp;This file does not contain any unusual text.<br>
&nbsp;This file is not unusual.<br>
bash$&nbsp;<b>grep file tstfile | grep text<br></b>This is an ordinary text file.<br>
&nbsp;This file does not contain any unusual text.<br>
Now, for an interesting recreational use of<i>&nbsp;grep</i>&nbsp;. . .<br>
<b>Example 16-18. Crossword puzzle solver</b><br>
Chapter 16. External Filters, Programs and Commands<br>
243<br>
<hr>
<A name=250></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# cw-solver.sh<br>
# This is actually a wrapper around a one-liner (line 46).<br>
# &nbsp;Crossword puzzle and anagramming word game solver.<br>
# &nbsp;You know *some* of the letters in the word you're looking for,<br>
#+ so you need a list of all valid words<br>
#+ with the known letters in given positions.<br>
# &nbsp;For example: w...i....n<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1???5????10<br>
# w in position 1, 3 unknowns, i in the 5th, 4 unknowns, n at the end.<br>
# (See comments at end of script.)<br>
E_NOPATT=71<br>
DICT=/usr/share/dict/word.lst<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^ &nbsp; Looks for word list here.<br>
# &nbsp;ASCII word list, one word per line.<br>
# &nbsp;If you happen to need an appropriate list,<br>
#+ download the author's &quot;yawl&quot; word list package.<br>
# &nbsp;http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz<br>
# &nbsp;or<br>
# &nbsp;http://bash.webofcrafts.net/yawl-0.3.2.tar.gz<br>
if [ -z &quot;$1&quot; ] &nbsp; # &nbsp;If no word pattern specified<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ as a command-line argument . . .<br>
&nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ . . . then . . .<br>
&nbsp; echo &quot;Usage:&quot; &nbsp;#+ Usage message.<br>
&nbsp; echo<br>
&nbsp; echo &quot;&quot;$0&quot; \&quot;pattern,\&quot;&quot;<br>
&nbsp; echo &quot;where \&quot;pattern\&quot; is in the form&quot;<br>
&nbsp; echo &quot;xxx..x.x...&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;The x's represent known letters,&quot;<br>
&nbsp; echo &quot;and the periods are unknown letters (blanks).&quot;<br>
&nbsp; echo &quot;Letters and periods can be in any position.&quot;<br>
&nbsp; echo &quot;For example, try: &nbsp; sh cw-solver.sh w...i....n&quot;<br>
&nbsp; echo<br>
&nbsp; exit $E_NOPATT<br>
fi<br>
echo<br>
# ===============================================<br>
# This is where all the work gets done.<br>
grep ^&quot;$1&quot;$ &quot;$DICT&quot; &nbsp; # Yes, only one line!<br>
# &nbsp; &nbsp;| &nbsp; &nbsp;|<br>
# ^ is start-of-word regex anchor.<br>
# $ is end-of-word regex anchor.<br>
# &nbsp;From _Stupid Grep Tricks_, vol. 1,<br>
#+ a book the ABS Guide author may yet get around<br>
#+ to writing . . . one of these days . . .<br>
# ===============================================<br>
echo<br>
exit $? &nbsp;# Script terminates here.<br>
# &nbsp;If there are too many words generated,<br>
#+ redirect the output to a file.<br>
$ sh cw-solver.sh w...i....n<br>
Chapter 16. External Filters, Programs and Commands<br>
244<br>
<hr>
<A name=251></a><IMG src="abs-guide-251_1.png"><br>
Advanced Bash-Scripting Guide<br>
wellington<br>
workingman<br>
workingmen<br>
<b>egrep</b>&nbsp;--<i>&nbsp;extended grep</i>&nbsp;-- is the same as<b>&nbsp;grep -E</b>. This uses a somewhat different, extended set of<br><a href="abs-guides.html#354">Regular Expressions, which can make the search a bit more flexible. It also allows the boolean | (</a><i>or</i>)<br>operator.<br>
bash $&nbsp;<b>egrep 'matches|Matches' file.txt<br></b>Line 1 matches.<br>
&nbsp;Line 3 Matches.<br>
&nbsp;Line 4 contains matches, but also Matches<br>
<b>fgrep</b>&nbsp;--<i>&nbsp;fast grep</i>&nbsp;-- is the same as<b>&nbsp;grep -F</b><a href="abs-guides.html#354">. It does a literal string search (no Regular Expressions),<br></a>which generally speeds things up a bit.<br>
On some Linux distros,<b>&nbsp;egrep</b>&nbsp;and<b>&nbsp;fgrep</b>&nbsp;are symbolic links to, or aliases for<br><b>grep</b>, but invoked with the&nbsp;-E&nbsp;and&nbsp;-F&nbsp;options, respectively.<br>
<b>Example 16-19. Looking up definitions in<i>&nbsp;Webster's 1913 Dictionary</i></b><br>
#!/bin/bash<br>
# dict-lookup.sh<br>
# &nbsp;This script looks up definitions in the 1913 Webster's Dictionary.<br>
# &nbsp;This Public Domain dictionary is available for download<br>
#+ from various sites, including<br>
#+ Project Gutenberg (http://www.gutenberg.org/etext/247).<br>
#<br>
# &nbsp;Convert it from DOS to UNIX format (with only LF at end of line)<br>
#+ before using it with this script.<br>
# &nbsp;Store the file in plain, uncompressed ASCII text.<br>
# &nbsp;Set DEFAULT_DICTFILE variable below to path/filename.<br>
E_BADARGS=85<br>
MAXCONTEXTLINES=50 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Maximum number of lines to show.<br>
DEFAULT_DICTFILE=&quot;/usr/share/dict/webster1913-dict.txt&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Default dictionary file pathname.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Change this as necessary.<br>
# &nbsp;Note:<br>
# &nbsp;----<br>
# &nbsp;This particular edition of the 1913 Webster's<br>
#+ begins each entry with an uppercase letter<br>
#+ (lowercase for the remaining characters).<br>
# &nbsp;Only the *very first line* of an entry begins this way,<br>
#+ and that's why the search algorithm below works.<br>
if [[ -z $(echo &quot;$1&quot; | sed -n '/^[A-Z]/p') ]]<br>
# &nbsp;Must at least specify word to look up, and<br>
#+ it must start with an uppercase letter.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` Word-to-define [dictionary-file]&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;Note: Word to look up must start with capital letter,&quot;<br>
&nbsp; echo &quot;with the rest of the word in lowercase.&quot;<br>
&nbsp; echo &quot;--------------------------------------------&quot;<br>
Chapter 16. External Filters, Programs and Commands<br>
245<br>
<hr>
<A name=252></a><IMG src="abs-guide-252_1.png"><br>
<IMG src="abs-guide-252_2.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Examples: Abandon, Dictionary, Marking, etc.&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ -z &quot;$2&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;May specify different dictionary<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ as an argument to this script.<br>
then<br>
&nbsp; dictfile=$DEFAULT_DICTFILE<br>
else<br>
&nbsp; dictfile=&quot;$2&quot;<br>
fi<br>
# ---------------------------------------------------------<br>
Definition=$(fgrep -A $MAXCONTEXTLINES &quot;$1 \\&quot; &quot;$dictfile&quot;)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Definitions in form &quot;Word \...&quot;<br>
#<br>
# &nbsp;And, yes, &quot;fgrep&quot; is fast enough<br>
#+ to search even a very large text file.<br>
# Now, snip out just the definition block.<br>
echo &quot;$Definition&quot; |<br>
sed -n '1,/^[A-Z]/p' |<br>
# &nbsp;Print from first line of output<br>
#+ to the first line of the next entry.<br>
sed '$d' | sed '$d'<br>
# &nbsp;Delete last two lines of output<br>
#+ (blank line and first line of next entry).<br>
# ---------------------------------------------------------<br>
exit $?<br>
# Exercises:<br>
# ---------<br>
# 1) &nbsp;Modify the script to accept any type of alphabetic input<br>
# &nbsp; + (uppercase, lowercase, mixed case), and convert it<br>
# &nbsp; + to an acceptable format for processing.<br>
#<br>
# 2) &nbsp;Convert the script to a GUI application,<br>
# &nbsp; + using something like 'gdialog' or 'zenity' . . .<br>
# &nbsp; &nbsp; The script will then no longer take its argument(s)<br>
# &nbsp; + from the command-line.<br>
#<br>
# 3) &nbsp;Modify the script to parse one of the other available<br>
# &nbsp; + Public Domain Dictionaries, such as the U.S. Census Bureau Gazetteer.<br>
<a href="abs-guides.html#709">See also Example A-41 for an example of speedy</a><i>&nbsp;fgrep</i>&nbsp;lookup on a large text file.<br>
<b>agrep</b>&nbsp;(<i>approximate grep</i>) extends the capabilities of<b>&nbsp;grep</b>&nbsp;to approximate matching. The search string<br>may differ by a specified number of characters from the resulting matches. This utility is not part of<br>the core Linux distribution.<br>
To search compressed files, use<b>&nbsp;zgrep</b>,<b>&nbsp;zegrep</b>, or<b>&nbsp;zfgrep</b>. These also work on<br>non-compressed files, though slower than plain<b>&nbsp;grep</b>,<b>&nbsp;egrep</b>,<b>&nbsp;fgrep</b>. They are handy<br>for searching through a mixed set of files, some compressed, some not.<br>
Chapter 16. External Filters, Programs and Commands<br>
246<br>
<hr>
<A name=253></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#265">To search bzipped files, use</a><b>&nbsp;bzgrep</b>.<br>
<b>look</b><br>
The command<b>&nbsp;look</b>&nbsp;works like<b>&nbsp;grep</b>, but does a lookup on a &quot;dictionary,&quot; a sorted word list. By<br>default,<b>&nbsp;look</b>&nbsp;searches for a match in&nbsp;/usr/dict/words, but a different dictionary file may be<br>specified.<br>
<b>Example 16-20. Checking words in a list for validity</b><br>
#!/bin/bash<br>
# lookup: Does a dictionary lookup on each word in a data file.<br>
file=words.data &nbsp;# Data file from which to read words to test.<br>
echo<br>
while [ &quot;$word&quot; != end ] &nbsp;# Last word in data file.<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ^^^<br>
&nbsp; read word &nbsp; &nbsp; &nbsp;# From data file, because of redirection at end of loop.<br>
&nbsp; look $word &gt; /dev/null &nbsp;# Don't want to display lines in dictionary file.<br>
&nbsp; lookup=$? &nbsp; &nbsp; &nbsp;# Exit status of 'look' command.<br>
&nbsp; if [ &quot;$lookup&quot; -eq 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;\&quot;$word\&quot; is valid.&quot;<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;\&quot;$word\&quot; is invalid.&quot;<br>
&nbsp; fi &nbsp;<br>
done &lt;&quot;$file&quot; &nbsp; &nbsp;# Redirects stdin to $file, so &quot;reads&quot; come from there.<br>
echo<br>
exit 0<br>
# ----------------------------------------------------------------<br>
# Code below line will not execute because of &quot;exit&quot; command above.<br>
# Stephane Chazelas proposes the following, more concise alternative:<br>
while read word &amp;&amp; [[ $word != end ]]<br>
do if look &quot;$word&quot; &gt; /dev/null<br>
&nbsp; &nbsp;then echo &quot;\&quot;$word\&quot; is valid.&quot;<br>
&nbsp; &nbsp;else echo &quot;\&quot;$word\&quot; is invalid.&quot;<br>
&nbsp; &nbsp;fi<br>
done &lt;&quot;$file&quot;<br>
exit 0<br>
<b>sed</b>,<b>&nbsp;awk</b><br>
Scripting languages especially suited for parsing text files and command output. May be embedded<br>singly or in combination in pipes and shell scripts.<br>
<a href="abs-guides.html#781"><b>sed</b></a><br>
Non-interactive &quot;stream editor&quot;, permits using many<b>&nbsp;ex</b><a href="abs-guides.html#239">&nbsp;commands in batch mode. It finds many uses<br></a>in shell scripts.<br>
<a href="abs-guides.html#784"><b>awk</b></a><br>
<a href="abs-guides.html#35">Programmable file extractor and formatter, good for manipulating and/or extracting fields (columns)<br></a>in structured text files. Its syntax is similar to C.<br>
Chapter 16. External Filters, Programs and Commands<br>
247<br>
<hr>
<A name=254></a><IMG src="abs-guide-254_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>wc</b><br>
<i>wc</i>&nbsp;gives a &quot;word count&quot; on a file or I/O stream:<br>
bash $&nbsp;<b>wc /usr/share/doc/sed-4.1.2/README<br></b>13 &nbsp;70 &nbsp;447 README<br>
[13 lines &nbsp;70 words &nbsp;447 characters]<br>
<b>wc -w</b>&nbsp;gives only the word count.<br>
<b>wc -l</b>&nbsp;gives only the line count.<br>
<b>wc -c</b>&nbsp;gives only the byte count.<br>
<b>wc -m</b>&nbsp;gives only the character count.<br>
<b>wc -L</b>&nbsp;gives only the length of the longest line.<br>
Using<b>&nbsp;wc</b>&nbsp;to count how many&nbsp;.txt&nbsp;files are in current working directory:<br>
$ ls *.txt | wc -l<br>
# &nbsp;Will work as long as none of the &quot;*.txt&quot; files<br>
#+ have a linefeed embedded in their name.<br>
# &nbsp;Alternative ways of doing this are:<br>
# &nbsp; &nbsp; &nbsp;find . -maxdepth 1 -name \*.txt -print0 | grep -cz .<br>
# &nbsp; &nbsp; &nbsp;(shopt -s nullglob; set -- *.txt; echo $#)<br>
# &nbsp;Thanks, S.C.<br>
Using<b>&nbsp;wc</b>&nbsp;to total up the size of all the files whose names begin with letters in the range d - h<br>
bash$&nbsp;<b>wc [d-h]* | grep total | awk '{print $3}'<br></b>71832<br>
Using<b>&nbsp;wc</b>&nbsp;to count the instances of the word &quot;Linux&quot; in the main source file for this book.<br>
bash$&nbsp;<b>grep Linux abs-book.sgml | wc -l<br></b>50<br>
<a href="abs-guides.html#278">See also Example 16-39 and Example 20-8.</a><br>
Certain commands include some of the functionality of<b>&nbsp;wc</b>&nbsp;as options.<br>
... | grep foo | wc -l<br>
# This frequently used construct can be more concisely rendered.<br>
... | grep -c foo<br>
# Just use the &quot;-c&quot; (or &quot;--count&quot;) option of grep.<br>
# Thanks, S.C.<br>
<b>tr</b><br>
character translation filter.<br>
<a href="abs-guides.html#25">Must use quoting and/or brackets, as appropriate. Quotes prevent the shell from<br></a>reinterpreting the special characters in<b>&nbsp;tr</b>&nbsp;command sequences. Brackets should be<br>quoted to prevent expansion by the shell.<br>
Chapter 16. External Filters, Programs and Commands<br>
248<br>
<hr>
<A name=255></a>Advanced Bash-Scripting Guide<br>
Either&nbsp;<b>tr &quot;A-Z&quot; &quot;*&quot; &lt;filename</b>&nbsp;or&nbsp;<b>tr A-Z \* &lt;filename</b>&nbsp;changes all the uppercase<br>letters in&nbsp;filename&nbsp;to asterisks (writes to&nbsp;stdout). On some systems this may not work, but&nbsp;<b>tr<br>A-Z '[**]'</b>&nbsp;will.<br>
The&nbsp;-d&nbsp;option deletes a range of characters.<br>
echo &quot;abcdef&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcdef<br>
echo &quot;abcdef&quot; | tr -d b-d &nbsp; &nbsp; # aef<br>
tr -d 0-9 &lt;filename<br>
# Deletes all digits from the file &quot;filename&quot;.<br>
The&nbsp;--squeeze-repeats&nbsp;(or&nbsp;-s) option deletes all but the first instance of a string of<br><a href="abs-guides.html#34">consecutive characters. This option is useful for removing excess whitespace.</a><br>
bash$&nbsp;<b>echo &quot;XXXXX&quot; | tr --squeeze-repeats 'X'<br></b>X<br>
The&nbsp;-c&nbsp;&quot;complement&quot; option<i>&nbsp;inverts</i>&nbsp;the character set to match. With this option,<b>&nbsp;tr</b>&nbsp;acts only upon<br>those characters<i>&nbsp;not</i>&nbsp;matching the specified set.<br>
bash$&nbsp;<b>echo &quot;acfdeb123&quot; | tr -c b-d +<br></b>+c+d+b++++<br>
Note that<b>&nbsp;tr</b><a href="abs-guides.html#357">&nbsp;recognizes POSIX character classes.&nbsp;</a>[72]<br>
bash$&nbsp;<b>echo &quot;abcd2ef1&quot; | tr '[:alpha:]' -<br></b>----2--1<br>
<b>Example 16-21.<i>&nbsp;toupper</i></b><b>: Transforms a file to all uppercase.</b><br>
#!/bin/bash<br>
# Changes a file to all uppercase.<br>
E_BADARGS=85<br>
if [ -z &quot;$1&quot; ] &nbsp;# Standard check for command-line arg.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
tr a-z A-Z &lt;&quot;$1&quot;<br>
# Same effect as above, but using POSIX character set notation:<br>
# &nbsp; &nbsp; &nbsp; &nbsp;tr '[:lower:]' '[:upper:]' &lt;&quot;$1&quot;<br>
# Thanks, S.C.<br>
# &nbsp; &nbsp; Or even . . .<br>
# &nbsp; &nbsp; cat &quot;$1&quot; | tr a-z A-Z<br>
# &nbsp; &nbsp; Or dozens of other ways . . .<br>
exit 0<br>
# &nbsp;Exercise:<br>
# &nbsp;Rewrite this script to give the option of changing a file<br>
#+ to *either* upper or lowercase.<br>
Chapter 16. External Filters, Programs and Commands<br>
249<br>
<hr>
<A name=256></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Hint: Use either the &quot;case&quot; or &quot;select&quot; command.<br>
<b>Example 16-22.<i>&nbsp;lowercase</i></b><b>: Changes all filenames in working directory to lowercase.</b><br>
#!/bin/bash<br>
#<br>
# &nbsp;Changes every filename in working directory to all lowercase.<br>
#<br>
# &nbsp;Inspired by a script of John Dubois,<br>
#+ which was translated into Bash by Chet Ramey,<br>
#+ and considerably simplified by the author of the ABS Guide.<br>
for filename in * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Traverse all files in directory.<br>
do<br>
&nbsp; &nbsp;fname=`basename $filename`<br>
&nbsp; &nbsp;n=`echo $fname | tr A-Z a-z` &nbsp;# Change name to lowercase.<br>
&nbsp; &nbsp;if [ &quot;$fname&quot; != &quot;$n&quot; ] &nbsp; &nbsp; &nbsp; # Rename only files not already lowercase.<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;mv $fname $n<br>
&nbsp; &nbsp;fi &nbsp;<br>
done &nbsp;&nbsp;<br>
exit $?<br>
# Code below this line will not execute because of &quot;exit&quot;.<br>
#--------------------------------------------------------#<br>
# To run it, delete script above line.<br>
# The above script will not work on filenames containing blanks or newlines.<br>
# Stephane Chazelas therefore suggests the following alternative:<br>
for filename in * &nbsp; &nbsp;# Not necessary to use basename,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# since &quot;*&quot; won't return any file containing &quot;/&quot;.<br>
do n=`echo &quot;$filename/&quot; | tr '[:upper:]' '[:lower:]'`<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POSIX char set notation.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Slash added so that trailing newlines are not<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;removed by command substitution.<br>
&nbsp; &nbsp;# Variable substitution:<br>
&nbsp; &nbsp;n=${n%/} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Removes trailing slash, added above, from filename.<br>
&nbsp; &nbsp;[[ $filename == $n ]] || mv &quot;$filename&quot; &quot;$n&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Checks if filename already lowercase.<br>
done<br>
exit $?<br>
<b>Example 16-23.<i>&nbsp;du</i></b><b>: DOS to UNIX text file conversion.</b><br>
#!/bin/bash<br>
# Du.sh: DOS to UNIX text file converter.<br>
E_WRONGARGS=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename-to-convert&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
Chapter 16. External Filters, Programs and Commands<br>
250<br>
<hr>
<A name=257></a>Advanced Bash-Scripting Guide<br>
fi<br>
NEWFILENAME=$1.unx<br>
CR='\015' &nbsp;# Carriage return.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 015 is octal ASCII code for CR.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Lines in a DOS text file end in CR-LF.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Lines in a UNIX text file end in LF only.<br>
tr -d $CR &lt; $1 &gt; $NEWFILENAME<br>
# Delete CR's and write to new file.<br>
echo &quot;Original DOS text file is \&quot;$1\&quot;.&quot;<br>
echo &quot;Converted UNIX text file is \&quot;$NEWFILENAME\&quot;.&quot;<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# Change the above script to convert from UNIX to DOS.<br>
<b>Example 16-24.<i>&nbsp;rot13</i></b><b>: ultra-weak encryption.</b><br>
#!/bin/bash<br>
# rot13.sh: Classic rot13 algorithm,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encryption that might fool a 3-year old.<br>
# Usage: ./rot13.sh filename<br>
# or &nbsp; &nbsp; ./rot13.sh &lt;filename<br>
# or &nbsp; &nbsp; ./rot13.sh and supply keyboard input (stdin)<br>
cat &quot;$@&quot; | tr 'a-zA-Z' 'n-za-mN-ZA-M' &nbsp; # &quot;a&quot; goes to &quot;n&quot;, &quot;b&quot; to &quot;o&quot;, etc.<br>
# &nbsp;The 'cat &quot;$@&quot;' construction<br>
#+ permits getting input either from stdin or from files.<br>
exit 0<br>
<b>Example 16-25. Generating &quot;Crypto-Quote&quot; Puzzles</b><br>
#!/bin/bash<br>
# crypto-quote.sh: Encrypt quotes<br>
# &nbsp;Will encrypt famous quotes in a simple monoalphabetic substitution.<br>
# &nbsp;The result is similar to the &quot;Crypto Quote&quot; puzzles<br>
#+ seen in the Op Ed pages of the Sunday paper.<br>
key=ETAOINSHRDLUBCFGJMQPVWZYXK<br>
# The &quot;key&quot; is nothing more than a scrambled alphabet.<br>
# Changing the &quot;key&quot; changes the encryption.<br>
# The 'cat &quot;$@&quot;' construction gets input either from stdin or from files.<br>
# If using stdin, terminate input with a Control-D.<br>
# Otherwise, specify filename as command-line parameter.<br>
cat &quot;$@&quot; | tr &quot;a-z&quot; &quot;A-Z&quot; | tr &quot;A-Z&quot; &quot;$key&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;to uppercase &nbsp;| &nbsp; &nbsp; encrypt &nbsp; &nbsp; &nbsp;&nbsp;<br>
# Will work on lowercase, uppercase, or mixed-case quotes.<br>
# Passes non-alphabetic characters through unchanged.<br>
Chapter 16. External Filters, Programs and Commands<br>
251<br>
<hr>
<A name=258></a>Advanced Bash-Scripting Guide<br>
# Try this script with something like:<br>
# &quot;Nothing so needs reforming as other people's habits.&quot;<br>
# --Mark Twain<br>
#<br>
# Output is:<br>
# &quot;CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ.&quot;<br>
# --BEML PZERC<br>
# To reverse the encryption:<br>
# cat &quot;$@&quot; | tr &quot;$key&quot; &quot;A-Z&quot;<br>
# &nbsp;This simple-minded cipher can be broken by an average 12-year old<br>
#+ using only pencil and paper.<br>
exit 0<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Modify the script so that it will either encrypt or decrypt,<br>
#+ depending on command-line argument(s).<br>
Of course,<i>&nbsp;tr</i>&nbsp;lends itself to<i>&nbsp;code obfuscation</i>.<br>
#!/bin/bash<br>
# jabh.sh<br>
x=&quot;wftedskaebjgdBstbdbsmnjgz&quot;<br>
echo $x | tr &quot;a-z&quot; &quot;oh, turtleneck Phrase Jar!&quot;<br>
# Based on the Wikipedia &quot;Just another Perl hacker&quot; article.<br>
<i><b>tr</b></i><b>&nbsp;variants</b><br>
The<b>&nbsp;tr</b>&nbsp;utility has two historic variants. The BSD version does not use brackets (<b>tr a-z A-Z</b>), but<br>the SysV one does (<b>tr '[a-z]' '[A-Z]'</b>). The GNU version of<b>&nbsp;tr</b>&nbsp;resembles the BSD one.<br>
<b>fold</b><br>
A filter that wraps lines of input to a specified width. This is especially useful with the&nbsp;-s&nbsp;option,<br><a href="abs-guides.html#258">which breaks lines at word spaces (see Example 16-26 and Example A-1).</a><br>
<b>fmt</b><br>
Simple-minded file formatter, used as a filter in a pipe to &quot;wrap&quot; long lines of text output.<br>
<b>Example 16-26. Formatted file listing.</b><br>
#!/bin/bash<br>
WIDTH=40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 40 columns wide.<br>
b=`ls /usr/local/bin` &nbsp; &nbsp; &nbsp; # Get a file listing...<br>
echo $b | fmt -w $WIDTH<br>
# Could also have been done by<br>
# &nbsp; &nbsp;echo $b | fold - -s -w $WIDTH<br>
Chapter 16. External Filters, Programs and Commands<br>
252<br>
<hr>
<A name=259></a><IMG src="abs-guide-259_1.png"><br>
<IMG src="abs-guide-259_2.png"><br>
Advanced Bash-Scripting Guide<br>
exit 0<br>
<a href="abs-guides.html#230">See also Example 16-5.</a><br>
A powerful alternative to<b>&nbsp;fmt</b>&nbsp;is Kamil Toman's<b>&nbsp;par</b>&nbsp;utility, available from<br><a href="http://www.cs.berkeley.edu/~amc/Par/">http://www.cs.berkeley.edu/~amc/Par/.</a><br>
<b>col</b><br>
This deceptively named filter removes reverse line feeds from an input stream. It also attempts to<br>replace whitespace with equivalent tabs. The chief use of<b>&nbsp;col</b>&nbsp;is in filtering the output from certain text<br>processing utilities, such as<b>&nbsp;groff</b>&nbsp;and<b>&nbsp;tbl</b>.<br>
<b>column</b><br>
Column formatter. This filter transforms list-type text output into a &quot;pretty-printed&quot; table by inserting<br>tabs at appropriate places.<br>
<b>Example 16-27. Using<i>&nbsp;column</i></b><b>&nbsp;to format a directory listing</b><br>
#!/bin/bash<br>
# colms.sh<br>
# A minor modification of the example file in the &quot;column&quot; man page.<br>
(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&quot; \<br>
; ls -l | sed 1d) | column -t<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
# &nbsp;The &quot;sed 1d&quot; in the pipe deletes the first line of output,<br>
#+ which would be &quot;total &nbsp; &nbsp; &nbsp; &nbsp;N&quot;,<br>
#+ where &quot;N&quot; is the total number of files found by &quot;ls -l&quot;.<br>
# The -t option to &quot;column&quot; pretty-prints a table.<br>
exit 0<br>
<b>colrm</b><br>
Column removal filter. This removes columns (characters) from a file and writes the file, lacking the<br>range of specified columns, back to&nbsp;stdout.&nbsp;<b>colrm 2 4 &lt;filename</b>&nbsp;removes the second<br>through fourth characters from each line of the text file&nbsp;filename.<br>
If the file contains tabs or nonprintable characters, this may cause unpredictable<br><a href="abs-guides.html#242">behavior. In such cases, consider using expand and</a><b>&nbsp;unexpand</b>&nbsp;in a pipe preceding<br><b>colrm</b>.<br>
<b>nl</b><br>
Line numbering filter:&nbsp;<b>nl filename</b>&nbsp;lists&nbsp;filename&nbsp;to&nbsp;stdout, but inserts consecutive numbers<br>at the beginning of each non-blank line. If&nbsp;filename&nbsp;omitted, operates on&nbsp;stdin.<br>
The output of<b>&nbsp;nl</b>&nbsp;is very similar to&nbsp;<b>cat -b</b>, since, by default<b>&nbsp;nl</b>&nbsp;does not list blank lines.<br>
<b>Example 16-28.<i>&nbsp;nl</i></b><b>: A self-numbering script.</b><br>
#!/bin/bash<br>
# line-number.sh<br>
# This script echoes itself twice to stdout with its lines numbered.<br>
Chapter 16. External Filters, Programs and Commands<br>
253<br>
<hr>
<A name=260></a>Advanced Bash-Scripting Guide<br>
# 'nl' sees this as line 4 since it does not number blank lines.<br>
# 'cat -n' sees the above line as number 6.<br>
nl `basename $0`<br>
echo; echo &nbsp;# Now, let's try it with 'cat -n'<br>
cat -n `basename $0`<br>
# The difference is that 'cat -n' numbers the blank lines.<br>
# Note that 'nl -ba' will also do so.<br>
exit 0<br>
# -----------------------------------------------------------------<br>
<b>pr</b><br>
Print formatting filter. This will paginate files (or&nbsp;stdout) into sections suitable for hard copy<br>printing or viewing on screen. Various options permit row and column manipulation, joining lines,<br>setting margins, numbering lines, adding page headers, and merging files, among other things. The<b>&nbsp;pr<br></b>command combines much of the functionality of<b>&nbsp;nl</b>,<b>&nbsp;paste</b>,<b>&nbsp;fold</b>,<b>&nbsp;column</b>, and<b>&nbsp;expand</b>.<br>
<b>pr -o 5 --width=65 fileZZZ | more</b>&nbsp;gives a nice paginated listing to screen of<br>fileZZZ&nbsp;with margins set at 5 and 65.<br>
A particularly useful option is&nbsp;-d, forcing double-spacing (same effect as<b>&nbsp;sed -G</b>).<br>
<b>gettext</b><br>
The GNU<b>&nbsp;gettext</b><a href="abs-guides.html#799">&nbsp;package is a set of utilities for localizing and translating the text output of programs<br></a>into foreign languages. While originally intended for C programs, it now supports quite a number of<br>programming and scripting languages.<br>
The<b>&nbsp;gettext</b><i>&nbsp;program</i>&nbsp;works on shell scripts. See the&nbsp;<i>info page</i>.<br>
<b>msgfmt</b><br>
<a href="abs-guides.html#799">A program for generating binary message catalogs. It is used for localization.</a><br>
<b>iconv</b><br>
<a href="abs-guides.html#799">A utility for converting file(s) to a different encoding (character set). Its chief use is for localization.</a><br>
# Convert a string from UTF-8 to UTF-16 and print to the BookList<br>
function write_utf8_string {<br>
&nbsp; &nbsp; STRING=$1<br>
&nbsp; &nbsp; BOOKLIST=$2<br>
&nbsp; &nbsp; echo -n &quot;$STRING&quot; | iconv -f UTF8 -t UTF16 | \<br>
&nbsp; &nbsp; cut -b 3- | tr -d \\n &gt;&gt; &quot;$BOOKLIST&quot;<br>
}<br>
# &nbsp;From Peter Knowles' &quot;booklistgen.sh&quot; script<br>
#+ for converting files to Sony Librie/PRS-50X format.<br>
# &nbsp;(http://booklistgensh.peterknowles.com)<br>
<b>recode</b><br>
Consider this a fancier version of<b>&nbsp;iconv</b>, above. This very versatile utility for converting a file to a<br>different encoding scheme. Note that<i>&nbsp;recode</i>&nbsp;is not part of the standard Linux installation.<br>
<b>TeX</b>,&nbsp;<b>gs</b><br>
<b>TeX</b>&nbsp;and<b>&nbsp;Postscript</b>&nbsp;are text markup languages used for preparing copy for printing or formatted<br>video display.<br>
<b>TeX</b>&nbsp;is Donald Knuth's elaborate typsetting system. It is often convenient to write a shell script<br>encapsulating all the options and arguments passed to one of these markup languages.<br>
Chapter 16. External Filters, Programs and Commands<br>
254<br>
<hr>
<A name=261></a>Advanced Bash-Scripting Guide<br>
<i>Ghostscript</i>&nbsp;(<b>gs</b>) is a GPL-ed Postscript interpreter.<br>
<b>texexec</b><br>
Utility for processing<i>&nbsp;TeX</i>&nbsp;and<i>&nbsp;pdf</i>&nbsp;files. Found in&nbsp;/usr/bin&nbsp;on many Linux distros, it is actually a<br><a href="abs-guides.html#503">shell wrapper that calls Perl to invoke</a><i>&nbsp;Tex</i>.<br>
texexec --pdfarrange --result=Concatenated.pdf *pdf<br>
# &nbsp;Concatenates all the pdf files in the current working directory<br>
#+ into the merged file, Concatenated.pdf . . .<br>
# &nbsp;(The --pdfarrange option repaginates a pdf file. See also --pdfcombine.)<br>
# &nbsp;The above command-line could be parameterized and put into a shell script.<br>
<b>enscript</b><br>
Utility for converting plain text file to PostScript<br>
For example,<b>&nbsp;enscript filename.txt -p filename.ps</b>&nbsp;produces the PostScript output file<br>filename.ps.<br>
<b>groff</b>,&nbsp;<b>tbl</b>,&nbsp;<b>eqn</b><br>
Yet another text markup and display formatting language is<b>&nbsp;groff</b>. This is the enhanced GNU version<br>of the venerable UNIX<b>&nbsp;roff/troff</b><a href="abs-guides.html#225">&nbsp;display and typesetting package. Manpages use</a><b>&nbsp;groff</b>.<br>
The<b>&nbsp;tbl</b>&nbsp;table processing utility is considered part of<b>&nbsp;groff</b>, as its function is to convert table markup<br>into<b>&nbsp;groff</b>&nbsp;commands.<br>
The<b>&nbsp;eqn</b>&nbsp;equation processing utility is likewise part of<b>&nbsp;groff</b>, and its function is to convert equation<br>markup into<b>&nbsp;groff</b>&nbsp;commands.<br>
<b>Example 16-29.<i>&nbsp;manview</i></b><b>: Viewing formatted manpages</b><br>
#!/bin/bash<br>
# manview.sh: Formats the source of a man page for viewing.<br>
# &nbsp;This script is useful when writing man page source.<br>
# &nbsp;It lets you look at the intermediate results on the fly<br>
#+ while working on it.<br>
E_WRONGARGS=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi<br>
# ---------------------------<br>
groff -Tascii -man $1 | less<br>
# From the man page for groff.<br>
# ---------------------------<br>
# &nbsp;If the man page includes tables and/or equations,<br>
#+ then the above code will barf.<br>
# &nbsp;The following line can handle such cases.<br>
#<br>
# &nbsp; gtbl &lt; &quot;$1&quot; | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man<br>
#<br>
# &nbsp; Thanks, S.C.<br>
Chapter 16. External Filters, Programs and Commands<br>
255<br>
<hr>
<A name=262></a><IMG src="abs-guide-262_1.png"><br>
<IMG src="abs-guide-262_2.png"><br>
Advanced Bash-Scripting Guide<br>
exit $? &nbsp; # See also the &quot;maned.sh&quot; script.<br>
<a href="abs-guides.html#704">See also Example A-39.</a><br>
<b>lex</b>,&nbsp;<b>yacc</b><br>
The<b>&nbsp;lex</b>&nbsp;lexical analyzer produces programs for pattern matching. This has been replaced by the<br>nonproprietary<b>&nbsp;flex</b>&nbsp;on Linux systems.<br>
The<b>&nbsp;yacc</b>&nbsp;utility creates a parser based on a set of specifications. This has been replaced by the<br>nonproprietary<b>&nbsp;bison</b>&nbsp;on Linux systems.<br>
<b>16.5. File and Archiving Commands</b><br>
<b>Archiving</b><br>
<b>tar</b><br>
The standard UNIX archiving utility.&nbsp;[73] Originally a<i>&nbsp;Tape ARchiving</i>&nbsp;program, it has developed into<br>a general purpose package that can handle all manner of archiving with all types of destination<br>devices, ranging from tape drives to regular files to even&nbsp;stdout<a href="abs-guides.html#29">&nbsp;(see Example 3-4). GNU</a><i>&nbsp;tar</i>&nbsp;has<br>been patched to accept various compression filters, for example:<b>&nbsp;tar czvf archive_name.tar.gz *</b>,<br><a href="abs-guides.html#265">which recursively archives and gzips all files in a directory tree except dotfiles in the current working<br></a><a href="abs-guides.html#98">directory ($PWD).&nbsp;</a>[74]<br>
Some useful<b>&nbsp;tar</b>&nbsp;options:<br>
-c<br>
1.&nbsp;<br>
&nbsp;create (a new archive)<br>
-x<br>
2.&nbsp;<br>
&nbsp;extract (files from existing archive)<br>
--delete<br>
3.&nbsp;<br>
&nbsp;delete (files from existing archive)<br>
This option will not work on magnetic tape devices.<br>
-r<br>
4.&nbsp;<br>
&nbsp;append (files to existing archive)<br>
-A<br>
5.&nbsp;<br>
&nbsp;append (<i>tar</i>&nbsp;files to existing archive)<br>
-t<br>
6.&nbsp;<br>
&nbsp;list (contents of existing archive)<br>
-u<br>
7.&nbsp;<br>
&nbsp;update archive<br>
-d<br>
8.&nbsp;<br>
&nbsp;compare archive with specified filesystem<br>
--after-date<br>
9.&nbsp;<br>
&nbsp;only process files with a date stamp<i>&nbsp;after</i>&nbsp;specified date<br>
-z<br>
10.&nbsp;<br>
<a href="abs-guides.html#265">&nbsp;gzip the archive</a><br>
(compress or uncompress, depending on whether combined with the&nbsp;-c&nbsp;or&nbsp;-x) option<br>-j<br>
11.&nbsp;<br>
<a href="abs-guides.html#265">&nbsp;bzip2 the archive</a><br>
It may be difficult to recover data from a corrupted<i>&nbsp;gzipped</i>&nbsp;tar archive. When<br>archiving important files, make multiple backups.<br>
<b>shar</b><br>
<i>Shell archiving</i>&nbsp;utility. The text files in a shell archive are concatenated without compression, and the<br>resultant archive is essentially a shell script, complete with #!/bin/sh header, containing all the<br>necessary unarchiving commands, as well as the files themselves.<i>&nbsp;Shar archives</i>&nbsp;still show up in<br>Usenet newsgroups, but otherwise<b>&nbsp;shar</b>&nbsp;has been replaced by<b>&nbsp;tar</b>/<b>gzip</b>. The<b>&nbsp;unshar</b>&nbsp;command<br>unpacks<i>&nbsp;shar</i>&nbsp;archives.<br>
Chapter 16. External Filters, Programs and Commands<br>
256<br>
<hr>
<A name=263></a><IMG src="abs-guide-263_1.png"><br>
<IMG src="abs-guide-263_2.png"><br>
Advanced Bash-Scripting Guide<br>
The<b>&nbsp;mailshar</b>&nbsp;command is a Bash script that uses<b>&nbsp;shar</b>&nbsp;to concatenate multiple files into a single one<br><a href="abs-guides.html#277">for e-mailing. This script supports compression and uuencoding.</a><br>
<b>ar</b><br>
Creation and manipulation utility for archives, mainly used for binary object file libraries.<br>
<b>rpm</b><br>
The<i>&nbsp;Red Hat Package Manager</i>, or<b>&nbsp;rpm</b>&nbsp;utility provides a wrapper for source or binary archives. It<br>includes commands for installing and checking the integrity of packages, among other things.<br>
A simple<b>&nbsp;rpm -i package_name.rpm</b>&nbsp;usually suffices to install a package, though there are many<br>more options available.<br>
<b>rpm -qf</b>&nbsp;identifies which package a file originates from.<br>
bash$&nbsp;<b>rpm -qf /bin/ls<br></b>coreutils-5.2.1-31<br>
<b>rpm -qa</b>&nbsp;gives a complete list of all installed<i>&nbsp;rpm</i>&nbsp;packages on a given system. An<br><b>rpm -qa package_name</b>&nbsp;lists only the package(s) corresponding to<br>package_name.<br>
bash$&nbsp;<b>rpm -qa<br></b>redhat-logos-1.1.3-1<br>
&nbsp;glibc-2.2.4-13<br>
&nbsp;cracklib-2.7-12<br>
&nbsp;dosfstools-2.7-1<br>
&nbsp;gdbm-1.8.0-10<br>
&nbsp;ksymoops-2.4.1-1<br>
&nbsp;mktemp-1.5-11<br>
&nbsp;perl-5.6.0-17<br>
&nbsp;reiserfs-utils-3.x.0j-2<br>
&nbsp;...<br>
bash$&nbsp;<b>rpm -qa docbook-utils<br></b>docbook-utils-0.6.9-2<br>
bash$&nbsp;<b>rpm -qa docbook | grep docbook<br></b>docbook-dtd31-sgml-1.0-10<br>
&nbsp;docbook-style-dsssl-1.64-3<br>
&nbsp;docbook-dtd30-sgml-1.0-10<br>
&nbsp;docbook-dtd40-sgml-1.0-11<br>
&nbsp;docbook-utils-pdf-0.6.9-2<br>
&nbsp;docbook-dtd41-sgml-1.0-10<br>
&nbsp;docbook-utils-0.6.9-2<br>
<b>cpio</b><br>
This specialized archiving copy command (<b>c</b>o<b>p</b>y<b>&nbsp;i</b>nput and<b>&nbsp;o</b>utput) is rarely seen any more, having<br>been supplanted by<b>&nbsp;tar</b>/<b>gzip</b>. It still has its uses, such as moving a directory tree. With an appropriate<br>block size (for copying) specified, it can be appreciably faster than<b>&nbsp;tar</b>.<br>
<b>Example 16-30. Using<i>&nbsp;cpio</i></b><b>&nbsp;to move a directory tree</b><br>
Chapter 16. External Filters, Programs and Commands<br>
257<br>
<hr>
<A name=264></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# Copying a directory tree using cpio.<br>
# Advantages of using 'cpio':<br>
# &nbsp; Speed of copying. It's faster than 'tar' with pipes.<br>
# &nbsp; Well suited for copying special files (named pipes, etc.)<br>
#+ &nbsp;that 'cp' may choke on.<br>
ARGS=2<br>
E_BADARGS=65<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` source destination&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
source=&quot;$1&quot;<br>
destination=&quot;$2&quot;<br>
###################################################################<br>
find &quot;$source&quot; -depth | cpio -admvp &quot;$destination&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^<br>
# &nbsp;Read the 'find' and 'cpio' info pages to decipher these options.<br>
# &nbsp;The above works only relative to $PWD (current directory) . . .<br>
#+ full pathnames are specified.<br>
###################################################################<br>
# Exercise:<br>
# --------<br>
# &nbsp;Add code to check the exit status ($?) of the 'find | cpio' pipe<br>
#+ and output appropriate error messages if anything went wrong.<br>
exit $?<br>
<b>rpm2cpio</b><br>
This command extracts a<b>&nbsp;cpio</b><a href="abs-guides.html#263">&nbsp;archive from an rpm one.</a><br>
<b>Example 16-31. Unpacking an<i>&nbsp;rpm</i></b><b>&nbsp;archive</b><br>
#!/bin/bash<br>
# de-rpm.sh: Unpack an 'rpm' archive<br>
: ${1?&quot;Usage: `basename $0` target-file&quot;}<br>
# Must specify 'rpm' archive name as an argument.<br>
TEMPFILE=$$.cpio &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Tempfile with &quot;unique&quot; name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;$$ is process ID of script.<br>
rpm2cpio &lt; $1 &gt; $TEMPFILE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Converts rpm archive into<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ cpio archive.<br>
cpio --make-directories -F $TEMPFILE -i &nbsp;# &nbsp;Unpacks cpio archive.<br>
rm -f $TEMPFILE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Deletes cpio archive.<br>
exit 0<br>
Chapter 16. External Filters, Programs and Commands<br>
258<br>
<hr>
<A name=265></a><IMG src="abs-guide-265_1.png"><br>
<IMG src="abs-guide-265_2.png"><br>
<IMG src="abs-guide-265_3.png"><br>
<IMG src="abs-guide-265_4.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp;Exercise:<br>
# &nbsp;Add check for whether 1) &quot;target-file&quot; exists and<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2) it is an rpm archive.<br>
# &nbsp;Hint: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Parse output of 'file' command.<br>
<b>pax</b><br>
The<i>&nbsp;pax</i><b>&nbsp;p</b>ortable<b>&nbsp;a</b>rchive e<b>x</b>change toolkit facilitates periodic file backups and is designed to be<br><a href="abs-guides.html#262">cross-compatible between various flavors of UNIX. It was designed to replace tar and cpio.</a><br>
pax -wf daily_backup.pax ~/linux-server/files&nbsp;<br>
# &nbsp;Creates a tar archive of all files in the target directory.<br>
# &nbsp;Note that the options to pax must be in the correct order --<br>
#+ pax -fw &nbsp; &nbsp; has an entirely different effect.<br>
pax -f daily_backup.pax<br>
# &nbsp;Lists the files in the archive.<br>
pax -rf daily_backup.pax ~/bsd-server/files<br>
# &nbsp;Restores the backed-up files from the Linux machine<br>
#+ onto a BSD one.<br>
Note that<i>&nbsp;pax</i>&nbsp;handles many of the standard archiving and compression commands.<br>
<b>Compression</b><br>
<b>gzip</b><br>
The standard GNU/UNIX compression utility, replacing the inferior and proprietary<b>&nbsp;compress</b>. The<br>corresponding decompression command is<b>&nbsp;gunzip</b>, which is the equivalent of<b>&nbsp;gzip -d</b>.<br>
The&nbsp;-c&nbsp;option sends the output of<b>&nbsp;gzip</b>&nbsp;to&nbsp;stdout<a href="abs-guides.html#24">. This is useful when piping to<br></a>other commands.<br>
The<b>&nbsp;zcat</b>&nbsp;filter decompresses a<i>&nbsp;gzipped</i>&nbsp;file to&nbsp;stdout, as possible input to a pipe or redirection. This<br>is, in effect, a<b>&nbsp;cat</b>&nbsp;command that works on compressed files (including files processed with the older<br><a href="abs-guides.html#265">compress utility). The</a><b>&nbsp;zcat</b>&nbsp;command is equivalent to<b>&nbsp;gzip -dc</b>.<br>
On some commercial UNIX systems,<b>&nbsp;zcat</b>&nbsp;is a synonym for<b>&nbsp;uncompress -c</b>, and will<br>not work on<i>&nbsp;gzipped</i>&nbsp;files.<br>
<a href="abs-guides.html#75">See also Example 7-7.</a><br>
<b>bzip2</b><br>
An alternate compression utility, usually more efficient (but slower) than<b>&nbsp;gzip</b>, especially on large<br>files. The corresponding decompression command is<b>&nbsp;bunzip2</b>.<br>
Similar to the<b>&nbsp;zcat</b>&nbsp;command,<b>&nbsp;bzcat</b>&nbsp;decompresses a<i>&nbsp;bzipped2-ed</i>&nbsp;file to&nbsp;stdout.<br>
<a href="abs-guides.html#262">Newer versions of tar have been patched with</a><b>&nbsp;bzip2</b>&nbsp;support.<br>
<b>compress</b>,&nbsp;<b>uncompress</b><br>
This is an older, proprietary compression utility found in commercial UNIX distributions. The more<br>efficient<b>&nbsp;gzip</b>&nbsp;has largely replaced it. Linux distributions generally include a<b>&nbsp;compress</b>&nbsp;workalike for<br>compatibility, although<b>&nbsp;gunzip</b>&nbsp;can unarchive files treated with<b>&nbsp;compress</b>.<br>
The<b>&nbsp;znew</b>&nbsp;command transforms<i>&nbsp;compressed</i>&nbsp;files into<i>&nbsp;gzipped</i>&nbsp;ones.<br>
<b>sq</b><br>
Chapter 16. External Filters, Programs and Commands<br>
259<br>
<hr>
<A name=266></a><IMG src="abs-guide-266_1.png"><br>
Advanced Bash-Scripting Guide<br>
Yet another compression (<b>sq</b><a href="abs-guides.html#882">ueeze) utility, a filter that works only on sorted ASCII word lists. It uses<br></a>the standard invocation syntax for a filter,<b>&nbsp;sq &lt; input-file &gt; output-file</b>. Fast, but not nearly as<br><a href="abs-guides.html#265">efficient as gzip. The corresponding uncompression filter is</a><b>&nbsp;unsq</b>, invoked like<b>&nbsp;sq</b>.<br>
The output of<b>&nbsp;sq</b>&nbsp;may be piped to<b>&nbsp;gzip</b>&nbsp;for further compression.<br>
<b>zip</b>,<b>&nbsp;unzip</b><br>
Cross-platform file archiving and compression utility compatible with DOS<i>&nbsp;pkzip.exe</i>. &quot;Zipped&quot;<br>archives seem to be a more common medium of file exchange on the Internet than &quot;tarballs.&quot;<br>
<b>unarc</b>,<b>&nbsp;unarj</b>,<b>&nbsp;unrar</b><br>
These Linux utilities permit unpacking archives compressed with the DOS<i>&nbsp;arc.exe</i>,<i>&nbsp;arj.exe</i>, and<br><i>rar.exe</i>&nbsp;programs.<br>
<b>lzma</b>,<b>&nbsp;unlzma</b>,<b>&nbsp;lzcat</b><br>
Highly efficient Lempel-Ziv-Markov compression. The syntax of<i>&nbsp;lzma</i>&nbsp;is similar to that of<i>&nbsp;gzip</i>. The<br><a href="http://www.7-zip.org/sdk.html">7-zip Website has more information.</a><br>
<b>File Information</b><br>
<b>file</b><br>
A utility for identifying file types. The command&nbsp;<b>file file-name</b>&nbsp;will return a file specification<br>for&nbsp;file-name, such as&nbsp;ascii text&nbsp;or&nbsp;data<a href="abs-guides.html#11">. It references the magic numbers found in<br></a>/usr/share/magic,&nbsp;/etc/magic, or&nbsp;/usr/lib/magic, depending on the Linux/UNIX<br>distribution.<br>
The&nbsp;-f&nbsp;option causes<b>&nbsp;file</b><a href="abs-guides.html#239">&nbsp;to run in batch mode, to read from a designated file a list of filenames to<br></a>analyze. The&nbsp;-z&nbsp;option, when used on a compressed target file, forces an attempt to analyze the<br>uncompressed file type.<br>
bash$&nbsp;<b>file test.tar.gz<br></b>test.tar.gz: gzip compressed data, deflated,<br>
&nbsp;last modified: Sun Sep 16 13:34:51 2001, os: Unix<br>
bash&nbsp;<b>file -z test.tar.gz<br></b>test.tar.gz: GNU tar archive (gzip compressed data, deflated,<br>
&nbsp;last modified: Sun Sep 16 13:34:51 2001, os: Unix)<br>
# Find sh and Bash scripts in a given directory:<br>
DIRECTORY=/usr/local/bin<br>
KEYWORD=Bourne<br>
# Bourne and Bourne-Again shell scripts<br>
file $DIRECTORY/* | fgrep $KEYWORD<br>
# Output:<br>
# /usr/local/bin/burn-cd: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bourne-Again shell script text executable<br>
# /usr/local/bin/burnit: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bourne-Again shell script text executable<br>
# /usr/local/bin/cassette.sh: &nbsp; &nbsp; &nbsp;Bourne shell script text executable<br>
# /usr/local/bin/copy-cd: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bourne-Again shell script text executable<br>
# . . .<br>
<b>Example 16-32. Stripping comments from C program files</b><br>
Chapter 16. External Filters, Programs and Commands<br>
260<br>
<hr>
<A name=267></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.<br>
E_NOARGS=0<br>
E_ARGERROR=66<br>
E_WRONG_FILE_TYPE=67<br>
if [ $# -eq &quot;$E_NOARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` C-program-file&quot; &gt;&amp;2 # Error message to stderr.<br>
&nbsp; exit $E_ARGERROR<br>
fi &nbsp;<br>
# Test for correct file type.<br>
type=`file $1 | awk '{ print $2, $3, $4, $5 }'`<br>
# &quot;file $1&quot; echoes file type . . .<br>
# Then awk removes the first field, the filename . . .<br>
# Then the result is fed into the variable &quot;type.&quot;<br>
correct_type=&quot;ASCII C program text&quot;<br>
if [ &quot;$type&quot; != &quot;$correct_type&quot; ]<br>
then<br>
&nbsp; echo<br>
&nbsp; echo &quot;This script works on C program files only.&quot;<br>
&nbsp; echo<br>
&nbsp; exit $E_WRONG_FILE_TYPE<br>
fi &nbsp;<br>
# Rather cryptic sed script:<br>
#--------<br>
sed '<br>
/^\/\*/d<br>
/.*\*\//d<br>
' $1<br>
#--------<br>
# Easy to understand if you take several hours to learn sed fundamentals.<br>
# &nbsp;Need to add one more line to the sed script to deal with<br>
#+ case where line of code has a comment following it on same line.<br>
# &nbsp;This is left as a non-trivial exercise.<br>
# &nbsp;Also, the above code deletes non-comment lines with a &quot;*/&quot; . . .<br>
#+ not a desirable result.<br>
exit 0<br>
# ----------------------------------------------------------------<br>
# Code below this line will not execute because of 'exit 0' above.<br>
# Stephane Chazelas suggests the following alternative:<br>
usage() {<br>
&nbsp; echo &quot;Usage: `basename $0` C-program-file&quot; &gt;&amp;2<br>
&nbsp; exit 1<br>
}<br>
WEIRD=`echo -n -e '\377'` &nbsp; # or WEIRD=$'\377'<br>
[[ $# -eq 1 ]] || usage<br>
case `file &quot;$1&quot;` in<br>
Chapter 16. External Filters, Programs and Commands<br>
261<br>
<hr>
<A name=268></a>Advanced Bash-Scripting Guide<br>
&nbsp; *&quot;C program text&quot;*) sed -e &quot;s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g&quot; &quot;$1&quot; \<br>
&nbsp; &nbsp; &nbsp;| tr '\377\n' '\n\377' \<br>
&nbsp; &nbsp; &nbsp;| sed -ne 'p;n' \<br>
&nbsp; &nbsp; &nbsp;| tr -d '\n' | tr '\377' '\n';;<br>
&nbsp; *) usage;;<br>
esac<br>
# &nbsp;This is still fooled by things like:<br>
# &nbsp;printf(&quot;/*&quot;);<br>
# &nbsp;or<br>
# &nbsp;/* &nbsp;/* buggy embedded comment */<br>
#<br>
# &nbsp;To handle all special cases (comments in strings, comments in string<br>
#+ where there is a \&quot;, \\&quot; ...),<br>
#+ the only way is to write a C parser (using lex or yacc perhaps?).<br>
exit 0<br>
<b>which</b><br>
<b>which command</b>&nbsp;gives the full path to &quot;command.&quot; This is useful for finding out whether a particular<br>command or utility is installed on the system.<br>
<b>$bash which rm</b><br>
/usr/bin/rm<br>
<a href="abs-guides.html#517">For an interesting use of this command, see Example 36-14.</a><br>
<b>whereis</b><br>
Similar to<b>&nbsp;which</b>, above,<b>&nbsp;whereis command</b>&nbsp;gives the full path to &quot;command,&quot; but also to its<br><a href="abs-guides.html#225">manpage.</a><br>
<b>$bash whereis rm</b><br>
rm: /bin/rm /usr/share/man/man1/rm.1.bz2<br>
<b>whatis</b><br>
<b>whatis command</b>&nbsp;looks up &quot;command&quot; in the&nbsp;<i>whatis</i>&nbsp;database. This is useful for identifying system<br>commands and important configuration files. Consider it a simplified<b>&nbsp;man</b>&nbsp;command.<br>
<b>$bash whatis whatis</b><br>
whatis &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (1) &nbsp;- search the whatis database for complete words<br>
<b>Example 16-33. Exploring&nbsp;/usr/X11R6/bin</b><br>
#!/bin/bash<br>
# What are all those mysterious binaries in /usr/X11R6/bin?<br>
DIRECTORY=&quot;/usr/X11R6/bin&quot;<br>
# Try also &quot;/bin&quot;, &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;, etc.<br>
for file in $DIRECTORY/*<br>
do<br>
&nbsp; whatis `basename $file` &nbsp; # Echoes info about the binary.<br>
done<br>
exit 0<br>
Chapter 16. External Filters, Programs and Commands<br>
262<br>
<hr>
<A name=269></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Note: For this to work, you must create a &quot;whatis&quot; database<br>
#+ with /usr/sbin/makewhatis.<br>
# &nbsp;You may wish to redirect output of this script, like so:<br>
# &nbsp; &nbsp;./what.sh &gt;&gt;whatis.db<br>
# &nbsp;or view it a page at a time on stdout,<br>
# &nbsp; &nbsp;./what.sh | less<br>
<a href="abs-guides.html#145">See also Example 11-3.</a><br>
<b>vdir</b><br>
<a href="abs-guides.html#220">Show a detailed directory listing. The effect is similar to ls -lb.</a><br>
This is one of the GNU<i>&nbsp;fileutils</i>.<br>
bash$&nbsp;<b>vdir<br></b>total 10<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4034 Jul 18 22:04 data1.xrolo<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4602 May 25 13:58 data1.xrolo.bak<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 877 Dec 17 &nbsp;2000 employment.xrolo<br>
bash&nbsp;<b>ls -l<br></b>total 10<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4034 Jul 18 22:04 data1.xrolo<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp;4602 May 25 13:58 data1.xrolo.bak<br>
&nbsp;-rw-r--r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 877 Dec 17 &nbsp;2000 employment.xrolo<br>
<b>locate</b>,&nbsp;<b>slocate</b><br>
The<b>&nbsp;locate</b>&nbsp;command searches for files using a database stored for just that purpose. The<b>&nbsp;slocate<br></b>command is the secure version of<b>&nbsp;locate</b>&nbsp;(which may be aliased to<b>&nbsp;slocate</b>).<br>
<b>$bash locate hickson</b><br>
/usr/lib/xephem/catalogs/hickson.edb<br>
<b>getfacl</b>,&nbsp;<b>setfacl</b><br>
These commands<i>&nbsp;retrieve</i>&nbsp;or<i>&nbsp;set</i>&nbsp;the<b>&nbsp;f</b>ile<b>&nbsp;a</b>ccess<b>&nbsp;c</b>ontrol<b>&nbsp;l</b>ist -- the<i>&nbsp;owner</i>,<i>&nbsp;group</i>, and file permissions.<br>
bash$&nbsp;<b>getfacl *<br></b># file: test1.txt<br>
&nbsp;# owner: bozo<br>
&nbsp;# group: bozgrp<br>
&nbsp;user::rw-<br>
&nbsp;group::rw-<br>
&nbsp;other::r--<br>
&nbsp;# file: test2.txt<br>
&nbsp;# owner: bozo<br>
&nbsp;# group: bozgrp<br>
&nbsp;user::rw-<br>
&nbsp;group::rw-<br>
&nbsp;other::r--<br>
bash$&nbsp;<b>setfacl -m u:bozo:rw yearly_budget.csv<br></b>bash$&nbsp;<b>getfacl yearly_budget.csv<br></b># file: yearly_budget.csv<br>
&nbsp;# owner: accountant<br>
&nbsp;# group: budgetgrp<br>
&nbsp;user::rw-<br>
&nbsp;user:bozo:rw-<br>
Chapter 16. External Filters, Programs and Commands<br>
263<br>
<hr>
<A name=270></a>Advanced Bash-Scripting Guide<br>
&nbsp;user:accountant:rw-<br>
&nbsp;group::rw-<br>
&nbsp;mask::rw-<br>
&nbsp;other::r--<br>
<b>readlink</b><br>
Disclose the file that a symbolic link points to.<br>
bash$&nbsp;<b>readlink /usr/bin/awk<br></b>../../bin/gawk<br>
<b>strings</b><br>
Use the<b>&nbsp;strings</b>&nbsp;command to find printable strings in a binary or data file. It will list sequences of<br>printable characters found in the target file. This might be handy for a quick 'n dirty examination of a<br>core dump or for looking at an unknown graphic image file (<b>strings image-file | more<br></b>might show something like<i>&nbsp;JFIF</i>, which would identify the file as a<i>&nbsp;jpeg</i>&nbsp;graphic). In a script, you<br>would probably parse the output of<b>&nbsp;strings</b><a href="abs-guides.html#246">&nbsp;with grep or sed. See Example 11-7 and Example 11-9.</a><br>
<b>Example 16-34. An &quot;improved&quot;<i>&nbsp;strings</i></b><b>&nbsp;command</b><br>
#!/bin/bash<br>
# wstrings.sh: &quot;word-strings&quot; (enhanced &quot;strings&quot; command)<br>
#<br>
# &nbsp;This script filters the output of &quot;strings&quot; by checking it<br>
#+ against a standard word list file.<br>
# &nbsp;This effectively eliminates gibberish and noise,<br>
#+ and outputs only recognized words.<br>
# ===========================================================<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Standard Check for Script Argument(s)<br>
ARGS=1<br>
E_BADARGS=85<br>
E_NOFILE=86<br>
if [ $# -ne $ARGS ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ ! -f &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Check if file exists.<br>
then<br>
&nbsp; &nbsp; echo &quot;File \&quot;$1\&quot; does not exist.&quot;<br>
&nbsp; &nbsp; exit $E_NOFILE<br>
fi<br>
# ===========================================================<br>
MINSTRLEN=3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Minimum string length.<br>
WORDFILE=/usr/share/dict/linux.words &nbsp;# &nbsp;Dictionary file.<br>
# &nbsp;May specify a different word list file<br>
#+ of one-word-per-line format.<br>
# &nbsp;For example, the &quot;yawl&quot; word-list package,<br>
# &nbsp;http://bash.webofcrafts.net/yawl-0.3.2.tar.gz<br>
wlist=`strings &quot;$1&quot; | tr A-Z a-z | tr '[:space:]' Z | \<br>
tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`<br>
Chapter 16. External Filters, Programs and Commands<br>
264<br>
<hr>
<A name=271></a><IMG src="abs-guide-271_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Translate output of 'strings' command with multiple passes of 'tr'.<br>
# &nbsp;&quot;tr A-Z a-z&quot; &nbsp;converts to lowercase.<br>
# &nbsp;&quot;tr '[:space:]'&quot; &nbsp;converts whitespace characters to Z's.<br>
# &nbsp;&quot;tr -cs '[:alpha:]' Z&quot; &nbsp;converts non-alphabetic characters to Z's,<br>
#+ and squeezes multiple consecutive Z's.<br>
# &nbsp;&quot;tr -s '\173-\377' Z&quot; &nbsp;converts all characters past 'z' to Z's<br>
#+ and squeezes multiple consecutive Z's,<br>
#+ which gets rid of all the weird characters that the previous<br>
#+ translation failed to deal with.<br>
# &nbsp;Finally, &quot;tr Z ' '&quot; converts all those Z's to whitespace,<br>
#+ which will be seen as word separators in the loop below.<br>
# &nbsp;********************************************************************<br>
# &nbsp;Note the technique of feeding the output of 'tr' back to itself,<br>
#+ but with different arguments and/or options on each successive pass.<br>
# &nbsp;********************************************************************<br>
for word in $wlist &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Important:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $wlist must not be quoted here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;$wlist&quot; does not work.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why not?<br>
do<br>
&nbsp; strlen=${#word} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # String length.<br>
&nbsp; if [ &quot;$strlen&quot; -lt &quot;$MINSTRLEN&quot; ] &nbsp; # Skip over short strings.<br>
&nbsp; then<br>
&nbsp; &nbsp; continue<br>
&nbsp; fi<br>
&nbsp; grep -Fw $word &quot;$WORDFILE&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Match whole words only.<br>
# &nbsp; &nbsp; &nbsp;^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;&quot;Fixed strings&quot; and<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ &quot;whole words&quot; options.&nbsp;<br>
done &nbsp;<br>
exit $?<br>
<b>Comparison</b><br>
<b>diff</b>,<b>&nbsp;patch</b><br>
<b>diff</b>: flexible file comparison utility. It compares the target files line-by-line sequentially. In some<br><a href="abs-guides.html#240">applications, such as comparing word dictionaries, it may be helpful to filter the files through sort and<br></a><b>uniq</b>&nbsp;before piping them to<b>&nbsp;diff</b>.&nbsp;<b>diff file-1 file-2</b>&nbsp;outputs the lines in the files that differ,<br>with carets showing which file each particular line belongs to.<br>
The&nbsp;--side-by-side&nbsp;option to<b>&nbsp;diff</b>&nbsp;outputs each compared file, line by line, in separate columns,<br>with non-matching lines marked. The&nbsp;-c&nbsp;and&nbsp;-u&nbsp;options likewise make the output of the command<br>easier to interpret.<br>
There are available various fancy frontends for<b>&nbsp;diff</b>, such as<b>&nbsp;sdiff</b>,<b>&nbsp;wdiff</b>,<b>&nbsp;xdiff</b>, and<b>&nbsp;mgdiff</b>.<br>
The<b>&nbsp;diff</b>&nbsp;command returns an exit status of 0 if the compared files are identical, and 1<br>if they differ. This permits use of<b>&nbsp;diff</b>&nbsp;in a test construct within a shell script (see<br>below).<br>
A common use for<b>&nbsp;diff</b>&nbsp;is generating difference files to be used with<b>&nbsp;patch</b>&nbsp;The&nbsp;-e&nbsp;option outputs<br>files suitable for<b>&nbsp;ed</b>&nbsp;or<b>&nbsp;ex</b>&nbsp;scripts.<br>
Chapter 16. External Filters, Programs and Commands<br>
265<br>
<hr>
<A name=272></a><IMG src="abs-guide-272_1.png"><br>
<IMG src="abs-guide-272_2.png"><br>
<IMG src="abs-guide-272_3.png"><br>
Advanced Bash-Scripting Guide<br>
<b>patch</b>: flexible versioning utility. Given a difference file generated by<b>&nbsp;diff</b>,<b>&nbsp;patch</b>&nbsp;can upgrade a<br>previous version of a package to a newer version. It is much more convenient to distribute a relatively<br>small &quot;diff&quot; file than the entire body of a newly revised package. Kernel &quot;patches&quot; have become the<br>preferred method of distributing the frequent releases of the Linux kernel.<br>
patch -p1 &lt;patch-file<br>
# Takes all the changes listed in 'patch-file'<br>
# and applies them to the files referenced therein.<br>
# This upgrades to a newer version of the package.<br>
Patching the kernel:<br>
cd /usr/src<br>
gzip -cd patchXX.gz | patch -p0<br>
# Upgrading kernel source using 'patch'.<br>
# From the Linux kernel docs &quot;README&quot;,<br>
# by anonymous author (Alan Cox?).<br>
The<b>&nbsp;diff</b>&nbsp;command can also recursively compare directories (for the filenames<br>present).<br>
bash$&nbsp;<b>diff -r ~/notes1 ~/notes2<br></b>Only in /home/bozo/notes1: file02<br>
&nbsp;Only in /home/bozo/notes1: file03<br>
&nbsp;Only in /home/bozo/notes2: file04<br>
Use<b>&nbsp;zdiff</b>&nbsp;to compare<i>&nbsp;gzipped</i>&nbsp;files.<br>
Use<b>&nbsp;diffstat</b>&nbsp;to create a histogram (point-distribution graph) of output from<b>&nbsp;diff</b>.<br>
<b>diff3</b>,<b>&nbsp;merge</b><br>
An extended version of<b>&nbsp;diff</b>&nbsp;that compares three files at a time. This command returns an exit value of<br>0 upon successful execution, but unfortunately this gives no information about the results of the<br>comparison.<br>
bash$&nbsp;<b>diff3 file-1 file-2 file-3<br></b>====<br>
&nbsp;1:1c<br>
&nbsp; &nbsp;This is line 1 of &quot;file-1&quot;.<br>
&nbsp;2:1c<br>
&nbsp; &nbsp;This is line 1 of &quot;file-2&quot;.<br>
&nbsp;3:1c<br>
&nbsp; &nbsp;This is line 1 of &quot;file-3&quot;<br>
The<b>&nbsp;merge</b>&nbsp;(3-way file merge) command is an interesting adjunct to<i>&nbsp;diff3</i>. Its syntax is&nbsp;<b>merge<br>Mergefile file1 file2</b>. The result is to output to&nbsp;Mergefile&nbsp;the changes that lead from<br>file1&nbsp;to&nbsp;file2. Consider this command a stripped-down version of<i>&nbsp;patch</i>.<br>
<b>sdiff</b><br>
Compare and/or edit two files in order to merge them into an output file. Because of its interactive<br>nature, this command would find little use in a script.<br>
<b>cmp</b><br>
The<b>&nbsp;cmp</b>&nbsp;command is a simpler version of<b>&nbsp;diff</b>, above. Whereas<b>&nbsp;diff</b>&nbsp;reports the differences between<br>
Chapter 16. External Filters, Programs and Commands<br>
266<br>
<hr>
<A name=273></a><IMG src="abs-guide-273_1.png"><br>
<IMG src="abs-guide-273_2.png"><br>
Advanced Bash-Scripting Guide<br>
two files,<b>&nbsp;cmp</b>&nbsp;merely shows at what point they differ.<br>
Like<b>&nbsp;diff</b>,<b>&nbsp;cmp</b>&nbsp;returns an exit status of 0 if the compared files are identical, and 1 if<br>they differ. This permits use in a test construct within a shell script.<br>
<b>Example 16-35. Using<i>&nbsp;cmp</i></b><b>&nbsp;to compare two files within a script.</b><br>
#!/bin/bash<br>
ARGS=2 &nbsp;# Two args to script expected.<br>
E_BADARGS=65<br>
E_UNREADABLE=66<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` file1 file2&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [[ ! -r &quot;$1&quot; || ! -r &quot;$2&quot; ]]<br>
then<br>
&nbsp; echo &quot;Both files to be compared must exist and be readable.&quot;<br>
&nbsp; exit $E_UNREADABLE<br>
fi<br>
cmp $1 $2 &amp;&gt; /dev/null &nbsp;# /dev/null buries the output of the &quot;cmp&quot; command.<br>
# &nbsp; cmp -s $1 $2 &nbsp;has same result (&quot;-s&quot; silent flag to &quot;cmp&quot;)<br>
# &nbsp; Thank you &nbsp;Anders Gustavsson for pointing this out.<br>
#<br>
# Also works with 'diff', i.e., &nbsp; diff $1 $2 &amp;&gt; /dev/null<br>
if [ $? -eq 0 ] &nbsp; &nbsp; &nbsp; &nbsp; # Test exit status of &quot;cmp&quot; command.<br>
then<br>
&nbsp; echo &quot;File \&quot;$1\&quot; is identical to file \&quot;$2\&quot;.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;File \&quot;$1\&quot; differs from file \&quot;$2\&quot;.&quot;<br>
fi<br>
exit 0<br>
Use<b>&nbsp;zcmp</b>&nbsp;on<i>&nbsp;gzipped</i>&nbsp;files.<br>
<b>comm</b><br>
Versatile file comparison utility. The files must be sorted for this to be useful.<br>
<b>comm&nbsp;<i>-options&nbsp;first-file&nbsp;second-file</i></b><br>
<b>comm file-1 file-2</b>&nbsp;outputs three columns:<br>
column 1 = lines unique to&nbsp;<br>
◊&nbsp;<br>
file-1<br>
column 2 = lines unique to&nbsp;<br>
◊&nbsp;<br>
file-2<br>
column 3 = lines common to both.<br>
◊&nbsp;<br>
The options allow suppressing output of one or more columns.<br>
-1<br>
◊&nbsp;<br>
&nbsp;suppresses column&nbsp;1<br>
-2<br>
◊&nbsp;<br>
&nbsp;suppresses column&nbsp;2<br>
-3<br>
◊&nbsp;<br>
&nbsp;suppresses column&nbsp;3<br>
Chapter 16. External Filters, Programs and Commands<br>
267<br>
<hr>
<A name=274></a><IMG src="abs-guide-274_1.png"><br>
Advanced Bash-Scripting Guide<br>
-12<br>
◊&nbsp;<br>
&nbsp;suppresses both columns&nbsp;1&nbsp;and&nbsp;2, etc.<br>
This command is useful for comparing &quot;dictionaries&quot; or<i>&nbsp;word lists</i>&nbsp;-- sorted text files with one word<br>per line.<br>
<b>Utilities</b><br>
<b>basename</b><br>
Strips the path information from a file name, printing only the file name. The construction<br><b>basename $0</b>&nbsp;lets the script know its name, that is, the name it was invoked by. This can be used<br>for &quot;usage&quot; messages if, for example a script is called with missing arguments:<br>
echo &quot;Usage: `basename $0` arg1 arg2 ... argn&quot;<br>
<b>dirname</b><br>
Strips the<b>&nbsp;basename</b>&nbsp;from a filename, printing only the path information.<br>
<b>basename</b>&nbsp;and<b>&nbsp;dirname</b>&nbsp;can operate on any arbitrary string. The argument does not<br><a href="abs-guides.html#577">need to refer to an existing file, or even be a filename for that matter (see Example<br>A-7).</a><br>
<b>Example 16-36.<i>&nbsp;basename</i></b><b>&nbsp;and<i>&nbsp;dirname</i></b><br>
#!/bin/bash<br>
a=/home/bozo/daily-journal.txt<br>
echo &quot;Basename of /home/bozo/daily-journal.txt = `basename $a`&quot;<br>
echo &quot;Dirname of /home/bozo/daily-journal.txt = `dirname $a`&quot;<br>
echo<br>
echo &quot;My own home is `basename ~/`.&quot; &nbsp; &nbsp; &nbsp; &nbsp; # `basename ~` also works.<br>
echo &quot;The home of my home is `dirname ~/`.&quot; &nbsp;# `dirname ~` &nbsp;also works.<br>
exit 0<br>
<b>split</b>,&nbsp;<b>csplit</b><br>
These are utilities for splitting a file into smaller chunks. Their usual use is for splitting up large files<br>in order to back them up on floppies or preparatory to e-mailing or uploading them.<br>
The<b>&nbsp;csplit</b>&nbsp;command splits a file according to<i>&nbsp;context</i>, the split occuring where patterns are matched.<br>
<b>Example 16-37. A script that copies itself in sections</b><br>
#!/bin/bash<br>
# splitcopy.sh<br>
# &nbsp;A script that splits itself into chunks,<br>
#+ then reassembles the chunks into an exact copy<br>
#+ of the original script.<br>
CHUNKSIZE=4 &nbsp; &nbsp;# &nbsp;Size of first chunk of split files.<br>
OUTPREFIX=xx &nbsp; # &nbsp;csplit prefixes, by default,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ files with &quot;xx&quot; ...<br>
csplit &quot;$0&quot; &quot;$CHUNKSIZE&quot;<br>
# Some comment lines for padding . . .<br>
Chapter 16. External Filters, Programs and Commands<br>
268<br>
<hr>
<A name=275></a><IMG src="abs-guide-275_1.png"><br>
Advanced Bash-Scripting Guide<br>
# Line 15<br>
# Line 16<br>
# Line 17<br>
# Line 18<br>
# Line 19<br>
# Line 20<br>
cat &quot;$OUTPREFIX&quot;* &gt; &quot;$0.copy&quot; &nbsp;# Concatenate the chunks.<br>
rm &quot;$OUTPREFIX&quot;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Get rid of the chunks.<br>
exit $?<br>
<b>Encoding and Encryption</b><br>
<b>sum</b>,&nbsp;<b>cksum</b>,&nbsp;<b>md5sum</b>,&nbsp;<b>sha1sum</b><br>
These are utilities for generating<i>&nbsp;checksums</i>. A<i>&nbsp;checksum</i>&nbsp;is a number&nbsp;[75] mathematically calculated<br>from the contents of a file, for the purpose of checking its integrity. A script might refer to a list of<br>checksums for security purposes, such as ensuring that the contents of key system files have not been<br>altered or corrupted. For security applications, use the<b>&nbsp;md5sum</b>&nbsp;(<b>m</b>essage<b>&nbsp;d</b>igest<b>&nbsp;5</b>&nbsp;check<b>sum</b>)<br>command, or better yet, the newer<b>&nbsp;sha1sum</b>&nbsp;(Secure Hash Algorithm).&nbsp;[76]<br>
bash$&nbsp;<b>cksum /boot/vmlinuz<br></b>1670054224 804083 /boot/vmlinuz<br>
bash$&nbsp;<b>echo -n &quot;Top Secret&quot; | cksum<br></b>3391003827 10<br>
bash$&nbsp;<b>md5sum /boot/vmlinuz<br></b>0f43eccea8f09e0a0b2b5cf1dcf333ba &nbsp;/boot/vmlinuz<br>
bash$&nbsp;<b>echo -n &quot;Top Secret&quot; | md5sum<br></b>8babc97a6f62a4649716f4df8d61728f &nbsp;-<br>
The<b>&nbsp;cksum</b>&nbsp;command shows the size, in bytes, of its target, whether file or&nbsp;stdout.<br>
The<b>&nbsp;md5sum</b>&nbsp;and<b>&nbsp;sha1sum</b><a href="abs-guides.html#27">&nbsp;commands display a dash when they receive their input<br></a>from&nbsp;stdout.<br>
<b>Example 16-38. Checking file integrity</b><br>
#!/bin/bash<br>
# file-integrity.sh: Checking whether files in a given directory<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;have been tampered with.<br>
E_DIR_NOMATCH=70<br>
E_BAD_DBFILE=71<br>
dbfile=File_record.md5<br>
# Filename for storing records (database file).<br>
set_up_database ()<br>
{<br>
&nbsp; echo &quot;&quot;$directory&quot;&quot; &gt; &quot;$dbfile&quot;<br>
Chapter 16. External Filters, Programs and Commands<br>
269<br>
<hr>
<A name=276></a>Advanced Bash-Scripting Guide<br>
&nbsp; # Write directory name to first line of file.<br>
&nbsp; md5sum &quot;$directory&quot;/* &gt;&gt; &quot;$dbfile&quot;<br>
&nbsp; # Append md5 checksums and filenames.<br>
}<br>
check_database ()<br>
{<br>
&nbsp; local n=0<br>
&nbsp; local filename<br>
&nbsp; local checksum<br>
&nbsp; # ------------------------------------------- #<br>
&nbsp; # &nbsp;This file check should be unnecessary,<br>
&nbsp; #+ but better safe than sorry.<br>
&nbsp; if [ ! -r &quot;$dbfile&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Unable to read checksum database file!&quot;<br>
&nbsp; &nbsp; exit $E_BAD_DBFILE<br>
&nbsp; fi<br>
&nbsp; # ------------------------------------------- #<br>
&nbsp; while read record[n]<br>
&nbsp; do<br>
&nbsp; &nbsp; directory_checked=&quot;${record[0]}&quot;<br>
&nbsp; &nbsp; if [ &quot;$directory_checked&quot; != &quot;$directory&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;Directories do not match up!&quot;<br>
&nbsp; &nbsp; &nbsp; # Tried to use file for a different directory.<br>
&nbsp; &nbsp; &nbsp; exit $E_DIR_NOMATCH<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ &quot;$n&quot; -gt 0 ] &nbsp; # Not directory name.<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )<br>
&nbsp; &nbsp; &nbsp; # &nbsp;md5sum writes records backwards,<br>
&nbsp; &nbsp; &nbsp; #+ checksum first, then filename.<br>
&nbsp; &nbsp; &nbsp; checksum[n]=$( md5sum &quot;${filename[n]}&quot; )<br>
&nbsp; &nbsp; &nbsp; if [ &quot;${record[n]}&quot; = &quot;${checksum[n]}&quot; ]<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;${filename[n]} unchanged.&quot;<br>
&nbsp; &nbsp; &nbsp; elif [ &quot;`basename ${filename[n]}`&quot; != &quot;$dbfile&quot; ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Skip over checksum database file,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ as it will change with each invocation of script.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;---<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This unfortunately means that when running<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ this script on $PWD, tampering with the<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ checksum database file will not be detected.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Exercise: Fix this.<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;${filename[n]} : CHECKSUM ERROR!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # File has been changed since last checked.<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; fi<br>
Chapter 16. External Filters, Programs and Commands<br>
270<br>
<hr>
<A name=277></a><IMG src="abs-guide-277_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; let &quot;n+=1&quot;<br>
&nbsp; done &lt;&quot;$dbfile&quot; &nbsp; &nbsp; &nbsp; # Read from checksum database file.&nbsp;<br>
} &nbsp;<br>
# =================================================== #<br>
# main ()<br>
if [ -z &nbsp;&quot;$1&quot; ]<br>
then<br>
&nbsp; directory=&quot;$PWD&quot; &nbsp; &nbsp; &nbsp;# &nbsp;If not specified,<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ use current working directory.<br>
&nbsp; directory=&quot;$1&quot;<br>
fi &nbsp;<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Clear screen.<br>
echo &quot; Running file integrity check on $directory&quot;<br>
echo<br>
# ------------------------------------------------------------------ #<br>
&nbsp; if [ ! -r &quot;$dbfile&quot; ] # Need to create database file?<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Setting up database file, \&quot;&quot;$directory&quot;/&quot;$dbfile&quot;\&quot;.&quot;; echo<br>
&nbsp; &nbsp; set_up_database<br>
&nbsp; fi &nbsp;<br>
# ------------------------------------------------------------------ #<br>
check_database &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Do the actual work.<br>
echo&nbsp;<br>
# &nbsp;You may wish to redirect the stdout of this script to a file,<br>
#+ especially if the directory checked has many files in it.<br>
exit 0<br>
# &nbsp;For a much more thorough file integrity check,<br>
#+ consider the &quot;Tripwire&quot; package,<br>
#+ http://sourceforge.net/projects/tripwire/.<br>
<a href="abs-guides.html#600">Also see Example A-19, Example 36-14, and Example 10-2 for creative uses of the</a><b>&nbsp;md5sum<br></b>command.<br>
There have been reports that the 128-bit<b>&nbsp;md5sum</b>&nbsp;can be cracked, so the more secure<br>160-bit<b>&nbsp;sha1sum</b>&nbsp;is a welcome new addition to the checksum toolkit.<br>
bash$&nbsp;<b>md5sum testfile<br></b>e181e2c8720c60522c4c4c981108e367 &nbsp;testfile<br>
bash$&nbsp;<b>sha1sum testfile<br></b>5d7425a9c08a66c3177f1e31286fa40986ffc996 &nbsp;testfile<br>
Security consultants have demonstrated that even<b>&nbsp;sha1sum</b>&nbsp;can be compromised. Fortunately, newer<br>Linux distros include longer bit-length<b>&nbsp;sha224sum</b>,<b>&nbsp;sha256sum</b>,<b>&nbsp;sha384sum</b>, and<b>&nbsp;sha512sum<br></b>commands.<br>
<b>uuencode</b><br>
<a href="abs-guides.html#882">This utility encodes binary files (images, sound files, compressed files, etc.) into ASCII characters,<br></a>making them suitable for transmission in the body of an e-mail message or in a newsgroup posting.<br>
Chapter 16. External Filters, Programs and Commands<br>
271<br>
<hr>
<A name=278></a><IMG src="abs-guide-278_1.png"><br>
Advanced Bash-Scripting Guide<br>
This is especially useful where MIME (multimedia) encoding is not available.<br>
<b>uudecode</b><br>
This reverses the encoding, decoding<i>&nbsp;uuencoded</i>&nbsp;files back into the original binaries.<br>
<b>Example 16-39. Uudecoding encoded files</b><br>
#!/bin/bash<br>
# Uudecodes all uuencoded files in current working directory.<br>
lines=35 &nbsp; &nbsp; &nbsp; &nbsp;# Allow 35 lines for the header (very generous).<br>
for File in * &nbsp; # Test all the files in $PWD.<br>
do<br>
&nbsp; search1=`head -n $lines $File | grep begin | wc -w`<br>
&nbsp; search2=`tail -n $lines $File | grep end | wc -w`<br>
&nbsp; # &nbsp;Uuencoded files have a &quot;begin&quot; near the beginning,<br>
&nbsp; #+ and an &quot;end&quot; near the end.<br>
&nbsp; if [ &quot;$search1&quot; -gt 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; if [ &quot;$search2&quot; -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;uudecoding - $File -&quot;<br>
&nbsp; &nbsp; &nbsp; uudecode $File<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; fi<br>
done &nbsp;<br>
# &nbsp;Note that running this script upon itself fools it<br>
#+ into thinking it is a uuencoded file,<br>
#+ because it contains both &quot;begin&quot; and &quot;end&quot;.<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Modify this script to check each file for a newsgroup header,<br>
#+ and skip to next if not found.<br>
exit 0<br>
<a href="abs-guides.html#258">The fold -s command may be useful (possibly in a pipe) to process long uudecoded<br></a>text messages downloaded from Usenet newsgroups.<br>
<b>mimencode</b>,&nbsp;<b>mmencode</b><br>
The<b>&nbsp;mimencode</b>&nbsp;and<b>&nbsp;mmencode</b>&nbsp;commands process multimedia-encoded e-mail attachments.<br>Although<i>&nbsp;mail user agents</i>&nbsp;(such as<i>&nbsp;pine</i>&nbsp;or<i>&nbsp;kmail</i>) normally handle this automatically, these particular<br><a href="abs-guides.html#239">utilities permit manipulating such attachments manually from the command-line or in batch<br>processing mode by means of a shell script.</a><br>
<b>crypt</b><br>
At one time, this was the standard UNIX file encryption utility.&nbsp;[77] Politically-motivated government<br>regulations prohibiting the export of encryption software resulted in the disappearance of<b>&nbsp;crypt</b>&nbsp;from<br>much of the UNIX world, and it is still missing from most Linux distributions. Fortunately,<br>programmers have come up with a number of decent alternatives to it, among them the author's very<br><a href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz">own cruft (see Example A-4).</a><br>
<b>openssl</b><br>
This is an Open Source implementation of<i>&nbsp;Secure Sockets Layer</i>&nbsp;encryption.<br>
# To encrypt a file:<br>
Chapter 16. External Filters, Programs and Commands<br>
272<br>
<hr>
<A name=279></a><IMG src="abs-guide-279_1.png"><br>
Advanced Bash-Scripting Guide<br>
openssl aes-128-ecb -salt -in file.txt -out file.encrypted \<br>
-pass pass:my_password<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^ &nbsp; User-selected password.<br>
# &nbsp; &nbsp; &nbsp; aes-128-ecb &nbsp; &nbsp; &nbsp;is the encryption method chosen.<br>
# To decrypt an openssl-encrypted file:<br>
openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \<br>
-pass pass:my_password<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^ &nbsp; User-selected password.<br>
<a href="abs-guides.html#24">Piping<i>&nbsp;openssl</i></a><a href="abs-guides.html#262">&nbsp;to/from tar makes it possible to encrypt an entire directory tree.</a><br>
# To encrypt a directory:<br>
sourcedir=&quot;/home/bozo/testfiles&quot;<br>
encrfile=&quot;encr-dir.tar.gz&quot;<br>
password=my_secret_password<br>
tar czvf - &quot;$sourcedir&quot; |<br>
openssl des3 -salt -out &quot;$encrfile&quot; -pass pass:&quot;$password&quot;<br>
# &nbsp; &nbsp; &nbsp; ^^^^ &nbsp; Uses des3 encryption.<br>
# Writes encrypted file &quot;encr-dir.tar.gz&quot; in current working directory.<br>
# To decrypt the resulting tarball:<br>
openssl des3 -d -salt -in &quot;$encrfile&quot; -pass pass:&quot;$password&quot; |<br>
tar -xzv<br>
# Decrypts and unpacks into current working directory.<br>
Of course,<i>&nbsp;openssl</i>&nbsp;has many other uses, such as obtaining signed<i>&nbsp;certificates</i>&nbsp;for Web sites. See the<br><a href="abs-guides.html#225">info page.</a><br>
<b>shred</b><br>
Securely erase a file by overwriting it multiple times with random bit patterns before deleting it. This<br><a href="abs-guides.html#315">command has the same effect as Example 16-60, but does it in a more thorough and elegant manner.</a><br>
This is one of the GNU<i>&nbsp;fileutils</i>.<br>
Advanced forensic technology may still be able to recover the contents of a file, even<br>after application of<b>&nbsp;shred</b>.<br>
<b>Miscellaneous</b><br>
<b>mktemp</b><br>
Create a<i>&nbsp;temporary file&nbsp;</i>[78] with a &quot;unique&quot; filename. When invoked from the command-line without<br>additional arguments, it creates a zero-length file in the&nbsp;/tmp&nbsp;directory.<br>
bash$&nbsp;<b>mktemp<br></b>/tmp/tmp.zzsvql3154<br>
PREFIX=filename<br>
tempfile=`mktemp $PREFIX.XXXXXX`<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^ Need at least 6 placeholders<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in the filename template.<br>
# &nbsp; If no filename template supplied,<br>
#+ &quot;tmp.XXXXXXXXXX&quot; is the default.<br>
echo &quot;tempfile name = $tempfile&quot;<br>
# tempfile name = filename.QA2ZpY<br>
Chapter 16. External Filters, Programs and Commands<br>
273<br>
<hr>
<A name=280></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or something similar...<br>
# &nbsp;Creates a file of that name in the current working directory<br>
#+ with 600 file permissions.<br>
# &nbsp;A &quot;umask 177&quot; is therefore unnecessary,<br>
#+ but it's good programming practice anyhow.<br>
<b>make</b><br>
Utility for building and compiling binary packages. This can also be used for any set of operations<br>triggered by incremental changes in source files.<br>
The<i>&nbsp;make</i>&nbsp;command checks a&nbsp;Makefile, a list of file dependencies and operations to be carried out.<br>
The<i>&nbsp;make</i>&nbsp;utility is, in effect, a powerful scripting language similar in many ways to<i>&nbsp;Bash</i>, but with<br>the capability of recognizing<i>&nbsp;dependencies</i><a href="http://www.gnu.org/manual/manual.html">. For in-depth coverage of this useful tool set, see the GNU<br>software documentation site.</a><br>
<b>install</b><br>
<a href="abs-guides.html#222">Special purpose file copying command, similar to cp, but capable of setting permissions and attributes<br></a>of the copied files. This command seems tailormade for installing software packages, and as such it<br>shows up frequently in&nbsp;Makefiles&nbsp;(in the&nbsp;<i>make install :</i>&nbsp;section). It could likewise prove<br>useful in installation scripts.<br>
<b>dos2unix</b><br>
This utility, written by Benjamin Lin and collaborators, converts DOS-formatted text files (lines<br><a href="abs-guides.html#493">terminated by CR-LF) to UNIX format (lines terminated by LF only), and vice-versa.</a><br>
<b>ptx</b><br>
The<b>&nbsp;ptx [targetfile]</b>&nbsp;command outputs a permuted index (cross-reference list) of the targetfile. This<br>may be further filtered and formatted in a pipe, if necessary.<br>
<b>more</b>,&nbsp;<b>less</b><br>
Pagers that display a text file or stream to&nbsp;stdout, one screenful at a time. These may be used to<br>filter the output of&nbsp;stdout&nbsp;. . . or of a script.<br>
An interesting application of<i>&nbsp;more</i>&nbsp;is to &quot;test drive&quot; a command sequence, to forestall potentially<br>unpleasant consequences.<br>
ls /home/bozo | awk '{print &quot;rm -rf &quot; $1}' | more<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^<br>
# Testing the effect of the following (disastrous) command-line:<br>
# &nbsp; &nbsp; &nbsp;ls /home/bozo | awk '{print &quot;rm -rf &quot; $1}' | sh<br>
# &nbsp; &nbsp; &nbsp;Hand off to the shell to execute . . . &nbsp; &nbsp; &nbsp; ^^<br>
The<i>&nbsp;less</i>&nbsp;pager has the interesting property of doing a formatted display of<i>&nbsp;man page</i>&nbsp;source. See<br><a href="abs-guides.html#704">Example A-39.</a><br>
<b>16.6. Communications Commands</b><br>
<a href="abs-guides.html#830">Certain of the following commands find use in network data transfer and analysis, as well as in chasing<br>spammers.</a><br>
<b>Information and Statistics</b><br>
<b>host</b><br>
Searches for information about an Internet host by name or IP address, using DNS.<br>
Chapter 16. External Filters, Programs and Commands<br>
274<br>
<hr>
<A name=281></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>host surfacemail.com<br></b>surfacemail.com. has address 202.92.42.236<br>
<b>ipcalc</b><br>
Displays IP information for a host. With the&nbsp;-h&nbsp;option,<b>&nbsp;ipcalc</b>&nbsp;does a reverse DNS lookup, finding the<br>name of the host (server) from the IP address.<br>
bash$&nbsp;<b>ipcalc -h 202.92.42.236<br></b>HOSTNAME=surfacemail.com<br>
<b>nslookup</b><br>
Do an Internet &quot;name server lookup&quot; on a host by IP address. This is essentially equivalent to<b>&nbsp;ipcalc<br>-h</b>&nbsp;or<b>&nbsp;dig -x</b>&nbsp;. The command may be run either interactively or noninteractively, i.e., from within a<br>script.<br>
The<b>&nbsp;nslookup</b>&nbsp;command has allegedly been &quot;deprecated,&quot; but it is still useful.<br>
bash$&nbsp;<b>nslookup -sil 66.97.104.180<br></b>nslookup kuhleersparnis.ch<br>
&nbsp;Server: &nbsp; &nbsp; &nbsp; &nbsp; 135.116.137.2<br>
&nbsp;Address: &nbsp; &nbsp; &nbsp; &nbsp;135.116.137.2#53<br>
&nbsp;Non-authoritative answer:<br>
&nbsp;Name: &nbsp; kuhleersparnis.ch<br>
<b>dig</b><br>
<b>D</b>omain<b>&nbsp;I</b>nformation<b>&nbsp;G</b>roper. Similar to<b>&nbsp;nslookup</b>,<i>&nbsp;dig</i>&nbsp;does an Internet<i>&nbsp;name server lookup</i>&nbsp;on a host.<br>May be run from the command-line or from within a script.<br>
Some interesting options to<i>&nbsp;dig</i>&nbsp;are&nbsp;+time=N&nbsp;for setting a query timeout to&nbsp;<i>N</i>&nbsp;seconds,&nbsp;+nofail&nbsp;for<br>continuing to query servers until a reply is received, and&nbsp;-x&nbsp;for doing a reverse address lookup.<br>
Compare the output of<b>&nbsp;dig -x</b>&nbsp;with<b>&nbsp;ipcalc -h</b>&nbsp;and<b>&nbsp;nslookup</b>.<br>
bash$&nbsp;<b>dig -x 81.9.6.2<br></b>;; Got answer:<br>
&nbsp;;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 11649<br>
&nbsp;;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0<br>
&nbsp;;; QUESTION SECTION:<br>
&nbsp;;2.6.9.81.in-addr.arpa. &nbsp; &nbsp; &nbsp; &nbsp; IN &nbsp; &nbsp; &nbsp;PTR<br>
&nbsp;;; AUTHORITY SECTION:<br>
&nbsp;6.9.81.in-addr.arpa. &nbsp; &nbsp;3600 &nbsp; &nbsp;IN &nbsp; &nbsp; &nbsp;SOA &nbsp; &nbsp; ns.eltel.net. noc.eltel.net.<br>
&nbsp;2002031705 900 600 86400 3600<br>
&nbsp;;; Query time: 537 msec<br>
&nbsp;;; SERVER: 135.116.137.2#53(135.116.137.2)<br>
&nbsp;;; WHEN: Wed Jun 26 08:35:24 2002<br>
&nbsp;;; MSG SIZE &nbsp;rcvd: 91<br>
<b>Example 16-40. Finding out where to report a spammer</b><br>
Chapter 16. External Filters, Programs and Commands<br>
275<br>
<hr>
<A name=282></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# spam-lookup.sh: Look up abuse contact to report a spammer.<br>
# Thanks, Michael Zick.<br>
# Check for command-line arg.<br>
ARGCOUNT=1<br>
E_WRONGARGS=65<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` domain-name&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi<br>
dig +short $1.contacts.abuse.net -c in -t txt<br>
# Also try:<br>
# &nbsp; &nbsp; dig +nssearch $1<br>
# &nbsp; &nbsp; Tries to find &quot;authoritative name servers&quot; and display SOA records.<br>
# The following also works:<br>
# &nbsp; &nbsp; whois -h whois.abuse.net $1<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ ^^^^^^^^^^^^^^^ &nbsp;Specify host. &nbsp;<br>
# &nbsp; &nbsp; Can even lookup multiple spammers with this, i.e.&quot;<br>
# &nbsp; &nbsp; whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Expand the functionality of this script<br>
#+ so that it automatically e-mails a notification<br>
#+ to the responsible ISP's contact address(es).<br>
# &nbsp;Hint: use the &quot;mail&quot; command.<br>
exit $?<br>
# spam-lookup.sh chinatietong.com<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A known spam domain.<br>
# &quot;crnet_mgr@chinatietong.com&quot;<br>
# &quot;crnet_tec@chinatietong.com&quot;<br>
# &quot;postmaster@chinatietong.com&quot;<br>
# &nbsp;For a more elaborate version of this script,<br>
#+ see the SpamViz home page, http://www.spamviz.net/index.html.<br>
<b>Example 16-41. Analyzing a spam domain</b><br>
#! /bin/bash<br>
# is-spammer.sh: Identifying spam domains<br>
# $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $<br>
# Above line is RCS ID info.<br>
#<br>
# &nbsp;This is a simplified version of the &quot;is_spammer.bash<br>
#+ script in the Contributed Scripts appendix.<br>
# is-spammer &lt;domain.name&gt;<br>
# Uses an external program: 'dig'<br>
Chapter 16. External Filters, Programs and Commands<br>
276<br>
<hr>
<A name=283></a>Advanced Bash-Scripting Guide<br>
# Tested with version: 9.2.4rc5<br>
# Uses functions.<br>
# Uses IFS to parse strings by assignment into arrays.<br>
# And even does something useful: checks e-mail blacklists.<br>
# Use the domain.name(s) from the text body:<br>
# http://www.good_stuff.spammer.biz/just_ignore_everything_else<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^<br>
# Or the domain.name(s) from any e-mail address:<br>
# Really_Good_Offer@spammer.biz<br>
#<br>
# as the only argument to this script.<br>
#(PS: have your Inet connection running)<br>
#<br>
# So, to invoke this script in the above two instances:<br>
# &nbsp; &nbsp; &nbsp; is-spammer.sh spammer.biz<br>
# Whitespace == :Space:Tab:Line Feed:Carriage Return:<br>
WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'<br>
# No Whitespace == Line Feed:Carriage Return<br>
No_WSP=$'\x0A'$'\x0D'<br>
# Field separator for dotted decimal ip addresses<br>
ADR_IFS=${No_WSP}'.'<br>
# Get the dns text resource record.<br>
# get_txt &lt;error_code&gt; &lt;list_query&gt;<br>
get_txt() {<br>
&nbsp; &nbsp; # Parse $1 by assignment at the dots.<br>
&nbsp; &nbsp; local -a dns<br>
&nbsp; &nbsp; IFS=$ADR_IFS<br>
&nbsp; &nbsp; dns=( $1 )<br>
&nbsp; &nbsp; IFS=$WSP_IFS<br>
&nbsp; &nbsp; if [ &quot;${dns[0]}&quot; == '127' ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # See if there is a reason.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo $(dig +short $2 -t txt)<br>
&nbsp; &nbsp; fi<br>
}<br>
# Get the dns address resource record.<br>
# chk_adr &lt;rev_dns&gt; &lt;list_server&gt;<br>
chk_adr() {<br>
&nbsp; &nbsp; local reply<br>
&nbsp; &nbsp; local server<br>
&nbsp; &nbsp; local reason<br>
&nbsp; &nbsp; server=${1}${2}<br>
&nbsp; &nbsp; reply=$( dig +short ${server} )<br>
&nbsp; &nbsp; # If reply might be an error code . . .<br>
&nbsp; &nbsp; if [ ${#reply} -gt 6 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; reason=$(get_txt ${reply} ${server} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; reason=${reason:-${reply}}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; echo ${reason:-' not blacklisted.'}<br>
}<br>
Chapter 16. External Filters, Programs and Commands<br>
277<br>
<hr>
<A name=284></a>Advanced Bash-Scripting Guide<br>
# Need to get the IP address from the name.<br>
echo 'Get address of: '$1<br>
ip_adr=$(dig +short $1)<br>
dns_reply=${ip_adr:-' no answer '}<br>
echo ' Found address: '${dns_reply}<br>
# A valid reply is at least 4 digits plus 3 dots.<br>
if [ ${#ip_adr} -gt 6 ]<br>
then<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; declare query<br>
&nbsp; &nbsp; # Parse by assignment at the dots.<br>
&nbsp; &nbsp; declare -a dns<br>
&nbsp; &nbsp; IFS=$ADR_IFS<br>
&nbsp; &nbsp; dns=( ${ip_adr} )<br>
&nbsp; &nbsp; IFS=$WSP_IFS<br>
&nbsp; &nbsp; # Reorder octets into dns query order.<br>
&nbsp; &nbsp; rev_dns=&quot;${dns[3]}&quot;'.'&quot;${dns[2]}&quot;'.'&quot;${dns[1]}&quot;'.'&quot;${dns[0]}&quot;'.'<br>
# See: http://www.spamhaus.org (Conservative, well maintained)<br>
&nbsp; &nbsp; echo -n 'spamhaus.org says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')<br>
# See: http://ordb.org (Open mail relays)<br>
&nbsp; &nbsp; echo -n ' &nbsp; ordb.org &nbsp;says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'relays.ordb.org')<br>
# See: http://www.spamcop.net/ (You can report spammers here)<br>
&nbsp; &nbsp; echo -n ' spamcop.net says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'bl.spamcop.net')<br>
# # # other blacklist operations # # #<br>
# See: http://cbl.abuseat.org.<br>
&nbsp; &nbsp; echo -n ' abuseat.org says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')<br>
# See: http://dsbl.org/usage (Various mail relays)<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; echo 'Distributed Server Listings'<br>
&nbsp; &nbsp; echo -n ' &nbsp; &nbsp; &nbsp; list.dsbl.org says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'list.dsbl.org')<br>
&nbsp; &nbsp; echo -n ' &nbsp; multihop.dsbl.org says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')<br>
&nbsp; &nbsp; echo -n 'unconfirmed.dsbl.org says: '<br>
&nbsp; &nbsp; echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')<br>
else<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; echo 'Could not use that address.'<br>
fi<br>
exit 0<br>
# Exercises:<br>
# --------<br>
Chapter 16. External Filters, Programs and Commands<br>
278<br>
<hr>
<A name=285></a>Advanced Bash-Scripting Guide<br>
# 1) Check arguments to script,<br>
# &nbsp; &nbsp;and exit with appropriate error message if necessary.<br>
# 2) Check if on-line at invocation of script,<br>
# &nbsp; &nbsp;and exit with appropriate error message if necessary.<br>
# 3) Substitute generic variables for &quot;hard-coded&quot; BHL domains.<br>
# 4) Set a time-out for the script using the &quot;+time=&quot; option<br>
&nbsp; &nbsp; &nbsp;to the 'dig' command.<br>
<a href="abs-guides.html#626">For a much more elaborate version of the above script, see Example A-28.</a><br>
<b>traceroute</b><br>
Trace the route taken by packets sent to a remote host. This command works within a LAN, WAN, or<br>over the Internet. The remote host may be specified by an IP address. The output of this command<br><a href="abs-guides.html#246">may be filtered by grep or sed in a pipe.</a><br>
bash$&nbsp;<b>traceroute 81.9.6.2<br></b>traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets<br>
&nbsp;1 &nbsp;tc43.xjbnnbrb.com (136.30.178.8) &nbsp;191.303 ms &nbsp;179.400 ms &nbsp;179.767 ms<br>
&nbsp;2 &nbsp;or0.xjbnnbrb.com (136.30.178.1) &nbsp;179.536 ms &nbsp;179.534 ms &nbsp;169.685 ms<br>
&nbsp;3 &nbsp;192.168.11.101 (192.168.11.101) &nbsp;189.471 ms &nbsp;189.556 ms *<br>
&nbsp;...<br>
<b>ping</b><br>
Broadcast an&nbsp;<i>ICMP ECHO_REQUEST</i>&nbsp;packet to another machine, either on a local or remote<br>network. This is a diagnostic tool for testing network connections, and it should be used with caution.<br>
bash$&nbsp;<b>ping localhost<br></b>PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.<br>
&nbsp;64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec<br>
&nbsp;64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec<br>
&nbsp;--- localhost.localdomain ping statistics ---<br>
&nbsp;2 packets transmitted, 2 packets received, 0% packet loss<br>
&nbsp;round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms<br>
A successful<i>&nbsp;ping</i><a href="abs-guides.html#57">&nbsp;returns an exit status of 0. This can be tested for in a script.</a><br>
&nbsp; HNAME=nastyspammer.com<br>
# HNAME=$HOST &nbsp; &nbsp; # Debug: test for localhost.<br>
&nbsp; count=2 &nbsp;# Send only two pings.<br>
if [[ `ping -c $count &quot;$HNAME&quot;` ]]<br>
then<br>
&nbsp; echo &quot;&quot;$HNAME&quot; still up and broadcasting spam your way.&quot;<br>
else<br>
&nbsp; echo &quot;&quot;$HNAME&quot; seems to be down. Pity.&quot;<br>
fi<br>
<b>whois</b><br>
Perform a DNS (Domain Name System) lookup. The&nbsp;-h&nbsp;option permits specifying which particular<br><i>whois</i><a href="abs-guides.html#44">&nbsp;server to query. See Example 4-6 and Example 16-40.</a><br>
<b>finger</b><br>
Retrieve information about users on a network. Optionally, this command can display a user's<br>~/.plan,&nbsp;~/.project, and&nbsp;~/.forward&nbsp;files, if present.<br>
Chapter 16. External Filters, Programs and Commands<br>
279<br>
<hr>
<A name=286></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>finger<br></b>Login &nbsp;Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tty &nbsp; &nbsp; &nbsp;Idle &nbsp;Login Time &nbsp; Office &nbsp; &nbsp; Office Phone<br>
&nbsp;bozo &nbsp; Bozo Bozeman &nbsp; tty1 &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp;Jun 25 16:59 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(:0)<br>
&nbsp;bozo &nbsp; Bozo Bozeman &nbsp; ttyp0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Jun 25 16:59 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(:0.0)<br>
&nbsp;bozo &nbsp; Bozo Bozeman &nbsp; ttyp1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Jun 25 17:07 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(:0.0)<br>
bash$&nbsp;<b>finger bozo<br></b>Login: bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name: Bozo Bozeman<br>
&nbsp;Directory: /home/bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Shell: /bin/bash<br>
&nbsp;Office: 2355 Clown St., 543-1234<br>
&nbsp;On since Fri Aug 31 20:13 (MST) on tty1 &nbsp; &nbsp;1 hour 38 minutes idle<br>
&nbsp;On since Fri Aug 31 20:13 (MST) on pts/0 &nbsp; 12 seconds idle<br>
&nbsp;On since Fri Aug 31 20:13 (MST) on pts/1<br>
&nbsp;On since Fri Aug 31 20:31 (MST) on pts/2 &nbsp; 1 hour 16 minutes idle<br>
&nbsp;Mail last read Tue Jul &nbsp;3 10:08 2007 (MST)&nbsp;<br>
&nbsp;No Plan.<br>
Out of security considerations, many networks disable<b>&nbsp;finger</b>&nbsp;and its associated daemon.&nbsp;[79]<br>
<b>chfn</b><br>
Change information disclosed by the<b>&nbsp;finger</b>&nbsp;command.<br>
<b>vrfy</b><br>
Verify an Internet e-mail address.<br>
This command seems to be missing from newer Linux distros.<br>
<b>Remote Host Access</b><br>
<b>sx</b>,<b>&nbsp;rx</b><br>
The<b>&nbsp;sx</b>&nbsp;and<b>&nbsp;rx</b>&nbsp;command set serves to transfer files to and from a remote host using the<i>&nbsp;xmodem<br></i>protocol. These are generally part of a communications package, such as<b>&nbsp;minicom</b>.<br>
<b>sz</b>,<b>&nbsp;rz</b><br>
The<b>&nbsp;sz</b>&nbsp;and<b>&nbsp;rz</b>&nbsp;command set serves to transfer files to and from a remote host using the<i>&nbsp;zmodem<br></i>protocol.<i>&nbsp;Zmodem</i>&nbsp;has certain advantages over<i>&nbsp;xmodem</i>, such as faster transmission rate and<br>resumption of interrupted file transfers. Like<b>&nbsp;sx</b>&nbsp;and<b>&nbsp;rx</b>, these are generally part of a communications<br>package.<br>
<b>ftp</b><br>
Utility and protocol for uploading / downloading files to or from a remote host. An ftp session can be<br><a href="abs-guides.html#363">automated in a script (see Example 19-6 and Example A-4).</a><br>
<b>uucp</b>,&nbsp;<b>uux</b>,&nbsp;<b>cu</b><br>
<b>uucp</b>:<i>&nbsp;UNIX to UNIX copy</i>. This is a communications package for transferring files between UNIX<br>servers. A shell script is an effective way to handle a<b>&nbsp;uucp</b>&nbsp;command sequence.<br>
Since the advent of the Internet and e-mail,<b>&nbsp;uucp</b>&nbsp;seems to have faded into obscurity, but it still exists<br>and remains perfectly workable in situations where an Internet connection is not available or<br>appropriate. The advantage of<b>&nbsp;uucp</b>&nbsp;is that it is fault-tolerant, so even if there is a service interruption<br>the copy operation will resume where it left off when the connection is restored.<br>
---<br>
<b>uux</b>:<i>&nbsp;UNIX to UNIX execute</i>. Execute a command on a remote system. This command is part of the<br><b>uucp</b>&nbsp;package.<br>
Chapter 16. External Filters, Programs and Commands<br>
280<br>
<hr>
<A name=287></a><IMG src="abs-guide-287_1.png"><br>
Advanced Bash-Scripting Guide<br>
---<br>
<b>cu</b>:<b>&nbsp;C</b>all<b>&nbsp;U</b>p a remote system and connect as a simple terminal. It is a sort of dumbed-down version of<br><a href="abs-guides.html#287">telnet. This command is part of the</a><b>&nbsp;uucp</b>&nbsp;package.<br>
<b>telnet</b><br>
Utility and protocol for connecting to a remote host.<br>
The<i>&nbsp;telnet</i>&nbsp;protocol contains security holes and should therefore probably be avoided.<br>Its use within a shell script is<i>&nbsp;not</i>&nbsp;recommended.<br>
<b>wget</b><br>
The<b>&nbsp;wget</b>&nbsp;utility<i>&nbsp;noninteractively</i>&nbsp;retrieves or downloads files from a Web or ftp site. It works well in<br>a script.<br>
wget -p http://www.xyz23.com/file01.html<br>
# &nbsp;The -p or --page-requisite option causes wget to fetch all files<br>
#+ required to display the specified page.<br>
wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE<br>
# &nbsp;The -r option recursively follows and retrieves all links<br>
#+ on the specified site.<br>
wget -c ftp://ftp.xyz25.net/bozofiles/filename.tar.bz2<br>
# &nbsp;The -c option lets wget resume an interrupted download.<br>
# &nbsp;This works with ftp servers and many HTTP sites.<br>
<b>Example 16-42. Getting a stock quote</b><br>
#!/bin/bash<br>
# quote-fetch.sh: Download a stock quote.<br>
E_NOPARAMS=86<br>
if [ -z &quot;$1&quot; ] &nbsp;# Must specify a stock (symbol) to fetch.<br>
&nbsp; then echo &quot;Usage: `basename $0` stock-symbol&quot;<br>
&nbsp; exit $E_NOPARAMS<br>
fi<br>
stock_symbol=$1<br>
file_suffix=.html<br>
# Fetches an HTML file, so name it appropriately.<br>
URL='http://finance.yahoo.com/q?s='<br>
# Yahoo finance board, with stock query suffix.<br>
# -----------------------------------------------------------<br>
wget -O ${stock_symbol}${file_suffix} &quot;${URL}${stock_symbol}&quot;<br>
# -----------------------------------------------------------<br>
# To look up stuff on http://search.yahoo.com:<br>
# -----------------------------------------------------------<br>
# URL=&quot;http://search.yahoo.com/search?fr=ush-news&amp;p=${query}&quot;<br>
# wget -O &quot;$savefilename&quot; &quot;${URL}&quot;<br>
# -----------------------------------------------------------<br>
# Saves a list of relevant URLs.<br>
exit $?<br>
Chapter 16. External Filters, Programs and Commands<br>
281<br>
<hr>
<A name=288></a>Advanced Bash-Scripting Guide<br>
# Exercises:<br>
# ---------<br>
#<br>
# 1) Add a test to ensure the user running the script is on-line.<br>
# &nbsp; &nbsp;(Hint: parse the output of 'ps -ax' for &quot;ppp&quot; or &quot;connect.&quot;<br>
#<br>
# 2) Modify this script to fetch the local weather report,<br>
#+ &nbsp; taking the user's zip code as an argument.<br>
<a href="abs-guides.html#666">See also Example A-30 and Example A-31.</a><br>
<b>lynx</b><br>
The<b>&nbsp;lynx</b>&nbsp;Web and file browser can be used inside a script (with the&nbsp;-dump&nbsp;option) to retrieve a file<br>from a Web or ftp site noninteractively.<br>
lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE<br>
With the&nbsp;-traversal&nbsp;option,<b>&nbsp;lynx</b>&nbsp;starts at the HTTP URL specified as an argument, then &quot;crawls&quot;<br>through all links located on that particular server. Used together with the&nbsp;-crawl&nbsp;option, outputs<br>page text to a log file.<br>
<b>rlogin</b><br>
<i>Remote login</i><a href="abs-guides.html#292">, initates a session on a remote host. This command has security issues, so use ssh<br></a>instead.<br>
<b>rsh</b><br>
<i>Remote shell</i>, executes command(s) on a remote host. This has security issues, so use<b>&nbsp;ssh<br></b>instead.<br>
<b>rcp</b><br>
<i>Remote copy</i>, copies files between two different networked machines.<br>
<b>rsync</b><br>
<i>Remote synchronize</i>, updates (synchronizes) files between two different networked machines.<br>
bash$&nbsp;<b>rsync -a ~/sourcedir/*txt /node1/subdirectory/</b><br>
<b>Example 16-43. Updating FC4</b><br>
#!/bin/bash<br>
# fc4upd.sh<br>
# Script author: Frank Wang.<br>
# Slight stylistic modifications by ABS Guide author.<br>
# Used in ABS Guide with permission.<br>
# &nbsp;Download Fedora Core 4 update from mirror site using rsync.&nbsp;<br>
# &nbsp;Should also work for newer Fedora Cores -- 5, 6, . . .<br>
# &nbsp;Only download latest package if multiple versions exist,<br>
#+ to save space.<br>
URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/<br>
# URL=rsync://ftp.kddilabs.jp/fedora/core/updates/<br>
# URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/<br>
DEST=${1:-/var/www/html/fedora/updates/}<br>
LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt<br>
PID_FILE=/var/run/${0##*/}.pid<br>
E_RETURN=85 &nbsp; &nbsp; &nbsp; &nbsp;# Something unexpected happened.<br>
Chapter 16. External Filters, Programs and Commands<br>
282<br>
<hr>
<A name=289></a>Advanced Bash-Scripting Guide<br>
# General rsync options<br>
# -r: recursive download<br>
# -t: reserve time<br>
# -v: verbose<br>
OPTS=&quot;-rtv --delete-excluded --delete-after --partial&quot;<br>
# rsync include pattern<br>
# Leading slash causes absolute path name match.<br>
INCLUDE=(<br>
&nbsp; &nbsp; &quot;/4/i386/kde-i18n-Chinese*&quot;&nbsp;<br>
# &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
# Quoting is necessary to prevent globbing.<br>
)&nbsp;<br>
# rsync exclude pattern<br>
# Temporarily comment out unwanted pkgs using &quot;#&quot; . . .<br>
EXCLUDE=(<br>
&nbsp; &nbsp; /1<br>
&nbsp; &nbsp; /2<br>
&nbsp; &nbsp; /3<br>
&nbsp; &nbsp; /testing<br>
&nbsp; &nbsp; /4/SRPMS<br>
&nbsp; &nbsp; /4/ppc<br>
&nbsp; &nbsp; /4/x86_64<br>
&nbsp; &nbsp; /4/i386/debug<br>
&nbsp; &nbsp;&quot;/4/i386/kde-i18n-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/openoffice.org-langpack-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/*i586.rpm&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/GFS-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/cman-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/dlm-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/gnbd-*&quot;<br>
&nbsp; &nbsp;&quot;/4/i386/kernel-smp*&quot;<br>
# &nbsp;&quot;/4/i386/kernel-xen*&quot;&nbsp;<br>
# &nbsp;&quot;/4/i386/xen-*&quot;&nbsp;<br>
)<br>
init () {<br>
&nbsp; &nbsp; # Let pipe command return possible rsync error, e.g., stalled network.<br>
&nbsp; &nbsp; set -o pipefail &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Newly introduced in Bash, version 3.<br>
&nbsp; &nbsp; TMP=${TMPDIR:-/tmp}/${0##*/}.$$ &nbsp;# Store refined download list.<br>
&nbsp; &nbsp; trap &quot;{<br>
&nbsp; &nbsp; &nbsp; &nbsp; rm -f $TMP 2&gt;/dev/null<br>
&nbsp; &nbsp; }&quot; EXIT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Clear temporary file on exit.<br>
}<br>
check_pid () {<br>
# Check if process exists.<br>
&nbsp; &nbsp; if [ -s &quot;$PID_FILE&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;PID file exists. Checking ...&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; PID=$(/bin/egrep -o &quot;^[[:digit:]]+&quot; $PID_FILE)<br>
&nbsp; &nbsp; &nbsp; &nbsp; if /bin/ps --pid $PID &amp;&gt;/dev/null; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Process $PID found. ${0##*/} seems to be running!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/usr/bin/logger -t ${0##*/} \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;Process $PID found. ${0##*/} seems to be running!&quot;<br>
Chapter 16. External Filters, Programs and Commands<br>
283<br>
<hr>
<A name=290></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit $E_RETURN<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Process $PID not found. Start new process . . .&quot;<br>
&nbsp; &nbsp; fi<br>
}<br>
# &nbsp;Set overall file update range starting from root or $URL,<br>
#+ according to above patterns.<br>
set_range () {<br>
&nbsp; &nbsp; include=<br>
&nbsp; &nbsp; exclude=<br>
&nbsp; &nbsp; for p in &quot;${INCLUDE[@]}&quot;; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; include=&quot;$include --include \&quot;$p\&quot;&quot;<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; for p in &quot;${EXCLUDE[@]}&quot;; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; exclude=&quot;$exclude --exclude \&quot;$p\&quot;&quot;<br>
&nbsp; &nbsp; done<br>
}<br>
# Retrieve and refine rsync update list.<br>
get_list () {<br>
&nbsp; &nbsp; echo $$ &gt; $PID_FILE || {<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Can't write to pid file $PID_FILE&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit $E_RETURN<br>
&nbsp; &nbsp; }<br>
&nbsp; &nbsp; echo -n &quot;Retrieving and refining update list . . .&quot;<br>
&nbsp; &nbsp; # Retrieve list -- 'eval' is needed to run rsync as a single command.<br>
&nbsp; &nbsp; # $3 and $4 is the date and time of file creation.<br>
&nbsp; &nbsp; # $5 is the full package name.<br>
&nbsp; &nbsp; previous=<br>
&nbsp; &nbsp; pre_file=<br>
&nbsp; &nbsp; pre_date=0<br>
&nbsp; &nbsp; eval /bin/nice /usr/bin/rsync \<br>
&nbsp; &nbsp; &nbsp; &nbsp; -r $include $exclude $URL | \<br>
&nbsp; &nbsp; &nbsp; &nbsp; egrep '^dr.x|^-r' | \<br>
&nbsp; &nbsp; &nbsp; &nbsp; awk '{print $3, $4, $5}' | \<br>
&nbsp; &nbsp; &nbsp; &nbsp; sort -k3 | \<br>
&nbsp; &nbsp; &nbsp; &nbsp; { while read line; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Get seconds since epoch, to filter out obsolete pkgs.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_date=$(date -d &quot;$(echo $line | awk '{print $1, $2}')&quot; +%s)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;echo $cur_date<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Get file name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_file=$(echo $line | awk '{print $3}')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;echo $cur_file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Get rpm pkg name from file name, if possible.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [[ $cur_file == *rpm ]]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_name=$(echo $cur_file | sed -r -e \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_name=<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # echo $pkg_name<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ -z &quot;$pkg_name&quot; ]; then &nbsp; # &nbsp;If not a rpm file,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $cur_file &gt;&gt; $TMP &nbsp; &nbsp;#+ then append to download list.<br>
Chapter 16. External Filters, Programs and Commands<br>
284<br>
<hr>
<A name=291></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elif [ &quot;$pkg_name&quot; != &quot;$previous&quot; ]; then &nbsp; # A new pkg found.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $pre_file &gt;&gt; $TMP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Output latest file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previous=$pkg_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Save current.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre_date=$cur_date<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre_file=$cur_file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elif [ &quot;$cur_date&quot; -gt &quot;$pre_date&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;If same pkg, but newer,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre_date=$cur_date &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then update latest pointer.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre_file=$cur_file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $pre_file &gt;&gt; $TMP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;TMP contains ALL<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ of refined list now.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # echo &quot;subshell=$BASH_SUBSHELL&quot;<br>
&nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; # Bracket required here to let final &quot;echo $pre_file &gt;&gt; $TMP&quot;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Remained in the same subshell ( 1 ) with the entire loop.<br>
&nbsp; &nbsp; RET=$? &nbsp;# Get return code of the pipe command.<br>
&nbsp; &nbsp; [ &quot;$RET&quot; -ne 0 ] &amp;&amp; {<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;List retrieving failed with code $RET&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit $E_RETURN<br>
&nbsp; &nbsp; }<br>
&nbsp; &nbsp; echo &quot;done&quot;; echo<br>
}<br>
# Real rsync download part.<br>
get_file () {<br>
&nbsp; &nbsp; echo &quot;Downloading...&quot;<br>
&nbsp; &nbsp; /bin/nice /usr/bin/rsync \<br>
&nbsp; &nbsp; &nbsp; &nbsp; $OPTS \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --filter &quot;merge,+/ $TMP&quot; \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --exclude '*' &nbsp;\<br>
&nbsp; &nbsp; &nbsp; &nbsp; $URL $DEST &nbsp; &nbsp; \<br>
&nbsp; &nbsp; &nbsp; &nbsp; | /usr/bin/tee $LOG<br>
&nbsp; &nbsp; RET=$?<br>
&nbsp; &nbsp;# &nbsp;--filter merge,+/ is crucial for the intention.&nbsp;<br>
&nbsp; &nbsp;# &nbsp;+ modifier means include and / means absolute path.<br>
&nbsp; &nbsp;# &nbsp;Then sorted list in $TMP will contain ascending dir name and&nbsp;<br>
&nbsp; &nbsp;#+ prevent the following --exclude '*' from &quot;shortcutting the circuit.&quot;&nbsp;<br>
&nbsp; &nbsp; echo &quot;Done&quot;<br>
&nbsp; &nbsp; rm -f $PID_FILE 2&gt;/dev/null<br>
&nbsp; &nbsp; return $RET<br>
}<br>
# -------<br>
# Main<br>
init<br>
check_pid<br>
set_range<br>
get_list<br>
get_file<br>
RET=$?<br>
# -------<br>
Chapter 16. External Filters, Programs and Commands<br>
285<br>
<hr>
<A name=292></a><IMG src="abs-guide-292_1.png"><br>
Advanced Bash-Scripting Guide<br>
if [ &quot;$RET&quot; -eq 0 ]; then<br>
&nbsp; &nbsp; /usr/bin/logger -t ${0##*/} &quot;Fedora update mirrored successfully.&quot;<br>
else<br>
&nbsp; &nbsp; /usr/bin/logger -t ${0##*/} \<br>
&nbsp; &nbsp; &quot;Fedora update mirrored with failure code: $RET&quot;<br>
fi<br>
exit $RET<br>
<a href="abs-guides.html#675">See also Example A-32.</a><br>
<a href="abs-guides.html#288">Using rcp, rsync, and similar utilities with security implications in a shell script may<br></a>not be advisable. Consider, instead, using<b>&nbsp;ssh</b><a href="abs-guides.html#293">, scp, or an</a><b>&nbsp;expect</b>&nbsp;script.<br>
<b>ssh</b><br>
<i>Secure shell</i>, logs onto a remote host and executes commands there. This secure replacement for<br><b>telnet</b>,<b>&nbsp;rlogin</b>,<b>&nbsp;rcp</b>, and<b>&nbsp;rsh</b><a href="abs-guides.html#225">&nbsp;uses identity authentication and encryption. See its manpage for details.</a><br>
<b>Example 16-44. Using<i>&nbsp;ssh</i></b><br>
#!/bin/bash<br>
# remote.bash: Using ssh.<br>
# This example by Michael Zick.<br>
# Used with permission.<br>
# &nbsp; Presumptions:<br>
# &nbsp; ------------<br>
# &nbsp; fd-2 isn't being captured ( '2&gt;/dev/null' ).<br>
# &nbsp; ssh/sshd presumes stderr ('2') will display to user.<br>
#<br>
# &nbsp; sshd is running on your machine.<br>
# &nbsp; For any 'standard' distribution, it probably is,<br>
#+ &nbsp;and without any funky ssh-keygen having been done.<br>
# Try ssh to your machine from the command-line:<br>
#<br>
# $ ssh $HOSTNAME<br>
# Without extra set-up you'll be asked for your password.<br>
# &nbsp; enter password<br>
# &nbsp; when done, &nbsp;$ exit<br>
#<br>
# Did that work? If so, you're ready for more fun.<br>
# Try ssh to your machine as 'root':<br>
#<br>
# &nbsp; $ &nbsp;ssh -l root $HOSTNAME<br>
# &nbsp; When asked for password, enter root's, not yours.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain<br>
# &nbsp; Enter 'exit' when done.<br>
# &nbsp;The above gives you an interactive shell.<br>
# &nbsp;It is possible for sshd to be set up in a 'single command' mode,<br>
#+ but that is beyond the scope of this example.<br>
# &nbsp;The only thing to note is that the following will work in<br>
#+ 'single command' mode.<br>
Chapter 16. External Filters, Programs and Commands<br>
286<br>
<hr>
<A name=293></a><IMG src="abs-guide-293_1.png"><br>
Advanced Bash-Scripting Guide<br>
# A basic, write stdout (local) command.<br>
ls -l<br>
# Now the same basic command on a remote machine.<br>
# Pass a different 'USERNAME' 'HOSTNAME' if desired:<br>
USER=${USERNAME:-$(whoami)}<br>
HOST=${HOSTNAME:-$(hostname)}<br>
# &nbsp;Now excute the above command-line on the remote host,<br>
#+ with all transmissions encrypted.<br>
ssh -l ${USER} ${HOST} &quot; ls -l &quot;<br>
# &nbsp;The expected result is a listing of your username's home<br>
#+ directory on the remote machine.<br>
# &nbsp;To see any difference, run this script from somewhere<br>
#+ other than your home directory.<br>
# &nbsp;In other words, the Bash command is passed as a quoted line<br>
#+ to the remote shell, which executes it on the remote machine.<br>
# &nbsp;In this case, sshd does &nbsp;' bash -c &quot;ls -l&quot; ' &nbsp; on your behalf.<br>
# &nbsp;For information on topics such as not having to enter a<br>
#+ password/passphrase for every command-line, see<br>
#+ &nbsp; &nbsp;man ssh<br>
#+ &nbsp; &nbsp;man ssh-keygen<br>
#+ &nbsp; &nbsp;man sshd_config.<br>
exit 0<br>
Within a loop,<b>&nbsp;ssh</b><a href="http://groups-beta.google.com/group/comp.unix.shell/msg/dcb446b5fff7d230">&nbsp;may cause unexpected behavior. According to a &nbsp;Usenet post in the<br></a>comp.unix shell archives,<b>&nbsp;ssh</b>&nbsp;inherits the loop's&nbsp;stdin. To remedy this, pass<b>&nbsp;ssh<br></b>either the&nbsp;-n&nbsp;or&nbsp;-f&nbsp;option.<br>
Thanks, Jason Bechtel, for pointing this out.<br>
<b>scp</b><br>
<i>Secure copy</i>, similar in function to<b>&nbsp;rcp</b>, copies files between two different networked machines,<br>but does so using authentication, and with a security level similar to<b>&nbsp;ssh</b>.<br>
<b>Local Network</b><br>
<b>write</b><br>
This is a utility for terminal-to-terminal communication. It allows sending lines from your terminal<br>(console or<i>&nbsp;xterm</i><a href="abs-guides.html#327">) to that of another user. The mesg command may, of course, be used to disable<br></a>write access to a terminal<br>
Since<b>&nbsp;write</b>&nbsp;is interactive, it would not normally find use in a script.<br>
<b>netconfig</b><br>
A command-line utility for configuring a network adapter (using<i>&nbsp;DHCP</i>). This command is native to<br>Red Hat centric Linux distros.<br>
<b>Mail</b><br>
<b>mail</b><br>
Send or read e-mail messages.<br>
Chapter 16. External Filters, Programs and Commands<br>
287<br>
<hr>
<A name=294></a>Advanced Bash-Scripting Guide<br>
This stripped-down command-line mail client works fine as a command embedded in a script.<br>
<b>Example 16-45. A script that mails itself</b><br>
#!/bin/sh<br>
# self-mailer.sh: Self-mailing script<br>
adr=${1:-`whoami`} &nbsp; &nbsp; # Default to current user, if not specified.<br>
# &nbsp;Typing 'self-mailer.sh wiseguy@superdupergenius.com'<br>
#+ sends this script to that addressee.<br>
# &nbsp;Just 'self-mailer.sh' (no argument) sends the script<br>
#+ to the person invoking it, for example, bozo@localhost.localdomain.<br>
#<br>
# &nbsp;For more on the ${parameter:-default} construct,<br>
#+ see the &quot;Parameter Substitution&quot; section<br>
#+ of the &quot;Variables Revisited&quot; chapter.<br>
# ============================================================================<br>
&nbsp; cat $0 | mail -s &quot;Script \&quot;`basename $0`\&quot; has mailed itself to you.&quot; &quot;$adr&quot;<br>
# ============================================================================<br>
# --------------------------------------------<br>
# &nbsp;Greetings from the self-mailing script.<br>
# &nbsp;A mischievous person has run this script,<br>
#+ which has caused it to mail itself to you.<br>
# &nbsp;Apparently, some people have nothing better<br>
#+ to do with their time.<br>
# --------------------------------------------<br>
echo &quot;At `date`, script \&quot;`basename $0`\&quot; mailed to &quot;$adr&quot;.&quot;<br>
exit 0<br>
# &nbsp;Note that the &quot;mailx&quot; command (in &quot;send&quot; mode) may be substituted<br>
#+ for &quot;mail&quot; ... but with somewhat different options.<br>
<b>mailto</b><br>
Similar to the<b>&nbsp;mail</b>&nbsp;command,<b>&nbsp;mailto</b>&nbsp;sends e-mail messages from the command-line or in a script.<br>However,<b>&nbsp;mailto</b>&nbsp;also permits sending MIME (multimedia) messages.<br>
<b>mailstats</b><br>
Show<i>&nbsp;mail statistics</i>. This command may be invoked only by<i>&nbsp;root</i>.<br>
root#&nbsp;<b>mailstats<br></b>Statistics from Tue Jan &nbsp;1 20:32:08 2008<br>
&nbsp; M &nbsp; msgsfr &nbsp;bytes_from &nbsp; msgsto &nbsp; &nbsp;bytes_to &nbsp;msgsrej msgsdis msgsqur &nbsp;Mailer<br>
&nbsp; 4 &nbsp; &nbsp; 1682 &nbsp; &nbsp; &nbsp;24118K &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0K &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp;esmtp<br>
&nbsp; 9 &nbsp; &nbsp; &nbsp;212 &nbsp; &nbsp; &nbsp; &nbsp;640K &nbsp; &nbsp; 1894 &nbsp; &nbsp; &nbsp;25131K &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0 &nbsp;local<br>
&nbsp;=====================================================================<br>
&nbsp; T &nbsp; &nbsp; 1894 &nbsp; &nbsp; &nbsp;24758K &nbsp; &nbsp; 1894 &nbsp; &nbsp; &nbsp;25131K &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 0<br>
&nbsp; C &nbsp; &nbsp; &nbsp;414 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br>
<b>vacation</b><br>
This utility automatically replies to e-mails that the intended recipient is on vacation and temporarily<br>unavailable. It runs on a network, in conjunction with<b>&nbsp;sendmail</b>, and is not applicable to a dial-up<br>POPmail account.<br>
Chapter 16. External Filters, Programs and Commands<br>
288<br>
<hr>
<A name=295></a>Advanced Bash-Scripting Guide<br>
<b>16.7. Terminal Control Commands</b><br>
<b>Command affecting the console or terminal</b><br>
<b>tput</b><br>
Initialize terminal and/or fetch information about it from terminfo data. Various options permit certain<br>terminal operations:<b>&nbsp;tput clear</b><a href="abs-guides.html#295">&nbsp;is the equivalent of clear;</a><b>&nbsp;tput reset</b><a href="abs-guides.html#295">&nbsp;is the equivalent of reset.</a><br>
bash$&nbsp;<b>tput longname<br></b>xterm terminal emulator (X Window System)<br>
Issuing a<b>&nbsp;tput cup X Y</b>&nbsp;moves the cursor to the (X,Y) coordinates in the current terminal. A<b>&nbsp;clear</b>&nbsp;to<br>erase the terminal screen would normally precede this.<br>
Some interesting options to<i>&nbsp;tput</i>&nbsp;are:<br>
bold<br>
◊&nbsp;<br>
, for high-intensity text<br>
smul<br>
◊&nbsp;<br>
, to underline text in the terminal<br>
smso<br>
◊&nbsp;<br>
, to render text in reverse<br>
sgr0<br>
◊&nbsp;<br>
, to reset the terminal parameters (to normal), without clearing the screen<br>
Example scripts using<i>&nbsp;tput</i>:<br>
<a href="abs-guides.html#516">Example 36-13</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#511">Example 36-11</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#724">Example A-44</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#717">Example A-42</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#428">Example 27-2</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#325">Note that stty offers a more powerful command set for controlling a terminal.</a><br>
<b>infocmp</b><br>
This command prints out extensive information about the current terminal. It references the<i>&nbsp;terminfo<br></i>database.<br>
bash$&nbsp;<b>infocmp<br></b># &nbsp; &nbsp; &nbsp; Reconstructed via infocmp from file:<br>
&nbsp;/usr/share/terminfo/r/rxvt<br>
&nbsp;rxvt|rxvt terminal emulator (X Window System),&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;am, bce, eo, km, mir, msgr, xenl, xon,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;colors#8, cols#80, it#8, lines#24, pairs#64,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bel=^G, blink=\E[5m, bold=\E[1m,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;civis=\E[?25l,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<br>
<b>reset</b><br>
Reset terminal parameters and clear text screen. As with<b>&nbsp;clear</b>, the cursor and prompt reappear in the<br>upper lefthand corner of the terminal.<br>
<b>clear</b><br>
The<b>&nbsp;clear</b>&nbsp;command simply clears the text screen at the console or in an<i>&nbsp;xterm</i>. The prompt and cursor<br>reappear at the upper lefthand corner of the screen or xterm window. This command may be used<br><a href="abs-guides.html#163">either at the command line or in a script. See Example 11-25.</a><br>
<b>resize</b><br>
Chapter 16. External Filters, Programs and Commands<br>
289<br>
<hr>
<A name=296></a>Advanced Bash-Scripting Guide<br>
Echoes commands necessary to set&nbsp;$TERM&nbsp;and&nbsp;$TERMCAP&nbsp;to duplicate the<i>&nbsp;size</i>&nbsp;(dimensions) of the<br>current terminal.<br>
bash$&nbsp;<b>resize<br></b>set noglob;<br>
&nbsp;setenv COLUMNS '80';<br>
&nbsp;setenv LINES '24';<br>
&nbsp;unset noglob;<br>
<b>script</b><br>
This utility records (saves to a file) all the user keystrokes at the command-line in a console or an<br>xterm window. This, in effect, creates a record of a session.<br>
<b>16.8. Math Commands</b><br>
<b>&quot;Doing the numbers&quot;</b><br>
<b>factor</b><br>
Decompose an integer into prime factors.<br>
bash$&nbsp;<b>factor 27417<br></b>27417: 3 13 19 37<br>
<b>Example 16-46. Generating prime numbers</b><br>
#!/bin/bash<br>
# primes2.sh<br>
# &nbsp;Generating prime numbers the quick-and-easy way,<br>
#+ without resorting to fancy algorithms.<br>
CEILING=10000 &nbsp; # 1 to 10000<br>
PRIME=0<br>
E_NOTPRIME=<br>
is_prime ()<br>
{<br>
&nbsp; local factors<br>
&nbsp; factors=( $(factor $1) ) &nbsp;# Load output of `factor` into array.<br>
if [ -z &quot;${factors[2]}&quot; ]<br>
# &nbsp;Third element of &quot;factors&quot; array:<br>
#+ ${factors[2]} is 2nd factor of argument.<br>
# &nbsp;If it is blank, then there is no 2nd factor,<br>
#+ and the argument is therefore prime.<br>
then<br>
&nbsp; return $PRIME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0<br>
else<br>
&nbsp; return $E_NOTPRIME &nbsp; &nbsp; &nbsp; &nbsp;# null<br>
fi<br>
}<br>
echo<br>
for n in $(seq $CEILING)<br>
do<br>
&nbsp; if is_prime $n<br>
Chapter 16. External Filters, Programs and Commands<br>
290<br>
<hr>
<A name=297></a>Advanced Bash-Scripting Guide<br>
&nbsp; then<br>
&nbsp; &nbsp; printf %5d $n<br>
&nbsp; fi &nbsp; # &nbsp; &nbsp;^ &nbsp;Five positions per number suffices.<br>
done &nbsp; # &nbsp; &nbsp; &nbsp; For a higher $CEILING, adjust upward, as necessary.<br>
echo<br>
exit<br>
<b>bc</b><br>
Bash can't handle floating point calculations, and it lacks operators for certain important mathematical<br>functions. Fortunately,<b>&nbsp;bc</b>&nbsp;gallops to the rescue.<br>
Not just a versatile, arbitrary precision calculation utility,<b>&nbsp;bc</b>&nbsp;offers many of the facilities of a<br>programming language. It has a syntax vaguely resembling<b>&nbsp;C</b>.<br>
<a href="abs-guides.html#24">Since it is a fairly well-behaved UNIX utility, and may therefore be used in a pipe,</a><b>&nbsp;bc</b>&nbsp;comes in handy<br>in scripts.<br>
Here is a simple template for using<b>&nbsp;bc</b><a href="abs-guides.html#170">&nbsp;to calculate a script variable. This uses command substitution.</a><br>
<b>variable=$(echo &quot;OPTIONS; OPERATIONS&quot; | bc)</b><br>
<b>Example 16-47. Monthly Payment on a Mortgage</b><br>
#!/bin/bash<br>
# monthlypmt.sh: Calculates monthly payment on a mortgage.<br>
# &nbsp;This is a modification of code in the<br>
#+ &quot;mcalc&quot; (mortgage calculator) package,<br>
#+ by Jeff Schmidt<br>
#+ and<br>
#+ Mendel Cooper (yours truly, the ABS Guide author).<br>
# &nbsp; http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz<br>
echo<br>
echo &quot;Given the principal, interest rate, and term of a mortgage,&quot;<br>
echo &quot;calculate the monthly payment.&quot;<br>
bottom=1.0<br>
echo<br>
echo -n &quot;Enter principal (no commas) &quot;<br>
read principal<br>
echo -n &quot;Enter interest rate (percent) &quot; &nbsp;# If 12%, enter &quot;12&quot;, not &quot;.12&quot;.<br>
read interest_r<br>
echo -n &quot;Enter term (months) &quot;<br>
read term<br>
&nbsp;interest_r=$(echo &quot;scale=9; $interest_r/100.0&quot; | bc) # Convert to decimal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^^^ &nbsp;Divide by 100.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;scale&quot; determines how many decimal places.<br>
&nbsp;interest_rate=$(echo &quot;scale=9; $interest_r/12 + 1.0&quot; | bc)<br>
Chapter 16. External Filters, Programs and Commands<br>
291<br>
<hr>
<A name=298></a>Advanced Bash-Scripting Guide<br>
&nbsp;top=$(echo &quot;scale=9; $principal*$interest_rate^$term&quot; | bc)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Standard formula for figuring interest.<br>
&nbsp;echo; echo &quot;Please be patient. This may take a while.&quot;<br>
&nbsp;let &quot;months = $term - 1&quot;<br>
# ====================================================================&nbsp;<br>
&nbsp;for ((x=$months; x &gt; 0; x--))<br>
&nbsp;do<br>
&nbsp; &nbsp;bot=$(echo &quot;scale=9; $interest_rate^$x&quot; | bc)<br>
&nbsp; &nbsp;bottom=$(echo &quot;scale=9; $bottom+$bot&quot; | bc)<br>
# &nbsp;bottom = $(($bottom + $bot&quot;))<br>
&nbsp;done<br>
# ====================================================================&nbsp;<br>
# --------------------------------------------------------------------&nbsp;<br>
# &nbsp;Rick Boivie pointed out a more efficient implementation<br>
#+ of the above loop, which decreases computation time by 2/3.<br>
# for ((x=1; x &lt;= $months; x++))<br>
# do<br>
# &nbsp; bottom=$(echo &quot;scale=9; $bottom * $interest_rate + 1&quot; | bc)<br>
# done<br>
# &nbsp;And then he came up with an even more efficient alternative,<br>
#+ one that cuts down the run time by about 95%!<br>
# bottom=`{<br>
# &nbsp; &nbsp; echo &quot;scale=9; bottom=$bottom; interest_rate=$interest_rate&quot;<br>
# &nbsp; &nbsp; for ((x=1; x &lt;= $months; x++))<br>
# &nbsp; &nbsp; do<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo 'bottom = bottom * interest_rate + 1'<br>
# &nbsp; &nbsp; done<br>
# &nbsp; &nbsp; echo 'bottom'<br>
# &nbsp; &nbsp; } | bc` &nbsp; &nbsp; &nbsp; # Embeds a 'for loop' within command substitution.<br>
# --------------------------------------------------------------------------<br>
# &nbsp;On the other hand, Frank Wang suggests:<br>
# &nbsp;bottom=$(echo &quot;scale=9; ($interest_rate^$term-1)/($interest_rate-1)&quot; | bc)<br>
# &nbsp;Because . . .<br>
# &nbsp;The algorithm behind the loop<br>
#+ is actually a sum of geometric proportion series.<br>
# &nbsp;The sum formula is e0(1-q^n)/(1-q),<br>
#+ where e0 is the first element and q=e(n+1)/e(n)<br>
#+ and n is the number of elements.<br>
# --------------------------------------------------------------------------<br>
&nbsp;# let &quot;payment = $top/$bottom&quot;<br>
&nbsp;payment=$(echo &quot;scale=2; $top/$bottom&quot; | bc)<br>
&nbsp;# Use two decimal places for dollars and cents.<br>
&nbsp;echo<br>
&nbsp;echo &quot;monthly payment = \$$payment&quot; &nbsp;# Echo a dollar sign in front of amount.<br>
&nbsp;echo<br>
&nbsp;exit 0<br>
Chapter 16. External Filters, Programs and Commands<br>
292<br>
<hr>
<A name=299></a>Advanced Bash-Scripting Guide<br>
&nbsp;# Exercises:<br>
&nbsp;# &nbsp; 1) Filter input to permit commas in principal amount.<br>
&nbsp;# &nbsp; 2) Filter input to permit interest to be entered as percent or decimal.<br>
&nbsp;# &nbsp; 3) If you are really ambitious,<br>
&nbsp;#+ &nbsp; &nbsp; expand this script to print complete amortization tables.<br>
<b>Example 16-48. Base Conversion</b><br>
#!/bin/bash<br>
###########################################################################<br>
# Shellscript: &nbsp;base.sh - print number to different bases (Bourne Shell)<br>
# Author &nbsp; &nbsp; : &nbsp;Heiner Steven (heiner.steven@odn.de)<br>
# Date &nbsp; &nbsp; &nbsp; : &nbsp;07-03-95<br>
# Category &nbsp; : &nbsp;Desktop<br>
# $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $<br>
# ==&gt; Above line is RCS ID info.<br>
###########################################################################<br>
# Description<br>
#<br>
# Changes<br>
# 21-03-95 stv &nbsp;fixed error occuring with 0xb as input (0.2)<br>
###########################################################################<br>
# ==&gt; Used in ABS Guide with the script author's permission.<br>
# ==&gt; Comments added by ABS Guide author.<br>
NOARGS=85<br>
PN=`basename &quot;$0&quot;` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Program name<br>
VER=`echo '$Revision: 1.2 $' | cut -d' ' -f2` &nbsp;# ==&gt; VER=1.2<br>
Usage () {<br>
&nbsp; &nbsp; echo &quot;$PN - print number to different bases, $VER (stv '95)<br>
usage: $PN [number ...]<br>
If no number is given, the numbers are read from standard input.<br>
A number may be<br>
&nbsp; &nbsp; binary (base 2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; starting with 0b (i.e. 0b1100)<br>
&nbsp; &nbsp; octal (base 8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;starting with 0 &nbsp;(i.e. 014)<br>
&nbsp; &nbsp; hexadecimal (base 16) &nbsp; &nbsp; &nbsp; starting with 0x (i.e. 0xc)<br>
&nbsp; &nbsp; decimal &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherwise (i.e. 12)&quot; &gt;&amp;2<br>
&nbsp; &nbsp; exit $NOARGS&nbsp;<br>
} &nbsp; # ==&gt; Prints usage message.<br>
Msg () {<br>
&nbsp; &nbsp; for i &nbsp; # ==&gt; in [list] missing. Why?<br>
&nbsp; &nbsp; do echo &quot;$PN: $i&quot; &gt;&amp;2<br>
&nbsp; &nbsp; done<br>
}<br>
Fatal () { Msg &quot;$@&quot;; exit 66; }<br>
PrintBases () {<br>
&nbsp; &nbsp; # Determine base of the number<br>
&nbsp; &nbsp; for i &nbsp; &nbsp; &nbsp;# ==&gt; in [list] missing...<br>
&nbsp; &nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; so operates on command-line arg(s).<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$i&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0b*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ibase=2;; &nbsp; &nbsp; &nbsp; # binary<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x*|[a-f]*|[A-F]*) &nbsp;ibase=16;; &nbsp; &nbsp; &nbsp;# hexadecimal<br>
Chapter 16. External Filters, Programs and Commands<br>
293<br>
<hr>
<A name=300></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ibase=8;; &nbsp; &nbsp; &nbsp; # octal<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [1-9]*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ibase=10;; &nbsp; &nbsp; &nbsp;# decimal<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Msg &quot;illegal number $i - ignored&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Remove prefix, convert hex digits to uppercase (bc needs this).<br>
&nbsp; &nbsp; &nbsp; &nbsp; number=`echo &quot;$i&quot; | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Uses &quot;:&quot; as sed separator, rather than &quot;/&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Convert number to decimal<br>
&nbsp; &nbsp; &nbsp; &nbsp; dec=`echo &quot;ibase=$ibase; $number&quot; | bc` &nbsp;# ==&gt; 'bc' is calculator utility.<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$dec&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0-9]*) &nbsp; &nbsp; ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # number ok<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # error: ignore<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Print all conversions in one line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; 'here document' feeds command list to 'bc'.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo `bc &lt;&lt;!<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obase=16; &quot;hex=&quot;; $dec<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obase=10; &quot;dec=&quot;; $dec<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obase=8; &nbsp;&quot;oct=&quot;; $dec<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obase=2; &nbsp;&quot;bin=&quot;; $dec<br>
!<br>
&nbsp; &nbsp; ` | sed -e 's: : &nbsp; &nbsp;:g'<br>
&nbsp; &nbsp; done<br>
}<br>
while [ $# -gt 0 ]<br>
# ==&gt; &nbsp;Is a &quot;while loop&quot; really necessary here,<br>
# ==&gt;+ since all the cases either break out of the loop<br>
# ==&gt;+ or terminate the script.<br>
# ==&gt; (Above comment by Paulo Marcel Coelho Aragao.)<br>
do<br>
&nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; --) &nbsp; &nbsp; shift; break;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; -h) &nbsp; &nbsp; Usage;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Help message.<br>
&nbsp; &nbsp; &nbsp; &nbsp; -*) &nbsp; &nbsp; Usage;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*) &nbsp; &nbsp; break;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # First number<br>
&nbsp; &nbsp; esac &nbsp; # ==&gt; Error checking for illegal input might be appropriate.<br>
&nbsp; &nbsp; shift<br>
done<br>
if [ $# -gt 0 ]<br>
then<br>
&nbsp; &nbsp; PrintBases &quot;$@&quot;<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Read from stdin.<br>
&nbsp; &nbsp; while read line<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; PrintBases $line<br>
&nbsp; &nbsp; done<br>
fi<br>
exit<br>
An alternate method of invoking<b>&nbsp;bc</b><a href="abs-guides.html#360">&nbsp;involves using a here document embedded within a command<br></a><a href="abs-guides.html#170">substitution block. This is especially appropriate when a script needs to pass a list of options and</a><br>
Chapter 16. External Filters, Programs and Commands<br>
294<br>
<hr>
<A name=301></a>Advanced Bash-Scripting Guide<br>
commands to<b>&nbsp;bc</b>.<br>
variable=`bc &lt;&lt; LIMIT_STRING<br>
options<br>
statements<br>
operations<br>
LIMIT_STRING<br>
`<br>
...or...<br>
variable=$(bc &lt;&lt; LIMIT_STRING<br>
options<br>
statements<br>
operations<br>
LIMIT_STRING<br>
)<br>
<b>Example 16-49. Invoking<i>&nbsp;bc</i></b><b>&nbsp;using a<i>&nbsp;here document</i></b><br>
#!/bin/bash<br>
# Invoking 'bc' using command substitution<br>
# in combination with a 'here document'.<br>
var1=`bc &lt;&lt; EOF<br>
18.33 * 19.78<br>
EOF<br>
`<br>
echo $var1 &nbsp; &nbsp; &nbsp; # 362.56<br>
# &nbsp;$( ... ) notation also works.<br>
v1=23.53<br>
v2=17.881<br>
v3=83.501<br>
v4=171.63<br>
var2=$(bc &lt;&lt; EOF<br>
scale = 4<br>
a = ( $v1 + $v2 )<br>
b = ( $v3 * $v4 )<br>
a * b + 15.35<br>
EOF<br>
)<br>
echo $var2 &nbsp; &nbsp; &nbsp; # 593487.8452<br>
var3=$(bc -l &lt;&lt; EOF<br>
scale = 9<br>
s ( 1.7 )<br>
EOF<br>
)<br>
# Returns the sine of 1.7 radians.<br>
# The &quot;-l&quot; option calls the 'bc' math library.<br>
echo $var3 &nbsp; &nbsp; &nbsp; # .991664810<br>
# Now, try it in a function...<br>
hypotenuse () &nbsp; &nbsp;# Calculate hypotenuse of a right triangle.<br>
Chapter 16. External Filters, Programs and Commands<br>
295<br>
<hr>
<A name=302></a>Advanced Bash-Scripting Guide<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# c = sqrt( a^2 + b^2 )<br>
hyp=$(bc -l &lt;&lt; EOF<br>
scale = 9<br>
sqrt ( $1 * $1 + $2 * $2 )<br>
EOF<br>
)<br>
# Can't directly return floating point values from a Bash function.<br>
# But, can echo-and-capture:<br>
echo &quot;$hyp&quot;<br>
}<br>
hyp=$(hypotenuse 3.68 7.31)<br>
echo &quot;hypotenuse = $hyp&quot; &nbsp; &nbsp;# 8.184039344<br>
exit 0<br>
<b>Example 16-50. Calculating PI</b><br>
#!/bin/bash<br>
# cannon.sh: Approximating PI by firing cannonballs.<br>
# Author: Mendel Cooper<br>
# License: Public Domain<br>
# Version 2.2, reldate 13oct08.<br>
# This is a very simple instance of a &quot;Monte Carlo&quot; simulation:<br>
#+ a mathematical model of a real-life event,<br>
#+ using pseudorandom numbers to emulate random chance.<br>
# &nbsp;Consider a perfectly square plot of land, 10000 units on a side.<br>
# &nbsp;This land has a perfectly circular lake in its center,<br>
#+ with a diameter of 10000 units.<br>
# &nbsp;The plot is actually mostly water, except for land in the four corners.<br>
# &nbsp;(Think of it as a square with an inscribed circle.)<br>
#<br>
# &nbsp;We will fire iron cannonballs from an old-style cannon<br>
#+ at the square.<br>
# &nbsp;All the shots impact somewhere on the square,<br>
#+ either in the lake or on the dry corners.<br>
# &nbsp;Since the lake takes up most of the area,<br>
#+ most of the shots will SPLASH! into the water.<br>
# &nbsp;Just a few shots will THUD! into solid ground<br>
#+ in the four corners of the square.<br>
#<br>
# &nbsp;If we take enough random, unaimed shots at the square,<br>
#+ Then the ratio of SPLASHES to total shots will approximate<br>
#+ the value of PI/4.<br>
#<br>
# &nbsp;The simplified explanation is that the cannon is actually<br>
#+ shooting only at the upper right-hand quadrant of the square,<br>
#+ i.e., Quadrant I of the Cartesian coordinate plane.<br>
#<br>
#<br>
# &nbsp;Theoretically, the more shots taken, the better the fit.<br>
# &nbsp;However, a shell script, as opposed to a compiled language<br>
#+ with floating-point math built in, requires some compromises.<br>
# &nbsp;This decreases the accuracy of the simulation.<br>
Chapter 16. External Filters, Programs and Commands<br>
296<br>
<hr>
<A name=303></a>Advanced Bash-Scripting Guide<br>
DIMENSION=10000 &nbsp;# Length of each side of the plot.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Also sets ceiling for random integers generated.<br>
MAXSHOTS=1000 &nbsp; &nbsp;# Fire this many shots.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 10000 or more would be better, but would take too long.<br>
PMULTIPLIER=4.0 &nbsp;# Scaling factor.<br>
declare -r M_PI=3.141592654<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Actual 9-place value of PI, for comparison purposes.<br>
get_random ()<br>
{<br>
SEED=$(head -n 1 /dev/urandom | od -N 1 | awk '{ print $2 }')<br>
RANDOM=$SEED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;From &quot;seeding-random.sh&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ example script.<br>
let &quot;rnum = $RANDOM % $DIMENSION&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Range less than 10000.<br>
echo $rnum<br>
}<br>
distance= &nbsp; &nbsp; &nbsp; &nbsp;# Declare global variable.<br>
hypotenuse () &nbsp; &nbsp;# Calculate hypotenuse of a right triangle.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# From &quot;alt-bc.sh&quot; example.<br>
distance=$(bc -l &lt;&lt; EOF<br>
scale = 0<br>
sqrt ( $1 * $1 + $2 * $2 )<br>
EOF<br>
)<br>
# &nbsp;Setting &quot;scale&quot; to zero rounds down result to integer value,<br>
#+ a necessary compromise in this script.<br>
# &nbsp;It decreases the accuracy of this simulation.<br>
}<br>
# ==========================================================<br>
# main() {<br>
# &quot;Main&quot; code block, mimicking a C-language main() function.<br>
# Initialize variables.<br>
shots=0<br>
splashes=0<br>
thuds=0<br>
Pi=0<br>
error=0<br>
while [ &quot;$shots&quot; -lt &nbsp;&quot;$MAXSHOTS&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Main loop.<br>
do<br>
&nbsp; xCoord=$(get_random) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Get random X and Y coords.<br>
&nbsp; yCoord=$(get_random)<br>
&nbsp; hypotenuse $xCoord $yCoord &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Hypotenuse of<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ right-triangle = distance.<br>
&nbsp; ((shots++))<br>
&nbsp; printf &quot;#%4d &nbsp; &quot; $shots<br>
&nbsp; printf &quot;Xc = %4d &nbsp;&quot; $xCoord<br>
&nbsp; printf &quot;Yc = %4d &nbsp;&quot; $yCoord<br>
&nbsp; printf &quot;Distance = %5d &nbsp;&quot; $distance &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; Distance from<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ &nbsp;center of lake<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ &nbsp;-- the &quot;origin&quot; --<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ &nbsp;coordinate (0,0).<br>
&nbsp; if [ &quot;$distance&quot; -le &quot;$DIMENSION&quot; ]<br>
Chapter 16. External Filters, Programs and Commands<br>
297<br>
<hr>
<A name=304></a>Advanced Bash-Scripting Guide<br>
&nbsp; then<br>
&nbsp; &nbsp; echo -n &quot;SPLASH! &nbsp;&quot;<br>
&nbsp; &nbsp; ((splashes++))<br>
&nbsp; else<br>
&nbsp; &nbsp; echo -n &quot;THUD! &nbsp; &nbsp;&quot;<br>
&nbsp; &nbsp; ((thuds++))<br>
&nbsp; fi<br>
&nbsp; Pi=$(echo &quot;scale=9; $PMULTIPLIER*$splashes/$shots&quot; | bc)<br>
&nbsp; # Multiply ratio by 4.0.<br>
&nbsp; echo -n &quot;PI ~ $Pi&quot;<br>
&nbsp; echo<br>
done<br>
echo<br>
echo &quot;After $shots shots, PI looks like approximately &nbsp; $Pi&quot;<br>
# &nbsp;Tends to run a bit high,<br>
#+ possibly due to round-off error and imperfect randomness of $RANDOM.<br>
# &nbsp;But still usually within plus-or-minus 5% . . .<br>
#+ a pretty fair rough approximation.<br>
error=$(echo &quot;scale=9; $Pi - $M_PI&quot; | bc)<br>
pct_error=$(echo &quot;scale=2; 100.0 * $error / $M_PI&quot; | bc)<br>
echo -n &quot;Deviation from mathematical value of PI = &nbsp; &nbsp; &nbsp; &nbsp;$error&quot;<br>
echo &quot; ($pct_error% error)&quot;<br>
echo<br>
# End of &quot;main&quot; code block.<br>
# }<br>
# ==========================================================<br>
exit 0<br>
# &nbsp;One might well wonder whether a shell script is appropriate for<br>
#+ an application as complex and computation-intensive as a simulation.<br>
#<br>
# &nbsp;There are at least two justifications.<br>
# &nbsp;1) As a proof of concept: to show it can be done.<br>
# &nbsp;2) To prototype and test the algorithms before rewriting<br>
#+ &nbsp; &nbsp;it in a compiled high-level language.<br>
<a href="abs-guides.html#698">See also Example A-37.</a><br>
<b>dc</b><br>
The<b>&nbsp;dc</b>&nbsp;(<b>d</b>esk<b>&nbsp;c</b><a href="abs-guides.html#884">alculator) utility is stack-oriented and uses RPN (</a><i>Reverse Polish Notation</i>). Like<b>&nbsp;bc</b>, it<br>has much of the power of a programming language.<br>
Similar to the procedure with<b>&nbsp;bc</b><a href="abs-guides.html#187">, echo a command-string to</a><b>&nbsp;dc</b>.<br>
echo &quot;[Printing a string ... ]P&quot; | dc<br>
# The P command prints the string between the preceding brackets.<br>
# And now for some simple arithmetic.<br>
echo &quot;7 8 * p&quot; | dc &nbsp; &nbsp; # 56<br>
# &nbsp;Pushes 7, then 8 onto the stack,<br>
#+ multiplies (&quot;*&quot; operator), then prints the result (&quot;p&quot; operator).<br>
Most persons avoid<b>&nbsp;dc</b>, because of its non-intuitive input and rather cryptic operators. Yet, it has its<br>uses.<br>
<b>Example 16-51. Converting a decimal number to hexadecimal</b><br>
Chapter 16. External Filters, Programs and Commands<br>
298<br>
<hr>
<A name=305></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# hexconvert.sh: Convert a decimal number to hexadecimal.<br>
E_NOARGS=85 # Command-line arg missing.<br>
BASE=16 &nbsp; &nbsp; # Hexadecimal.<br>
if [ -z &quot;$1&quot; ]<br>
then &nbsp; &nbsp; &nbsp; &nbsp;# Need a command-line argument.<br>
&nbsp; echo &quot;Usage: $0 number&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Exercise: add argument validity checking.<br>
hexcvt ()<br>
{<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo 0<br>
&nbsp; return &nbsp; &nbsp;# &quot;Return&quot; 0 if no arg passed to function.<br>
fi<br>
echo &quot;&quot;$1&quot; &quot;$BASE&quot; o p&quot; | dc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;o &nbsp; &nbsp;sets radix (numerical base) of output.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p &nbsp;prints the top of stack.<br>
# For other options: 'man dc' ...<br>
return<br>
}<br>
hexcvt &quot;$1&quot;<br>
exit<br>
<a href="abs-guides.html#225">Studying the info page for</a><b>&nbsp;dc</b>&nbsp;is a painful path to understanding its intricacies. There seems to be a<br>small, select group of<i>&nbsp;dc wizards</i>&nbsp;who delight in showing off their mastery of this powerful, but<br>arcane utility.<br>
bash$&nbsp;<b>echo &quot;16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq&quot; | dc<br></b>Bash<br>
dc &lt;&lt;&lt; 10k5v1+2/p # 1.6180339887<br>
# &nbsp;^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Feed operations to dc using a Here String.<br>
# &nbsp; &nbsp; &nbsp;^^^ &nbsp; &nbsp; &nbsp; &nbsp;Pushes 10 and sets that as the precision (10k).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;Pushes 5 and takes its square root<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (5v, v = square root).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp;Pushes 1 and adds it to the running total (1+).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp;Pushes 2 and divides the running total by that (2/).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ Pops and prints the result (p)<br>
# &nbsp;The result is &nbsp;1.6180339887 ...<br>
# &nbsp;... which happens to be the Pythagorean Golden Ratio, to 10 places.<br>
<b>Example 16-52. Factoring</b><br>
#!/bin/bash<br>
# factr.sh: Factor a number<br>
MIN=2 &nbsp; &nbsp; &nbsp; # Will not work for number smaller than this.<br>
E_NOARGS=85<br>
E_TOOSMALL=86<br>
Chapter 16. External Filters, Programs and Commands<br>
299<br>
<hr>
<A name=306></a>Advanced Bash-Scripting Guide<br>
if [ -z $1 ]<br>
then<br>
&nbsp; echo &quot;Usage: $0 number&quot;<br>
&nbsp; exit $E_NOARGS<br>
fi<br>
if [ &quot;$1&quot; -lt &quot;$MIN&quot; ]<br>
then<br>
&nbsp; echo &quot;Number to factor must be $MIN or greater.&quot;<br>
&nbsp; exit $E_TOOSMALL<br>
fi &nbsp;<br>
# Exercise: Add type checking (to reject non-integer arg).<br>
echo &quot;Factors of $1:&quot;<br>
# -------------------------------------------------------<br>
echo &nbsp;&quot;$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=\<br>
1lrli2+dsi!&gt;.]ds.xd1&lt;2&quot; | dc<br>
# -------------------------------------------------------<br>
# &nbsp;Above code written by Michel Charpentier &lt;charpov@cs.unh.edu&gt;<br>
# &nbsp;(as a one-liner, here broken into two lines for display purposes).<br>
# &nbsp;Used in ABS Guide with permission (thanks!).<br>
&nbsp;exit<br>
&nbsp;# $ sh factr.sh 270138<br>
&nbsp;# 2<br>
&nbsp;# 3<br>
&nbsp;# 11<br>
&nbsp;# 4093<br>
<b>awk</b><br>
<a href="abs-guides.html#784">Yet another way of doing floating point math in a script is using awk's built-in math functions in a<br></a><a href="abs-guides.html#503">shell wrapper.</a><br>
<b>Example 16-53. Calculating the hypotenuse of a triangle</b><br>
#!/bin/bash<br>
# hypotenuse.sh: Returns the &quot;hypotenuse&quot; of a right triangle.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(square root of sum of squares of the &quot;legs&quot;)<br>
ARGS=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Script needs sides of triangle passed.<br>
E_BADARGS=85 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Wrong number of arguments.<br>
if [ $# -ne &quot;$ARGS&quot; ] # Test number of arguments to script.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` side_1 side_2&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
AWKSCRIPT=' { printf( &quot;%3.7f\n&quot;, sqrt($1*$1 + $2*$2) ) } '<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command(s) / parameters passed to awk<br>
# Now, pipe the parameters to awk.<br>
&nbsp; &nbsp; echo -n &quot;Hypotenuse of $1 and $2 = &quot;<br>
&nbsp; &nbsp; echo $1 $2 | awk &quot;$AWKSCRIPT&quot;<br>
# &nbsp; ^^^^^^^^^^^^<br>
# An echo-and-pipe is an easy way of passing shell parameters to awk.<br>
Chapter 16. External Filters, Programs and Commands<br>
300<br>
<hr>
<A name=307></a>Advanced Bash-Scripting Guide<br>
exit<br>
# Exercise: Rewrite this script using 'bc' rather than awk.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Which method is more intuitive?<br>
<b>16.9. Miscellaneous Commands</b><br>
<b>Command that fit in no special category</b><br>
<b>jot</b>,&nbsp;<b>seq</b><br>
These utilities emit a sequence of integers, with a user-selectable increment.<br>
The default separator character between each integer is a newline, but this can be changed with the&nbsp;-s<br>option.<br>
bash$&nbsp;<b>seq 5<br></b>1<br>
&nbsp;2<br>
&nbsp;3<br>
&nbsp;4<br>
&nbsp;5<br>
bash$&nbsp;<b>seq -s : 5<br></b>1:2:3:4:5<br>
Both<b>&nbsp;jot</b>&nbsp;and<b>&nbsp;seq</b><a href="abs-guides.html#144">&nbsp;come in handy in a for loop.</a><br>
<b>Example 16-54. Using<i>&nbsp;seq</i></b><b>&nbsp;to generate loop arguments</b><br>
#!/bin/bash<br>
# Using &quot;seq&quot;<br>
echo<br>
for a in `seq 80` &nbsp;# or &nbsp; for a in $( seq 80 )<br>
# Same as &nbsp; for a in 1 2 3 4 5 ... 80 &nbsp; (saves much typing!).<br>
# May also use 'jot' (if present on system).<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp; &nbsp; &nbsp;# 1 2 3 4 5 ... 80<br>
# Example of using the output of a command to generate&nbsp;<br>
# the [list] in a &quot;for&quot; loop.<br>
echo; echo<br>
COUNT=80 &nbsp;# Yes, 'seq' also accepts a replaceable parameter.<br>
for a in `seq $COUNT` &nbsp;# or &nbsp; for a in $( seq $COUNT )<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp; &nbsp; &nbsp;# 1 2 3 4 5 ... 80<br>
Chapter 16. External Filters, Programs and Commands<br>
301<br>
<hr>
<A name=308></a>Advanced Bash-Scripting Guide<br>
echo; echo<br>
BEGIN=75<br>
END=80<br>
for a in `seq $BEGIN $END`<br>
# &nbsp;Giving &quot;seq&quot; two arguments starts the count at the first one,<br>
#+ and continues until it reaches the second.<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp; &nbsp; &nbsp;# 75 76 77 78 79 80<br>
echo; echo<br>
BEGIN=45<br>
INTERVAL=5<br>
END=80<br>
for a in `seq $BEGIN $INTERVAL $END`<br>
# &nbsp;Giving &quot;seq&quot; three arguments starts the count at the first one,<br>
#+ uses the second for a step interval,<br>
#+ and continues until it reaches the third.<br>
do<br>
&nbsp; echo -n &quot;$a &quot;<br>
done &nbsp; &nbsp; &nbsp;# 45 50 55 60 65 70 75 80<br>
echo; echo<br>
exit 0<br>
A simpler example:<br>
# &nbsp;Create a set of 10 files,<br>
#+ named file.1, file.2 . . . file.10.<br>
COUNT=10<br>
PREFIX=file<br>
for filename in `seq $COUNT`<br>
do<br>
&nbsp; touch $PREFIX.$filename<br>
&nbsp; # &nbsp;Or, can do other operations,<br>
&nbsp; #+ such as rm, grep, etc.<br>
done<br>
<b>Example 16-55. Letter Count&quot;</b><br>
#!/bin/bash<br>
# letter-count.sh: Counting letter occurrences in a text file.<br>
# Written by Stefano Palmeri.<br>
# Used in ABS Guide with permission.<br>
# Slightly modified by document author.<br>
MINARGS=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Script requires at least two arguments.<br>
E_BADARGS=65<br>
FILE=$1<br>
let LETTERS=$#-1 &nbsp; # How many letters specified (as command-line args).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (Subtract 1 from number of command-line args.)<br>
show_help(){<br>
Chapter 16. External Filters, Programs and Commands<br>
302<br>
<hr>
<A name=309></a><IMG src="abs-guide-309_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo Usage: `basename $0` file letters &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo Note: `basename $0` arguments are case sensitive.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo Example: `basename $0` foobar.txt G n U L i N U x.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
}<br>
# Checks number of arguments.<br>
if [ $# -lt $MINARGS ]; then<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;echo &quot;Not enough arguments.&quot;<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;show_help<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi &nbsp;<br>
# Checks if file exists.<br>
if [ ! -f $FILE ]; then<br>
&nbsp; &nbsp; echo &quot;File \&quot;$FILE\&quot; does not exist.&quot;<br>
&nbsp; &nbsp; exit $E_BADARGS<br>
fi<br>
# Counts letter occurrences .<br>
for n in `seq $LETTERS`; do<br>
&nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; &nbsp; if [[ `echo -n &quot;$1&quot; | wc -c` -eq 1 ]]; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Checks arg.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$1&quot; -\&gt; `cat $FILE | tr -cd &nbsp;&quot;$1&quot; | wc -c` # &nbsp;Counting.<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$1 is not a &nbsp;single char.&quot;<br>
&nbsp; &nbsp; &nbsp; fi &nbsp;<br>
done<br>
exit $?<br>
# &nbsp;This script has exactly the same functionality as letter-count2.sh,<br>
#+ but executes faster.<br>
# &nbsp;Why?<br>
Somewhat more capable than<i>&nbsp;seq</i>,<b>&nbsp;jot</b>&nbsp;is a classic UNIX utility that is not normally<br>included in a standard Linux distro. However, the source<i>&nbsp;rpm</i>&nbsp;is available for<br><a href="http://www.mit.edu/afs/athena/system/rhlinux/athena-9.0/free/SRPMS/athena-jot-9.0-3.src.rpm">download from the &nbsp;MIT repository.</a><br>
Unlike<i>&nbsp;seq</i>,<b>&nbsp;jot</b>&nbsp;can generate a sequence of random numbers, using the&nbsp;-r&nbsp;option.<br>
bash$&nbsp;<b>jot -r 3 999<br></b>1069<br>
&nbsp;1272<br>
&nbsp;1428<br>
<b>getopt</b><br>
The<b>&nbsp;getopt</b><a href="abs-guides.html#26">&nbsp;command parses command-line options preceded by a dash. This external command<br></a><a href="abs-guides.html#208">corresponds to the getopts Bash builtin. Using</a><b>&nbsp;getopt</b>&nbsp;permits handling long options by means of the<br>-l&nbsp;flag, and this also allows parameter reshuffling.<br>
Chapter 16. External Filters, Programs and Commands<br>
303<br>
<hr>
<A name=310></a><IMG src="abs-guide-310_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>Example 16-56. Using<i>&nbsp;getopt</i></b><b>&nbsp;to parse command-line options</b><br>
#!/bin/bash<br>
# Using getopt<br>
# Try the following when invoking this script:<br>
# &nbsp; sh ex33a.sh -a<br>
# &nbsp; sh ex33a.sh -abc<br>
# &nbsp; sh ex33a.sh -a -b -c<br>
# &nbsp; sh ex33a.sh -d<br>
# &nbsp; sh ex33a.sh -dXYZ<br>
# &nbsp; sh ex33a.sh -d XYZ<br>
# &nbsp; sh ex33a.sh -abcd<br>
# &nbsp; sh ex33a.sh -abcdZ<br>
# &nbsp; sh ex33a.sh -z<br>
# &nbsp; sh ex33a.sh a<br>
# Explain the results of each of the above.<br>
E_OPTERR=65<br>
if [ &quot;$#&quot; -eq 0 ]<br>
then &nbsp; # Script needs at least one command-line argument.<br>
&nbsp; echo &quot;Usage $0 -[options a,b,c]&quot;<br>
&nbsp; exit $E_OPTERR<br>
fi &nbsp;<br>
set -- `getopt &quot;abcd:&quot; &quot;$@&quot;`<br>
# Sets positional parameters to command-line arguments.<br>
# What happens if you use &quot;$*&quot; instead of &quot;$@&quot;?<br>
while [ ! -z &quot;$1&quot; ]<br>
do<br>
&nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; -a) echo &quot;Option \&quot;a\&quot;&quot;;;<br>
&nbsp; &nbsp; -b) echo &quot;Option \&quot;b\&quot;&quot;;;<br>
&nbsp; &nbsp; -c) echo &quot;Option \&quot;c\&quot;&quot;;;<br>
&nbsp; &nbsp; -d) echo &quot;Option \&quot;d\&quot; $2&quot;;;<br>
&nbsp; &nbsp; &nbsp;*) break;;<br>
&nbsp; esac<br>
&nbsp; shift<br>
done<br>
# &nbsp;It is usually better to use the 'getopts' builtin in a script.<br>
# &nbsp;See &quot;ex33.sh.&quot;<br>
exit 0<br>
As<i>&nbsp;Peggy Russell</i>&nbsp;points out:<br>
<a href="abs-guides.html#199">It is often necessary to include an eval to correctly process whitespace and</a><i>&nbsp;quotes</i>.<br>
args=$(getopt -o a:bc:d -- &quot;$@&quot;)<br>
eval set -- &quot;$args&quot;<br>
<a href="abs-guides.html#131">See Example 10-5 for a simplified emulation of</a><b>&nbsp;getopt</b>.<br>
<b>run-parts</b><br>
The<b>&nbsp;run-parts</b>&nbsp;command&nbsp;[80] executes all the scripts in a target directory, sequentially in<br>ASCII-sorted filename order. Of course, the scripts need to have execute permission.<br>
Chapter 16. External Filters, Programs and Commands<br>
304<br>
<hr>
<A name=311></a><IMG src="abs-guide-311_1.png"><br>
<IMG src="abs-guide-311_2.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#338">The cron daemon invokes</a><b>&nbsp;run-parts</b>&nbsp;to run the scripts in the&nbsp;/etc/cron.*&nbsp;directories.<br>
<b>yes</b><br>
In its default behavior the<b>&nbsp;yes</b>&nbsp;command feeds a continuous string of the character&nbsp;y&nbsp;followed by a<br>line feed to&nbsp;stdout. A<b>&nbsp;control</b>-<b>C</b>&nbsp;terminates the run. A different output string may be specified, as<br>in&nbsp;<b>yes different string</b>, which would continually output&nbsp;different string&nbsp;to<br>stdout.<br>
One might well ask the purpose of this. From the command-line or in a script, the output of<b>&nbsp;yes</b>&nbsp;can be<br>redirected or piped into a program expecting user input. In effect, this becomes a sort of poor man's<br>version of<i>&nbsp;expect</i>.<br>
<b>yes | fsck /dev/hda1</b>&nbsp;runs<b>&nbsp;fsck</b>&nbsp;non-interactively (careful!).<br>
<b>yes | rm -r dirname</b>&nbsp;has same effect as&nbsp;<b>rm -rf dirname</b>&nbsp;(careful!).<br>
Caution advised when piping<i>&nbsp;yes</i>&nbsp;to a potentially dangerous system command, such as<br><a href="abs-guides.html#344">fsck or fdisk. It might have unintended consequences.</a><br>
The<i>&nbsp;yes</i>&nbsp;command parses variables, or more accurately, it echoes parsed variables. For<br>example:<br>
bash$&nbsp;<b>yes $BASH_VERSION<br></b>3.1.17(1)-release<br>
&nbsp;3.1.17(1)-release<br>
&nbsp;3.1.17(1)-release<br>
&nbsp;3.1.17(1)-release<br>
&nbsp;3.1.17(1)-release<br>
&nbsp;. . .<br>
This particular &quot;feature&quot; may be used to create a<i>&nbsp;very large</i>&nbsp;ASCII file on the fly:<br>
bash$&nbsp;<b>yes $PATH &gt; huge_file.txt<br>Ctl-C</b><br>
Hit&nbsp;<b>Ctl-C</b><i>&nbsp;very quickly</i>, or you just might get more than you bargained for. . . .<br>
The<i>&nbsp;yes</i><a href="abs-guides.html#399">&nbsp;command may be emulated in a very simple script function.</a><br>
yes ()<br>
{ # Trivial emulation of &quot;yes&quot; ...<br>
&nbsp; local DEFAULT_TEXT=&quot;y&quot;<br>
&nbsp; while [ true ] &nbsp; # Endless loop.<br>
&nbsp; do<br>
&nbsp; &nbsp; if [ -z &quot;$1&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;$DEFAULT_TEXT&quot;<br>
&nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If argument ...<br>
&nbsp; &nbsp; &nbsp; echo &quot;$1&quot; &nbsp; &nbsp;# ... expand and echo it.<br>
&nbsp; &nbsp; fi<br>
&nbsp; done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;The only things missing are the<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ --help and --version options.<br>
<b>banner</b><br>
Prints arguments as a large vertical banner to&nbsp;stdout<a href="abs-guides.html#882">, using an ASCII character (default '#'). This<br></a>may be redirected to a printer for hardcopy.<br>
Chapter 16. External Filters, Programs and Commands<br>
305<br>
<hr>
<A name=312></a>Advanced Bash-Scripting Guide<br>
Note that<i>&nbsp;banner</i>&nbsp;has been dropped from many Linux distros.<br>
<b>printenv</b><br>
<a href="abs-guides.html#41">Show all the environmental variables set for a particular user.</a><br>
bash$&nbsp;<b>printenv | grep HOME<br></b>HOME=/home/bozo<br>
<b>lp</b><br>
The<b>&nbsp;lp</b>&nbsp;and<b>&nbsp;lpr</b>&nbsp;commands send file(s) to the print queue, to be printed as hard copy.&nbsp;[81] These<br>commands trace the origin of their names to the line printers of another era.<br>
bash$&nbsp;<b>lp file1.txt</b>&nbsp;or&nbsp;bash&nbsp;<b>lp &lt;file1.txt</b><br>
It is often useful to pipe the formatted output from<b>&nbsp;pr</b>&nbsp;to<b>&nbsp;lp</b>.<br>
bash$&nbsp;<b>pr -options file1.txt | lp</b><br>
<a href="abs-guides.html#261">Formatting packages, such as groff and</a><i>&nbsp;Ghostscript</i>&nbsp;may send their output directly to<b>&nbsp;lp</b>.<br>
bash$&nbsp;<b>groff -Tascii file.tr | lp</b><br>
bash$&nbsp;<b>gs -options | lp file.ps</b><br>
Related commands are<b>&nbsp;lpq</b>, for viewing the print queue, and<b>&nbsp;lprm</b>, for removing jobs from the print<br>queue.<br>
<b>tee</b><br>
[UNIX borrows an idea from the plumbing trade.]<br>
This is a redirection operator, but with a difference. Like the plumber's<i>&nbsp;tee,</i>&nbsp;it permits &quot;siphoning off&quot;<br><i>to a file</i>&nbsp;the output of a command or commands within a pipe, but without affecting the result. This is<br>useful for printing an ongoing process to a file or paper, perhaps to keep track of it for debugging<br>purposes.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(redirection)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |----&gt; to file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br>
&nbsp; ==========================|====================<br>
&nbsp; command ---&gt; command ---&gt; |tee ---&gt; command ---&gt; ---&gt; output of pipe<br>
&nbsp; ===============================================<br>
cat listfile* | sort | tee check.file | uniq &gt; result.file<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^ &nbsp; ^^^^ &nbsp; &nbsp;<br>
# &nbsp;The file &quot;check.file&quot; contains the concatenated sorted &quot;listfiles,&quot;<br>
#+ before the duplicate lines are removed by 'uniq.'<br>
<b>mkfifo</b><br>
This obscure command creates a<i>&nbsp;named pipe</i>, a temporary<i>&nbsp;first-in-first-out buffer</i>&nbsp;for transferring data<br>between processes.&nbsp;[82] Typically, one process writes to the FIFO, and the other reads from it. See<br><a href="abs-guides.html#591">Example A-14.</a><br>
#!/bin/bash<br>
# This short script by Omair Eshkenazi.<br>
Chapter 16. External Filters, Programs and Commands<br>
306<br>
<hr>
<A name=313></a>Advanced Bash-Scripting Guide<br>
# Used in ABS Guide with permission (thanks!).<br>
mkfifo pipe1 &nbsp; # Yes, pipes can be given names.<br>
mkfifo pipe2 &nbsp; # Hence the designation &quot;named pipe.&quot;<br>
(cut -d' ' -f1 | tr &quot;a-z&quot; &quot;A-Z&quot;) &gt;pipe2 &lt;pipe1 &amp;<br>
ls -l | tr -s ' ' | cut -d' ' -f3,9- | tee pipe1 |<br>
cut -d' ' -f2 | paste - pipe2<br>
rm -f pipe1<br>
rm -f pipe2<br>
# No need to kill background processes when script terminates (why not?).<br>
exit $?<br>
Now, invoke the script and explain the output:<br>
sh mkfifo-example.sh<br>
4830.tar.gz &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BOZO<br>
pipe1 &nbsp; BOZO<br>
pipe2 &nbsp; BOZO<br>
mkfifo-example.sh &nbsp; &nbsp;BOZO<br>
Mixed.msg BOZO<br>
<b>pathchk</b><br>
This command checks the validity of a filename. If the filename exceeds the maximum allowable<br>length (255 characters) or one or more of the directories in its path is not searchable, then an error<br>message results.<br>
Unfortunately,<b>&nbsp;pathchk</b>&nbsp;does not return a recognizable error code, and it is therefore pretty much<br><a href="abs-guides.html#68">useless in a script. Consider instead the file test operators.</a><br>
<b>dd</b><br>
Though this somewhat obscure and much feared<b>&nbsp;d</b>ata<b>&nbsp;d</b>uplicator command originated as a utility for<br>exchanging data on magnetic tapes between UNIX minicomputers and IBM mainframes, it still has its<br>uses. The<b>&nbsp;dd</b>&nbsp;command simply copies a file (or&nbsp;stdin/stdout), but with conversions.&nbsp;Possible<br>conversions include ASCII/EBCDIC,&nbsp;[83] upper/lower case, swapping of byte pairs between input<br>and output, and skipping and/or truncating the head or tail of the input file.<br>
# Converting a file to all uppercase:<br>
dd if=$filename conv=ucase &gt; $filename.uppercase<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lcase &nbsp; # For lower case conversion<br>
Some basic options to<b>&nbsp;dd</b>&nbsp;are:<br>
if=INFILE<br>
◊&nbsp;<br>
INFILE is the<i>&nbsp;source</i>&nbsp;file.<br>of=OUTFILE<br>
◊&nbsp;<br>
OUTFILE is the<i>&nbsp;target</i>&nbsp;file, the file that will have the data written to it.<br>bs=BLOCKSIZE<br>
◊&nbsp;<br>
This is the size of each block of data being read and written, usually a power of 2.<br>skip=BLOCKS<br>
◊&nbsp;<br>
Chapter 16. External Filters, Programs and Commands<br>
307<br>
<hr>
<A name=314></a>Advanced Bash-Scripting Guide<br>
How many blocks of data to skip in INFILE before starting to copy. This is useful when the<br>INFILE has &quot;garbage&quot; or garbled data in its header or when it is desirable to copy only a<br>portion of the INFILE.<br>seek=BLOCKS<br>
◊&nbsp;<br>
How many blocks of data to skip in OUTFILE before starting to copy, leaving blank data at<br>beginning of OUTFILE.<br>count=BLOCKS<br>
◊&nbsp;<br>
Copy only this many blocks of data, rather than the entire INFILE.<br>conv=CONVERSION<br>
◊&nbsp;<br>
Type of conversion to be applied to INFILE data before copying operation.<br>
A&nbsp;<b>dd --help</b>&nbsp;lists all the options this powerful utility takes.<br>
<b>Example 16-57. A script that copies itself</b><br>
#!/bin/bash<br>
# self-copy.sh<br>
# This script copies itself.<br>
file_subscript=copy<br>
dd if=$0 of=$0.$file_subscript 2&gt;/dev/null<br>
# Suppress messages from dd: &nbsp; ^^^^^^^^^^^<br>
exit $?<br>
# &nbsp;A program whose only output is its own source code<br>
#+ is called a &quot;quine&quot; per Willard Quine.<br>
# &nbsp;Does this script qualify as a quine?<br>
<b>Example 16-58. Exercising<i>&nbsp;dd</i></b><br>
#!/bin/bash<br>
# exercising-dd.sh<br>
# Script by Stephane Chazelas.<br>
# Somewhat modified by ABS Guide author.<br>
infile=$0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This script.<br>
outfile=log.txt &nbsp; &nbsp; # Output file left behind.<br>
n=8<br>
p=11<br>
dd if=$infile of=$outfile bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null<br>
# Extracts characters n to p (8 to 11) from this script (&quot;bash&quot;).<br>
# ----------------------------------------------------------------<br>
echo -n &quot;hello vertical world&quot; | dd cbs=1 conv=unblock 2&gt; /dev/null<br>
# Echoes &quot;hello vertical world&quot; vertically downward.<br>
# Why? A newline follows each character dd emits.<br>
exit $?<br>
Chapter 16. External Filters, Programs and Commands<br>
308<br>
<hr>
<A name=315></a>Advanced Bash-Scripting Guide<br>
To demonstrate just how versatile<b>&nbsp;dd</b>&nbsp;is, let's use it to capture keystrokes.<br>
<b>Example 16-59. Capturing Keystrokes</b><br>
#!/bin/bash<br>
# dd-keypress.sh: Capture keystrokes without needing to press ENTER.<br>
keypresses=4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Number of keypresses to capture.<br>
old_tty_setting=$(stty -g) &nbsp; &nbsp; &nbsp; &nbsp;# Save old terminal settings.<br>
echo &quot;Press $keypresses keys.&quot;<br>
stty -icanon -echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Disable canonical mode.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Disable local echo.<br>
keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)<br>
# 'dd' uses stdin, if &quot;if&quot; (input file) not specified.<br>
stty &quot;$old_tty_setting&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Restore old terminal settings.<br>
echo &quot;You pressed the \&quot;$keys\&quot; keys.&quot;<br>
# Thanks, Stephane Chazelas, for showing the way.<br>
exit 0<br>
The<b>&nbsp;dd</b>&nbsp;command can do random access on a data stream.<br>
echo -n . | dd bs=1 seek=4 of=file conv=notrunc<br>
# &nbsp;The &quot;conv=notrunc&quot; option means that the output file<br>
#+ will not be truncated.<br>
# Thanks, S.C.<br>
The<b>&nbsp;dd</b>&nbsp;command can copy raw data and disk images to and from devices, such as floppies and tape<br><a href="abs-guides.html#575">drives (Example A-5). A common use is creating boot floppies.</a><br>
<b>dd if=kernel-image of=/dev/fd0H1440</b><br>
Similarly,<b>&nbsp;dd</b>&nbsp;can copy the entire contents of a floppy, even one formatted with a &quot;foreign&quot; OS, to the<br>hard drive as an image file.<br>
<b>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</b><br>
Other applications of<b>&nbsp;dd</b><a href="abs-guides.html#473">&nbsp;include initializing temporary swap files (Example 31-2) and ramdisks<br></a><a href="abs-guides.html#474">(Example 31-3). It can even do a low-level copy of an entire hard drive partition, although this is not<br></a>necessarily recommended.<br>
People (with presumably nothing better to do with their time) are constantly thinking of interesting<br>applications of<b>&nbsp;dd</b>.<br>
Chapter 16. External Filters, Programs and Commands<br>
309<br>
<hr>
<A name=316></a>Advanced Bash-Scripting Guide<br>
<b>Example 16-60. Securely deleting a file</b><br>
#!/bin/bash<br>
# blot-out.sh: Erase &quot;all&quot; traces of a file.<br>
# &nbsp;This script overwrites a target file alternately<br>
#+ with random bytes, then zeros before finally deleting it.<br>
# &nbsp;After that, even examining the raw disk sectors by conventional methods<br>
#+ will not reveal the original file data.<br>
PASSES=7 &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Number of file-shredding passes.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Increasing this slows script execution,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ especially on large target files.<br>
BLOCKSIZE=1 &nbsp; &nbsp; &nbsp;# &nbsp;I/O with /dev/urandom requires unit block size,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ otherwise you get weird results.<br>
E_BADARGS=70 &nbsp; &nbsp; # &nbsp;Various error exit codes.<br>
E_NOT_FOUND=71<br>
E_CHANGED_MIND=72<br>
if [ -z &quot;$1&quot; ] &nbsp; # No filename specified.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
file=$1<br>
if [ ! -e &quot;$file&quot; ]<br>
then<br>
&nbsp; echo &quot;File \&quot;$file\&quot; not found.&quot;<br>
&nbsp; exit $E_NOT_FOUND<br>
fi &nbsp;<br>
echo; echo -n &quot;Are you absolutely sure you want to blot out \&quot;$file\&quot; (y/n)? &quot;<br>
read answer<br>
case &quot;$answer&quot; in<br>
[nN]) echo &quot;Changed your mind, huh?&quot;<br>
&nbsp; &nbsp; &nbsp; exit $E_CHANGED_MIND<br>
&nbsp; &nbsp; &nbsp; ;;<br>
*) &nbsp; &nbsp;echo &quot;Blotting out file \&quot;$file\&quot;.&quot;;;<br>
esac<br>
flength=$(ls -l &quot;$file&quot; | awk '{print $5}') &nbsp;# Field 5 is file length.<br>
pass_count=1<br>
chmod u+w &quot;$file&quot; &nbsp; # Allow overwriting/deleting the file.<br>
echo<br>
while [ &quot;$pass_count&quot; -le &quot;$PASSES&quot; ]<br>
do<br>
&nbsp; echo &quot;Pass #$pass_count&quot;<br>
&nbsp; sync &nbsp; &nbsp; &nbsp; &nbsp; # Flush buffers.<br>
&nbsp; dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Fill with random bytes.<br>
&nbsp; sync &nbsp; &nbsp; &nbsp; &nbsp; # Flush buffers again.<br>
&nbsp; dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Fill with zeros.<br>
&nbsp; sync &nbsp; &nbsp; &nbsp; &nbsp; # Flush buffers yet again.<br>
&nbsp; let &quot;pass_count += 1&quot;<br>
&nbsp; echo<br>
Chapter 16. External Filters, Programs and Commands<br>
310<br>
<hr>
<A name=317></a>Advanced Bash-Scripting Guide<br>
done &nbsp;<br>
rm -f $file &nbsp; &nbsp;# Finally, delete scrambled and shredded file.<br>
sync &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Flush buffers a final time.<br>
echo &quot;File \&quot;$file\&quot; blotted out and deleted.&quot;; echo<br>
exit 0<br>
# &nbsp;This is a fairly secure, if inefficient and slow method<br>
#+ of thoroughly &quot;shredding&quot; a file.<br>
# &nbsp;The &quot;shred&quot; command, part of the GNU &quot;fileutils&quot; package,<br>
#+ does the same thing, although more efficiently.<br>
# &nbsp;The file cannot not be &quot;undeleted&quot; or retrieved by normal methods.<br>
# &nbsp;However . . .<br>
#+ this simple method would *not* likely withstand<br>
#+ sophisticated forensic analysis.<br>
# &nbsp;This script may not play well with a journaled file system.<br>
# &nbsp;Exercise (difficult): Fix it so it does.<br>
# &nbsp;Tom Vier's &quot;wipe&quot; file-deletion package does a much more thorough job<br>
#+ of file shredding than this simple script.<br>
# &nbsp; &nbsp; http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2<br>
# &nbsp;For an in-depth analysis on the topic of file deletion and security,<br>
#+ see Peter Gutmann's paper,<br>
#+ &nbsp; &nbsp; &quot;Secure Deletion of Data From Magnetic and Solid-State Memory&quot;.<br>
# &nbsp; &nbsp; &nbsp; http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html<br>
<a href="abs-guides.html#571">See also the dd thread entry in the bibliography.</a><br>
<b>od</b><br>
The<b>&nbsp;od</b>, or<i>&nbsp;octal dump</i>&nbsp;filter converts input (or files) to octal (base-8) or other bases. This is useful for<br><a href="abs-guides.html#460">viewing or processing binary data files or otherwise unreadable system device files, such as<br></a>/dev/urandom, and as a filter for binary data.<br>
head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'<br>
# Sample output: 1324725719, 3918166450, 2989231420, etc.<br>
# From rnd.sh example script, by Stéphane Chazelas<br>
<a href="abs-guides.html#122">See also Example 9-16 and Example A-36.</a><br>
<b>hexdump</b><br>
Performs a hexadecimal, octal, decimal, or ASCII dump of a binary file. This command is the rough<br>equivalent of<b>&nbsp;od</b>, above, but not nearly as useful. May be used to view the contents of a binary file, in<br><a href="abs-guides.html#313">combination with dd and less.</a><br>
dd if=/bin/ls | hexdump -C | less<br>
# The -C option nicely formats the output in tabular form.<br>
<b>objdump</b><br>
Displays information about an object file or binary executable in either hexadecimal form or as a<br>disassembled listing (with the&nbsp;-d&nbsp;option).<br>
bash$&nbsp;<b>objdump -d /bin/ls<br></b>/bin/ls: &nbsp; &nbsp; file format elf32-i386<br>
Chapter 16. External Filters, Programs and Commands<br>
311<br>
<hr>
<A name=318></a>Advanced Bash-Scripting Guide<br>
&nbsp;Disassembly of section .init:<br>
&nbsp;080490bc &lt;.init&gt;:<br>
&nbsp; 80490bc: &nbsp; &nbsp; &nbsp; 55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push &nbsp; %ebp<br>
&nbsp; 80490bd: &nbsp; &nbsp; &nbsp; 89 e5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov &nbsp; &nbsp;%esp,%ebp<br>
&nbsp; . . .<br>
<b>mcookie</b><br>
This command generates a &quot;magic cookie,&quot; a 128-bit (32-character) pseudorandom hexadecimal<br>number, normally used as an authorization &quot;signature&quot; by the X server. This also available for use in a<br>script as a &quot;quick 'n dirty&quot; random number.<br>
random000=$(mcookie)<br>
<a href="abs-guides.html#275">Of course, a script could use md5sum for the same purpose.</a><br>
# Generate md5 checksum on the script itself.<br>
random001=`md5sum $0 | awk '{print $1}'`<br>
# Uses 'awk' to strip off the filename.<br>
The<b>&nbsp;mcookie</b>&nbsp;command gives yet another way to generate a &quot;unique&quot; filename.<br>
<b>Example 16-61. Filename generator</b><br>
#!/bin/bash<br>
# tempfile-name.sh: &nbsp;temp filename generator<br>
BASE_STR=`mcookie` &nbsp; # 32-character magic cookie.<br>
POS=11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Arbitrary position in magic cookie string.<br>
LEN=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Get $LEN consecutive characters.<br>
prefix=temp &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This is, after all, a &quot;temp&quot; file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;For more &quot;uniqueness,&quot; generate the<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ filename prefix using the same method<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ as the suffix, below.<br>
suffix=${BASE_STR:POS:LEN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Extract a 5-character string,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ starting at position 11.<br>
temp_filename=$prefix.$suffix<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Construct the filename.<br>
echo &quot;Temp filename = &quot;$temp_filename&quot;&quot;<br>
# sh tempfile-name.sh<br>
# Temp filename = temp.e19ea<br>
# &nbsp;Compare this method of generating &quot;unique&quot; filenames<br>
#+ with the 'date' method in ex51.sh.<br>
exit 0<br>
<b>units</b><br>
This utility converts between different<i>&nbsp;units of measure</i>. While normally invoked in interactive mode,<br><b>units</b>&nbsp;may find use in a script.<br>
Chapter 16. External Filters, Programs and Commands<br>
312<br>
<hr>
<A name=319></a>Advanced Bash-Scripting Guide<br>
<b>Example 16-62. Converting meters to miles</b><br>
#!/bin/bash<br>
# unit-conversion.sh<br>
convert_units () &nbsp;# Takes as arguments the units to convert.<br>
{<br>
&nbsp; cf=$(units &quot;$1&quot; &quot;$2&quot; | sed --silent -e '1p' | awk '{print $2}')<br>
&nbsp; # Strip off everything except the actual conversion factor.<br>
&nbsp; echo &quot;$cf&quot;<br>
} &nbsp;<br>
Unit1=miles<br>
Unit2=meters<br>
cfactor=`convert_units $Unit1 $Unit2`<br>
quantity=3.73<br>
result=$(echo $quantity*$cfactor | bc)<br>
echo &quot;There are $result $Unit2 in $quantity $Unit1.&quot;<br>
# &nbsp;What happens if you pass incompatible units,<br>
#+ such as &quot;acres&quot; and &quot;miles&quot; to the function?<br>
exit 0<br>
<b>m4</b><br>
A hidden treasure,<b>&nbsp;m4</b>&nbsp;is a powerful macro&nbsp;[84] processing filter, virtually a complete language.<br>Although originally written as a pre-processor for<i>&nbsp;RatFor</i>,<b>&nbsp;m4</b>&nbsp;turned out to be useful as a stand-alone<br>utility. In fact,<b>&nbsp;m4</b><a href="abs-guides.html#199">&nbsp;combines some of the functionality of eval, tr, and awk, in addition to its extensive<br></a>macro expansion facilities.<br>
The April, 2002 issue of&nbsp;<a href="http://www.linuxjournal.com"><i>Linux Journal</i></a>&nbsp;has a very nice article on<b>&nbsp;m4</b>&nbsp;and its uses.<br>
<b>Example 16-63. Using<i>&nbsp;m4</i></b><br>
#!/bin/bash<br>
# m4.sh: Using the m4 macro processor<br>
# Strings<br>
string=abcdA01<br>
echo &quot;len($string)&quot; | m4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; 7<br>
echo &quot;substr($string,4)&quot; | m4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # A01<br>
echo &quot;regexp($string,[0-1][0-1],\&amp;Z)&quot; | m4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 01Z<br>
# Arithmetic<br>
var=99<br>
echo &quot;incr($var)&quot; | m4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;100<br>
echo &quot;eval($var / 3)&quot; | m4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;33<br>
exit<br>
<b>xmessage</b><br>
<a href="abs-guides.html#187">This X-based variant of echo pops up a message/query window on the desktop.</a><br>
xmessage Left click to continue -button okay<br>
<b>zenity</b><br>
Chapter 16. External Filters, Programs and Commands<br>
313<br>
<hr>
<A name=320></a><IMG src="abs-guide-320_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="http://freshmeat.net/projects/zenity">The zenity utility is adept at displaying</a><i>&nbsp;GTK+</i><a href="abs-guides.html#535">&nbsp;dialog widgets and very suitable for scripting purposes.</a><br>
<b>doexec</b><br>
The<b>&nbsp;doexec</b>&nbsp;command enables passing an arbitrary list of arguments to a<i>&nbsp;binary executable</i>. In<br>particular, passing&nbsp;<i>argv[0]</i><a href="abs-guides.html#42">&nbsp;(which corresponds to $0 in a script) lets the executable be invoked by<br></a>various names, and it can then carry out different sets of actions, according to the name by which it<br>was called. What this amounts to is roundabout way of passing options to an executable.<br>
For example, the&nbsp;/usr/local/bin&nbsp;directory might contain a binary called &quot;aaa&quot;. Invoking<b>&nbsp;doexec<br>/usr/local/bin/aaa list</b>&nbsp;would<i>&nbsp;list</i>&nbsp;all those files in the current working directory beginning with an &quot;a&quot;,<br>while invoking (the same executable with)<b>&nbsp;doexec /usr/local/bin/aaa delete</b>&nbsp;would<i>&nbsp;delete</i>&nbsp;those files.<br>
The various behaviors of the executable must be defined within the code of the<br>executable itself, analogous to something like the following in a shell script:<br>
case `basename $0` in<br>
&quot;name1&quot; ) do_something;;<br>
&quot;name2&quot; ) do_something_else;;<br>
&quot;name3&quot; ) do_yet_another_thing;;<br>
* &nbsp; &nbsp; &nbsp; ) bail_out;;<br>
esac<br>
<b>dialog</b><br>
<a href="abs-guides.html#536">The dialog family of tools provide a method of calling interactive &quot;dialog&quot; boxes from a script. The<br></a>more elaborate variations of<b>&nbsp;dialog</b>&nbsp;--<b>&nbsp;gdialog</b>,<b>&nbsp;Xdialog</b>, and<b>&nbsp;kdialog</b>&nbsp;-- actually invoke X-Windows<br><a href="abs-guides.html#535">widgets.</a><br>
<b>sox</b><br>
The<b>&nbsp;sox</b>, or &quot;<b>so</b>und e<b>x</b>change&quot; command plays and performs transformations on sound files. In fact,<br>the&nbsp;/usr/bin/play&nbsp;executable (now deprecated) is nothing but a shell wrapper for<i>&nbsp;sox</i>.<br>
For example,<b>&nbsp;sox soundfile.wav soundfile.au</b>&nbsp;changes a WAV sound file into a (Sun audio format)<br>AU sound file.<br>
Shell scripts are ideally suited for batch-processing<b>&nbsp;sox</b>&nbsp;operations on sound files. For examples, see<br><a href="http://osl.iu.edu/~tveldhui/radio/">the &nbsp;Linux Radio Timeshift HOWTO and the MP3do Project.</a><br>
Chapter 16. External Filters, Programs and Commands<br>
314<br>
<hr>
<A name=321></a><IMG src="abs-guide-321_1.png"><br>
<b>Chapter 17. System and Administrative Commands</b><br>
The startup and shutdown scripts in&nbsp;/etc/rc.d&nbsp;illustrate the uses (and usefulness) of many of these<br>comands. These are usually invoked by<i>&nbsp;root</i>&nbsp;and used for system maintenance or emergency filesystem<br>repairs. Use with caution, as some of these commands may damage your system if misused.<br>
<b>Users and Groups</b><br>
<b>users</b><br>
Show all logged on users. This is the approximate equivalent of<b>&nbsp;who -q</b>.<br>
<b>groups</b><br>
<a href="abs-guides.html#93">Lists the current user and the groups she belongs to. This corresponds to the $GROUPS internal<br></a>variable, but gives the group names, rather than the numbers.<br>
bash$&nbsp;<b>groups<br></b>bozita cdrom cdwriter audio xgrp<br>
bash$&nbsp;<b>echo $GROUPS<br></b>501<br>
<b>chown</b>,&nbsp;<b>chgrp</b><br>
The<b>&nbsp;chown</b>&nbsp;command changes the ownership of a file or files. This command is a useful method that<br><i>root</i>&nbsp;can use to shift file ownership from one user to another. An ordinary user may not change the<br>ownership of files, not even her own files.&nbsp;[85]<br>
root#&nbsp;<b>chown bozo *.txt</b><br>
The<b>&nbsp;chgrp</b>&nbsp;command changes the&nbsp;<i>group</i>&nbsp;ownership of a file or files. You must be owner of the<br>file(s) as well as a member of the destination group (or<i>&nbsp;root</i>) to use this operation.<br>
chgrp --recursive dunderheads *.data<br>
# &nbsp;The &quot;dunderheads&quot; group will now own all the &quot;*.data&quot; files<br>
#+ all the way down the $PWD directory tree (that's what &quot;recursive&quot; means).<br>
<b>useradd</b>,<b>&nbsp;userdel</b><br>
The<b>&nbsp;useradd</b>&nbsp;administrative command adds a user account to the system and creates a home directory<br>for that particular user, if so specified. The corresponding<b>&nbsp;userdel</b>&nbsp;command removes a user account<br>from the system&nbsp;[86] and deletes associated files.<br>
The<b>&nbsp;adduser</b>&nbsp;command is a synonym for<b>&nbsp;useradd</b>&nbsp;and is usually a symbolic link to it.<br>
<b>usermod</b><br>
Modify a user account. Changes may be made to the password, group membership, expiration date,<br>and other attributes of a given user's account. With this command, a user's password may be locked,<br>which has the effect of disabling the account.<br>
<b>groupmod</b><br>
Modify a given group. The group name and/or ID number may be changed using this command.<br>
<b>id</b><br>
The<b>&nbsp;id</b>&nbsp;command lists the real and effective user IDs and the group IDs of the user associated with the<br><a href="abs-guides.html#103">current process. This is the counterpart to the $UID, $EUID, and $GROUPS internal Bash variables.</a><br>
bash$&nbsp;<b>id<br></b>uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)<br>
Chapter 17. System and Administrative Commands<br>
315<br>
<hr>
<A name=322></a><IMG src="abs-guide-322_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>echo $UID<br></b>501<br>
The<b>&nbsp;id</b>&nbsp;command shows the<i>&nbsp;effective</i>&nbsp;IDs only when they differ from the<i>&nbsp;real</i>&nbsp;ones.<br>
<a href="abs-guides.html#103">Also see Example 9-5.</a><br>
<b>lid</b><br>
The<i>&nbsp;lid</i>&nbsp;(list ID) command shows the group(s) that a given user belongs to, or alternately, the users<br>belonging to a given group. May be invoked only by root.<br>
root#&nbsp;<b>lid bozo</b><br>
bozo(gid=500)<br>
root#&nbsp;<b>lid daemon</b><br>
bin(gid=1)<br>
&nbsp; daemon(gid=2)<br>
&nbsp; adm(gid=4)<br>
&nbsp; lp(gid=7)<br>
<b>who</b><br>
Show all users logged on to the system.<br>
bash$&nbsp;<b>who<br></b>bozo &nbsp;tty1 &nbsp; &nbsp; Apr 27 17:45<br>
&nbsp;bozo &nbsp;pts/0 &nbsp; &nbsp;Apr 27 17:46<br>
&nbsp;bozo &nbsp;pts/1 &nbsp; &nbsp;Apr 27 17:47<br>
&nbsp;bozo &nbsp;pts/2 &nbsp; &nbsp;Apr 27 17:49<br>
The&nbsp;-m&nbsp;gives detailed information about only the current user. Passing any two arguments to<b>&nbsp;who</b>&nbsp;is<br>the equivalent of<b>&nbsp;who -m</b>, as in<b>&nbsp;who am i</b>&nbsp;or<b>&nbsp;who The Man</b>.<br>
bash$&nbsp;<b>who -m<br></b>localhost.localdomain!bozo &nbsp;pts/2 &nbsp; &nbsp;Apr 27 17:49<br>
<b>whoami</b>&nbsp;is similar to<b>&nbsp;who -m</b>, but only lists the user name.<br>
bash$&nbsp;<b>whoami<br></b>bozo<br>
<b>w</b><br>
Show all logged on users and the processes belonging to them. This is an extended version of<b>&nbsp;who</b>.<br>The output of<b>&nbsp;w</b><a href="abs-guides.html#246">&nbsp;may be piped to grep to find a specific user and/or process.</a><br>
bash$&nbsp;<b>w | grep startx<br></b>bozo &nbsp;tty1 &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4:22pm &nbsp;6:41 &nbsp; 4.47s &nbsp;0.45s &nbsp;startx<br>
<b>logname</b><br>
Show current user's login name (as found in&nbsp;/var/run/utmp). This is a near-equivalent to<br><a href="abs-guides.html#322">whoami, above.</a><br>
bash$&nbsp;<b>logname<br></b>bozo<br>
bash$&nbsp;<b>whoami<br></b>bozo<br>
Chapter 17. System and Administrative Commands<br>
316<br>
<hr>
<A name=323></a><IMG src="abs-guide-323_1.png"><br>
Advanced Bash-Scripting Guide<br>
However . . .<br>
bash$&nbsp;<b>su<br></b>Password: ......<br>
bash#&nbsp;<b>whoami<br></b>root<br>
bash#&nbsp;<b>logname<br></b>bozo<br>
While<b>&nbsp;logname</b>&nbsp;prints the name of the logged in user,<b>&nbsp;whoami</b>&nbsp;gives the name of the<br>user attached to the current process. As we have just seen, sometimes these are not the<br>same.<br>
<b>su</b><br>
Runs a program or script as a<b>&nbsp;s</b>ubstitute<b>&nbsp;u</b>ser.<b>&nbsp;su rjones</b>&nbsp;starts a shell as user<i>&nbsp;rjones</i>. A naked<b>&nbsp;su<br></b>defaults to<i>&nbsp;root</i><a href="abs-guides.html#591">. See Example A-14.</a><br>
<b>sudo</b><br>
Runs a command as<i>&nbsp;root</i>&nbsp;(or another user). This may be used in a script, thus permitting a<i>&nbsp;regular<br>user</i>&nbsp;to run the script.<br>
#!/bin/bash<br>
# Some commands.<br>
sudo cp /root/secretfile /home/bozo/secret<br>
# Some more commands.<br>
The file&nbsp;/etc/sudoers&nbsp;holds the names of users permitted to invoke<b>&nbsp;sudo</b>.<br>
<b>passwd</b><br>
Sets, changes, or manages a user's password.<br>
The<b>&nbsp;passwd</b>&nbsp;command can be used in a script, but probably<i>&nbsp;should not</i>&nbsp;be.<br>
<b>Example 17-1. Setting a new password</b><br>
#!/bin/bash<br>
# &nbsp;setnew-password.sh: For demonstration purposes only.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Not a good idea to actually run this script.<br>
# &nbsp;This script must be run as root.<br>
ROOT_UID=0 &nbsp; &nbsp; &nbsp; &nbsp; # Root has $UID 0.<br>
E_WRONG_USER=65 &nbsp; &nbsp;# Not root?<br>
E_NOSUCHUSER=70<br>
SUCCESS=0<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo; echo &quot;Only root can run this script.&quot;; echo<br>
&nbsp; exit $E_WRONG_USER<br>
else<br>
&nbsp; echo<br>
&nbsp; echo &quot;You should know better than to run this script, root.&quot;<br>
&nbsp; echo &quot;Even root users get the blues... &quot;<br>
&nbsp; echo<br>
fi &nbsp;<br>
Chapter 17. System and Administrative Commands<br>
317<br>
<hr>
<A name=324></a><IMG src="abs-guide-324_1.png"><br>
Advanced Bash-Scripting Guide<br>
username=bozo<br>
NEWPASSWORD=security_violation<br>
# Check if bozo lives here.<br>
grep -q &quot;$username&quot; /etc/passwd<br>
if [ $? -ne $SUCCESS ]<br>
then<br>
&nbsp; echo &quot;User $username does not exist.&quot;<br>
&nbsp; echo &quot;No password changed.&quot;<br>
&nbsp; exit $E_NOSUCHUSER<br>
fi &nbsp;<br>
echo &quot;$NEWPASSWORD&quot; | passwd --stdin &quot;$username&quot;<br>
# &nbsp;The '--stdin' option to 'passwd' permits<br>
#+ getting a new password from stdin (or a pipe).<br>
echo; echo &quot;User $username's password changed!&quot;<br>
# Using the 'passwd' command in a script is dangerous.<br>
exit 0<br>
The<b>&nbsp;passwd</b>&nbsp;command's&nbsp;-l,&nbsp;-u, and&nbsp;-d&nbsp;options permit locking, unlocking, and deleting a user's<br>password. Only<i>&nbsp;root</i>&nbsp;may use these options.<br>
<b>ac</b><br>
Show users' logged in time, as read from&nbsp;/var/log/wtmp. This is one of the GNU accounting<br>utilities.<br>
bash$&nbsp;<b>ac</b><br>
&nbsp; &nbsp; &nbsp; &nbsp;total &nbsp; &nbsp; &nbsp; 68.08<br>
<b>last</b><br>
List<i>&nbsp;last</i>&nbsp;logged in users, as read from&nbsp;/var/log/wtmp. This command can also show remote<br>logins.<br>
For example, to show the last few times the system rebooted:<br>
bash$&nbsp;<b>last reboot<br></b>reboot &nbsp; system boot &nbsp;2.6.9-1.667 &nbsp; &nbsp; &nbsp;Fri Feb &nbsp;4 18:18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(00:02) &nbsp; &nbsp;<br>
&nbsp;reboot &nbsp; system boot &nbsp;2.6.9-1.667 &nbsp; &nbsp; &nbsp;Fri Feb &nbsp;4 15:20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(01:27) &nbsp; &nbsp;<br>
&nbsp;reboot &nbsp; system boot &nbsp;2.6.9-1.667 &nbsp; &nbsp; &nbsp;Fri Feb &nbsp;4 12:56 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(00:49) &nbsp; &nbsp;<br>
&nbsp;reboot &nbsp; system boot &nbsp;2.6.9-1.667 &nbsp; &nbsp; &nbsp;Thu Feb &nbsp;3 21:08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(02:17) &nbsp; &nbsp;<br>
&nbsp;. . .<br>
&nbsp;wtmp begins Tue Feb &nbsp;1 12:50:09 2005<br>
<b>newgrp</b><br>
Change user's<i>&nbsp;group ID</i>&nbsp;without logging out. This permits access to the new group's files. Since users<br>may be members of multiple groups simultaneously, this command finds only limited use.<br>
Kurt Glaesemann points out that the<i>&nbsp;newgrp</i>&nbsp;command could prove helpful in setting<br><a href="abs-guides.html#321">the default group permissions for files a user writes. However, the chgrp command<br></a>might be more convenient for this purpose.<br>
<b>Terminals</b><br>
<b>tty</b><br>
Chapter 17. System and Administrative Commands<br>
318<br>
<hr>
<A name=325></a>Advanced Bash-Scripting Guide<br>
Echoes the name (filename) of the current user's terminal. Note that each separate<i>&nbsp;xterm</i>&nbsp;window<br>counts as a different terminal.<br>
bash$&nbsp;<b>tty<br></b>/dev/pts/1<br>
<b>stty</b><br>
Shows and/or changes terminal settings. This complex command, used in a script, can control<br>terminal behavior and the way output displays. See the info page, and study it carefully.<br>
<b>Example 17-2. Setting an<i>&nbsp;erase</i></b><b>&nbsp;character</b><br>
#!/bin/bash<br>
# erase.sh: Using &quot;stty&quot; to set an erase character when reading input.<br>
echo -n &quot;What is your name? &quot;<br>
read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Try to backspace<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to erase characters of input.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Problems?<br>
echo &quot;Your name is $name.&quot;<br>
stty erase '#' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Set &quot;hashmark&quot; (#) as erase character.<br>
echo -n &quot;What is your name? &quot;<br>
read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Use # to erase last character typed.<br>
echo &quot;Your name is $name.&quot;<br>
exit 0<br>
# Even after the script exits, the new key value remains set.<br>
# Exercise: How would you reset the erase character to the default value?<br>
<b>Example 17-3.<i>&nbsp;secret password</i></b><b>: Turning off terminal echoing</b><br>
#!/bin/bash<br>
# secret-pw.sh: secret password<br>
echo<br>
echo -n &quot;Enter password &quot;<br>
read passwd<br>
echo &quot;password is $passwd&quot;<br>
echo -n &quot;If someone had been looking over your shoulder, &quot;<br>
echo &quot;your password would have been compromised.&quot;<br>
echo &amp;&amp; echo &nbsp;# Two line-feeds in an &quot;and list.&quot;<br>
stty -echo &nbsp; &nbsp;# Turns off screen echo.<br>
echo -n &quot;Enter password again &quot;<br>
read passwd<br>
echo<br>
echo &quot;password is $passwd&quot;<br>
echo<br>
stty echo &nbsp; &nbsp; # Restores screen echo.<br>
exit 0<br>
# Do an 'info stty' for more on this useful-but-tricky command.<br>
Chapter 17. System and Administrative Commands<br>
319<br>
<hr>
<A name=326></a>Advanced Bash-Scripting Guide<br>
A creative use of<b>&nbsp;stty</b>&nbsp;is detecting a user keypress (without hitting<b>&nbsp;ENTER</b>).<br>
<b>Example 17-4. Keypress detection</b><br>
#!/bin/bash<br>
# keypress.sh: Detect a user keypress (&quot;hot keys&quot;).<br>
echo<br>
old_tty_settings=$(stty -g) &nbsp; # Save old settings (why?).<br>
stty -icanon<br>
Keypress=$(head -c1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# or $(dd bs=1 count=1 2&gt; /dev/null)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # on non-GNU systems<br>
echo<br>
echo &quot;Key pressed was \&quot;&quot;$Keypress&quot;\&quot;.&quot;<br>
echo<br>
stty &quot;$old_tty_settings&quot; &nbsp; &nbsp; &nbsp;# Restore old settings.<br>
# Thanks, Stephane Chazelas.<br>
exit 0<br>
<a href="abs-guides.html#101">Also see Example 9-3 and Example A-43.</a><br>
<b>terminals and modes</b><br>
Normally, a terminal works in the<i>&nbsp;canonical</i>&nbsp;mode. When a user hits a key, the resulting character does<br>not immediately go to the program actually running in this terminal. A buffer local to the terminal stores<br>keystrokes. When the user hits the<b>&nbsp;ENTER</b>&nbsp;key, this sends all the stored keystrokes to the program<br>running. There is even a basic line editor inside the terminal.<br>
bash$&nbsp;<b>stty -a<br></b>speed 9600 baud; rows 36; columns 96; line = 0;<br>
&nbsp;intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;<br>
&nbsp;start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;<br>
&nbsp;...<br>
&nbsp;isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt<br>
Using canonical mode, it is possible to redefine the special keys for the local terminal line editor.<br>
bash$&nbsp;<b>cat &gt; filexxx<br>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;<br>&lt;ctl-D&gt;<br></b>bash$&nbsp;<b>cat filexxx<br></b>hello world<br>
bash$&nbsp;<b>wc -c &lt; filexxx<br></b>12<br>
The process controlling the terminal receives only 12 characters (11 alphabetic ones, plus a newline),<br>although the user hit 26 keys.<br>
Chapter 17. System and Administrative Commands<br>
320<br>
<hr>
<A name=327></a><IMG src="abs-guide-327_1.png"><br>
Advanced Bash-Scripting Guide<br>
In non-canonical (&quot;raw&quot;) mode, every key hit (including special editing keys such as<b>&nbsp;ctl-H</b>) sends a<br>character immediately to the controlling process.<br>
The Bash prompt disables both&nbsp;icanon&nbsp;and&nbsp;echo, since it replaces the basic terminal line editor with its<br>own more elaborate one. For example, when you hit<b>&nbsp;ctl-A</b>&nbsp;at the Bash prompt, there's no<b>&nbsp;^A</b>&nbsp;echoed by<br>the terminal, but Bash gets a<b>&nbsp;\1</b>&nbsp;character, interprets it, and moves the cursor to the begining of the line.<br>
<i>Stéphane Chazelas</i><br>
<b>setterm</b><br>
Set certain terminal attributes. This command writes to its terminal's&nbsp;stdout&nbsp;a string that changes<br>the behavior of that terminal.<br>
bash$&nbsp;<b>setterm -cursor off<br></b>bash$<br>
The<b>&nbsp;setterm</b>&nbsp;command can be used within a script to change the appearance of text written to<br>stdout<a href="abs-guides.html#511">, although there are certainly better tools available for this purpose.</a><br>
setterm -bold on<br>
echo bold hello<br>
setterm -bold off<br>
echo normal hello<br>
<b>tset</b><br>
Show or initialize terminal settings. This is a less capable version of<b>&nbsp;stty</b>.<br>
bash$&nbsp;<b>tset -r<br></b>Terminal type is xterm-xfree86.<br>
&nbsp;Kill is control-U (^U).<br>
&nbsp;Interrupt is control-C (^C).<br>
<b>setserial</b><br>
Set or display serial port parameters. This command must be run by<i>&nbsp;root</i>&nbsp;and is usually found in a<br>system setup script.<br>
# From /etc/pcmcia/serial script:<br>
IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`<br>
setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ<br>
<b>getty</b>,&nbsp;<b>agetty</b><br>
The initialization process for a terminal uses<b>&nbsp;getty</b>&nbsp;or<b>&nbsp;agetty</b>&nbsp;to set it up for login by a user. These<br>commands are not used within user shell scripts. Their scripting counterpart is<b>&nbsp;stty</b>.<br>
<b>mesg</b><br>
Enables or disables write access to the current user's terminal. Disabling access would prevent another<br><a href="abs-guides.html#293">user on the network to write to the terminal.</a><br>
It can be quite annoying to have a message about ordering pizza suddenly appear in<br>the middle of the text file you are editing. On a multi-user network, you might<br>therefore wish to disable write access to your terminal when you need to avoid<br>interruptions.<br>
<b>wall</b><br>
Chapter 17. System and Administrative Commands<br>
321<br>
<hr>
<A name=328></a><IMG src="abs-guide-328_1.png"><br>
Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#293">This is an acronym for &quot;write all,&quot; i.e., sending a message to all users at every terminal logged into the<br></a>network. It is primarily a system administrator's tool, useful, for example, when warning everyone<br><a href="abs-guides.html#360">that the system will shortly go down due to a problem (see Example 19-1).</a><br>
bash$&nbsp;<b>wall System going down for maintenance in 5 minutes!<br></b>Broadcast message from bozo (pts/1) Sun Jul &nbsp;8 13:53:27 2001...<br>
&nbsp;System going down for maintenance in 5 minutes!<br>
If write access to a particular terminal has been disabled with<b>&nbsp;mesg</b>, then<b>&nbsp;wall</b>&nbsp;cannot<br>send a message to that terminal.<br>
<b>Information and Statistics</b><br>
<b>uname</b><br>
Output system specifications (OS, kernel version, etc.) to&nbsp;stdout. Invoked with the&nbsp;-a&nbsp;option, gives<br><a href="abs-guides.html#230">verbose system info (see Example 16-5). The&nbsp;</a>-s&nbsp;option shows only the OS type.<br>
bash$&nbsp;<b>uname<br></b>Linux<br>
bash$&nbsp;<b>uname -s<br></b>Linux<br>
bash$&nbsp;<b>uname -a<br></b>Linux iron.bozo 2.6.15-1.2054_FC5 #1 Tue Mar 14 15:48:33 EST 2006<br>
&nbsp;i686 i686 i386 GNU/Linux<br>
<b>arch</b><br>
Show system architecture. Equivalent to<b>&nbsp;uname -m</b><a href="abs-guides.html#165">. See Example 11-26.</a><br>
bash$&nbsp;<b>arch<br></b>i686<br>
bash$&nbsp;<b>uname -m<br></b>i686<br>
<b>lastcomm</b><br>
Gives information about previous commands, as stored in the&nbsp;/var/account/pacct&nbsp;file.<br>Command name and user name can be specified by options. This is one of the GNU accounting<br>utilities.<br>
<b>lastlog</b><br>
List the last login time of all system users. This references the&nbsp;/var/log/lastlog&nbsp;file.<br>
bash$&nbsp;<b>lastlog<br></b>root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tty1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fri Dec &nbsp;7 18:43:21 -0700 2001<br>
&nbsp;bin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **Never logged in**<br>
&nbsp;daemon &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;**Never logged in**<br>
&nbsp;...<br>
&nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tty1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sat Dec &nbsp;8 21:14:29 -0700 2001<br>
bash$&nbsp;<b>lastlog | grep root<br></b>root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tty1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fri Dec &nbsp;7 18:43:21 -0700 2001<br>
Chapter 17. System and Administrative Commands<br>
322<br>
<hr>
<A name=329></a><IMG src="abs-guide-329_1.png"><br>
Advanced Bash-Scripting Guide<br>
This command will fail if the user invoking it does not have read permission for the<br>/var/log/lastlog&nbsp;file.<br>
<b>lsof</b><br>
List open files. This command outputs a detailed table of all currently open files and gives<br>information about their owner, size, the processes associated with them, and more. Of course,<b>&nbsp;lsof<br></b><a href="abs-guides.html#246">may be piped to grep and/or awk to parse and analyze its results.</a><br>
bash$&nbsp;<b>lsof<br></b>COMMAND &nbsp; &nbsp;PID &nbsp; &nbsp;USER &nbsp; FD &nbsp; TYPE &nbsp; &nbsp; DEVICE &nbsp; &nbsp;SIZE &nbsp; &nbsp; NODE NAME<br>
&nbsp;init &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp;root &nbsp;mem &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp;3,5 &nbsp; 30748 &nbsp; &nbsp;30303 /sbin/init<br>
&nbsp;init &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp;root &nbsp;mem &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp;3,5 &nbsp; 73120 &nbsp; &nbsp; 8069 /lib/ld-2.1.3.so<br>
&nbsp;init &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp;root &nbsp;mem &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp;3,5 &nbsp;931668 &nbsp; &nbsp; 8075 /lib/libc-2.1.3.so<br>
&nbsp;cardmgr &nbsp; &nbsp;213 &nbsp; &nbsp;root &nbsp;mem &nbsp; &nbsp;REG &nbsp; &nbsp; &nbsp; &nbsp;3,5 &nbsp; 36956 &nbsp; &nbsp;30357 /sbin/cardmgr<br>
&nbsp;...<br>
The<b>&nbsp;lsof</b>&nbsp;command is a useful, if complex administrative tool. If you are unable to dismount a<br>filesystem and get an error message that it is still in use, then running<i>&nbsp;lsof</i>&nbsp;helps determine which files<br>are still open on that filesystem. The&nbsp;-i&nbsp;option lists open network socket files, and this can help trace<br>intrusion or hack attempts.<br>
bash$&nbsp;<b>lsof -an -i tcp<br></b>COMMAND &nbsp;PID USER &nbsp;FD &nbsp;TYPE DEVICE SIZE NODE NAME<br>
&nbsp;firefox 2330 bozo &nbsp;32u IPv4 &nbsp; 9956 &nbsp; &nbsp; &nbsp; TCP 66.0.118.137:57596-&gt;67.112.7.104:http ...<br>
&nbsp;firefox 2330 bozo &nbsp;38u IPv4 &nbsp;10535 &nbsp; &nbsp; &nbsp; TCP 66.0.118.137:57708-&gt;216.79.48.24:http ...<br>
<a href="abs-guides.html#470">See Example 30-2 for an effective use of</a><b>&nbsp;lsof</b>.<br>
<b>strace</b><br>
<b>S</b>ystem<b>&nbsp;trace</b>: diagnostic and debugging tool for tracing<i>&nbsp;system calls</i>&nbsp;and signals. This command and<br><b>ltrace</b>, following, are useful for diagnosing why a given program or package fails to run . . . perhaps<br>due to missing libraries or related causes.<br>
bash$&nbsp;<b>strace df<br></b>execve(&quot;/bin/df&quot;, [&quot;df&quot;], [/* 45 vars */]) = 0<br>
&nbsp;uname({sys=&quot;Linux&quot;, node=&quot;bozo.localdomain&quot;, ...}) = 0<br>
&nbsp;brk(0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 0x804f5e4<br>
&nbsp;...<br>
This is the Linux equivalent of the Solaris<b>&nbsp;truss</b>&nbsp;command.<br>
<b>ltrace</b><br>
<b>L</b>ibrary<b>&nbsp;trace</b>: diagnostic and debugging tool that traces<i>&nbsp;library calls</i>&nbsp;invoked by a given command.<br>
bash$&nbsp;<b>ltrace df<br></b>__libc_start_main(0x804a910, 1, 0xbfb589a4, 0x804fb70, 0x804fb68 &lt;unfinished ...&gt;:<br>
&nbsp;setlocale(6, &quot;&quot;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = &quot;en_US.UTF-8&quot;<br>
bindtextdomain(&quot;coreutils&quot;, &quot;/usr/share/locale&quot;) = &quot;/usr/share/locale&quot;<br>
textdomain(&quot;coreutils&quot;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= &quot;coreutils&quot;<br>
__cxa_atexit(0x804b650, 0, 0, 0x8052bf0, 0xbfb58908) = 0<br>
getenv(&quot;DF_BLOCK_SIZE&quot;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= NULL<br>
&nbsp;...<br>
<b>nc</b><br>
The<b>&nbsp;nc</b>&nbsp;(<i>netcat</i>) utility is a complete toolkit for connecting to and listening to TCP and UDP ports. It is<br>useful as a diagnostic and testing tool and as a component in simple script-based HTTP clients and<br>
Chapter 17. System and Administrative Commands<br>
323<br>
<hr>
<A name=330></a>Advanced Bash-Scripting Guide<br>
servers.<br>
bash$&nbsp;<b>nc localhost.localdomain 25<br></b>220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1;<br>
&nbsp;Thu, 31 Mar 2005 15:41:35 -0700<br>
<a href="abs-guides.html#395">A real-life usage example.</a><br>
<b>Example 17-5. Checking a remote server for<i>&nbsp;identd</i></b><br>
#! /bin/sh<br>
## Duplicate DaveG's ident-scan thingie using netcat. Oooh, he'll be p*ssed.<br>
## Args: target port [port port port ...]<br>
## Hose stdout _and_ stderr together.<br>
##<br>
## &nbsp;Advantages: runs slower than ident-scan, giving remote inetd less cause<br>
##+ for alarm, and only hits the few known daemon ports you specify.<br>
## &nbsp;Disadvantages: requires numeric-only port args, the output sleazitude,<br>
##+ and won't work for r-services when coming from high source ports.<br>
# Script author: Hobbit &lt;hobbit@avian.org&gt;<br>
# Used in ABS Guide with permission.<br>
# ---------------------------------------------------<br>
E_BADARGS=65 &nbsp; &nbsp; &nbsp; # Need at least two args.<br>
TWO_WINKS=2 &nbsp; &nbsp; &nbsp; &nbsp;# How long to sleep.<br>
THREE_WINKS=3<br>
IDPORT=113 &nbsp; &nbsp; &nbsp; &nbsp; # Authentication &quot;tap ident&quot; port.<br>
RAND1=999<br>
RAND2=31337<br>
TIMEOUT0=9<br>
TIMEOUT1=8<br>
TIMEOUT2=4<br>
# ---------------------------------------------------<br>
case &quot;${2}&quot; in<br>
&nbsp; &quot;&quot; ) echo &quot;Need HOST and at least one PORT.&quot; ; exit $E_BADARGS ;;<br>
esac<br>
# Ping 'em once and see if they *are* running identd.<br>
nc -z -w $TIMEOUT0 &quot;$1&quot; $IDPORT || \<br>
{ echo &quot;Oops, $1 isn't running identd.&quot; ; exit 0 ; }<br>
# &nbsp;-z scans for listening daemons.<br>
# &nbsp; &nbsp; -w $TIMEOUT = How long to try to connect.<br>
# Generate a randomish base port.<br>
RP=`expr $$ % $RAND1 + $RAND2`<br>
TRG=&quot;$1&quot;<br>
shift<br>
while test &quot;$1&quot; ; do<br>
&nbsp; nc -v -w $TIMEOUT1 -p ${RP} &quot;$TRG&quot; ${1} &lt; /dev/null &gt; /dev/null &amp;<br>
&nbsp; PROC=$!<br>
&nbsp; sleep $THREE_WINKS<br>
&nbsp; echo &quot;${1},${RP}&quot; | nc -w $TIMEOUT2 -r &quot;$TRG&quot; $IDPORT 2&gt;&amp;1<br>
&nbsp; sleep $TWO_WINKS<br>
# Does this look like a lamer script or what . . . ?<br>
# ABS Guide author comments: &quot;Ain't really all that bad . . .<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kinda clever, actually.&quot;<br>
Chapter 17. System and Administrative Commands<br>
324<br>
<hr>
<A name=331></a>Advanced Bash-Scripting Guide<br>
&nbsp; kill -HUP $PROC<br>
&nbsp; RP=`expr ${RP} + 1`<br>
&nbsp; shift<br>
done<br>
exit $?<br>
# &nbsp;Notes:<br>
# &nbsp;-----<br>
# &nbsp;Try commenting out line 30 and running this script<br>
#+ with &quot;localhost.localdomain 25&quot; as arguments.<br>
# &nbsp;For more of Hobbit's 'nc' example scripts,<br>
#+ look in the documentation:<br>
#+ the /usr/share/doc/nc-X.XX/scripts directory.<br>
And, of course, there's Dr. Andrew Tridgell's notorious one-line script in the BitKeeper Affair:<br>
echo clone | nc thunk.org 5000 &gt; e2fsprogs.dat<br>
<b>free</b><br>
Shows memory and cache usage in tabular form. The output of this command lends itself to parsing,<br><a href="abs-guides.html#246">using grep, awk or</a><b>&nbsp;Perl</b>. The<b>&nbsp;procinfo</b>&nbsp;command shows all the information that<b>&nbsp;free</b>&nbsp;does, and much<br>more.<br>
bash$&nbsp;<b>free</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;total &nbsp; &nbsp; &nbsp; used &nbsp; &nbsp; &nbsp; free &nbsp; &nbsp; shared &nbsp; &nbsp;buffers &nbsp; &nbsp; cached<br>
&nbsp; &nbsp;Mem: &nbsp; &nbsp; &nbsp; &nbsp; 30504 &nbsp; &nbsp; &nbsp;28624 &nbsp; &nbsp; &nbsp; 1880 &nbsp; &nbsp; &nbsp;15820 &nbsp; &nbsp; &nbsp; 1608 &nbsp; &nbsp; &nbsp; 16376<br>
&nbsp; &nbsp;-/+ buffers/cache: &nbsp; &nbsp; &nbsp;10640 &nbsp; &nbsp; &nbsp;19864<br>
&nbsp; &nbsp;Swap: &nbsp; &nbsp; &nbsp; &nbsp;68540 &nbsp; &nbsp; &nbsp; 3128 &nbsp; &nbsp; &nbsp;65412<br>
To show unused RAM memory:<br>
bash$&nbsp;<b>free | grep Mem | awk '{ print $4 }'<br></b>1880<br>
<b>procinfo</b><br>
Extract and list information and statistics from the&nbsp;<a href="abs-guides.html#460">/proc&nbsp;pseudo-filesystem. This gives a very<br></a>extensive and detailed listing.<br>
bash$&nbsp;<b>procinfo | grep Bootup<br></b>Bootup: Wed Mar 21 15:15:50 2001 &nbsp; &nbsp;Load average: 0.04 0.21 0.34 3/47 6829<br>
<b>lsdev</b><br>
List devices, that is, show installed hardware.<br>
bash$&nbsp;<b>lsdev<br></b>Device &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DMA &nbsp; IRQ &nbsp;I/O Ports<br>
&nbsp;------------------------------------------------<br>
&nbsp;cascade &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 2&nbsp;<br>
&nbsp;dma &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0080-008f<br>
&nbsp;dma1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0000-001f<br>
&nbsp;dma2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00c0-00df<br>
&nbsp;fpu &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;00f0-00ff<br>
&nbsp;ide0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14 &nbsp;01f0-01f7 03f6-03f6<br>
&nbsp;...<br>
<b>du</b><br>
Show (disk) file usage, recursively. Defaults to current working directory, unless otherwise specified.<br>
Chapter 17. System and Administrative Commands<br>
325<br>
<hr>
<A name=332></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>du -ach<br></b>1.0k &nbsp; &nbsp;./wi.sh<br>
&nbsp;1.0k &nbsp; &nbsp;./tst.sh<br>
&nbsp;1.0k &nbsp; &nbsp;./random.file<br>
&nbsp;6.0k &nbsp; &nbsp;.<br>
&nbsp;6.0k &nbsp; &nbsp;total<br>
<b>df</b><br>
Shows filesystem usage in tabular form.<br>
bash$&nbsp;<b>df<br></b>Filesystem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1k-blocks &nbsp; &nbsp; &nbsp;Used Available Use% Mounted on<br>
&nbsp;/dev/hda5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 273262 &nbsp; &nbsp; 92607 &nbsp; &nbsp;166547 &nbsp;36% /<br>
&nbsp;/dev/hda8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 222525 &nbsp; &nbsp;123951 &nbsp; &nbsp; 87085 &nbsp;59% /home<br>
&nbsp;/dev/hda7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1408796 &nbsp; 1075744 &nbsp; &nbsp;261488 &nbsp;80% /usr<br>
<b>dmesg</b><br>
Lists all system bootup messages to&nbsp;stdout. Handy for debugging and ascertaining which device<br>drivers were installed and which system interrupts in use. The output of<b>&nbsp;dmesg</b>&nbsp;may, of course, be<br><a href="abs-guides.html#246">parsed with grep, sed, or awk from within a script.</a><br>
bash$&nbsp;<b>dmesg | grep hda<br></b>Kernel command line: ro root=/dev/hda2<br>
&nbsp;hda: IBM-DLGA-23080, ATA DISK drive<br>
&nbsp;hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63<br>
&nbsp;hda: hda1 hda2 hda3 &lt; hda5 hda6 hda7 &gt; hda4<br>
<b>stat</b><br>
Gives detailed and verbose<i>&nbsp;stat</i>istics on a given file (even a directory or device file) or set of files.<br>
bash$&nbsp;<b>stat test.cru</b><br>
&nbsp;File: &quot;test.cru&quot;<br>
&nbsp; &nbsp;Size: 49970 &nbsp; &nbsp; &nbsp; &nbsp;Allocated Blocks: 100 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filetype: Regular File<br>
&nbsp; &nbsp;Mode: (0664/-rw-rw-r--) &nbsp; &nbsp; &nbsp; &nbsp; Uid: ( &nbsp;501/ bozo) &nbsp;Gid: ( &nbsp;501/ bozo)<br>
&nbsp;Device: &nbsp;3,8 &nbsp; Inode: 18185 &nbsp; &nbsp; Links: 1 &nbsp; &nbsp;<br>
&nbsp;Access: Sat Jun &nbsp;2 16:40:24 2001<br>
&nbsp;Modify: Sat Jun &nbsp;2 16:40:24 2001<br>
&nbsp;Change: Sat Jun &nbsp;2 16:40:24 2001<br>
If the target file does not exist,<b>&nbsp;stat</b>&nbsp;returns an error message.<br>
bash$&nbsp;<b>stat nonexistent-file<br></b>nonexistent-file: No such file or directory<br>
In a script, you can use<b>&nbsp;stat</b>&nbsp;to extract information about files (and filesystems) and set variables<br>accordingly.<br>
#!/bin/bash<br>
# fileinfo2.sh<br>
# Per suggestion of Joël Bourquard and . . .<br>
# http://www.linuxquestions.org/questions/showthread.php?t=410766<br>
FILENAME=testfile.txt<br>
file_name=$(stat -c%n &quot;$FILENAME&quot;) &nbsp; # Same as &quot;$FILENAME&quot; of course.<br>
file_owner=$(stat -c%U &quot;$FILENAME&quot;)<br>
file_size=$(stat -c%s &quot;$FILENAME&quot;)<br>
# &nbsp;Certainly easier than using &quot;ls -l $FILENAME&quot;<br>
Chapter 17. System and Administrative Commands<br>
326<br>
<hr>
<A name=333></a><IMG src="abs-guide-333_1.png"><br>
Advanced Bash-Scripting Guide<br>
#+ and then parsing with sed.<br>
file_inode=$(stat -c%i &quot;$FILENAME&quot;)<br>
file_type=$(stat -c%F &quot;$FILENAME&quot;)<br>
file_access_rights=$(stat -c%A &quot;$FILENAME&quot;)<br>
echo &quot;File name: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$file_name&quot;<br>
echo &quot;File owner: &nbsp; &nbsp; &nbsp; &nbsp; $file_owner&quot;<br>
echo &quot;File size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$file_size&quot;<br>
echo &quot;File inode: &nbsp; &nbsp; &nbsp; &nbsp; $file_inode&quot;<br>
echo &quot;File type: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$file_type&quot;<br>
echo &quot;File access rights: $file_access_rights&quot;<br>
exit 0<br>
sh fileinfo2.sh<br>
File name: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;testfile.txt<br>
File owner: &nbsp; &nbsp; &nbsp; &nbsp; bozo<br>
File size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;418<br>
File inode: &nbsp; &nbsp; &nbsp; &nbsp; 1730378<br>
File type: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;regular file<br>
File access rights: -rw-rw-r--<br>
<b>vmstat</b><br>
Display virtual memory statistics.<br>
bash$&nbsp;<b>vmstat</b><br>
&nbsp; procs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memory &nbsp; &nbsp;swap &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;io system &nbsp; &nbsp; &nbsp; &nbsp; cpu<br>
&nbsp;r &nbsp;b &nbsp;w &nbsp; swpd &nbsp; free &nbsp; buff &nbsp;cache &nbsp;si &nbsp;so &nbsp; &nbsp;bi &nbsp; &nbsp;bo &nbsp; in &nbsp; &nbsp;cs &nbsp;us &nbsp;sy id<br>
&nbsp;0 &nbsp;0 &nbsp;0 &nbsp; &nbsp; &nbsp;0 &nbsp;11040 &nbsp; 2636 &nbsp;38952 &nbsp; 0 &nbsp; 0 &nbsp; &nbsp;33 &nbsp; &nbsp; 7 &nbsp;271 &nbsp; &nbsp;88 &nbsp; 8 &nbsp; 3 89<br>
<b>uptime</b><br>
Shows how long the system has been running, along with associated statistics.<br>
bash$&nbsp;<b>uptime<br></b>10:28pm &nbsp;up &nbsp;1:57, &nbsp;3 users, &nbsp;load average: 0.17, 0.34, 0.27<br>
A<i>&nbsp;load average</i>&nbsp;of 1 or less indicates that the system handles processes immediately. A<br>load average greater than 1 means that processes are being queued. When the load<br>average gets above 3 (on a single-core processor), then system performance is<br>significantly degraded.<br>
<b>hostname</b><br>
Lists the system's host name. This command sets the host name in an&nbsp;/etc/rc.d&nbsp;setup script<br>(/etc/rc.d/rc.sysinit&nbsp;or similar). It is equivalent to<b>&nbsp;uname -n</b>, and a counterpart to the<br><a href="abs-guides.html#93">$HOSTNAME internal variable.</a><br>
bash$&nbsp;<b>hostname<br></b>localhost.localdomain<br>
bash$&nbsp;<b>echo $HOSTNAME<br></b>localhost.localdomain<br>
Similar to the<b>&nbsp;hostname</b>&nbsp;command are the<b>&nbsp;domainname</b>,<b>&nbsp;dnsdomainname</b>,<b>&nbsp;nisdomainname</b>, and<br><b>ypdomainname</b>&nbsp;commands. Use these to display or set the system DNS or NIS/YP domain name.<br>Various options to<b>&nbsp;hostname</b>&nbsp;also perform these functions.<br>
<b>hostid</b><br>
Echo a 32-bit hexadecimal numerical identifier for the host machine.<br>
Chapter 17. System and Administrative Commands<br>
327<br>
<hr>
<A name=334></a><IMG src="abs-guide-334_1.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>hostid<br></b>7f0100<br>
This command allegedly fetches a &quot;unique&quot; serial number for a particular system.<br>Certain product registration procedures use this number to brand a particular user<br>license. Unfortunately,<b>&nbsp;hostid</b>&nbsp;only returns the machine network address in<br>hexadecimal, with pairs of bytes transposed.<br>
The network address of a typical non-networked Linux machine, is found in<br>/etc/hosts.<br>
bash$&nbsp;<b>cat /etc/hosts<br></b>127.0.0.1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localhost.localdomain localhost<br>
As it happens, transposing the bytes of&nbsp;<b>127.0.0.1</b>, we get&nbsp;<b>0.127.1.0</b>, which<br>translates in hex to&nbsp;<b>007f0100</b>, the exact equivalent of what<b>&nbsp;hostid</b>&nbsp;returns, above.<br>There exist only a few million other Linux machines with this identical<i>&nbsp;hostid</i>.<br>
<b>sar</b><br>
Invoking<b>&nbsp;sar</b>&nbsp;(System Activity Reporter) gives a very detailed rundown on system statistics. The<br>Santa Cruz Operation (&quot;Old&quot; SCO) released<b>&nbsp;sar</b>&nbsp;as Open Source in June, 1999.<br>
<a href="http://perso.wanadoo.fr/sebastien.godard/">This command is not part of the base Linux distribution, but may be obtained as part of the sysstat<br>utilities package, written by Sebastien Godard.</a><br>
bash$&nbsp;<b>sar<br></b>Linux 2.4.9 (brooks.seringas.fr) &nbsp; &nbsp; &nbsp; &nbsp;09/26/03<br>
10:30:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CPU &nbsp; &nbsp; %user &nbsp; &nbsp; %nice &nbsp; %system &nbsp; %iowait &nbsp; &nbsp; %idle<br>
10:40:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;2.21 &nbsp; &nbsp; 10.90 &nbsp; &nbsp; 65.48 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 21.41<br>
10:50:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;3.36 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 72.36 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 24.28<br>
11:00:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;1.12 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 80.77 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 18.11<br>
Average: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;2.23 &nbsp; &nbsp; &nbsp;3.63 &nbsp; &nbsp; 72.87 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 21.27<br>
14:32:30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LINUX RESTART<br>
15:00:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CPU &nbsp; &nbsp; %user &nbsp; &nbsp; %nice &nbsp; %system &nbsp; %iowait &nbsp; &nbsp; %idle<br>
15:10:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;8.59 &nbsp; &nbsp; &nbsp;2.40 &nbsp; &nbsp; 17.47 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 71.54<br>
15:20:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;4.07 &nbsp; &nbsp; &nbsp;1.00 &nbsp; &nbsp; 11.95 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 82.98<br>
15:30:00 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;0.79 &nbsp; &nbsp; &nbsp;2.94 &nbsp; &nbsp; &nbsp;7.56 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 88.71<br>
Average: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;all &nbsp; &nbsp; &nbsp;6.33 &nbsp; &nbsp; &nbsp;1.70 &nbsp; &nbsp; 14.71 &nbsp; &nbsp; &nbsp;0.00 &nbsp; &nbsp; 77.26<br>
<b>readelf</b><br>
Show information and statistics about a designated<i>&nbsp;elf</i>&nbsp;binary. This is part of the<i>&nbsp;binutils</i>&nbsp;package.<br>
bash$&nbsp;<b>readelf -h /bin/bash<br></b>ELF Header:<br>
&nbsp; &nbsp;Magic: &nbsp; 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00&nbsp;<br>
&nbsp; &nbsp;Class: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ELF32<br>
&nbsp; &nbsp;Data: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2's complement, little endian<br>
&nbsp; &nbsp;Version: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 (current)<br>
&nbsp; &nbsp;OS/ABI: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UNIX - System V<br>
&nbsp; &nbsp;ABI Version: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br>
&nbsp; &nbsp;Type: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXEC (Executable file)<br>
&nbsp; &nbsp;. . .<br>
<b>size</b><br>
Chapter 17. System and Administrative Commands<br>
328<br>
<hr>
<A name=335></a><IMG src="abs-guide-335_1.png"><br>
Advanced Bash-Scripting Guide<br>
The<b>&nbsp;size [/path/to/binary]</b>&nbsp;command gives the segment sizes of a binary executable or archive file.<br>This is mainly of use to programmers.<br>
bash$&nbsp;<b>size /bin/bash</b><br>
&nbsp; text &nbsp; &nbsp;data &nbsp; &nbsp; bss &nbsp; &nbsp; dec &nbsp; &nbsp; hex filename<br>
&nbsp; 495971 &nbsp; 22496 &nbsp; 17392 &nbsp;535859 &nbsp; 82d33 /bin/bash<br>
<b>System Logs</b><br>
<b>logger</b><br>
Appends a user-generated message to the system log (/var/log/messages). You do not have to<br>be<i>&nbsp;root</i>&nbsp;to invoke<b>&nbsp;logger</b>.<br>
logger Experiencing instability in network connection at 23:10, 05/21.<br>
# Now, do a 'tail /var/log/messages'.<br>
By embedding a<b>&nbsp;logger</b>&nbsp;command in a script, it is possible to write debugging information to<br>/var/log/messages.<br>
logger -t $0 -i Logging at line &quot;$LINENO&quot;.<br>
# The &quot;-t&quot; option specifies the tag for the logger entry.<br>
# The &quot;-i&quot; option records the process ID.<br>
# tail /var/log/message<br>
# ...<br>
# Jul &nbsp;7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.<br>
<b>logrotate</b><br>
This utility manages the system log files, rotating, compressing, deleting, and/or e-mailing them, as<br>appropriate. This keeps the&nbsp;/var/log<a href="abs-guides.html#338">&nbsp;from getting cluttered with old log files. Usually cron runs<br></a><b>logrotate</b>&nbsp;on a daily basis.<br>
Adding an appropriate entry to&nbsp;/etc/logrotate.conf&nbsp;makes it possible to manage personal log<br>files, as well as system-wide ones.<br>
<a href="http://www.gnu.org/software/rottlog/">Stefano Falsetto has created rottlog, which he considers to be an improved version of<br></a><b>logrotate</b>.<br>
<b>Job Control</b><br>
<b>ps</b><br>
<i>P</i>rocess&nbsp;<i>S</i>tatistics: lists currently executing processes by owner and PID (process ID). This is usually<br>invoked with&nbsp;ax&nbsp;or&nbsp;aux<a href="abs-guides.html#246">&nbsp;options, and may be piped to grep or sed to search for a specific process (see<br></a><a href="abs-guides.html#202">Example 15-14 and Example 29-3).</a><br>
bash$&nbsp;<b>&nbsp;ps ax | grep sendmail<br></b>295 ? &nbsp; &nbsp; &nbsp;S &nbsp; &nbsp; &nbsp;0:00 sendmail: accepting connections on port 25<br>
To display system processes in graphical &quot;tree&quot; format:<b>&nbsp;ps afjx</b>&nbsp;or<b>&nbsp;ps ax --forest</b>.<br>
<b>pgrep</b>,&nbsp;<b>pkill</b><br>
Combining the<b>&nbsp;ps</b><a href="abs-guides.html#246">&nbsp;command with grep or kill.</a><br>
bash$&nbsp;<b>ps a | grep mingetty<br></b>2212 tty2 &nbsp; &nbsp; Ss+ &nbsp; &nbsp;0:00 /sbin/mingetty tty2<br>
&nbsp;2213 tty3 &nbsp; &nbsp; Ss+ &nbsp; &nbsp;0:00 /sbin/mingetty tty3<br>
Chapter 17. System and Administrative Commands<br>
329<br>
<hr>
<A name=336></a>Advanced Bash-Scripting Guide<br>
&nbsp;2214 tty4 &nbsp; &nbsp; Ss+ &nbsp; &nbsp;0:00 /sbin/mingetty tty4<br>
&nbsp;2215 tty5 &nbsp; &nbsp; Ss+ &nbsp; &nbsp;0:00 /sbin/mingetty tty5<br>
&nbsp;2216 tty6 &nbsp; &nbsp; Ss+ &nbsp; &nbsp;0:00 /sbin/mingetty tty6<br>
&nbsp;4849 pts/2 &nbsp; &nbsp;S+ &nbsp; &nbsp; 0:00 grep mingetty<br>
bash$&nbsp;<b>pgrep mingetty<br></b>2212 mingetty<br>
&nbsp;2213 mingetty<br>
&nbsp;2214 mingetty<br>
&nbsp;2215 mingetty<br>
&nbsp;2216 mingetty<br>
Compare the action of<b>&nbsp;pkill</b><a href="abs-guides.html#218">&nbsp;with killall.</a><br>
<b>pstree</b><br>
Lists currently executing processes in &quot;tree&quot; format. The&nbsp;-p&nbsp;option shows the PIDs, as well as the<br>process names.<br>
<b>top</b><br>
Continuously updated display of most cpu-intensive processes. The&nbsp;-b&nbsp;option displays in text mode,<br>so that the output may be parsed or accessed from a script.<br>
bash$&nbsp;<b>top -b</b><br>
&nbsp;8:30pm &nbsp;up 3 min, &nbsp;3 users, &nbsp;load average: 0.49, 0.32, 0.13<br>
&nbsp;45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped<br>
&nbsp;CPU states: 13.6% user, &nbsp;7.3% system, &nbsp;0.0% nice, 78.9% idle<br>
&nbsp;Mem: &nbsp; &nbsp;78396K av, &nbsp; 65468K used, &nbsp; 12928K free, &nbsp; &nbsp; &nbsp; 0K shrd, &nbsp; &nbsp;2352K buff<br>
&nbsp;Swap: &nbsp;157208K av, &nbsp; &nbsp; &nbsp; 0K used, &nbsp;157208K free &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 37244K cached<br>
&nbsp; &nbsp;PID USER &nbsp; &nbsp; PRI &nbsp;NI &nbsp;SIZE &nbsp;RSS SHARE STAT %CPU %MEM &nbsp; TIME COMMAND<br>
&nbsp; &nbsp;848 bozo &nbsp; &nbsp; &nbsp;17 &nbsp; 0 &nbsp; 996 &nbsp;996 &nbsp; 800 R &nbsp; &nbsp; 5.6 &nbsp;1.2 &nbsp; 0:00 top<br>
&nbsp; &nbsp; &nbsp;1 root &nbsp; &nbsp; &nbsp; 8 &nbsp; 0 &nbsp; 512 &nbsp;512 &nbsp; 444 S &nbsp; &nbsp; 0.0 &nbsp;0.6 &nbsp; 0:04 init<br>
&nbsp; &nbsp; &nbsp;2 root &nbsp; &nbsp; &nbsp; 9 &nbsp; 0 &nbsp; &nbsp; 0 &nbsp; &nbsp;0 &nbsp; &nbsp; 0 SW &nbsp; &nbsp;0.0 &nbsp;0.0 &nbsp; 0:00 keventd<br>
&nbsp; &nbsp;...<br>
<b>nice</b><br>
Run a background job with an altered priority. Priorities run from 19 (lowest) to -20 (highest). Only<br><i>root</i>&nbsp;may set the negative (higher) priorities. Related commands are<b>&nbsp;renice</b>&nbsp;and<b>&nbsp;snice</b>, which change<br>the priority of a running process or processes, and<b>&nbsp;skill</b><a href="abs-guides.html#217">, which sends a kill signal to a process or<br></a>processes.<br>
<b>nohup</b><br>
Keeps a command running even after user logs off. The command will run as a foreground process<br>unless followed by &amp;. If you use<b>&nbsp;nohup</b><a href="abs-guides.html#216">&nbsp;within a script, consider coupling it with a wait to avoid<br></a>creating an<i>&nbsp;orphan</i><a href="abs-guides.html#218">&nbsp;or zombie process.</a><br>
<b>pidof</b><br>
Identifies<i>&nbsp;process ID (PID)</i><a href="abs-guides.html#217">&nbsp;of a running job. Since job control commands, such as kill and renice act<br></a>on the<i>&nbsp;PID</i>&nbsp;of a process (not its name), it is sometimes necessary to identify that<i>&nbsp;PID</i>. The<b>&nbsp;pidof<br></b><a href="abs-guides.html#98">command is the approximate counterpart to the $PPID internal variable.</a><br>
bash$&nbsp;<b>pidof xclock<br></b>880<br>
<b>Example 17-6.<i>&nbsp;pidof</i></b><b>&nbsp;helps kill a process</b><br>
Chapter 17. System and Administrative Commands<br>
330<br>
<hr>
<A name=337></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# kill-process.sh<br>
NOPROCESS=2<br>
process=xxxyyyzzz &nbsp;# Use nonexistent process.<br>
# For demo purposes only...<br>
# ... don't want to actually kill any actual process with this script.<br>
#<br>
# If, for example, you wanted to use this script to logoff the Internet,<br>
# &nbsp; &nbsp; process=pppd<br>
t=`pidof $process` &nbsp; &nbsp; &nbsp; # Find pid (process id) of $process.<br>
# The pid is needed by 'kill' (can't 'kill' by program name).<br>
if [ -z &quot;$t&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If process not present, 'pidof' returns null.<br>
then<br>
&nbsp; echo &quot;Process $process was not running.&quot;<br>
&nbsp; echo &quot;Nothing killed.&quot;<br>
&nbsp; exit $NOPROCESS<br>
fi &nbsp;<br>
kill $t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# May need 'kill -9' for stubborn process.<br>
# Need a check here to see if process allowed itself to be killed.<br>
# Perhaps another &quot; t=`pidof $process` &quot; or ...<br>
# This entire script could be replaced by<br>
# &nbsp; &nbsp; &nbsp; &nbsp;kill $(pidof -x process_name)<br>
# or<br>
# &nbsp; &nbsp; &nbsp; &nbsp;killall process_name<br>
# but it would not be as instructive.<br>
exit 0<br>
<b>fuser</b><br>
Identifies the processes (by PID) that are accessing a given file, set of files, or directory. May also be<br>invoked with the&nbsp;-k&nbsp;option, which kills those processes. This has interesting implications for system<br>security, especially in scripts preventing unauthorized users from accessing system services.<br>
bash$&nbsp;<b>fuser -u /usr/bin/vim<br></b>/usr/bin/vim: &nbsp; &nbsp; &nbsp; &nbsp; 3207e(bozo)<br>
bash$&nbsp;<b>fuser -u /dev/null<br></b>/dev/null: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3009(bozo) &nbsp;3010(bozo) &nbsp;3197(bozo) &nbsp;3199(bozo)<br>
One important application for<b>&nbsp;fuser</b>&nbsp;is when physically inserting or removing storage media, such as<br><a href="abs-guides.html#342">CD ROM disks or USB flash drives. Sometimes trying a umount fails with a device is busy error<br></a>message. This means that some user(s) and/or process(es) are accessing the device. An<b>&nbsp;fuser -um<br>/dev/device_name</b>&nbsp;will clear up the mystery, so you can kill any relevant processes.<br>
bash$&nbsp;<b>umount /mnt/usbdrive<br></b>umount: /mnt/usbdrive: device is busy<br>
bash$&nbsp;<b>fuser -um /dev/usbdrive</b><br>
Chapter 17. System and Administrative Commands<br>
331<br>
<hr>
<A name=338></a><IMG src="abs-guide-338_1.png"><br>
<IMG src="abs-guide-338_2.png"><br>
Advanced Bash-Scripting Guide<br>
/mnt/usbdrive: &nbsp; &nbsp; &nbsp; &nbsp;1772c(bozo)<br>
bash$&nbsp;<b>kill -9 1772<br></b>bash$&nbsp;<b>umount /mnt/usbdrive</b><br>
The<b>&nbsp;fuser</b>&nbsp;command, invoked with the&nbsp;-n&nbsp;option identifies the processes accessing a<i>&nbsp;port</i>. This is<br><a href="abs-guides.html#339">especially useful in combination with nmap.</a><br>
root#&nbsp;<b>nmap localhost.localdomain<br></b>PORT &nbsp; &nbsp; STATE SERVICE<br>
&nbsp;25/tcp &nbsp; open &nbsp;smtp<br>
root#&nbsp;<b>fuser -un tcp 25<br></b>25/tcp: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2095(root)<br>
root#&nbsp;<b>ps ax | grep 2095 | grep -v grep<br></b>2095 ? &nbsp; &nbsp; &nbsp; &nbsp;Ss &nbsp; &nbsp; 0:00 sendmail: accepting connections<br>
<b>cron</b><br>
Administrative program scheduler, performing such duties as cleaning up and deleting system log<br>files and updating the slocate database. This is the<i>&nbsp;superuser</i><a href="abs-guides.html#238">&nbsp;version of at (although each user may<br></a>have their own&nbsp;crontab&nbsp;file which can be changed with the<b>&nbsp;crontab</b><a href="abs-guides.html#886">&nbsp;command). It runs as a daemon<br></a>and executes scheduled entries from&nbsp;/etc/crontab.<br>
Some flavors of Linux run<b>&nbsp;crond</b>, Matthew Dillon's version of<b>&nbsp;cron</b>.<br>
<b>Process Control and Booting</b><br>
<b>init</b><br>
The<b>&nbsp;init</b><a href="abs-guides.html#186">&nbsp;command is the parent of all processes. Called in the final step of a bootup,</a><b>&nbsp;init</b>&nbsp;determines<br>the runlevel of the system from&nbsp;/etc/inittab. Invoked by its alias<b>&nbsp;telinit</b>, and by<i>&nbsp;root</i>&nbsp;only.<br>
<b>telinit</b><br>
Symlinked to<b>&nbsp;init</b>, this is a means of changing the system runlevel, usually done for system<br>maintenance or emergency filesystem repairs. Invoked only by<i>&nbsp;root</i>. This command can be dangerous<br>-- be certain you understand it well before using!<br>
<b>runlevel</b><br>
Shows the current and last runlevel, that is, whether the system is halted (runlevel&nbsp;0), in single-user<br>mode (1), in multi-user mode (2&nbsp;or&nbsp;3), in X Windows (5), or rebooting (6). This command accesses<br>the&nbsp;/var/run/utmp&nbsp;file.<br>
<b>halt</b>,&nbsp;<b>shutdown</b>,&nbsp;<b>reboot</b><br>
Command set to shut the system down, usually just prior to a power down.<br>
On some Linux distros, the<b>&nbsp;halt</b>&nbsp;command has 755 permissions, so it can be invoked<br>by a non-root user. A careless<i>&nbsp;halt</i>&nbsp;in a terminal or a script may shut down the system!<br>
<b>service</b><br>
Starts or stops a system<i>&nbsp;service</i>. The startup scripts in&nbsp;/etc/init.d&nbsp;and&nbsp;/etc/rc.d&nbsp;use this<br>command to start services at bootup.<br>
Chapter 17. System and Administrative Commands<br>
332<br>
<hr>
<A name=339></a>Advanced Bash-Scripting Guide<br>
root#&nbsp;<b>/sbin/service iptables stop<br></b>Flushing firewall rules: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ &nbsp;OK &nbsp;]<br>
&nbsp;Setting chains to policy ACCEPT: filter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[ &nbsp;OK &nbsp;]<br>
&nbsp;Unloading iptables modules: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[ &nbsp;OK &nbsp;]<br>
<b>Network</b><br>
<b>nmap</b><br>
<b>N</b>etwork<b>&nbsp;map</b>per and port scanner. This command scans a server to locate open ports and the services<br>associated with those ports. It can also report information about packet filters and firewalls. This is an<br>important security tool for locking down a network against hacking attempts.<br>
#!/bin/bash<br>
SERVER=$HOST &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # localhost.localdomain (127.0.0.1).<br>
PORT_NUMBER=25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # SMTP port.<br>
nmap $SERVER | grep -w &quot;$PORT_NUMBER&quot; &nbsp;# Is that particular port open?<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grep -w matches whole words only,<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so this wouldn't match port 1025, for example.<br>
exit 0<br>
# 25/tcp &nbsp; &nbsp; open &nbsp; &nbsp; &nbsp; &nbsp;smtp<br>
<b>ifconfig</b><br>
Network<i>&nbsp;interface configuration</i>&nbsp;and tuning utility.<br>
bash$&nbsp;<b>ifconfig -a<br></b>lo &nbsp; &nbsp; &nbsp; &nbsp;Link encap:Local Loopback<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inet addr:127.0.0.1 &nbsp;Mask:255.0.0.0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UP LOOPBACK RUNNING &nbsp;MTU:16436 &nbsp;Metric:1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RX packets:10 errors:0 dropped:0 overruns:0 frame:0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TX packets:10 errors:0 dropped:0 overruns:0 carrier:0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;collisions:0 txqueuelen:0&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RX bytes:700 (700.0 b) &nbsp;TX bytes:700 (700.0 b)<br>
The<b>&nbsp;ifconfig</b>&nbsp;command is most often used at bootup to set up the interfaces, or to shut them down<br>when rebooting.<br>
# Code snippets from /etc/rc.d/init.d/network<br>
# ...<br>
# Check that networking is up.<br>
[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0<br>
[ -x /sbin/ifconfig ] || exit 0<br>
# ...<br>
for i in $interfaces ; do<br>
&nbsp; if ifconfig $i 2&gt;/dev/null | grep -q &quot;UP&quot; &gt;/dev/null 2&gt;&amp;1 ; then<br>
&nbsp; &nbsp; action &quot;Shutting down interface $i: &quot; ./ifdown $i boot<br>
&nbsp; fi<br>
# &nbsp;The GNU-specific &quot;-q&quot; option to &quot;grep&quot; means &quot;quiet&quot;, i.e.,<br>
#+ producing no output.<br>
# &nbsp;Redirecting output to /dev/null is therefore not strictly necessary.<br>
Chapter 17. System and Administrative Commands<br>
333<br>
<hr>
<A name=340></a><IMG src="abs-guide-340_1.png"><br>
Advanced Bash-Scripting Guide<br>
# ...<br>
echo &quot;Currently active devices:&quot;<br>
echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^ &nbsp;should be quoted to prevent globbing.<br>
# &nbsp;The following also work.<br>
# &nbsp; &nbsp;echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'<br>
# &nbsp; &nbsp;echo $(/sbin/ifconfig | sed -e 's/ .*//')<br>
# &nbsp;Thanks, S.C., for additional comments.<br>
<a href="abs-guides.html#480">See also Example 32-6.</a><br>
<b>netstat</b><br>
Show current network statistics and information, such as routing tables and active connections. This<br>utility accesses information in&nbsp;/proc/net<a href="abs-guides.html#460">&nbsp;(Chapter 29). See Example 29-4.</a><br>
<b>netstat -r</b><a href="abs-guides.html#341">&nbsp;is equivalent to route.</a><br>
bash$&nbsp;<b>netstat<br></b>Active Internet connections (w/o servers)<br>
&nbsp;Proto Recv-Q Send-Q Local Address &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Foreign Address &nbsp; &nbsp; &nbsp; &nbsp; State &nbsp; &nbsp; &nbsp;<br>
&nbsp;Active UNIX domain sockets (w/o servers)<br>
&nbsp;Proto RefCnt Flags &nbsp; &nbsp; &nbsp; Type &nbsp; &nbsp; &nbsp; State &nbsp; &nbsp; &nbsp; &nbsp; I-Node Path<br>
&nbsp;unix &nbsp;11 &nbsp; &nbsp; [ ] &nbsp; &nbsp; &nbsp; &nbsp; DGRAM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;906 &nbsp; &nbsp;/dev/log<br>
&nbsp;unix &nbsp;3 &nbsp; &nbsp; &nbsp;[ ] &nbsp; &nbsp; &nbsp; &nbsp; STREAM &nbsp; &nbsp; CONNECTED &nbsp; &nbsp; 4514 &nbsp; /tmp/.X11-unix/X0<br>
&nbsp;unix &nbsp;3 &nbsp; &nbsp; &nbsp;[ ] &nbsp; &nbsp; &nbsp; &nbsp; STREAM &nbsp; &nbsp; CONNECTED &nbsp; &nbsp; 4513<br>
&nbsp;. . .<br>
A<b>&nbsp;netstat -lptu</b><a href="abs-guides.html#461">&nbsp;shows sockets that are listening to ports, and the associated processes.<br></a>This can be useful for determining whether a computer has been hacked or<br>compromised.<br>
<b>iwconfig</b><br>
This is the command set for configuring a wireless network. It is the wireless equivalent of<b>&nbsp;ifconfig</b>,<br>above.<br>
<b>ip</b><br>
General purpose utility for setting up, changing, and analyzing<i>&nbsp;IP</i>&nbsp;(Internet Protocol) networks and<br>attached devices. This command is part of the<i>&nbsp;iproute2</i>&nbsp;package.<br>
bash$&nbsp;<b>ip link show<br></b>1: lo: &lt;LOOPBACK,UP&gt; mtu 16436 qdisc noqueue&nbsp;<br>
&nbsp; &nbsp; &nbsp;link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>
&nbsp;2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast qlen 1000<br>
&nbsp; &nbsp; &nbsp;link/ether 00:d0:59:ce:af:da brd ff:ff:ff:ff:ff:ff<br>
&nbsp;3: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop&nbsp;<br>
&nbsp; &nbsp; &nbsp;link/sit 0.0.0.0 brd 0.0.0.0<br>
bash$&nbsp;<b>ip route list<br></b>169.254.0.0/16 dev lo &nbsp;scope link<br>
Or, in a script:<br>
#!/bin/bash<br>
# Script by Juan Nicolas Ruiz<br>
# Used with his kind permission.<br>
# Setting up (and stopping) a GRE tunnel.<br>
Chapter 17. System and Administrative Commands<br>
334<br>
<hr>
<A name=341></a>Advanced Bash-Scripting Guide<br>
# --- start-tunnel.sh ---<br>
LOCAL_IP=&quot;192.168.1.17&quot;<br>
REMOTE_IP=&quot;10.0.5.33&quot;<br>
OTHER_IFACE=&quot;192.168.0.100&quot;<br>
REMOTE_NET=&quot;192.168.3.0/24&quot;<br>
/sbin/ip tunnel add netb mode gre remote $REMOTE_IP \<br>
&nbsp; local $LOCAL_IP ttl 255<br>
/sbin/ip addr add $OTHER_IFACE dev netb<br>
/sbin/ip link set netb up<br>
/sbin/ip route add $REMOTE_NET dev netb<br>
exit 0 &nbsp;#############################################<br>
# --- stop-tunnel.sh ---<br>
REMOTE_NET=&quot;192.168.3.0/24&quot;<br>
/sbin/ip route del $REMOTE_NET dev netb<br>
/sbin/ip link set netb down<br>
/sbin/ip tunnel del netb<br>
exit 0<br>
<b>route</b><br>
Show info about or make changes to the kernel routing table.<br>
bash$&nbsp;<b>route<br></b>Destination &nbsp; &nbsp; Gateway &nbsp; &nbsp; &nbsp; &nbsp; Genmask &nbsp; &nbsp; &nbsp; &nbsp; Flags &nbsp; MSS Window &nbsp;irtt Iface<br>
&nbsp;pm3-67.bozosisp * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 255.255.255.255 UH &nbsp; &nbsp; &nbsp; 40 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 ppp0<br>
&nbsp;127.0.0.0 &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 255.0.0.0 &nbsp; &nbsp; &nbsp; U &nbsp; &nbsp; &nbsp; &nbsp;40 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 lo<br>
&nbsp;default &nbsp; &nbsp; &nbsp; &nbsp; pm3-67.bozosisp 0.0.0.0 &nbsp; &nbsp; &nbsp; &nbsp; UG &nbsp; &nbsp; &nbsp; 40 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 ppp0<br>
<b>iptables</b><br>
The<b>&nbsp;iptables</b>&nbsp;command set is a packet filtering tool used mainly for such security purposes as setting<br>up network firewalls. This is a complex tool, and a detailed explanation of its use is beyond the scope<br><a href="http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html">of this document. Oskar Andreasson's tutorial is a reasonable starting point.</a><br>
<a href="abs-guides.html#338">See also shutting down<i>&nbsp;iptables</i></a><a href="abs-guides.html#470">&nbsp;and Example 30-2.</a><br>
<b>chkconfig</b><br>
Check network and system configuration. This command lists and manages the network and system<br>services started at bootup in the&nbsp;/etc/rc?.d&nbsp;directory.<br>
Originally a port from IRIX to Red Hat Linux,<b>&nbsp;chkconfig</b>&nbsp;may not be part of the core installation of<br>some Linux flavors.<br>
bash$&nbsp;<b>chkconfig --list<br></b>atd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0:off &nbsp; 1:off &nbsp; 2:off &nbsp; 3:on &nbsp; &nbsp;4:on &nbsp; &nbsp;5:on &nbsp; &nbsp;6:off<br>
&nbsp;rwhod &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0:off &nbsp; 1:off &nbsp; 2:off &nbsp; 3:off &nbsp; 4:off &nbsp; 5:off &nbsp; 6:off<br>
&nbsp;...<br>
<b>tcpdump</b><br>
Network packet &quot;sniffer.&quot; This is a tool for analyzing and troubleshooting traffic on a network by<br>dumping packet headers that match specified criteria.<br>
Chapter 17. System and Administrative Commands<br>
335<br>
<hr>
<A name=342></a><IMG src="abs-guide-342_1.png"><br>
Advanced Bash-Scripting Guide<br>
Dump ip packet traffic between hosts<i>&nbsp;bozoville</i>&nbsp;and<i>&nbsp;caduceus</i>:<br>
bash$&nbsp;<b>tcpdump ip host bozoville and caduceus</b><br>
Of course, the output of<b>&nbsp;tcpdump</b><a href="abs-guides.html#240">&nbsp;can be parsed with certain of the previously discussed text<br>processing utilities.</a><br>
<b>Filesystem</b><br>
<b>mount</b><br>
Mount a filesystem, usually on an external device, such as a floppy or CDROM.&nbsp;The file<br>/etc/fstab&nbsp;provides a handy listing of available filesystems, partitions, and devices, including<br>options, that may be automatically or manually mounted. The file&nbsp;/etc/mtab&nbsp;shows the currently<br>mounted filesystems and partitions (including the virtual ones, such as&nbsp;/proc).<br>
<b>mount -a</b>&nbsp;mounts all filesystems and partitions listed in&nbsp;/etc/fstab, except those with a&nbsp;noauto<br>option. At bootup, a startup script in&nbsp;/etc/rc.d&nbsp;(rc.sysinit&nbsp;or something similar) invokes this<br>to get everything mounted.<br>
mount -t iso9660 /dev/cdrom /mnt/cdrom<br>
# Mounts CD ROM. ISO 9660 is a standard CD ROM filesystem.<br>
mount /mnt/cdrom<br>
# Shortcut, if /mnt/cdrom listed in /etc/fstab<br>
The versatile<i>&nbsp;mount</i>&nbsp;command can even mount an ordinary file on a block device, and the file will act<br>as if it were a filesystem.<i>&nbsp;Mount</i><a href="abs-guides.html#460">&nbsp;accomplishes that by associating the file with a loopback device. One<br></a>application of this is to mount and examine an ISO9660 filesystem image before burning it onto a<br>CDR.&nbsp;[87]<br>
<b>Example 17-7. Checking a CD image</b><br>
# As root...<br>
mkdir /mnt/cdtest &nbsp;# Prepare a mount point, if not already there.<br>
mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest &nbsp; # Mount the image.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;-o loop&quot; option equivalent to &quot;losetup /dev/loop0&quot;<br>
cd /mnt/cdtest &nbsp; &nbsp; # Now, check the image.<br>
ls -alR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# List the files in the directory tree there.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# And so forth.<br>
<b>umount</b><br>
Unmount a currently mounted filesystem. Before physically removing a previously mounted floppy or<br>CDROM disk, the device must be<b>&nbsp;umount</b>ed, else filesystem corruption may result.<br>
umount /mnt/cdrom<br>
# You may now press the eject button and safely remove the disk.<br>
The<b>&nbsp;automount</b>&nbsp;utility, if properly installed, can mount and unmount floppies or<br>CDROM disks as they are accessed or removed. On &quot;multispindle&quot; laptops with<br>swappable floppy and optical drives, this can cause problems, however.<br>
<b>gnome-mount</b><br>
Chapter 17. System and Administrative Commands<br>
336<br>
<hr>
<A name=343></a>Advanced Bash-Scripting Guide<br>
The newer Linux distros have deprecated<b>&nbsp;mount</b>&nbsp;and<b>&nbsp;umount</b>. The successor, for command-line<br>mounting of removable storage devices, is<b>&nbsp;gnome-mount</b>. It can take the&nbsp;-d<a href="abs-guides.html#460">&nbsp;option to mount a device<br>file by its listing in&nbsp;</a>/dev.<br>
For example, to mount a USB flash drive:<br>
bash$&nbsp;<b>gnome-mount -d /dev/sda1<br></b>gnome-mount 0.4<br>
bash$&nbsp;<b>df<br></b>. . .<br>
&nbsp;/dev/sda1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;63584 &nbsp; &nbsp; 12034 &nbsp; &nbsp; 51550 &nbsp;19% /media/disk<br>
<b>sync</b><br>
Forces an immediate write of all updated data from buffers to hard drive (synchronize drive with<br>buffers). While not strictly necessary, a<b>&nbsp;sync</b>&nbsp;assures the sys admin or user that the data just changed<br>will survive a sudden power failure. In the olden days, a&nbsp;<b>sync; sync</b>&nbsp;(twice, just to make<br>absolutely sure) was a useful precautionary measure before a system reboot.<br>
At times, you may wish to force an immediate buffer flush, as when securely deleting a file (see<br><a href="abs-guides.html#315">Example 16-60) or when the lights begin to flicker.</a><br>
<b>losetup</b><br>
<a href="abs-guides.html#460">Sets up and configures &nbsp;loopback devices.</a><br>
<b>Example 17-8. Creating a filesystem in a file</b><br>
SIZE=1000000 &nbsp;# 1 meg<br>
head -c $SIZE &lt; /dev/zero &gt; file &nbsp;# Set up file of designated size.<br>
losetup /dev/loop0 file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set it up as loopback device.<br>
mke2fs /dev/loop0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Create filesystem.<br>
mount -o loop /dev/loop0 /mnt &nbsp; &nbsp; # Mount it.<br>
# Thanks, S.C.<br>
<b>mkswap</b><br>
Creates a swap partition or file. The swap area must subsequently be enabled with<b>&nbsp;swapon</b>.<br>
<b>swapon</b>,&nbsp;<b>swapoff</b><br>
Enable / disable swap partitition or file. These commands usually take effect at bootup and shutdown.<br>
<b>mke2fs</b><br>
Create a Linux<i>&nbsp;ext2</i>&nbsp;filesystem. This command must be invoked as<i>&nbsp;root</i>.<br>
<b>Example 17-9. Adding a new hard drive</b><br>
#!/bin/bash<br>
# Adding a second hard drive to system.<br>
# Software configuration. Assumes hardware already mounted.<br>
# From an article by the author of the ABS Guide.<br>
# In issue #38 of _Linux Gazette_, http://www.linuxgazette.com.<br>
ROOT_UID=0 &nbsp; &nbsp; # This script must be run as root.<br>
E_NOTROOT=67 &nbsp; # Non-root exit error.<br>
Chapter 17. System and Administrative Commands<br>
337<br>
<hr>
<A name=344></a><IMG src="abs-guide-344_1.png"><br>
<IMG src="abs-guide-344_2.png"><br>
Advanced Bash-Scripting Guide<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo &quot;Must be root to run this script.&quot;<br>
&nbsp; exit $E_NOTROOT<br>
fi &nbsp;<br>
# Use with extreme caution!<br>
# If something goes wrong, you may wipe out your current filesystem.<br>
NEWDISK=/dev/hdb &nbsp; &nbsp; &nbsp; &nbsp; # Assumes /dev/hdb vacant. Check!<br>
MOUNTPOINT=/mnt/newdisk &nbsp;# Or choose another mount point.<br>
fdisk $NEWDISK<br>
mke2fs -cv $NEWDISK1 &nbsp; # Check for bad blocks (verbose output).<br>
# &nbsp;Note: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; /dev/hdb1, *not* /dev/hdb!<br>
mkdir $MOUNTPOINT<br>
chmod 777 $MOUNTPOINT &nbsp;# Makes new drive accessible to all users.<br>
# Now, test ...<br>
# mount -t ext2 /dev/hdb1 /mnt/newdisk<br>
# Try creating a directory.<br>
# If it works, umount it, and proceed.<br>
# Final step:<br>
# Add the following line to /etc/fstab.<br>
# /dev/hdb1 &nbsp;/mnt/newdisk &nbsp;ext2 &nbsp;defaults &nbsp;1 1<br>
exit<br>
<a href="abs-guides.html#343">See also Example 17-8 and Example 31-3.</a><br>
<b>tune2fs</b><br>
Tune<i>&nbsp;ext2</i>&nbsp;filesystem. May be used to change filesystem parameters, such as maximum mount count.<br>This must be invoked as<i>&nbsp;root</i>.<br>
This is an extremely dangerous command. Use it at your own risk, as you may<br>inadvertently destroy your filesystem.<br>
<b>dumpe2fs</b><br>
Dump (list to&nbsp;stdout) very verbose filesystem info. This must be invoked as<i>&nbsp;root</i>.<br>
root#&nbsp;<b>dumpe2fs /dev/hda7 | grep 'ount count'<br></b>dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09<br>
&nbsp;Mount count: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6<br>
&nbsp;Maximum mount count: &nbsp; &nbsp; &nbsp;20<br>
<b>hdparm</b><br>
List or change hard disk parameters. This command must be invoked as<i>&nbsp;root</i>, and it may be dangerous<br>if misused.<br>
<b>fdisk</b><br>
Create or change a partition table on a storage device, usually a hard drive. This command must be<br>invoked as<i>&nbsp;root</i>.<br>
Use this command with extreme caution. If something goes wrong, you may destroy<br>an existing filesystem.<br>
<b>fsck</b>,&nbsp;<b>e2fsck</b>,&nbsp;<b>debugfs</b><br>
Chapter 17. System and Administrative Commands<br>
338<br>
<hr>
<A name=345></a><IMG src="abs-guide-345_1.png"><br>
Advanced Bash-Scripting Guide<br>
Filesystem check, repair, and debug command set.<br>
<b>fsck</b>: a front end for checking a UNIX filesystem (may invoke other utilities). The actual filesystem<br>type generally defaults to<i>&nbsp;ext2</i>.<br>
<b>e2fsck</b>: ext2 filesystem checker.<br>
<b>debugfs</b>: ext2 filesystem debugger. One of the uses of this versatile, but dangerous command is to<br>(attempt to) recover deleted files. For advanced users only!<br>
All of these should be invoked as<i>&nbsp;root</i>, and they can damage or destroy a filesystem if<br>misused.<br>
<b>badblocks</b><br>
Checks for bad blocks (physical media flaws) on a storage device. This command finds use when<br>formatting a newly installed hard drive or testing the integrity of backup media.&nbsp;[88] As an example,<br><b>badblocks /dev/fd0</b>&nbsp;tests a floppy disk.<br>
The<b>&nbsp;badblocks</b>&nbsp;command may be invoked destructively (overwrite all data) or in non-destructive<br>read-only mode. If<i>&nbsp;root user</i>&nbsp;owns the device to be tested, as is generally the case, then<i>&nbsp;root</i>&nbsp;must<br>invoke this command.<br>
<b>lsusb</b>,<b>&nbsp;usbmodules</b><br>
The<b>&nbsp;lsusb</b>&nbsp;command lists all USB (Universal Serial Bus) buses and the devices hooked up to them.<br>
The<b>&nbsp;usbmodules</b>&nbsp;command outputs information about the driver modules for connected USB devices.<br>
bash$&nbsp;<b>lsusb<br></b>Bus 001 Device 001: ID 0000:0000 &nbsp;<br>
&nbsp;Device Descriptor:<br>
&nbsp; &nbsp;bLength &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18<br>
&nbsp; &nbsp;bDescriptorType &nbsp; &nbsp; &nbsp; &nbsp; 1<br>
&nbsp; &nbsp;bcdUSB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1.00<br>
&nbsp; &nbsp;bDeviceClass &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9 Hub<br>
&nbsp; &nbsp;bDeviceSubClass &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp;<br>
&nbsp; &nbsp;bDeviceProtocol &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp;<br>
&nbsp; &nbsp;bMaxPacketSize0 &nbsp; &nbsp; &nbsp; &nbsp; 8<br>
&nbsp; &nbsp;idVendor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0x0000&nbsp;<br>
&nbsp; &nbsp;idProduct &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0x0000<br>
&nbsp; &nbsp;. . .<br>
<b>lspci</b><br>
Lists<i>&nbsp;pci</i>&nbsp;busses present.<br>
bash$&nbsp;<b>lspci<br></b>00:00.0 Host bridge: Intel Corporation 82845 845<br>
&nbsp;(Brookdale) Chipset Host Bridge (rev 04)<br>
&nbsp;00:01.0 PCI bridge: Intel Corporation 82845 845<br>
&nbsp;(Brookdale) Chipset AGP Bridge (rev 04)<br>
&nbsp;00:1d.0 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #1) (rev 02)<br>
&nbsp;00:1d.1 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #2) (rev 02)<br>
&nbsp;00:1d.2 USB Controller: Intel Corporation 82801CA/CAM USB (Hub #3) (rev 02)<br>
&nbsp;00:1e.0 PCI bridge: Intel Corporation 82801 Mobile PCI Bridge (rev 42)<br>
&nbsp; &nbsp;. . .<br>
Chapter 17. System and Administrative Commands<br>
339<br>
<hr>
<A name=346></a><IMG src="abs-guide-346_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>mkbootdisk</b><br>
Creates a boot floppy which can be used to bring up the system if, for example, the MBR (master boot<br>record) becomes corrupted. Of special interest is the&nbsp;--iso&nbsp;option, which uses<b>&nbsp;mkisofs</b>&nbsp;to create a<br>bootable<i>&nbsp;ISO9660</i>&nbsp;filesystem image suitable for burning a bootable CDR.<br>
The<b>&nbsp;mkbootdisk</b>&nbsp;command is actually a Bash script, written by Erik Troan, in the&nbsp;/sbin&nbsp;directory.<br>
<b>mkisofs</b><br>
Creates an<i>&nbsp;ISO9660</i>&nbsp;filesystem suitable for a CDR image.<br>
<b>chroot</b><br>
<a href="abs-guides.html#96">CHange ROOT directory. Normally commands are fetched from $PATH, relative to&nbsp;</a>/, the default<br><i>root directory</i>. This changes the<i>&nbsp;root</i>&nbsp;directory to a different one (and also changes the working<br>directory to there). This is useful for security purposes, for instance when the system administrator<br><a href="abs-guides.html#287">wishes to restrict certain users, such as those telnetting in, to a secured portion of the filesystem (this<br></a>is sometimes referred to as confining a guest user to a &quot;chroot jail&quot;). Note that after a<b>&nbsp;chroot</b>, the<br>execution path for system binaries is no longer valid.<br>
A&nbsp;<b>chroot /opt</b>&nbsp;would cause references to&nbsp;/usr/bin&nbsp;to be translated to&nbsp;/opt/usr/bin.<br>Likewise,&nbsp;<b>chroot /aaa/bbb /bin/ls</b>&nbsp;would redirect future instances of<b>&nbsp;ls</b>&nbsp;to&nbsp;/aaa/bbb&nbsp;as<br>the base directory, rather than&nbsp;/&nbsp;as is normally the case. An<b>&nbsp;alias XX 'chroot /aaa/bbb ls'</b>&nbsp;in a user's<br><a href="abs-guides.html#804">~/.bashrc</a>&nbsp;effectively restricts which portion of the filesystem she may run command &quot;XX&quot; on.<br>
The<b>&nbsp;chroot</b>&nbsp;command is also handy when running from an emergency boot floppy (<b>chroot</b>&nbsp;to<br>/dev/fd0), or as an option to<b>&nbsp;lilo</b>&nbsp;when recovering from a system crash. Other uses include<br><a href="abs-guides.html#263">installation from a different filesystem (an rpm option) or running a readonly filesystem from a CD<br></a>ROM. Invoke only as<i>&nbsp;root</i>, and use with care.<br>
It might be necessary to copy certain system files to a<i>&nbsp;chrooted</i>&nbsp;directory, since the<br>normal&nbsp;$PATH&nbsp;can no longer be relied upon.<br>
<b>lockfile</b><br>
This utility is part of the<b>&nbsp;procmail</b><a href="http://www.procmail.org">&nbsp;package (www.procmail.org). It creates a</a><i>&nbsp;lock file</i>, a<i>&nbsp;semaphore<br></i>that controls access to a file, device, or resource.<br>
<b>Definition:</b>&nbsp;A<i>&nbsp;semaphore</i>&nbsp;is a flag or signal. (The usage originated in railroading, where a<br>colored flag, lantern, or striped movable arm<i>&nbsp;semaphore</i>&nbsp;indicated whether a particular track was in<br>use and therefore unavailable for another train.) A UNIX process can check the appropriate<br>semaphore to determine whether a particular resource is available/accessible.<br>
The lock file serves as a flag that this particular file, device, or resource is in use by a process (and is<br>therefore &quot;busy&quot;). The presence of a lock file permits only restricted access (or no access) to other<br>processes.<br>
lockfile /home/bozo/lockfiles/$0.lock<br>
# Creates a write-protected lockfile prefixed with the name of the script.<br>
lockfile /home/bozo/lockfiles/${0##*/}.lock<br>
# A safer version of the above, as pointed out by E. Choroba.<br>
Lock files are used in such applications as protecting system mail folders from simultaneously being<br>changed by multiple users, indicating that a modem port is being accessed, and showing that an<br>instance of Firefox is using its cache. Scripts may check for the existence of a lock file created by a<br>certain process to check if that process is running. Note that if a script attempts to create a lock file<br>that already exists, the script will likely hang.<br>
Chapter 17. System and Administrative Commands<br>
340<br>
<hr>
<A name=347></a><IMG src="abs-guide-347_1.png"><br>
<IMG src="abs-guide-347_2.png"><br>
Advanced Bash-Scripting Guide<br>
Normally, applications create and check for lock files in the&nbsp;/var/lock&nbsp;directory.&nbsp;[89] A script can<br>test for the presence of a lock file by something like the following.<br>
appname=xyzip<br>
# Application &quot;xyzip&quot; created lock file &quot;/var/lock/xyzip.lock&quot;.<br>
if [ -e &quot;/var/lock/$appname.lock&quot; ]<br>
then &nbsp; #+ Prevent other programs &amp; scripts<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;from accessing files/resources used by xyzip.<br>
&nbsp; ...<br>
<b>flock</b><br>
Much less useful than the<b>&nbsp;lockfile</b>&nbsp;command is<b>&nbsp;flock</b>. It sets an &quot;advisory&quot; lock on a file and then<br>executes a command while the lock is on. This is to prevent any other process from setting a lock on<br>that file until completion of the specified command.<br>
flock $0 cat $0 &gt; lockfile__$0<br>
# &nbsp;Set a lock on the script the above line appears in,<br>
#+ while listing the script to stdout.<br>
Unlike<b>&nbsp;lockfile</b>,<b>&nbsp;flock</b>&nbsp;does<i>&nbsp;not</i>&nbsp;automatically create a lock file.<br>
<b>mknod</b><br>
<a href="abs-guides.html#460">Creates block or character device files (may be necessary when installing new hardware on the<br></a>system). The<b>&nbsp;MAKEDEV</b>&nbsp;utility has virtually all of the functionality of<b>&nbsp;mknod</b>, and is easier to use.<br>
<b>MAKEDEV</b><br>
Utility for creating device files. It must be run as<i>&nbsp;root</i>, and in the&nbsp;/dev&nbsp;directory. It is a sort of<br>advanced version of<b>&nbsp;mknod</b>.<br>
<b>tmpwatch</b><br>
Automatically deletes files which have not been accessed within a specified period of time. Usually<br><a href="abs-guides.html#338">invoked by cron to remove stale log files.</a><br>
<b>Backup</b><br>
<b>dump</b>,&nbsp;<b>restore</b><br>
The<b>&nbsp;dump</b>&nbsp;command is an elaborate filesystem backup utility, generally used on larger installations<br>and networks.&nbsp;[90] It reads raw disk partitions and writes a backup file in a binary format. Files to be<br>backed up may be saved to a variety of storage media, including disks and tape drives. The<b>&nbsp;restore<br></b>command restores backups made with<b>&nbsp;dump</b>.<br>
<b>fdformat</b><br>
Perform a low-level format on a floppy disk (/dev/fd0*).<br>
<b>System Resources</b><br>
<b>ulimit</b><br>
Sets an<i>&nbsp;upper limit</i>&nbsp;on use of system resources. Usually invoked with the&nbsp;-f&nbsp;option, which sets a limit<br>on file size (<b>ulimit -f 1000</b>&nbsp;limits files to 1 meg maximum).&nbsp;[91] The&nbsp;-t&nbsp;option limits the coredump<br>size (<b>ulimit -c 0</b>&nbsp;eliminates coredumps). Normally, the value of<b>&nbsp;ulimit</b>&nbsp;would be set in<br>/etc/profile&nbsp;and/or&nbsp;~/.bash_profile<a href="abs-guides.html#793">&nbsp;(see Appendix G).</a><br>
Judicious use of<b>&nbsp;ulimit</b>&nbsp;can protect a system against the dreaded<i>&nbsp;fork bomb</i>.<br>
#!/bin/bash<br>
# This script is for illustrative purposes only.<br>
Chapter 17. System and Administrative Commands<br>
341<br>
<hr>
<A name=348></a>Advanced Bash-Scripting Guide<br>
# Run it at your own peril -- it WILL freeze your system.<br>
while true &nbsp;# &nbsp;Endless loop.<br>
do<br>
&nbsp; $0 &amp; &nbsp; &nbsp; &nbsp;# &nbsp;This script invokes itself . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ forks an infinite number of times . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ until the system freezes up because all resources exhausted.<br>
done &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This is the notorious&nbsp;&quot;sorcerer's appentice&quot;&nbsp;scenario.<br>
exit 0 &nbsp; &nbsp; &nbsp;# &nbsp;Will not exit here, because this script will never terminate.<br>
A<b>&nbsp;ulimit -Hu XX</b>&nbsp;(where<i>&nbsp;XX</i>&nbsp;is the user process limit) in&nbsp;/etc/profile&nbsp;would abort this<br>script when it exceeded the preset limit.<br>
<b>quota</b><br>
Display user or group disk quotas.<br>
<b>setquota</b><br>
Set user or group disk quotas from the command-line.<br>
<b>umask</b><br>
User file creation permissions<i>&nbsp;mask</i>. Limit the default file attributes for a particular user. All files<br>created by that user take on the attributes specified by<b>&nbsp;umask</b>. The (octal) value passed to<b>&nbsp;umask<br></b>defines the file permissions<i>&nbsp;disabled</i>. For example,<b>&nbsp;umask 022</b>&nbsp;ensures that new files will have at<br>most 755 permissions (777 NAND 022).&nbsp;[92] Of course, the user may later change the attributes of<br><a href="abs-guides.html#223">particular files with chmod. The usual practice is to set the value of</a><b>&nbsp;umask</b>&nbsp;in&nbsp;/etc/profile<br>and/or&nbsp;~/.bash_profile<a href="abs-guides.html#793">&nbsp;(see Appendix G).</a><br>
<b>Example 17-10. Using<i>&nbsp;umask</i></b><b>&nbsp;to hide an output file from prying eyes</b><br>
#!/bin/bash<br>
# rot13a.sh: Same as &quot;rot13.sh&quot; script, but writes output to &quot;secure&quot; file.<br>
# Usage: ./rot13a.sh filename<br>
# or &nbsp; &nbsp; ./rot13a.sh &lt;filename<br>
# or &nbsp; &nbsp; ./rot13a.sh and supply keyboard input (stdin)<br>
umask 177 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;File creation mask.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Files created by this script<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ will have 600 permissions.<br>
OUTFILE=decrypted.txt &nbsp; # &nbsp;Results output to file &quot;decrypted.txt&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ which can only be read/written<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;by invoker of script (or root).<br>
cat &quot;$@&quot; | tr 'a-zA-Z' 'n-za-mN-ZA-M' &gt; $OUTFILE&nbsp;<br>
# &nbsp; &nbsp;^^ Input from stdin or a file. &nbsp; ^^^^^^^^^^ Output redirected to file.&nbsp;<br>
exit 0<br>
<b>rdev</b><br>
Get info about or make changes to root device, swap space, or video mode. The functionality of<b>&nbsp;rdev<br></b>has generally been taken over by<b>&nbsp;lilo</b>, but<b>&nbsp;rdev</b>&nbsp;remains useful for setting up a ram disk. This is a<br>dangerous command, if misused.<br>
<b>Modules</b><br>
<b>lsmod</b><br>
List installed kernel modules.<br>
Chapter 17. System and Administrative Commands<br>
342<br>
<hr>
<A name=349></a><IMG src="abs-guide-349_1.png"><br>
<IMG src="abs-guide-349_2.png"><br>
Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>lsmod<br></b>Module &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Size &nbsp;Used by<br>
&nbsp;autofs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9456 &nbsp; 2 (autoclean)<br>
&nbsp;opl3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11376 &nbsp; 0<br>
&nbsp;serial_cs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5456 &nbsp; 0 (unused)<br>
&nbsp;sb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 34752 &nbsp; 0<br>
&nbsp;uart401 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6384 &nbsp; 0 [sb]<br>
&nbsp;sound &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;58368 &nbsp; 0 [opl3 sb uart401]<br>
&nbsp;soundlow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 464 &nbsp; 0 [sound]<br>
&nbsp;soundcore &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2800 &nbsp; 6 [sb sound]<br>
&nbsp;ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6448 &nbsp; 2 [serial_cs]<br>
&nbsp;i82365 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 22928 &nbsp; 2<br>
&nbsp;pcmcia_core &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;45984 &nbsp; 0 [serial_cs ds i82365]<br>
Doing a<b>&nbsp;cat /proc/modules</b>&nbsp;gives the same information.<br>
<b>insmod</b><br>
Force installation of a kernel module (use<b>&nbsp;modprobe</b>&nbsp;instead, when possible). Must be invoked as<br><i>root</i>.<br>
<b>rmmod</b><br>
Force unloading of a kernel module. Must be invoked as<i>&nbsp;root</i>.<br>
<b>modprobe</b><br>
Module loader that is normally invoked automatically in a startup script. Must be invoked as<i>&nbsp;root</i>.<br>
<b>depmod</b><br>
Creates module dependency file. Usually invoked from a startup script.<br>
<b>modinfo</b><br>
Output information about a loadable module.<br>
bash$&nbsp;<b>modinfo hid<br></b>filename: &nbsp; &nbsp;/lib/modules/2.4.20-6/kernel/drivers/usb/hid.o<br>
&nbsp;description: &quot;USB HID support drivers&quot;<br>
&nbsp;author: &nbsp; &nbsp; &nbsp;&quot;Andreas Gal, Vojtech Pavlik &lt;vojtech@suse.cz&gt;&quot;<br>
&nbsp;license: &nbsp; &nbsp; &quot;GPL&quot;<br>
<b>Miscellaneous</b><br>
<b>env</b><br>
<a href="abs-guides.html#41">Runs a program or script with certain environmental variables set or changed (without changing the<br></a>overall system environment). The&nbsp;[varname=xxx]&nbsp;permits changing the environmental variable<br>varname&nbsp;for the duration of the script. With no options specified, this command lists all the<br>environmental variable settings.&nbsp;[93]<br>
The first line of a script (the &quot;sha-bang&quot; line) may use<b>&nbsp;env</b>&nbsp;when the path to the shell<br>or interpreter is unknown.<br>
#! /usr/bin/env perl<br>
print &quot;This Perl script will run,\n&quot;;<br>
print &quot;even when I don't know where to find Perl.\n&quot;;<br>
# Good for portable cross-platform scripts,<br>
# where the Perl binaries may not be in the expected place.<br>
# Thanks, S.C.<br>
Chapter 17. System and Administrative Commands<br>
343<br>
<hr>
<A name=350></a><IMG src="abs-guide-350_1.png"><br>
Advanced Bash-Scripting Guide<br>
Or even ...<br>
#!/bin/env bash<br>
# Queries the $PATH enviromental variable for the location of bash.<br>
# Therefore ...<br>
# This script will run where Bash is not in its usual place, in /bin.<br>
...<br>
<b>ldd</b><br>
Show shared lib dependencies for an executable file.<br>
bash$&nbsp;<b>ldd /bin/ls<br></b>libc.so.6 =&gt; /lib/libc.so.6 (0x4000c000)<br>
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x80000000)<br>
<b>watch</b><br>
Run a command repeatedly, at specified time intervals.<br>
The default is two-second intervals, but this may be changed with the&nbsp;-n&nbsp;option.<br>
watch -n 5 tail /var/log/messages<br>
# Shows tail end of system log, /var/log/messages, every five seconds.<br>
<a href="abs-guides.html#24">Unfortunately, piping the output of</a><b>&nbsp;watch command</b><a href="abs-guides.html#246">&nbsp;to grep does not work.</a><br>
<b>strip</b><br>
Remove the debugging symbolic references from an executable binary. This decreases its size, but<br>makes debugging it impossible.<br>
<a href="abs-guides.html#280">This command often occurs in a Makefile, but rarely in a shell script.</a><br>
<b>nm</b><br>
List symbols in an unstripped compiled binary.<br>
<b>rdist</b><br>
Remote distribution client: synchronizes, clones, or backs up a file system on a remote server.<br>
<b>17.1. Analyzing a System Script</b><br>
Using our knowledge of administrative commands, let us examine a system script. One of the shortest and<br>simplest to understand scripts is &quot;killall,&quot;&nbsp;[94] used to suspend running processes at system shutdown.<br>
<b>Example 17-11.<i>&nbsp;killall</i></b><b>, from&nbsp;/etc/rc.d/init.d</b><br>
#!/bin/sh<br>
# --&gt; Comments added by the author of this document marked by &quot;# --&gt;&quot;.<br>
# --&gt; This is part of the 'rc' script package<br>
# --&gt; by Miquel van Smoorenburg, &lt;miquels@drinkel.nl.mugnet.org&gt;.<br>
# --&gt; This particular script seems to be Red Hat / FC specific<br>
# --&gt; (may not be present in other distributions).<br>
# &nbsp;Bring down all unneeded services that are still running<br>
#+ (there shouldn't be any, so this is just a sanity check)<br>
Chapter 17. System and Administrative Commands<br>
344<br>
<hr>
<A name=351></a>Advanced Bash-Scripting Guide<br>
for i in /var/lock/subsys/*; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; Standard for/in loop, but since &quot;do&quot; is on same line,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; it is necessary to add &quot;;&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Check if the script is there.<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ! -f $i ] &amp;&amp; continue<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; This is a clever use of an &quot;and list&quot;, equivalent to:<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; if [ ! -f &quot;$i&quot; ]; then continue<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Get the subsystem name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; subsys=${i#/var/lock/subsys/}<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; Match variable name, which, in this case, is the file name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; This is the exact equivalent of subsys=`basename $i`.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; &nbsp;It gets it from the lock file name<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt;+ (if there is a lock file,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt;+ that's proof the process has been running).<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; &nbsp;See the &quot;lockfile&quot; entry, above.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Bring the subsystem down.<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ -f /etc/rc.d/init.d/$subsys.init ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/etc/rc.d/init.d/$subsys.init stop<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/etc/rc.d/init.d/$subsys stop<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; &nbsp;Suspend running jobs and daemons.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; &nbsp;Note that &quot;stop&quot; is a positional parameter,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt;+ not a shell builtin.<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
done<br>
That wasn't so bad. Aside from a little fancy footwork with variable matching, there is no new material there.<br>
<b>Exercise 1.</b>&nbsp;In&nbsp;/etc/rc.d/init.d, analyze the<b>&nbsp;halt</b>&nbsp;script. It is a bit longer than<b>&nbsp;killall</b>, but similar in<br>concept. Make a copy of this script somewhere in your home directory and experiment with it (do<i>&nbsp;not</i>&nbsp;run it as<br><i>root</i>). Do a simulated run with the&nbsp;-vn&nbsp;flags (<b>sh -vn scriptname</b>). Add extensive comments. Change<br><a href="abs-guides.html#187">the commands to echos.</a><br>
<b>Exercise 2.</b>&nbsp;Look at some of the more complex scripts in&nbsp;/etc/rc.d/init.d. Try to understand at least<br>portions of them. Follow the above procedure to analyze them. For some additional insight, you might also<br>examine the file&nbsp;sysvinitfiles&nbsp;in&nbsp;/usr/share/doc/initscripts-?.??, which is part of the<br>&quot;initscripts&quot; documentation.<br>
Chapter 17. System and Administrative Commands<br>
345<br>
<hr>
<A name=352></a><b>Part 5. Advanced Topics</b><br>
At this point, we are ready to delve into certain of the difficult and unusual aspects of scripting. Along the<br>way, we will attempt to &quot;push the envelope&quot; in various ways and examine<i>&nbsp;boundary conditions</i>&nbsp;(what happens<br>when we move into uncharted territory?).<br>
<b>Table of Contents<br></b><a href="abs-guides.html#354">18. Regular Expressions</a><br>
<a href="abs-guides.html#354">18.1. A Brief Introduction to Regular Expressions<br></a><a href="abs-guides.html#358">18.2. Globbing</a><br>
<a href="abs-guides.html#360">19. Here Documents</a><br>
<a href="abs-guides.html#370">19.1. Here Strings</a><br>
<a href="abs-guides.html#374">20. I/O Redirection</a><br>
<a href="abs-guides.html#377">20.1. Using<i>&nbsp;exec<br></i></a><a href="abs-guides.html#380">20.2. Redirecting Code Blocks<br></a><a href="abs-guides.html#385">20.3. Applications</a><br>
<a href="abs-guides.html#387">21. Subshells<br></a><a href="abs-guides.html#392">22. Restricted Shells<br></a><a href="abs-guides.html#394">23. Process Substitution<br></a><a href="abs-guides.html#399">24. Functions</a><br>
<a href="abs-guides.html#403">24.1. Complex Functions and Function Complexities<br></a><a href="abs-guides.html#413">24.2. Local Variables<br></a><a href="abs-guides.html#417">24.3. Recursion Without Local Variables</a><br>
<a href="abs-guides.html#421">25. Aliases<br></a><a href="abs-guides.html#424">26. List Constructs<br></a><a href="abs-guides.html#427">27. Arrays<br></a><a href="abs-guides.html#456">28. Indirect References<br></a>29.&nbsp;<a href="abs-guides.html#460">/dev&nbsp;and&nbsp;/proc</a><br>
29.1.&nbsp;<a href="abs-guides.html#460">/dev<br></a>29.2.&nbsp;<a href="abs-guides.html#463">/proc</a><br>
<a href="abs-guides.html#469">30. Network Programming<br></a><a href="abs-guides.html#472">31. Of Zeros and Nulls<br></a><a href="abs-guides.html#476">32. Debugging<br></a><a href="abs-guides.html#487">33. Options<br></a><a href="abs-guides.html#490">34. Gotchas<br></a><a href="abs-guides.html#499">35. Scripting With Style</a><br>
<a href="abs-guides.html#499">35.1. Unofficial Shell Scripting Stylesheet</a><br>
<a href="abs-guides.html#502">36. Miscellany</a><br>
<a href="abs-guides.html#502">36.1. Interactive and non-interactive shells and scripts<br></a><a href="abs-guides.html#503">36.2. Shell Wrappers<br></a><a href="abs-guides.html#508">36.3. Tests and Comparisons: Alternatives<br></a><a href="abs-guides.html#509">36.4. Recursion: a script calling itself<br></a><a href="abs-guides.html#511">36.5. &quot;Colorizing&quot; Scripts<br></a><a href="abs-guides.html#524">36.6. Optimizations<br></a><a href="abs-guides.html#525">36.7. Assorted Tips<br></a><a href="abs-guides.html#537">36.8. Security Issues<br></a><a href="abs-guides.html#538">36.9. Portability Issues<br></a><a href="abs-guides.html#540">36.10. Shell Scripting Under Windows</a><br>
<a href="abs-guides.html#541">37. Bash, versions 2, 3, and 4</a><br>
Part 5. Advanced Topics<br>
346<br>
<hr>
<A name=353></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#541">37.1. Bash, version 2<br></a><a href="abs-guides.html#545">37.2. Bash, version 3<br></a><a href="abs-guides.html#549">37.3. Bash, version 4</a><br>
Part 5. Advanced Topics<br>
347<br>
<hr>
<A name=354></a><b>Chapter 18. Regular Expressions</b><br>
<i>. . . the intellectual activity associated with<br>software development is largely one of gaining<br>insight.</i><br>
<i>--Stowe Boyd</i><br>
To fully utilize the power of shell scripting, you need to master Regular Expressions. Certain commands and<br><a href="abs-guides.html#246">utilities commonly used in scripts, such as grep, expr, sed and awk, interpret and use REs. As of version 3,<br></a><a href="abs-guides.html#547">Bash has acquired its own RE-match operator:</a><b>&nbsp;=~</b>.<br>
<b>18.1. A Brief Introduction to Regular Expressions</b><br>
An expression is a string of characters. Those characters having an interpretation above and beyond their<br>literal meaning are called<i>&nbsp;metacharacters</i>. A quote symbol, for example, may denote speech by a person,<br><i>ditto</i>, or a meta-meaning&nbsp;[95] for the symbols that follow. Regular Expressions are sets of characters and/or<br>metacharacters that match (or specify) patterns.<br>
A Regular Expression contains one or more of the following:<br>
<i>A character set</i><br>
•&nbsp;<br>
. These are the characters retaining their literal meaning. The simplest type of Regular<br>
Expression consists<i>&nbsp;only</i>&nbsp;of a character set, with no metacharacters.<br>
•&nbsp;<br>
<i>An anchor</i>. These designate (<i>anchor</i>) the position in the line of text that the RE is to match. For<br>example, ^, and $ are anchors.<br><i>Modifiers</i><br>
•&nbsp;<br>
. These expand or narrow (<i>modify</i>) the range of text the RE is to match. Modifiers include<br>
the asterisk, brackets, and the backslash.<br>
The main uses for Regular Expressions (<i>RE</i>s) are text searches and string manipulation. An RE<i>&nbsp;matches</i>&nbsp;a<br>single character or a set of characters -- a string or a part of a string.<br>
The asterisk -- * -- matches any number of repeats of the character string or RE preceding it,<br>
•&nbsp;<br>
including<i>&nbsp;zero</i>&nbsp;instances.<br>
&quot;1133*&quot; matches&nbsp;<i>11 + one or more 3's</i>:&nbsp;<i>113</i>,&nbsp;<i>1133</i>,&nbsp;<i>1133333</i>, and so forth.<br>The<br>
•&nbsp;<br>
<i>&nbsp;dot</i>&nbsp;-- . -- matches any one character, except a newline.&nbsp;[96]<br>
&quot;13.&quot; matches&nbsp;<i>13 + at least one of any character (including a space)</i>:<br><i>1133</i>,&nbsp;<i>11333</i>, but not&nbsp;<i>13</i>&nbsp;(additional character missing).<br>
<a href="abs-guides.html#249">See Example 16-18 for a demonstration of</a><i>&nbsp;dot single-character</i>&nbsp;matching.<br>The caret -- ^ -- matches the beginning of a line, but sometimes, depending on context, negates the<br>
•&nbsp;<br>
meaning of a set of characters in an RE.<br>
•&nbsp;<br>
The dollar sign -- $ -- at the end of an RE matches the end of a line.<br>
&quot;XXX$&quot; matches XXX at the end of a line.<br>
Chapter 18. Regular Expressions<br>
348<br>
<hr>
<A name=355></a>Advanced Bash-Scripting Guide<br>
&quot;^$&quot; matches blank lines.<br>
•&nbsp;<br>
Brackets -- [...] -- enclose a set of characters to match in a single RE.<br>
&quot;[xyz]&quot; matches any one of the characters&nbsp;<i>x</i>,&nbsp;<i>y</i>, or&nbsp;<i>z</i>.<br>
&quot;[c-n]&quot; matches any one of the characters in the range&nbsp;<i>c</i>&nbsp;to&nbsp;<i>n</i>.<br>
&quot;[B-Pk-y]&quot; matches any one of the characters in the ranges&nbsp;<i>B</i>&nbsp;to&nbsp;<i>P</i>&nbsp;and&nbsp;<i>k</i>&nbsp;to&nbsp;<i>y</i>.<br>
&quot;[a-z0-9]&quot; matches any single lowercase letter or any digit.<br>
&quot;[^b-d]&quot; matches any character<i>&nbsp;except</i>&nbsp;those in the range&nbsp;<i>b</i>&nbsp;to&nbsp;<i>d</i>. This is an instance of ^ negating or<br>inverting the meaning of the following RE (taking on a role similar to ! in a different context).<br>
Combined sequences of bracketed characters match common word patterns. &quot;[Yy][Ee][Ss]&quot; matches<br><i>yes</i>,&nbsp;<i>Yes</i>,&nbsp;<i>YES</i>,&nbsp;<i>yEs</i>, and so forth. &quot;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&quot; matches any<br>Social Security number.<br>
•&nbsp;<br>
<a href="abs-guides.html#49">The backslash -- \ -- escapes a special character, which means that character gets interpreted literally<br></a>(and is therefore no longer<i>&nbsp;special</i>).<br>
A &quot;\$&quot; reverts back to its literal meaning of &quot;$&quot;, rather than its RE meaning of end-of-line. Likewise a<br>&quot;\\&quot; has the literal meaning of &quot;\&quot;.<br>
•&nbsp;<br>
<a href="abs-guides.html#49">Escaped &quot;angle brackets&quot; -- \&lt;...\&gt; -- mark word boundaries.</a><br>
The angle brackets must be escaped, since otherwise they have only their literal character meaning.<br>
&quot;\&lt;the\&gt;&quot; matches the word &quot;the,&quot; but not the words &quot;them,&quot; &quot;there,&quot; &quot;other,&quot; etc.<br>
bash$&nbsp;<b>cat textfile<br></b>This is line 1, of which there is only one instance.<br>
&nbsp;This is the only instance of line 2.<br>
&nbsp;This is line 3, another line.<br>
&nbsp;This is line 4.<br>
bash$&nbsp;<b>grep 'the' textfile<br></b>This is line 1, of which there is only one instance.<br>
&nbsp;This is the only instance of line 2.<br>
&nbsp;This is line 3, another line.<br>
bash$&nbsp;<b>grep '\&lt;the\&gt;' textfile<br></b>This is the only instance of line 2.<br>
The only way to be certain that a particular RE works is to test it.<br>
TEST FILE: tstfile &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No match.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No match.<br>
Chapter 18. Regular Expressions<br>
349<br>
<hr>
<A name=356></a><IMG src="abs-guide-356_1.png"><br>
Advanced Bash-Scripting Guide<br>
Run &nbsp; grep &quot;1133*&quot; &nbsp;on this file. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Match.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No match.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No match.<br>
This line contains the number 113. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Match.<br>
This line contains the number 13. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No match.<br>
This line contains the number 133. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No match.<br>
This line contains the number 1133. &nbsp; &nbsp; &nbsp; &nbsp; # Match.<br>
This line contains the number 113312. &nbsp; &nbsp; &nbsp; # Match.<br>
This line contains the number 1112. &nbsp; &nbsp; &nbsp; &nbsp; # No match.<br>
This line contains the number 113312312. &nbsp; &nbsp;# Match.<br>
This line contains no numbers at all. &nbsp; &nbsp; &nbsp; # No match.<br>
bash$&nbsp;<b>grep &quot;1133*&quot; tstfile<br></b>Run &nbsp; grep &quot;1133*&quot; &nbsp;on this file. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Match.<br>
&nbsp;This line contains the number 113. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Match.<br>
&nbsp;This line contains the number 1133. &nbsp; &nbsp; &nbsp; &nbsp; # Match.<br>
&nbsp;This line contains the number 113312. &nbsp; &nbsp; &nbsp; # Match.<br>
&nbsp;This line contains the number 113312312. &nbsp; &nbsp;# Match.<br>
<b>Extended REs.</b><br>
•&nbsp;<br>
<a href="abs-guides.html#251">&nbsp;Additional metacharacters added to the basic set. Used in egrep, awk, and Perl.</a><br>
•&nbsp;<br>
The question mark -- ? -- matches zero or one of the previous RE. It is generally used for matching<br>single characters.<br>
•&nbsp;<br>
The plus -- + -- matches one or more of the previous RE. It serves a role similar to the *, but does<i>&nbsp;not<br></i>match zero occurrences.<br>
# GNU versions of sed and awk can use &quot;+&quot;,<br>
# but it needs to be escaped.<br>
echo a111b | sed -ne '/a1\+b/p'<br>
echo a111b | grep 'a1\+b'<br>
echo a111b | gawk '/a1+b/'<br>
# All of above are equivalent.<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#49">Escaped &quot;curly brackets&quot; -- \{ \} -- indicate the number of occurrences of a preceding RE to match.</a><br>
•&nbsp;<br>
It is necessary to escape the curly brackets since they have only their literal character meaning<br>otherwise. This usage is technically not part of the basic RE set.<br>
&quot;[0-9]\{5\}&quot; matches exactly five digits (characters in the range of 0 to 9).<br>
Curly brackets are not available as an RE in the &quot;classic&quot; (non-POSIX compliant)<br><a href="abs-guides.html#784">version of awk.&nbsp;</a>However, the GNU extended version of<i>&nbsp;awk</i>,<b>&nbsp;gawk</b>, has the<br>--re-interval&nbsp;option that permits them (without being escaped).<br>
bash$&nbsp;<b>echo 2222 | gawk --re-interval '/2{3}/'<br></b>2222<br>
<b>Perl</b>&nbsp;and some<b>&nbsp;egrep</b>&nbsp;versions do not require escaping the curly brackets.<br>
•&nbsp;<br>
Parentheses --<b>&nbsp;( )</b>&nbsp;-- enclose a group of REs. They are useful with the following &quot;|&quot; operator and in<br><a href="abs-guides.html#128">substring extraction using expr.</a><br>
Chapter 18. Regular Expressions<br>
350<br>
<hr>
<A name=357></a><IMG src="abs-guide-357_1.png"><br>
<IMG src="abs-guide-357_2.png"><br>
Advanced Bash-Scripting Guide<br>
The --<br>
•&nbsp;<br>
<b>&nbsp;|</b>&nbsp;-- &quot;or&quot; RE operator matches any of a set of alternate characters.<br>
bash$&nbsp;<b>egrep 're(a|e)d' misc.txt<br></b>People who read seem to be better informed than those who do not.<br>
&nbsp;The clarinet produces sound by the vibration of its reed.<br>
Some versions of<b>&nbsp;sed</b>,<b>&nbsp;ed</b>, and<b>&nbsp;ex</b>&nbsp;support escaped versions of the extended Regular Expressions<br>described above, as do the GNU utilities.<br>
<b>POSIX Character Classes.</b><br>
•&nbsp;<br>
<b>[:class:]</b><br>
This is an alternate method of specifying a range of characters to match.<br><b>[:alnum:]</b><br>
•&nbsp;<br>
&nbsp;matches alphabetic or numeric characters. This is equivalent to&nbsp;<b>A-Za-z0-9</b>.<br>
<b>[:alpha:]</b><br>
•&nbsp;<br>
&nbsp;matches alphabetic characters. This is equivalent to&nbsp;<b>A-Za-z</b>.<br>
<b>[:blank:]</b><br>
•&nbsp;<br>
&nbsp;matches a space or a tab.<br>
<b>[:cntrl:]</b><br>
•&nbsp;<br>
&nbsp;matches control characters.<br>
<b>[:digit:]</b><br>
•&nbsp;<br>
&nbsp;matches (decimal) digits. This is equivalent to&nbsp;<b>0-9</b>.<br>
<b>[:graph:]</b><br>
•&nbsp;<br>
<a href="abs-guides.html#882">&nbsp;(graphic printable characters). Matches characters in the range of ASCII 33 - 126. This</a><br>
is the same as&nbsp;<b>[:print:]</b>, below, but excluding the space character.<br><b>[:lower:]</b><br>
•&nbsp;<br>
&nbsp;matches lowercase alphabetic characters. This is equivalent to&nbsp;<b>a-z</b>.<br>
<b>[:print:]</b><br>
•&nbsp;<br>
&nbsp;(printable characters). Matches characters in the range of ASCII 32 - 126. This is the<br>
same as&nbsp;<b>[:graph:]</b>, above, but adding the space character.<br><b>[:space:]</b><br>
•&nbsp;<br>
&nbsp;matches whitespace characters (space and horizontal tab).<br>
<b>[:upper:]</b><br>
•&nbsp;<br>
&nbsp;matches uppercase alphabetic characters. This is equivalent to&nbsp;<b>A-Z</b>.<br>
<b>[:xdigit:]</b><br>
•&nbsp;<br>
&nbsp;matches hexadecimal digits. This is equivalent to&nbsp;<b>0-9A-Fa-f</b>.<br>
<a href="abs-guides.html#65">POSIX character classes generally require quoting or double brackets ([[ ]]).</a><br>
bash$&nbsp;<b>grep [[:digit:]] test.file<br></b>abc=723<br>
# ...<br>
if [[ $arow =~ [[:digit:]] ]] &nbsp; # &nbsp;Numerical input?<br>
then &nbsp; &nbsp; &nbsp; # &nbsp;POSIX char class<br>
&nbsp; if [[ $acol =~ [[:alpha:]] ]] # Number followed by a letter? Illegal!<br>
# ...<br>
# From ktour.sh example script.<br>
<a href="abs-guides.html#358">These character classes may even be used with globbing, to a limited extent.</a><br>
bash$&nbsp;<b>ls -l ?[[:digit:]][[:digit:]]?<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug 21 14:47 a33b<br>
<a href="abs-guides.html#255">POSIX character classes are used in Example 16-21 and Example 16-22.</a><br>
<a href="abs-guides.html#781">Sed, awk, and Perl, used as filters in scripts, take REs as arguments when &quot;sifting&quot; or transforming files or I/O<br></a><a href="abs-guides.html#590">streams. See Example A-12 and Example A-16 for illustrations of this.</a><br>
The standard reference on this complex topic is Friedl's<i>&nbsp;Mastering Regular Expressions</i>.<i>&nbsp;Sed &amp; Awk</i>, by<br>Dougherty and Robbins, also gives a very lucid treatment of REs. See the&nbsp;<a href="abs-guides.html#565"><i>Bibliography</i>&nbsp;for more information<br></a>on these books.<br>
Chapter 18. Regular Expressions<br>
351<br>
<hr>
<A name=358></a>Advanced Bash-Scripting Guide<br>
<b>18.2. Globbing</b><br>
<a href="abs-guides.html#781">Bash itself cannot recognize Regular Expressions. Inside scripts, it is commands and utilities -- such as sed<br></a><a href="abs-guides.html#784">and awk -- that interpret RE's.</a><br>
Bash<i>&nbsp;does</i>&nbsp;carry out<i>&nbsp;filename expansion&nbsp;</i>[97] -- a process known as<i>&nbsp;globbing</i>&nbsp;-- but this does<i>&nbsp;not</i>&nbsp;use the<br>standard RE set. Instead, globbing recognizes and expands<i>&nbsp;wild cards</i>. Globbing interprets the standard wild<br>card characters&nbsp;<a href="abs-guides.html#18">[98] -- * and ?, character lists in square brackets, and certain other special characters (such as ^<br></a>for negating the sense of a match).&nbsp;There are important limitations on wild card characters in globbing,<br>however. Strings containing&nbsp;<i>*</i><a href="abs-guides.html#804">&nbsp;will not match filenames that start with a dot, as, for example,&nbsp;.bashrc</a>.&nbsp;[99]<br>Likewise, the&nbsp;<i>?</i>&nbsp;has a different meaning in globbing than as part of an RE.<br>
bash$&nbsp;<b>ls -l<br></b>total 2<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 a.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 b.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 c.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 466 Aug &nbsp;6 17:48 t2.sh<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 758 Jul 30 09:02 test1.txt<br>
bash$&nbsp;<b>ls -l t?.sh<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 466 Aug &nbsp;6 17:48 t2.sh<br>
bash$&nbsp;<b>ls -l [ab]*<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 a.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 b.1<br>
bash$&nbsp;<b>ls -l [a-c]*<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 a.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 b.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 c.1<br>
bash$&nbsp;<b>ls -l [^ab]*<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 c.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 466 Aug &nbsp;6 17:48 t2.sh<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 758 Jul 30 09:02 test1.txt<br>
bash$&nbsp;<b>ls -l {b*,c*,*est*}<br></b>-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 b.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; &nbsp; 0 Aug &nbsp;6 18:42 c.1<br>
&nbsp;-rw-rw-r-- &nbsp; &nbsp;1 bozo &nbsp;bozo &nbsp; &nbsp; &nbsp; 758 Jul 30 09:02 test1.txt<br>
<a href="abs-guides.html#187">Bash performs filename expansion on unquoted command-line arguments. The echo command demonstrates<br></a>this.<br>
bash$&nbsp;<b>echo *<br></b>a.1 b.1 c.1 t2.sh test1.txt<br>
bash$&nbsp;<b>echo t*<br></b>t2.sh test1.txt<br>
bash$&nbsp;<b>echo t?.sh<br></b>t2.sh<br>
Chapter 18. Regular Expressions<br>
352<br>
<hr>
<A name=359></a><IMG src="abs-guide-359_1.png"><br>
Advanced Bash-Scripting Guide<br>
It is possible to modify the way Bash interprets special characters in globbing. A<b>&nbsp;set -f</b>&nbsp;command<br>disables globbing, and the&nbsp;nocaseglob&nbsp;and&nbsp;nullglob<a href="abs-guides.html#213">&nbsp;options to shopt change globbing behavior.</a><br>
<a href="abs-guides.html#146">See also Example 11-4.</a><br>
Chapter 18. Regular Expressions<br>
353<br>
<hr>
<A name=360></a><b>Chapter 19. Here Documents</b><br>
<i>Here and now, boys.</i><br>
<i>--Aldous Huxley, Island</i><br>
A<i>&nbsp;here document</i><a href="abs-guides.html#374">&nbsp;is a special-purpose code block. It uses a form of I/O redirection to feed a command list to<br></a><a href="abs-guides.html#286">an interactive program or a command, such as ftp, cat, or the</a><i>&nbsp;ex</i>&nbsp;text editor.<br>
COMMAND &lt;&lt;InputComesFromHERE<br>
...<br>
...<br>
...<br>
InputComesFromHERE<br>
A<i>&nbsp;limit string</i>&nbsp;delineates (frames) the command list. The special symbol &lt;&lt; precedes the limit string. This has<br>the effect of redirecting the output of a command block into the&nbsp;stdin&nbsp;of the program or command. It is<br>similar to&nbsp;<b>interactive-program &lt; command-file</b>, where&nbsp;command-file&nbsp;contains<br>
command #1<br>
command #2<br>
...<br>
The<i>&nbsp;here document</i>&nbsp;equivalent looks like this:<br>
interactive-program &lt;&lt;LimitString<br>
command #1<br>
command #2<br>
...<br>
LimitString<br>
Choose a<i>&nbsp;limit string</i>&nbsp;sufficiently unusual that it will not occur anywhere in the command list and confuse<br>matters.<br>
Note that<i>&nbsp;here documents</i>&nbsp;may sometimes be used to good effect with non-interactive utilities and commands,<br><a href="abs-guides.html#327">such as, for example, wall.</a><br>
<b>Example 19-1.<i>&nbsp;broadcast</i></b><b>: Sends message to everyone logged in</b><br>
#!/bin/bash<br>
wall &lt;&lt;zzz23EndOfMessagezzz23<br>
E-mail your noontime orders for pizza to the system administrator.<br>
&nbsp; &nbsp; (Add an extra dollar for anchovy or mushroom topping.)<br>
# Additional message text goes here.<br>
# Note: 'wall' prints comment lines.<br>
zzz23EndOfMessagezzz23<br>
# Could have been done more efficiently by<br>
# &nbsp; &nbsp; &nbsp; &nbsp; wall &lt;message-file<br>
# &nbsp;However, embedding the message template in a script<br>
#+ is a quick-and-dirty one-off solution.<br>
exit<br>
Chapter 19. Here Documents<br>
354<br>
<hr>
<A name=361></a>Advanced Bash-Scripting Guide<br>
Even such unlikely candidates as the<i>&nbsp;vi</i>&nbsp;text editor lend themselves to<i>&nbsp;here documents</i>.<br>
<b>Example 19-2.<i>&nbsp;dummyfile</i></b><b>: Creates a 2-line dummy file</b><br>
#!/bin/bash<br>
# Noninteractive use of 'vi' to edit a file.<br>
# Emulates 'sed'.<br>
E_BADARGS=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
TARGETFILE=$1<br>
# Insert 2 lines in file, then save.<br>
#--------Begin here document-----------#<br>
vi $TARGETFILE &lt;&lt;x23LimitStringx23<br>
i<br>
This is line 1 of the example file.<br>
This is line 2 of the example file.<br>
^[<br>
ZZ<br>
x23LimitStringx23<br>
#----------End here document-----------#<br>
# &nbsp;Note that ^[ above is a literal escape<br>
#+ typed by Control-V &lt;Esc&gt;.<br>
# &nbsp;Bram Moolenaar points out that this may not work with 'vim'<br>
#+ because of possible problems with terminal interaction.<br>
exit<br>
The above script could just as effectively have been implemented with<b>&nbsp;ex</b>, rather than<b>&nbsp;vi</b>.&nbsp;<i>Here documents<br></i>containing a list of<b>&nbsp;ex</b>&nbsp;commands are common enough to form their own category, known as<i>&nbsp;ex scripts</i>.<br>
#!/bin/bash<br>
# &nbsp;Replace all instances of &quot;Smith&quot; with &quot;Jones&quot;<br>
#+ in files with a &quot;.txt&quot; filename suffix.&nbsp;<br>
ORIGINAL=Smith<br>
REPLACEMENT=Jones<br>
for word in $(fgrep -l $ORIGINAL *.txt)<br>
do<br>
&nbsp; # -------------------------------------<br>
&nbsp; ex $word &lt;&lt;EOF<br>
&nbsp; :%s/$ORIGINAL/$REPLACEMENT/g<br>
&nbsp; :wq<br>
EOF<br>
&nbsp; # :%s is the &quot;ex&quot; substitution command.<br>
&nbsp; # :wq is write-and-quit.<br>
&nbsp; # -------------------------------------<br>
done<br>
Chapter 19. Here Documents<br>
355<br>
<hr>
<A name=362></a>Advanced Bash-Scripting Guide<br>
Analogous to &quot;ex scripts&quot; are<i>&nbsp;cat scripts</i>.<br>
<b>Example 19-3. Multi-line message using<i>&nbsp;cat</i></b><br>
#!/bin/bash<br>
# &nbsp;'echo' is fine for printing single line messages,<br>
#+ &nbsp;but somewhat problematic for for message blocks.<br>
# &nbsp; A 'cat' here document overcomes this limitation.<br>
cat &lt;&lt;End-of-message<br>
-------------------------------------<br>
This is line 1 of the message.<br>
This is line 2 of the message.<br>
This is line 3 of the message.<br>
This is line 4 of the message.<br>
This is the last line of the message.<br>
-------------------------------------<br>
End-of-message<br>
# &nbsp;Replacing line 7, above, with<br>
#+ &nbsp; cat &gt; $Newfile &lt;&lt;End-of-message<br>
#+ &nbsp; &nbsp; &nbsp; ^^^^^^^^^^<br>
#+ writes the output to the file $Newfile, rather than to stdout.<br>
exit 0<br>
#--------------------------------------------<br>
# Code below disabled, due to &quot;exit 0&quot; above.<br>
# S.C. points out that the following also works.<br>
echo &quot;-------------------------------------<br>
This is line 1 of the message.<br>
This is line 2 of the message.<br>
This is line 3 of the message.<br>
This is line 4 of the message.<br>
This is the last line of the message.<br>
-------------------------------------&quot;<br>
# However, text may not include double quotes unless they are escaped.<br>
The&nbsp;-&nbsp;option to mark a here document limit string (<b>&lt;&lt;-LimitString</b>) suppresses leading tabs (but not<br>spaces) in the output. This may be useful in making a script more readable.<br>
<b>Example 19-4. Multi-line message, with tabs suppressed</b><br>
#!/bin/bash<br>
# Same as previous example, but...<br>
# &nbsp;The - option to a here document &lt;&lt;-<br>
#+ suppresses leading tabs in the body of the document,<br>
#+ but *not* spaces.<br>
cat &lt;&lt;-ENDOFMESSAGE<br>
&nbsp; &nbsp; &nbsp; &nbsp; This is line 1 of the message.<br>
&nbsp; &nbsp; &nbsp; &nbsp; This is line 2 of the message.<br>
&nbsp; &nbsp; &nbsp; &nbsp; This is line 3 of the message.<br>
Chapter 19. Here Documents<br>
356<br>
<hr>
<A name=363></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; This is line 4 of the message.<br>
&nbsp; &nbsp; &nbsp; &nbsp; This is the last line of the message.<br>
ENDOFMESSAGE<br>
# The output of the script will be flush left.<br>
# Leading tab in each line will not show.<br>
# Above 5 lines of &quot;message&quot; prefaced by a tab, not spaces.<br>
# Spaces not affected by &nbsp; &lt;&lt;- &nbsp;.<br>
# Note that this option has no effect on *embedded* tabs.<br>
exit 0<br>
A<i>&nbsp;here document</i>&nbsp;supports parameter and command substitution. It is therefore possible to pass different<br>parameters to the body of the here document, changing its output accordingly.<br>
<b>Example 19-5. Here document with replaceable parameters</b><br>
#!/bin/bash<br>
# Another 'cat' here document, using parameter substitution.<br>
# Try it with no command-line parameters, &nbsp; ./scriptname<br>
# Try it with one command-line parameter, &nbsp; ./scriptname Mortimer<br>
# Try it with one two-word quoted command-line parameter,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ./scriptname &quot;Mortimer Jones&quot;<br>
CMDLINEPARAM=1 &nbsp; &nbsp; # &nbsp;Expect at least command-line parameter.<br>
if [ $# -ge $CMDLINEPARAM ]<br>
then<br>
&nbsp; NAME=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;If more than one command-line param,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then just take the first.<br>
else<br>
&nbsp; NAME=&quot;John Doe&quot; &nbsp;# &nbsp;Default, if no command-line parameter.<br>
fi &nbsp;<br>
RESPONDENT=&quot;the author of this fine script&quot; &nbsp;<br>
cat &lt;&lt;Endofmessage<br>
Hello, there, $NAME.<br>
Greetings to you, $NAME, from $RESPONDENT.<br>
# This comment shows up in the output (why?).<br>
Endofmessage<br>
# Note that the blank lines show up in the output.<br>
# So does the comment.<br>
exit<br>
This is a useful script containing a<i>&nbsp;here document</i>&nbsp;with parameter substitution.<br>
<b>Example 19-6. Upload a file pair to<i>&nbsp;Sunsite</i></b><b>&nbsp;incoming directory</b><br>
Chapter 19. Here Documents<br>
357<br>
<hr>
<A name=364></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# upload.sh<br>
# &nbsp;Upload file pair (Filename.lsm, Filename.tar.gz)<br>
#+ to incoming directory at Sunsite/UNC (ibiblio.org).<br>
# &nbsp;Filename.tar.gz is the tarball itself.<br>
# &nbsp;Filename.lsm is the descriptor file.<br>
# &nbsp;Sunsite requires &quot;lsm&quot; file, otherwise will bounce contributions.<br>
E_ARGERROR=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` Filename-to-upload&quot;<br>
&nbsp; exit $E_ARGERROR<br>
fi &nbsp;<br>
Filename=`basename $1` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Strips pathname out of file name.<br>
Server=&quot;ibiblio.org&quot;<br>
Directory=&quot;/incoming/Linux&quot;<br>
# &nbsp;These need not be hard-coded into script,<br>
#+ but may instead be changed to command-line argument.<br>
Password=&quot;your.e-mail.address&quot; &nbsp; # Change above to suit.<br>
ftp -n $Server &lt;&lt;End-Of-Session<br>
# -n option disables auto-logon<br>
user anonymous &quot;$Password&quot; &nbsp; &nbsp; &nbsp; # &nbsp;If this doesn't work, then try:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;quote user anonymous &quot;$Password&quot;<br>
binary<br>
bell &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Ring 'bell' after each file transfer.<br>
cd $Directory<br>
put &quot;$Filename.lsm&quot;<br>
put &quot;$Filename.tar.gz&quot;<br>
bye<br>
End-Of-Session<br>
exit 0<br>
Quoting or escaping the &quot;limit string&quot; at the head of a here document disables parameter substitution within its<br>body. The reason for this is that<i>&nbsp;quoting/escaping the limit string</i><a href="abs-guides.html#49">&nbsp;effectively escapes the $, `, and \ special<br></a><a href="">characters, and causes them to be interpreted literally. (Thank you, Allen Halsey, for pointing this out.)</a><br>
<b>Example 19-7. Parameter substitution turned off</b><br>
#!/bin/bash<br>
# &nbsp;A 'cat' here-document, but with parameter substitution disabled.<br>
NAME=&quot;John Doe&quot;<br>
RESPONDENT=&quot;the author of this fine script&quot; &nbsp;<br>
cat &lt;&lt;'Endofmessage'<br>
Hello, there, $NAME.<br>
Greetings to you, $NAME, from $RESPONDENT.<br>
Chapter 19. Here Documents<br>
358<br>
<hr>
<A name=365></a>Advanced Bash-Scripting Guide<br>
Endofmessage<br>
# &nbsp; No parameter substitution when the &quot;limit string&quot; is quoted or escaped.<br>
# &nbsp; Either of the following at the head of the here document would have<br>
#+ &nbsp;the same effect.<br>
# &nbsp; cat &lt;&lt;&quot;Endofmessage&quot;<br>
# &nbsp; cat &lt;&lt;\Endofmessage<br>
# &nbsp; And, likewise:<br>
cat &lt;&lt;&quot;SpecialCharTest&quot;<br>
Directory listing would follow<br>
if limit string were not quoted.<br>
`ls -l`<br>
Arithmetic expansion would take place<br>
if limit string were not quoted.<br>
$((5 + 3))<br>
A a single backslash would echo<br>
if limit string were not quoted.<br>
\\<br>
SpecialCharTest<br>
exit<br>
Disabling parameter substitution permits outputting literal text. Generating scripts or even program code is<br>one use for this.<br>
<b>Example 19-8. A script that generates another script</b><br>
#!/bin/bash<br>
# generate-script.sh<br>
# Based on an idea by Albert Reiner.<br>
OUTFILE=generated.sh &nbsp; &nbsp; &nbsp; &nbsp; # Name of the file to generate.<br>
# -----------------------------------------------------------<br>
# 'Here document containing the body of the generated script.<br>
(<br>
cat &lt;&lt;'EOF'<br>
#!/bin/bash<br>
echo &quot;This is a generated shell script.&quot;<br>
# &nbsp;Note that since we are inside a subshell,<br>
#+ we can't access variables in the &quot;outside&quot; script.<br>
echo &quot;Generated file will be named: $OUTFILE&quot;<br>
# &nbsp;Above line will not work as normally expected<br>
#+ because parameter expansion has been disabled.<br>
# &nbsp;Instead, the result is literal output.<br>
Chapter 19. Here Documents<br>
359<br>
<hr>
<A name=366></a>Advanced Bash-Scripting Guide<br>
a=7<br>
b=3<br>
let &quot;c = $a * $b&quot;<br>
echo &quot;c = $c&quot;<br>
exit 0<br>
EOF<br>
) &gt; $OUTFILE<br>
# -----------------------------------------------------------<br>
# &nbsp;Quoting the 'limit string' prevents variable expansion<br>
#+ within the body of the above 'here document.'<br>
# &nbsp;This permits outputting literal strings in the output file.<br>
if [ -f &quot;$OUTFILE&quot; ]<br>
then<br>
&nbsp; chmod 755 $OUTFILE<br>
&nbsp; # Make the generated file executable.<br>
else<br>
&nbsp; echo &quot;Problem in creating file: \&quot;$OUTFILE\&quot;&quot;<br>
fi<br>
# &nbsp;This method can also be used for generating<br>
#+ C programs, Perl programs, Python programs, Makefiles,<br>
#+ and the like.<br>
exit 0<br>
<a href="abs-guides.html#170">It is possible to set a variable from the output of a here document. This is actually a devious form of command<br>substitution.</a><br>
variable=$(cat &lt;&lt;SETVAR<br>
This variable<br>
runs over multiple lines.<br>
SETVAR)<br>
echo &quot;$variable&quot;<br>
A here document can supply input to a function in the same script.<br>
<b>Example 19-9. Here documents and functions</b><br>
#!/bin/bash<br>
# here-function.sh<br>
GetPersonalData ()<br>
{<br>
&nbsp; read firstname<br>
&nbsp; read lastname<br>
&nbsp; read address<br>
&nbsp; read city&nbsp;<br>
&nbsp; read state&nbsp;<br>
&nbsp; read zipcode<br>
} # This certainly looks like an interactive function, but...<br>
# Supply input to the above function.<br>
Chapter 19. Here Documents<br>
360<br>
<hr>
<A name=367></a><IMG src="abs-guide-367_1.png"><br>
Advanced Bash-Scripting Guide<br>
GetPersonalData &lt;&lt;RECORD001<br>
Bozo<br>
Bozeman<br>
2726 Nondescript Dr.<br>
Baltimore<br>
MD<br>
21226<br>
RECORD001<br>
echo<br>
echo &quot;$firstname $lastname&quot;<br>
echo &quot;$address&quot;<br>
echo &quot;$city, $state $zipcode&quot;<br>
echo<br>
exit 0<br>
It is possible to use : as a dummy command accepting output from a here document. This, in effect, creates an<br>&quot;anonymous&quot; here document.<br>
<b>Example 19-10. &quot;Anonymous&quot; Here Document</b><br>
#!/bin/bash<br>
: &lt;&lt;TESTVARIABLES<br>
${HOSTNAME?}${USER?}${MAIL?} &nbsp;# Print error message if one of the variables not set.<br>
TESTVARIABLES<br>
exit $?<br>
A variation of the above technique permits &quot;commenting out&quot; blocks of code.<br>
<b>Example 19-11. Commenting out a block of code</b><br>
#!/bin/bash<br>
# commentblock.sh<br>
: &lt;&lt;COMMENTBLOCK<br>
echo &quot;This line will not echo.&quot;<br>
This is a comment line missing the &quot;#&quot; prefix.<br>
This is another comment line missing the &quot;#&quot; prefix.<br>
&amp;*@!!++=<br>
The above line will cause no error message,<br>
because the Bash interpreter will ignore it.<br>
COMMENTBLOCK<br>
echo &quot;Exit value of above \&quot;COMMENTBLOCK\&quot; is $?.&quot; &nbsp; # 0<br>
# No error shown.<br>
echo<br>
# &nbsp;The above technique also comes in useful for commenting out<br>
#+ a block of working code for debugging purposes.<br>
# &nbsp;This saves having to put a &quot;#&quot; at the beginning of each line,<br>
#+ then having to go back and delete each &quot;#&quot; later.<br>
Chapter 19. Here Documents<br>
361<br>
<hr>
<A name=368></a><IMG src="abs-guide-368_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp;Note that the use of of colon, above, is optional.<br>
echo &quot;Just before commented-out code block.&quot;<br>
# &nbsp;The lines of code between the double-dashed lines will not execute.<br>
# &nbsp;===================================================================<br>
: &lt;&lt;DEBUGXXX<br>
for file in *<br>
do<br>
&nbsp;cat &quot;$file&quot;<br>
done<br>
DEBUGXXX<br>
# &nbsp;===================================================================<br>
echo &quot;Just after commented-out code block.&quot;<br>
exit 0<br>
######################################################################<br>
# &nbsp;Note, however, that if a bracketed variable is contained within<br>
#+ the commented-out code block,<br>
#+ then this could cause problems.<br>
# &nbsp;for example:<br>
#/!/bin/bash<br>
&nbsp; : &lt;&lt;COMMENTBLOCK<br>
&nbsp; echo &quot;This line will not echo.&quot;<br>
&nbsp; &amp;*@!!++=<br>
&nbsp; ${foo_bar_bazz?}<br>
&nbsp; $(rm -rf /tmp/foobar/)<br>
&nbsp; $(touch my_build_directory/cups/Makefile)<br>
COMMENTBLOCK<br>
$ sh commented-bad.sh<br>
commented-bad.sh: line 3: foo_bar_bazz: parameter null or not set<br>
# The remedy for this is to strong-quote the 'COMMENTBLOCK' in line 49, above.<br>
&nbsp; : &lt;&lt;'COMMENTBLOCK'<br>
# Thank you, Kurt Pfeifle, for pointing this out.<br>
Yet another twist of this nifty trick makes &quot;self-documenting&quot; scripts possible.<br>
<b>Example 19-12. A self-documenting script</b><br>
#!/bin/bash<br>
# self-document.sh: self-documenting script<br>
# Modification of &quot;colm.sh&quot;.<br>
DOC_REQUEST=70<br>
if [ &quot;$1&quot; = &quot;-h&quot; &nbsp;-o &quot;$1&quot; = &quot;--help&quot; ] &nbsp; &nbsp; # Request help.<br>
then<br>
&nbsp; echo; echo &quot;Usage: $0 [directory-name]&quot;; echo<br>
&nbsp; sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' &quot;$0&quot; |<br>
&nbsp; sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi<br>
Chapter 19. Here Documents<br>
362<br>
<hr>
<A name=369></a><IMG src="abs-guide-369_1.png"><br>
<IMG src="abs-guide-369_2.png"><br>
<IMG src="abs-guide-369_3.png"><br>
Advanced Bash-Scripting Guide<br>
: &lt;&lt;DOCUMENTATIONXX<br>
List the statistics of a specified directory in tabular format.<br>
---------------------------------------------------------------<br>
The command-line parameter gives the directory to be listed.<br>
If no directory specified or directory specified cannot be read,<br>
then list the current working directory.<br>
DOCUMENTATIONXX<br>
if [ -z &quot;$1&quot; -o ! -r &quot;$1&quot; ]<br>
then<br>
&nbsp; directory=.<br>
else<br>
&nbsp; directory=&quot;$1&quot;<br>
fi &nbsp;<br>
echo &quot;Listing of &quot;$directory&quot;:&quot;; echo<br>
(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&quot; \<br>
; ls -l &quot;$directory&quot; | sed 1d) | column -t<br>
exit 0<br>
<a href="abs-guides.html#361">Using a cat script is an alternate way of accomplishing this.</a><br>
DOC_REQUEST=70<br>
if [ &quot;$1&quot; = &quot;-h&quot; &nbsp;-o &quot;$1&quot; = &quot;--help&quot; ] &nbsp; &nbsp; # Request help.<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Use a &quot;cat script&quot; . . .<br>
&nbsp; cat &lt;&lt;DOCUMENTATIONXX<br>
List the statistics of a specified directory in tabular format.<br>
---------------------------------------------------------------<br>
The command-line parameter gives the directory to be listed.<br>
If no directory specified or directory specified cannot be read,<br>
then list the current working directory.<br>
DOCUMENTATIONXX<br>
exit $DOC_REQUEST<br>
fi<br>
<a href="abs-guides.html#626">See also Example A-28, Example A-40, Example A-41, and Example A-42 for more examples of<br></a>self-documenting scripts.<br>
Here documents create temporary files, but these files are deleted after opening and are not accessible to<br>any other process.<br>
bash$&nbsp;<b>bash -c 'lsof -a -p $$ -d0' &lt;&lt; EOF<br></b>&gt;&nbsp;<b>EOF<br></b>lsof &nbsp; &nbsp;1213 bozo &nbsp; &nbsp;0r &nbsp; REG &nbsp; &nbsp;3,5 &nbsp; &nbsp;0 30386 /tmp/t1213-0-sh (deleted)<br>
Some utilities will not work inside a<i>&nbsp;here document</i>.<br>
The closing<i>&nbsp;limit string</i>, on the final line of a here document, must start in the<i>&nbsp;first</i>&nbsp;character position.<br>There can be<i>&nbsp;no leading whitespace</i>. Trailing whitespace after the limit string likewise causes<br>unexpected behavior. The whitespace prevents the limit string from being recognized.&nbsp;[100]<br>
Chapter 19. Here Documents<br>
363<br>
<hr>
<A name=370></a><IMG src="abs-guide-370_1.png"><br>
Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
echo &quot;----------------------------------------------------------------------&quot;<br>
cat &lt;&lt;LimitString<br>
echo &quot;This is line 1 of the message inside the here document.&quot;<br>
echo &quot;This is line 2 of the message inside the here document.&quot;<br>
echo &quot;This is the final line of the message inside the here document.&quot;<br>
&nbsp; &nbsp; &nbsp;LimitString<br>
#^^^^Indented limit string. Error! This script will not behave as expected.<br>
echo &quot;----------------------------------------------------------------------&quot;<br>
# &nbsp;These comments are outside the 'here document',<br>
#+ and should not echo.<br>
echo &quot;Outside the here document.&quot;<br>
exit 0<br>
echo &quot;This line had better not echo.&quot; &nbsp;# Follows an 'exit' command.<br>
Some people very cleverly use a single ! as a limit string. But, that's not necessarily a good idea.<br>
# This works.<br>
cat &lt;&lt;!<br>
Hello!<br>
! Three more exclamations !!!<br>
!<br>
# But . . .<br>
cat &lt;&lt;!<br>
Hello!<br>
Single exclamation point follows!<br>
!<br>
!<br>
# Crashes with an error message.<br>
# However, the following will work.<br>
cat &lt;&lt;EOF<br>
Hello!<br>
Single exclamation point follows!<br>
!<br>
EOF<br>
# It's safer to use a multi-character limit string.<br>
For those tasks too complex for a<i>&nbsp;here document</i>, consider using the&nbsp;<i>expect</i>&nbsp;scripting language, which was<br>specifically designed for feeding input into interactive programs.<br>
<b>19.1. Here Strings</b><br>
A&nbsp;<i>here</i><br>
<i>string</i>&nbsp;can be considered as a stripped-down form of a&nbsp;<i>here</i><br>
<i>document</i>.<br>
Chapter 19. Here Documents<br>
364<br>
<hr>
<A name=371></a>Advanced Bash-Scripting Guide<br>
It consists of nothing more than&nbsp;<b>COMMAND &lt;&lt;&lt; $WORD</b>,<br>where $WORD is expanded and fed to the stdin of&nbsp;<b>COMMAND</b>.<br>
<a href="abs-guides.html#187">As a simple example, consider this alternative to the echo-grep construction.</a><br>
# Instead of:<br>
if echo &quot;$VAR&quot; | grep -q txt &nbsp; # if [[ $VAR = *txt* ]]<br>
# etc.<br>
# Try:<br>
if grep -q &quot;txt&quot; &lt;&lt;&lt; &quot;$VAR&quot;<br>
then &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; ^^^<br>
&nbsp; &nbsp;echo &quot;$VAR contains the substring sequence \&quot;txt\&quot;&quot;<br>
fi<br>
# Thank you, Sebastian Kaminski, for the suggestion.<br>
<a href="abs-guides.html#190">Or, in combination with read:</a><br>
String=&quot;This is a string of words.&quot;<br>
read -r -a Words &lt;&lt;&lt; &quot;$String&quot;<br>
# &nbsp;The -a option to &quot;read&quot;<br>
#+ assigns the resulting values to successive members of an array.<br>
echo &quot;First word in String is: &nbsp; &nbsp;${Words[0]}&quot; &nbsp; # This<br>
echo &quot;Second word in String is: &nbsp; ${Words[1]}&quot; &nbsp; # is<br>
echo &quot;Third word in String is: &nbsp; &nbsp;${Words[2]}&quot; &nbsp; # a<br>
echo &quot;Fourth word in String is: &nbsp; ${Words[3]}&quot; &nbsp; # string<br>
echo &quot;Fifth word in String is: &nbsp; &nbsp;${Words[4]}&quot; &nbsp; # of<br>
echo &quot;Sixth word in String is: &nbsp; &nbsp;${Words[5]}&quot; &nbsp; # words.<br>
echo &quot;Seventh word in String is: &nbsp;${Words[6]}&quot; &nbsp; # (null)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Past end of $String.<br>
# Thank you, Francisco Lobo, for the suggestion.<br>
It is, of course, possible to feed the output of a<i>&nbsp;here string</i>&nbsp;into the&nbsp;stdin<a href="abs-guides.html#144">&nbsp;of a loop.</a><br>
# As Seamus points out . . .<br>
ArrayVar=( element0 element1 element2 {A..D} )<br>
while read element ; do<br>
&nbsp; echo &quot;$element&quot; 1&gt;&amp;2<br>
done &lt;&lt;&lt; $(echo ${ArrayVar[*]})<br>
# element0 element1 element2 A B C D<br>
<b>Example 19-13. Prepending a line to a file</b><br>
#!/bin/bash<br>
# prepend.sh: Add text at beginning of file.<br>
#<br>
# &nbsp;Example contributed by Kenny Stauffer,<br>
#+ and slightly modified by document author.<br>
E_NOSUCHFILE=85<br>
Chapter 19. Here Documents<br>
365<br>
<hr>
<A name=372></a>Advanced Bash-Scripting Guide<br>
read -p &quot;File: &quot; file &nbsp; # -p arg to 'read' displays prompt.<br>
if [ ! -e &quot;$file&quot; ]<br>
then &nbsp; # Bail out if no such file.<br>
&nbsp; echo &quot;File $file not found.&quot;<br>
&nbsp; exit $E_NOSUCHFILE<br>
fi<br>
read -p &quot;Title: &quot; title<br>
cat - $file &lt;&lt;&lt;$title &gt; $file.new<br>
echo &quot;Modified file is $file.new&quot;<br>
exit &nbsp;# Ends script execution.<br>
&nbsp; from 'man bash':<br>
&nbsp; Here Strings<br>
&nbsp; &nbsp; &nbsp; &nbsp; A variant of here documents, the format is:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;&lt;&lt;word<br>
&nbsp; &nbsp; &nbsp; &nbsp; The word is expanded and supplied to the command on its standard input.<br>
&nbsp; Of course, the following also works:<br>
&nbsp; &nbsp;sed -e '1i\<br>
&nbsp; &nbsp;Title: ' $file<br>
<b>Example 19-14. Parsing a mailbox</b><br>
#!/bin/bash<br>
# &nbsp;Script by Francisco Lobo,<br>
#+ and slightly modified and commented by ABS Guide author.<br>
# &nbsp;Used in ABS Guide with permission. (Thank you!)<br>
# This script will not run under Bash versions &lt; 3.0.<br>
E_MISSING_ARG=67<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: $0 mailbox-file&quot;<br>
&nbsp; exit $E_MISSING_ARG<br>
fi<br>
mbox_grep() &nbsp;# Parse mailbox file.<br>
{<br>
&nbsp; &nbsp; declare -i body=0 match=0<br>
&nbsp; &nbsp; declare -a date sender<br>
&nbsp; &nbsp; declare mail header value<br>
&nbsp; &nbsp; while IFS= read -r mail<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reset $IFS.<br>
# &nbsp;Otherwise &quot;read&quot; will strip leading &amp; trailing space from its input.<br>
&nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp;if [[ $mail =~ &quot;^From &quot; ]] &nbsp; # Match &quot;From&quot; field in message.<br>
&nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( body &nbsp;= 0 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;Zero out&quot; variables.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( match = 0 ))<br>
Chapter 19. Here Documents<br>
366<br>
<hr>
<A name=373></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset date<br>
&nbsp; &nbsp; &nbsp; &nbsp;elif (( body ))<br>
&nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( match ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # echo &quot;$mail&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Uncomment above line if you want entire body of message to display.<br>
&nbsp; &nbsp; &nbsp; &nbsp;elif [[ $mail ]]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IFS=: read -r header value &lt;&lt;&lt; &quot;$mail&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^ &nbsp;&quot;here string&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case &quot;$header&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Ff][Rr][Oo][Mm] ) [[ $value =~ &quot;$2&quot; ]] &amp;&amp; (( match++ )) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Match &quot;From&quot; line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Dd][Aa][Tt][Ee] ) read -r -a date &lt;&lt;&lt; &quot;$value&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Match &quot;Date&quot; line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Rr][Ee][Cc][Ee][Ii][Vv][Ee][Dd] ) read -r -a sender &lt;&lt;&lt; &quot;$value&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Match IP Address (may be spoofed).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( body++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( match &nbsp;)) &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;MESSAGE ${date:+of: ${date[*]} }&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp;Entire $date array &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;IP address of sender: ${sender[1]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp;Second field of &quot;Received&quot; line &nbsp; &nbsp;^<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; done &lt; &quot;$1&quot; # Redirect stdout of file into loop.<br>
}<br>
mbox_grep &quot;$1&quot; &nbsp;# Send mailbox file to function.<br>
exit $?<br>
# Exercises:<br>
# ---------<br>
# 1) Break the single function, above, into multiple functions,<br>
#+ &nbsp; for the sake of readability.<br>
# 2) Add additional parsing to the script, checking for various keywords.<br>
$ mailbox_grep.sh scam_mail<br>
&nbsp; MESSAGE of Thu, 5 Jan 2006 08:00:56 -0500 (EST)&nbsp;<br>
&nbsp; IP address of sender: 196.3.62.4<br>
Exercise: Find other uses for<i>&nbsp;here strings</i><a href="abs-guides.html#305">, such as, for example, feeding input to<i>&nbsp;dc</i>.</a><br>
Chapter 19. Here Documents<br>
367<br>
<hr>
<A name=374></a><b>Chapter 20. I/O Redirection</b><br>
There are always three default<i>&nbsp;files&nbsp;</i>[101] open,&nbsp;stdin&nbsp;(the keyboard),&nbsp;stdout&nbsp;(the screen), and&nbsp;stderr<br>(error messages output to the screen). These, and any other open files, can be redirected. Redirection simply<br>means capturing output from a file, command, program, script, or even code block within a script (see<br><a href="abs-guides.html#21">Example 3-1 and Example 3-2) and sending it as input to another file, command, program, or script.</a><br>
Each open file gets assigned a file descriptor.&nbsp;[102] The file descriptors for&nbsp;stdin,&nbsp;stdout, and&nbsp;stderr<br>are 0, 1, and 2, respectively. For opening additional files, there remain descriptors 3 to 9. It is sometimes<br>useful to assign one of these additional file descriptors to&nbsp;stdin,&nbsp;stdout, or&nbsp;stderr&nbsp;as a temporary<br>duplicate link.&nbsp;[103] This simplifies restoration to normal after complex redirection and reshuffling (see<br><a href="abs-guides.html#377">Example 20-1).</a><br>
&nbsp; &nbsp;COMMAND_OUTPUT &gt;<br>
&nbsp; &nbsp; &nbsp; # Redirect stdout to a file.<br>
&nbsp; &nbsp; &nbsp; # Creates the file if not present, otherwise overwrites it.<br>
&nbsp; &nbsp; &nbsp; ls -lR &gt; dir-tree.list<br>
&nbsp; &nbsp; &nbsp; # Creates a file containing a listing of the directory tree.<br>
&nbsp; &nbsp;: &gt; filename<br>
&nbsp; &nbsp; &nbsp; # The &gt; truncates file &quot;filename&quot; to zero length.<br>
&nbsp; &nbsp; &nbsp; # If file not present, creates zero-length file (same effect as 'touch').<br>
&nbsp; &nbsp; &nbsp; # The : serves as a dummy placeholder, producing no output.<br>
&nbsp; &nbsp;&gt; filename &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; # The &gt; truncates file &quot;filename&quot; to zero length.<br>
&nbsp; &nbsp; &nbsp; # If file not present, creates zero-length file (same effect as 'touch').<br>
&nbsp; &nbsp; &nbsp; # (Same result as &quot;: &gt;&quot;, above, but this does not work with some shells.)<br>
&nbsp; &nbsp;COMMAND_OUTPUT &gt;&gt;<br>
&nbsp; &nbsp; &nbsp; # Redirect stdout to a file.<br>
&nbsp; &nbsp; &nbsp; # Creates the file if not present, otherwise appends to it.<br>
&nbsp; &nbsp; &nbsp; # Single-line redirection commands (affect only the line they are on):<br>
&nbsp; &nbsp; &nbsp; # --------------------------------------------------------------------<br>
&nbsp; &nbsp;1&gt;filename<br>
&nbsp; &nbsp; &nbsp; # Redirect stdout to file &quot;filename.&quot;<br>
&nbsp; &nbsp;1&gt;&gt;filename<br>
&nbsp; &nbsp; &nbsp; # Redirect and append stdout to file &quot;filename.&quot;<br>
&nbsp; &nbsp;2&gt;filename<br>
&nbsp; &nbsp; &nbsp; # Redirect stderr to file &quot;filename.&quot;<br>
&nbsp; &nbsp;2&gt;&gt;filename<br>
&nbsp; &nbsp; &nbsp; # Redirect and append stderr to file &quot;filename.&quot;<br>
&nbsp; &nbsp;&amp;&gt;filename<br>
&nbsp; &nbsp; &nbsp; # Redirect both stdout and stderr to file &quot;filename.&quot;<br>
&nbsp; &nbsp; &nbsp; # This operator is now functional, as of Bash 4, final release.<br>
&nbsp; &nbsp;M&gt;N<br>
&nbsp; &nbsp; &nbsp;# &quot;M&quot; is a file descriptor, which defaults to 1, if not explicitly set.<br>
&nbsp; &nbsp; &nbsp;# &quot;N&quot; is a filename.<br>
&nbsp; &nbsp; &nbsp;# File descriptor &quot;M&quot; is redirect to file &quot;N.&quot;<br>
&nbsp; &nbsp;M&gt;&amp;N<br>
&nbsp; &nbsp; &nbsp;# &quot;M&quot; is a file descriptor, which defaults to 1, if not set.<br>
Chapter 20. I/O Redirection<br>
368<br>
<hr>
<A name=375></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp;# &quot;N&quot; is another file descriptor.<br>
&nbsp; &nbsp; &nbsp; #==============================================================================<br>
&nbsp; &nbsp; &nbsp; # Redirecting stdout, one line at a time.<br>
&nbsp; &nbsp; &nbsp; LOGFILE=script.log<br>
&nbsp; &nbsp; &nbsp; echo &quot;This statement is sent to the log file, \&quot;$LOGFILE\&quot;.&quot; 1&gt;$LOGFILE<br>
&nbsp; &nbsp; &nbsp; echo &quot;This statement is appended to \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE<br>
&nbsp; &nbsp; &nbsp; echo &quot;This statement is also appended to \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE<br>
&nbsp; &nbsp; &nbsp; echo &quot;This statement is echoed to stdout, and will not appear in \&quot;$LOGFILE\&quot;.&quot;<br>
&nbsp; &nbsp; &nbsp; # These redirection commands automatically &quot;reset&quot; after each line.<br>
&nbsp; &nbsp; &nbsp; # Redirecting stderr, one line at a time.<br>
&nbsp; &nbsp; &nbsp; ERRORFILE=script.errors<br>
&nbsp; &nbsp; &nbsp; bad_command1 2&gt;$ERRORFILE &nbsp; &nbsp; &nbsp; # &nbsp;Error message sent to $ERRORFILE.<br>
&nbsp; &nbsp; &nbsp; bad_command2 2&gt;&gt;$ERRORFILE &nbsp; &nbsp; &nbsp;# &nbsp;Error message appended to $ERRORFILE.<br>
&nbsp; &nbsp; &nbsp; bad_command3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Error message echoed to stderr,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and does not appear in $ERRORFILE.<br>
&nbsp; &nbsp; &nbsp; # These redirection commands also automatically &quot;reset&quot; after each line.<br>
&nbsp; &nbsp; &nbsp; #=======================================================================<br>
&nbsp; &nbsp;2&gt;&amp;1<br>
&nbsp; &nbsp; &nbsp; # Redirects stderr to stdout.<br>
&nbsp; &nbsp; &nbsp; # Error messages get sent to same place as standard output.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;filename 2&gt;&amp;1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bad_command &gt;&gt;filename 2&gt;&amp;1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Appends both stdout and stderr to the file &quot;filename&quot; ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2&gt;&amp;1 | [command(s)]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bad_command 2&gt;&amp;1 | awk '{print $5}' &nbsp; # found<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Sends stderr through a pipe.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # |&amp; was added to Bash 4 as an abbreviation for 2&gt;&amp;.<br>
&nbsp; &nbsp;i&gt;&amp;j<br>
&nbsp; &nbsp; &nbsp; # Redirects file descriptor&nbsp;<i>i</i>&nbsp;to&nbsp;<i>j</i>.<br>
&nbsp; &nbsp; &nbsp; # All output of file pointed to by&nbsp;<i>i</i>&nbsp;gets sent to file pointed to by&nbsp;<i>j</i>.<br>
&nbsp; &nbsp;&gt;&amp;j<br>
&nbsp; &nbsp; &nbsp; # Redirects, by default, file descriptor&nbsp;<i>1</i>&nbsp;(stdout) to&nbsp;<i>j</i>.<br>
&nbsp; &nbsp; &nbsp; # All stdout gets sent to file pointed to by&nbsp;<i>j</i>.<br>
&nbsp; &nbsp;0&lt; FILENAME<br>
&nbsp; &nbsp; &lt; FILENAME<br>
&nbsp; &nbsp; &nbsp; # Accept input from a file.<br>
&nbsp; &nbsp; &nbsp; # Companion command to&nbsp;&quot;&gt;&quot;, and often used in combination with it.<br>
&nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; # grep search-word &lt;filename<br>
&nbsp; &nbsp;[j]&lt;&gt;filename<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Open file &quot;filename&quot; for reading and writing,<br>
&nbsp; &nbsp; &nbsp; #+ and assign file descriptor &quot;j&quot; to it.<br>
&nbsp; &nbsp; &nbsp; # &nbsp;If &quot;filename&quot; does not exist, create it.<br>
&nbsp; &nbsp; &nbsp; # &nbsp;If file descriptor &quot;j&quot; is not specified, default to fd 0, stdin.<br>
&nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; # &nbsp;An application of this is writing at a specified place in a file.&nbsp;<br>
&nbsp; &nbsp; &nbsp; echo 1234567890 &gt; File &nbsp; &nbsp;# Write string to &quot;File&quot;.<br>
&nbsp; &nbsp; &nbsp; exec 3&lt;&gt; File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Open &quot;File&quot; and assign fd 3 to it.<br>
Chapter 20. I/O Redirection<br>
369<br>
<hr>
<A name=376></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; read -n 4 &lt;&amp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Read only 4 characters.<br>
&nbsp; &nbsp; &nbsp; echo -n . &gt;&amp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Write a decimal point there.<br>
&nbsp; &nbsp; &nbsp; exec 3&gt;&amp;- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Close fd 3.<br>
&nbsp; &nbsp; &nbsp; cat File &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ==&gt; 1234.67890<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Random access, by golly.<br>
&nbsp; &nbsp;|<br>
&nbsp; &nbsp; &nbsp; # Pipe.<br>
&nbsp; &nbsp; &nbsp; # General purpose process and command chaining tool.<br>
&nbsp; &nbsp; &nbsp; # Similar to&nbsp;&quot;&gt;&quot;, but more general in effect.<br>
&nbsp; &nbsp; &nbsp; # Useful for chaining commands, scripts, files, and programs together.<br>
&nbsp; &nbsp; &nbsp; cat *.txt | sort | uniq &gt; result-file<br>
&nbsp; &nbsp; &nbsp; # Sorts the output of all the .txt files and deletes duplicate lines,<br>
&nbsp; &nbsp; &nbsp; # finally saves results to&nbsp;&quot;result-file&quot;.<br>
Multiple instances of input and output redirection and/or pipes can be combined in a single command line.<br>
command &lt; input-file &gt; output-file<br>
# Or the equivalent:<br>
&lt; input-file command &gt; output-file &nbsp; # Although this is non-standard.<br>
command1 | command2 | command3 &gt; output-file<br>
<a href="abs-guides.html#264">See Example 16-31 and Example A-14.</a><br>
Multiple output streams may be redirected to one file.<br>
ls -yz &gt;&gt; command.log 2&gt;&amp;1<br>
# &nbsp;Capture result of illegal options &quot;yz&quot; in file &quot;command.log.&quot;<br>
# &nbsp;Because stderr is redirected to the file,<br>
#+ any error messages will also be there.<br>
# &nbsp;Note, however, that the following does *not* give the same result.<br>
ls -yz 2&gt;&amp;1 &gt;&gt; command.log<br>
# &nbsp;Outputs an error message, but does not write to file.<br>
# &nbsp;More precisely, the command output (in this case, null)<br>
#+ writes to the file, but the error message goes only to stdout.<br>
# &nbsp;If redirecting both stdout and stderr,<br>
#+ the order of the commands makes a difference.<br>
<b>Closing File Descriptors</b><br>
n&lt;&amp;-<br>
Close input file descriptor&nbsp;<i>n</i>.<br>
0&lt;&amp;-, &lt;&amp;-<br>
Close&nbsp;stdin.<br>
n&gt;&amp;-<br>
Close output file descriptor&nbsp;<i>n</i>.<br>
1&gt;&amp;-, &gt;&amp;-<br>
Close&nbsp;stdout.<br>
Child processes inherit open file descriptors. This is why pipes work. To prevent an fd from being inherited,<br>close it.<br>
Chapter 20. I/O Redirection<br>
370<br>
<hr>
<A name=377></a>Advanced Bash-Scripting Guide<br>
# Redirecting only stderr to a pipe.<br>
exec 3&gt;&amp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Save current &quot;value&quot; of stdout.<br>
ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;- &nbsp; &nbsp;# Close fd 3 for 'grep' (but not 'ls').<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^ &nbsp; ^^^^<br>
exec 3&gt;&amp;- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Now close it for the remainder of the script.<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#788">For a more detailed introduction to I/O redirection see Appendix E.</a><br>
<b>20.1. Using<i>&nbsp;exec</i></b><br>
An<b>&nbsp;exec &lt;filename</b>&nbsp;command redirects&nbsp;stdin&nbsp;to a file. From that point on, all&nbsp;stdin&nbsp;comes from that file,<br>rather than its normal source (usually keyboard input). This provides a method of reading a file line by line<br><a href="abs-guides.html#781">and possibly parsing each line of input using sed and/or awk.</a><br>
<b>Example 20-1. Redirecting&nbsp;stdin&nbsp;using<i>&nbsp;exec</i></b><br>
#!/bin/bash<br>
# Redirecting stdin using 'exec'.<br>
exec 6&lt;&amp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Link file descriptor #6 with stdin.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Saves stdin.<br>
exec &lt; data-file &nbsp; # stdin replaced by file &quot;data-file&quot;<br>
read a1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reads first line of file &quot;data-file&quot;.<br>
read a2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reads second line of file &quot;data-file.&quot;<br>
echo<br>
echo &quot;Following lines read from file.&quot;<br>
echo &quot;-------------------------------&quot;<br>
echo $a1<br>
echo $a2<br>
echo; echo; echo<br>
exec 0&lt;&amp;6 6&lt;&amp;-<br>
# &nbsp;Now restore stdin from fd #6, where it had been saved,<br>
#+ and close fd #6 ( 6&lt;&amp;- ) to free it for other processes to use.<br>
#<br>
# &lt;&amp;6 6&lt;&amp;- &nbsp; &nbsp;also works.<br>
echo -n &quot;Enter data &nbsp;&quot;<br>
read b1 &nbsp;# Now &quot;read&quot; functions as expected, reading from normal stdin.<br>
echo &quot;Input read from stdin.&quot;<br>
echo &quot;----------------------&quot;<br>
echo &quot;b1 = $b1&quot;<br>
echo<br>
exit 0<br>
Similarly, an<b>&nbsp;exec &gt;filename</b>&nbsp;command redirects&nbsp;stdout&nbsp;to a designated file. This sends all command<br>output that would normally go to&nbsp;stdout&nbsp;to that file.<br>
Chapter 20. I/O Redirection<br>
371<br>
<hr>
<A name=378></a><IMG src="abs-guide-378_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>exec N &gt; filename</b>&nbsp;affects the entire script or<i>&nbsp;current shell</i><a href="abs-guides.html#19">. Redirection in the PID of the script or shell<br></a>from that point on has changed. However . . .<br>
<b>N &gt; filename</b>&nbsp;affects only the newly-forked process, not the entire script or shell.<br>
Thank you, Ahmed Darwish, for pointing this out.<br>
<b>Example 20-2. Redirecting&nbsp;stdout&nbsp;using<i>&nbsp;exec</i></b><br>
#!/bin/bash<br>
# reassign-stdout.sh<br>
LOGFILE=logfile.txt<br>
exec 6&gt;&amp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Link file descriptor #6 with stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Saves stdout.<br>
exec &gt; $LOGFILE &nbsp; &nbsp; # stdout replaced with file &quot;logfile.txt&quot;.<br>
# ----------------------------------------------------------- #<br>
# All output from commands in this block sent to file $LOGFILE.<br>
echo -n &quot;Logfile: &quot;<br>
date<br>
echo &quot;-------------------------------------&quot;<br>
echo<br>
echo &quot;Output of \&quot;ls -al\&quot; command&quot;<br>
echo<br>
ls -al<br>
echo; echo<br>
echo &quot;Output of \&quot;df\&quot; command&quot;<br>
echo<br>
df<br>
# ----------------------------------------------------------- #<br>
exec 1&gt;&amp;6 6&gt;&amp;- &nbsp; &nbsp; &nbsp;# Restore stdout and close file descriptor #6.<br>
echo<br>
echo &quot;== stdout now restored to default == &quot;<br>
echo<br>
ls -al<br>
echo<br>
exit 0<br>
<b>Example 20-3. Redirecting both&nbsp;stdin&nbsp;and&nbsp;stdout&nbsp;in the same script with<i>&nbsp;exec</i></b><br>
#!/bin/bash<br>
# upperconv.sh<br>
# Converts a specified input file to uppercase.<br>
E_FILE_ACCESS=70<br>
E_WRONG_ARGS=71<br>
if [ ! -r &quot;$1&quot; ] &nbsp; &nbsp; # Is specified input file readable?<br>
then<br>
&nbsp; echo &quot;Can't read from input file!&quot;<br>
Chapter 20. I/O Redirection<br>
372<br>
<hr>
<A name=379></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Usage: $0 input-file output-file&quot;<br>
&nbsp; exit $E_FILE_ACCESS<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Will exit with same error<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ even if input file ($1) not specified (why?).<br>
if [ -z &quot;$2&quot; ]<br>
then<br>
&nbsp; echo &quot;Need to specify output file.&quot;<br>
&nbsp; echo &quot;Usage: $0 input-file output-file&quot;<br>
&nbsp; exit $E_WRONG_ARGS<br>
fi<br>
exec 4&lt;&amp;0<br>
exec &lt; $1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Will read from input file.<br>
exec 7&gt;&amp;1<br>
exec &gt; $2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Will write to output file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Assumes output file writable (add check?).<br>
# -----------------------------------------------<br>
&nbsp; &nbsp; cat - | tr a-z A-Z &nbsp; # Uppercase conversion.<br>
# &nbsp; ^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reads from stdin.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^ &nbsp; # Writes to stdout.<br>
# However, both stdin and stdout were redirected.<br>
# Note that the 'cat' can be omitted.<br>
# -----------------------------------------------<br>
exec 1&gt;&amp;7 7&gt;&amp;- &nbsp; &nbsp; &nbsp; # Restore stout.<br>
exec 0&lt;&amp;4 4&lt;&amp;- &nbsp; &nbsp; &nbsp; # Restore stdin.<br>
# After restoration, the following line prints to stdout as expected.<br>
echo &quot;File \&quot;$1\&quot; written to \&quot;$2\&quot; as uppercase conversion.&quot;<br>
exit 0<br>
<a href="abs-guides.html#388">I/O redirection is a clever way of avoiding the dreaded inaccessible variables within a subshell problem.</a><br>
<b>Example 20-4. Avoiding a subshell</b><br>
#!/bin/bash<br>
# avoid-subshell.sh<br>
# Suggested by Matthew Walker.<br>
Lines=0<br>
echo<br>
cat myfile.txt | while read line;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $line<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(( Lines++ )); &nbsp;# &nbsp;Incremented values of this variable<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ inaccessible outside loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Subshell problem.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done<br>
echo &quot;Number of lines read = $Lines&quot; &nbsp; &nbsp; # 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Wrong!<br>
echo &quot;------------------------&quot;<br>
Chapter 20. I/O Redirection<br>
373<br>
<hr>
<A name=380></a>Advanced Bash-Scripting Guide<br>
exec 3&lt;&gt; myfile.txt<br>
while read line &lt;&amp;3<br>
do {<br>
&nbsp; echo &quot;$line&quot;<br>
&nbsp; (( Lines++ )); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Incremented values of this variable<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ accessible outside loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;No subshell, no problem.<br>
}<br>
done<br>
exec 3&gt;&amp;-<br>
echo &quot;Number of lines read = $Lines&quot; &nbsp; &nbsp; # 8<br>
echo<br>
exit 0<br>
# Lines below not seen by script.<br>
$ cat myfile.txt<br>
Line 1.<br>
Line 2.<br>
Line 3.<br>
Line 4.<br>
Line 5.<br>
Line 6.<br>
Line 7.<br>
Line 8.<br>
<b>20.2. Redirecting Code Blocks</b><br>
<a href="abs-guides.html#153">Blocks of code, such as while, until, and for loops, even if/then test blocks can also incorporate redirection of<br></a>stdin<a href="abs-guides.html#412">. Even a function may use this form of redirection (see Example 24-11). The &lt; operator at the end of<br></a>the code block accomplishes this.<br>
<b>Example 20-5. Redirected<i>&nbsp;while</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# redir2.sh<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; &nbsp; &nbsp; # Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
#+ Filename=${1:-names.data}<br>
# &nbsp;can replace the above test (parameter substitution).<br>
count=0<br>
echo<br>
while [ &quot;$name&quot; != Smith ] &nbsp;# Why is variable $name in quotes?<br>
do<br>
Chapter 20. I/O Redirection<br>
374<br>
<hr>
<A name=381></a>Advanced Bash-Scripting Guide<br>
&nbsp; read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reads from $Filename, rather than stdin.<br>
&nbsp; echo $name<br>
&nbsp; let &quot;count += 1&quot;<br>
done &lt;&quot;$Filename&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Redirects stdin to file $Filename.&nbsp;<br>
# &nbsp; &nbsp;^^^^^^^^^^^^<br>
echo; echo &quot;$count names read&quot;; echo<br>
exit 0<br>
# &nbsp;Note that in some older shell scripting languages,<br>
#+ the redirected loop would run as a subshell.<br>
# &nbsp;Therefore, $count would return 0, the initialized value outside the loop.<br>
# &nbsp;Bash and ksh avoid starting a subshell *whenever possible*,<br>
#+ so that this script, for example, runs correctly.<br>
# &nbsp;(Thanks to Heiner Steven for pointing this out.)<br>
# &nbsp;However . . .<br>
# &nbsp;Bash *can* sometimes start a subshell in a PIPED &quot;while-read&quot; loop,<br>
#+ as distinct from a REDIRECTED &quot;while&quot; loop.<br>
abc=hi<br>
echo -e &quot;1\n2\n3&quot; | while read l<br>
&nbsp; &nbsp; &nbsp;do abc=&quot;$l&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo $abc<br>
&nbsp; &nbsp; &nbsp;done<br>
echo $abc<br>
# &nbsp;Thanks, Bruno de Oliveira Schneider, for demonstrating this<br>
#+ with the above snippet of code.<br>
# &nbsp;And, thanks, Brian Onn, for correcting an annotation error.<br>
<b>Example 20-6. Alternate form of redirected<i>&nbsp;while</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# This is an alternate form of the preceding script.<br>
# &nbsp;Suggested by Heiner Steven<br>
#+ as a workaround in those situations when a redirect loop<br>
#+ runs as a subshell, and therefore variables inside the loop<br>
# +do not keep their values upon loop termination.<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; &nbsp; # Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
exec 3&lt;&amp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Save stdin to file descriptor 3.<br>
exec 0&lt;&quot;$Filename&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Redirect standard input.<br>
count=0<br>
echo<br>
while [ &quot;$name&quot; != Smith ]<br>
do<br>
Chapter 20. I/O Redirection<br>
375<br>
<hr>
<A name=382></a>Advanced Bash-Scripting Guide<br>
&nbsp; read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reads from redirected stdin ($Filename).<br>
&nbsp; echo $name<br>
&nbsp; let &quot;count += 1&quot;<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Loop reads from file $Filename<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ because of line 20.<br>
# &nbsp;The original version of this script terminated the &quot;while&quot; loop with<br>
#+ &nbsp; &nbsp; &nbsp;done &lt;&quot;$Filename&quot;&nbsp;<br>
# &nbsp;Exercise:<br>
# &nbsp;Why is this unnecessary?<br>
exec 0&lt;&amp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Restore old stdin.<br>
exec 3&lt;&amp;- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Close temporary fd 3.<br>
echo; echo &quot;$count names read&quot;; echo<br>
exit 0<br>
<b>Example 20-7. Redirected<i>&nbsp;until</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
# Same as previous example, but with &quot;until&quot; loop.<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; &nbsp; &nbsp; &nbsp; # Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
# while [ &quot;$name&quot; != Smith ]<br>
until [ &quot;$name&quot; = Smith ] &nbsp; &nbsp; # Change &nbsp;!= &nbsp;to =.<br>
do<br>
&nbsp; read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reads from $Filename, rather than stdin.<br>
&nbsp; echo $name<br>
done &lt;&quot;$Filename&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Redirects stdin to file $Filename.&nbsp;<br>
# &nbsp; &nbsp;^^^^^^^^^^^^<br>
# Same results as with &quot;while&quot; loop in previous example.<br>
exit 0<br>
<b>Example 20-8. Redirected<i>&nbsp;for</i></b><b>&nbsp;loop</b><br>
#!/bin/bash<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
line_count=`wc $Filename | awk '{ print $1 }'`<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of lines in target file.<br>
#<br>
# &nbsp;Very contrived and kludgy, nevertheless shows that<br>
#+ it's possible to redirect stdin within a &quot;for&quot; loop...<br>
#+ if you're clever enough.<br>
Chapter 20. I/O Redirection<br>
376<br>
<hr>
<A name=383></a>Advanced Bash-Scripting Guide<br>
#<br>
# More concise is &nbsp; &nbsp; line_count=$(wc -l &lt; &quot;$Filename&quot;)<br>
for name in `seq $line_count` &nbsp;# Recall that &quot;seq&quot; prints sequence of numbers.<br>
# while [ &quot;$name&quot; != Smith ] &nbsp; -- &nbsp; more complicated than a &quot;while&quot; loop &nbsp; --<br>
do<br>
&nbsp; read name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reads from $Filename, rather than stdin.<br>
&nbsp; echo $name<br>
&nbsp; if [ &quot;$name&quot; = Smith ] &nbsp; &nbsp; &nbsp; # Need all this extra baggage here.<br>
&nbsp; then<br>
&nbsp; &nbsp; break<br>
&nbsp; fi &nbsp;<br>
done &lt;&quot;$Filename&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Redirects stdin to file $Filename.&nbsp;<br>
# &nbsp; &nbsp;^^^^^^^^^^^^<br>
exit 0<br>
We can modify the previous example to also redirect the output of the loop.<br>
<b>Example 20-9. Redirected<i>&nbsp;for</i></b><b>&nbsp;loop (both&nbsp;stdin&nbsp;and&nbsp;stdout&nbsp;redirected)</b><br>
#!/bin/bash<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
Savefile=$Filename.new &nbsp; &nbsp; &nbsp; &nbsp; # Filename to save results in.<br>
FinalName=Jonah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Name to terminate &quot;read&quot; on.<br>
line_count=`wc $Filename | awk '{ print $1 }'` &nbsp;# Number of lines in target file.<br>
for name in `seq $line_count`<br>
do<br>
&nbsp; read name<br>
&nbsp; echo &quot;$name&quot;<br>
&nbsp; if [ &quot;$name&quot; = &quot;$FinalName&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; break<br>
&nbsp; fi &nbsp;<br>
done &lt; &quot;$Filename&quot; &gt; &quot;$Savefile&quot; &nbsp; &nbsp; # Redirects stdin to file $Filename,<br>
# &nbsp; &nbsp;^^^^^^^^^^^^^^^^^^^^^^^^^^^ &nbsp; &nbsp; &nbsp; and saves it to backup file.<br>
exit 0<br>
<b>Example 20-10. Redirected<i>&nbsp;if/then</i></b><b>&nbsp;test</b><br>
#!/bin/bash<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; Filename=names.data &nbsp; # Default, if no filename specified.<br>
else<br>
&nbsp; Filename=$1<br>
fi &nbsp;<br>
Chapter 20. I/O Redirection<br>
377<br>
<hr>
<A name=384></a>Advanced Bash-Scripting Guide<br>
TRUE=1<br>
if [ &quot;$TRUE&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# if true &nbsp; &nbsp;and &nbsp; if : &nbsp; also work.<br>
then<br>
&nbsp;read name<br>
&nbsp;echo $name<br>
fi &lt;&quot;$Filename&quot;<br>
# &nbsp;^^^^^^^^^^^^<br>
# Reads only first line of file.<br>
# An &quot;if/then&quot; test has no way of iterating unless embedded in a loop.<br>
exit 0<br>
<b>Example 20-11. Data file<i>&nbsp;names.data</i></b><b>&nbsp;for above examples</b><br>
Aristotle<br>
Belisarius<br>
Capablanca<br>
Euler<br>
Goethe<br>
Hegel<br>
Jonah<br>
Laplace<br>
Maroczy<br>
Purcell<br>
Schmidt<br>
Semmelweiss<br>
Smith<br>
Turing<br>
Venn<br>
Warshawski<br>
Znosko-Borowski<br>
# &nbsp;This is a data file for<br>
#+ &quot;redir2.sh&quot;, &quot;redir3.sh&quot;, &quot;redir4.sh&quot;, &quot;redir4a.sh&quot;, &quot;redir5.sh&quot;.<br>
Redirecting the&nbsp;stdout<a href="abs-guides.html#21">&nbsp;of a code block has the effect of saving its output to a file. See Example 3-2.</a><br>
<a href="abs-guides.html#360">Here documents are a special case of redirected code blocks. That being the case, it should be possible to feed<br></a>the output of a<i>&nbsp;here document</i>&nbsp;into the&nbsp;stdin&nbsp;for a<i>&nbsp;while loop</i>.<br>
# This example by Albert Siersema<br>
# Used with permission (thanks!).<br>
function doesOutput()<br>
&nbsp;# Could be an external command too, of course.<br>
&nbsp;# Here we show you can use a function as well.<br>
{<br>
&nbsp; ls -al *.jpg | awk '{print $5,$9}'<br>
}<br>
nr=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;We want the while loop to be able to manipulate these and<br>
totalSize=0 &nbsp; #+ to be able to see the changes after the 'while' finished.<br>
while read fileSize fileName ; do<br>
&nbsp; echo &quot;$fileName is $fileSize bytes&quot;<br>
&nbsp; let nr++<br>
&nbsp; totalSize=$((totalSize+fileSize)) &nbsp; # Or: &quot;let totalSize+=fileSize&quot;<br>
Chapter 20. I/O Redirection<br>
378<br>
<hr>
<A name=385></a>Advanced Bash-Scripting Guide<br>
done&lt;&lt;EOF<br>
$(doesOutput)<br>
EOF<br>
echo &quot;$nr files totaling $totalSize bytes&quot;<br>
<b>20.3. Applications</b><br>
<a href="abs-guides.html#194">Clever use of I/O redirection permits parsing and stitching together snippets of command output (see Example<br>15-7). This permits generating report and log files.</a><br>
<b>Example 20-12. Logging events</b><br>
#!/bin/bash<br>
# logevents.sh<br>
# Author: Stephane Chazelas.<br>
# Used in ABS Guide with permission.<br>
# Event logging to a file.<br>
# Must be run as root (for write access in /var/log).<br>
ROOT_UID=0 &nbsp; &nbsp; # Only users with $UID 0 have root privileges.<br>
E_NOTROOT=67 &nbsp; # Non-root exit error.<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo &quot;Must be root to run this script.&quot;<br>
&nbsp; exit $E_NOTROOT<br>
fi &nbsp;<br>
FD_DEBUG1=3<br>
FD_DEBUG2=4<br>
FD_DEBUG3=5<br>
# === Uncomment one of the two lines below to activate script. ===<br>
# LOG_EVENTS=1<br>
# LOG_VARS=1<br>
log() &nbsp;# Writes time and date to log file.<br>
{<br>
echo &quot;$(date) &nbsp;$*&quot; &gt;&amp;7 &nbsp; &nbsp; # This *appends* the date to the file.<br>
# &nbsp; &nbsp; ^^^^^^^ &nbsp;command substitution<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# See below.<br>
}<br>
case $LOG_LEVEL in<br>
&nbsp;1) exec 3&gt;&amp;2 &nbsp; &nbsp; &nbsp; &nbsp; 4&gt; /dev/null 5&gt; /dev/null;;<br>
&nbsp;2) exec 3&gt;&amp;2 &nbsp; &nbsp; &nbsp; &nbsp; 4&gt;&amp;2 &nbsp; &nbsp; &nbsp; &nbsp; 5&gt; /dev/null;;<br>
&nbsp;3) exec 3&gt;&amp;2 &nbsp; &nbsp; &nbsp; &nbsp; 4&gt;&amp;2 &nbsp; &nbsp; &nbsp; &nbsp; 5&gt;&amp;2;;<br>
&nbsp;*) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;<br>
esac<br>
FD_LOGVARS=6<br>
Chapter 20. I/O Redirection<br>
379<br>
<hr>
<A name=386></a>Advanced Bash-Scripting Guide<br>
if [[ $LOG_VARS ]]<br>
then exec 6&gt;&gt; /var/log/vars.log<br>
else exec 6&gt; /dev/null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bury output.<br>
fi<br>
FD_LOGEVENTS=7<br>
if [[ $LOG_EVENTS ]]<br>
then<br>
&nbsp; # exec 7 &gt;(exec gawk '{print strftime(), $0}' &gt;&gt; /var/log/event.log)<br>
&nbsp; # Above line fails in versions of Bash more recent than 2.04. Why?<br>
&nbsp; exec 7&gt;&gt; /var/log/event.log &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Append to &quot;event.log&quot;.<br>
&nbsp; log &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Write time and date.<br>
else exec 7&gt; /dev/null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bury output.<br>
fi<br>
echo &quot;DEBUG3: beginning&quot; &gt;&amp;${FD_DEBUG3}<br>
ls -l &gt;&amp;5 2&gt;&amp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # command1 &gt;&amp;5 2&gt;&amp;4<br>
echo &quot;Done&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# command2&nbsp;<br>
echo &quot;sending mail&quot; &gt;&amp;${FD_LOGEVENTS}<br>
# Writes &quot;sending mail&quot; to file descriptor #7.<br>
exit 0<br>
Chapter 20. I/O Redirection<br>
380<br>
<hr>
<A name=387></a><b>Chapter 21. Subshells</b><br>
Running a shell script launches a new process, a<i>&nbsp;subshell</i>.<br>
<b>Definition:</b>&nbsp;A<i>&nbsp;subshell</i><a href="abs-guides.html#42">&nbsp;is a child process launched by a shell (or</a><i>&nbsp;shell script</i>).<br>
A subshell is a separate instance of the command processor -- the<i>&nbsp;shell</i>&nbsp;that gives you the prompt at the<br>console or in an<i>&nbsp;xterm</i>&nbsp;window. Just as your commands are interpreted at the command-line prompt, similarly<br><a href="abs-guides.html#239">does a script batch-process a list of commands. Each shell script running is, in effect, a subprocess (</a><i>child<br>process</i><a href="abs-guides.html#186">) of the parent shell.</a><br>
A shell script can itself launch subprocesses. These<i>&nbsp;subshells</i>&nbsp;let the script do parallel processing, in effect<br>executing multiple subtasks simultaneously.<br>
#!/bin/bash<br>
# subshell-test.sh<br>
(<br>
# Inside parentheses, and therefore a subshell . . .<br>
while [ 1 ] &nbsp; # Endless loop.<br>
do<br>
&nbsp; echo &quot;Subshell running . . .&quot;<br>
done<br>
)<br>
# &nbsp;Script will run forever,<br>
#+ or at least until terminated by a Ctl-C.<br>
exit $? &nbsp;# End of script (but will never get here).<br>
Now, run the script:<br>
sh subshell-test.sh<br>
And, while the script is running, from a different xterm:<br>
ps -ef | grep subshell-test.sh<br>
UID &nbsp; &nbsp; &nbsp; PID &nbsp; PPID &nbsp;C STIME TTY &nbsp; &nbsp; &nbsp;TIME &nbsp; &nbsp; CMD<br>
500 &nbsp; &nbsp; &nbsp; 2698 &nbsp;2502 &nbsp;0 14:26 pts/4 &nbsp; &nbsp;00:00:00 sh subshell-test.sh<br>
500 &nbsp; &nbsp; &nbsp; 2699 &nbsp;2698 21 14:26 pts/4 &nbsp; &nbsp;00:00:24 sh subshell-test.sh<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^<br>
Analysis:<br>
PID 2698, the script, launched PID 2699, the subshell.<br>
Note: The &quot;UID ...&quot; line would be filtered out by the &quot;grep&quot; command,<br>
but is shown here for illustrative purposes.<br>
<a href="abs-guides.html#220">In general, an external command in a script forks off a subprocess,&nbsp;</a><a href="abs-guides.html#186">[104] whereas a Bash builtin does not. For<br></a>this reason, builtins execute more quickly and use fewer system resources than their external command<br>equivalents.<br>
<b>Command List within Parentheses</b><br>
Chapter 21. Subshells<br>
381<br>
<hr>
<A name=388></a>Advanced Bash-Scripting Guide<br>
( command1; command2; command3; ... )<br>
A command list embedded between&nbsp;<i>parentheses</i>&nbsp;runs as a subshell.<br>
Variables in a subshell are<i>&nbsp;not</i>&nbsp;visible outside the block of code in the subshell. They are not accessible to the<br><a href="abs-guides.html#186">parent process, to the shell that launched the subshell. These are, in effect, variables local to the</a><i>&nbsp;child process</i>.<br>
<b>Example 21-1. Variable scope in a subshell</b><br>
#!/bin/bash<br>
# subshell.sh<br>
echo<br>
echo &quot;We are outside the subshell.&quot;<br>
echo &quot;Subshell level OUTSIDE subshell = $BASH_SUBSHELL&quot;<br>
# Bash, version 3, adds the new &nbsp; &nbsp; &nbsp; &nbsp; $BASH_SUBSHELL variable.<br>
echo; echo<br>
outer_variable=Outer<br>
global_variable=<br>
# &nbsp;Define global variable for &quot;storage&quot; of<br>
#+ value of subshell variable.<br>
(<br>
echo &quot;We are inside the subshell.&quot;<br>
echo &quot;Subshell level INSIDE subshell = $BASH_SUBSHELL&quot;<br>
inner_variable=Inner<br>
echo &quot;From inside subshell, \&quot;inner_variable\&quot; = $inner_variable&quot;<br>
echo &quot;From inside subshell, \&quot;outer\&quot; = $outer_variable&quot;<br>
global_variable=&quot;$inner_variable&quot; &nbsp; # &nbsp;Will this allow &quot;exporting&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ a subshell variable?<br>
)<br>
echo; echo<br>
echo &quot;We are outside the subshell.&quot;<br>
echo &quot;Subshell level OUTSIDE subshell = $BASH_SUBSHELL&quot;<br>
echo<br>
if [ -z &quot;$inner_variable&quot; ]<br>
then<br>
&nbsp; echo &quot;inner_variable undefined in main body of shell&quot;<br>
else<br>
&nbsp; echo &quot;inner_variable defined in main body of shell&quot;<br>
fi<br>
echo &quot;From main body of shell, \&quot;inner_variable\&quot; = $inner_variable&quot;<br>
# &nbsp;$inner_variable will show as blank (uninitialized)<br>
#+ because variables defined in a subshell are &quot;local variables&quot;.<br>
# &nbsp;Is there a remedy for this?<br>
echo &quot;global_variable = &quot;$global_variable&quot;&quot; &nbsp;# Why doesn't this work?<br>
echo<br>
# =======================================================================<br>
# Additionally ...<br>
Chapter 21. Subshells<br>
382<br>
<hr>
<A name=389></a><IMG src="abs-guide-389_1.png"><br>
Advanced Bash-Scripting Guide<br>
echo &quot;-----------------&quot;; echo<br>
var=41 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Global variable.<br>
( let &quot;var+=1&quot;; echo &quot;\$var INSIDE subshell = $var&quot; ) &nbsp;# 42<br>
echo &quot;\$var OUTSIDE subshell = $var&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 41<br>
# &nbsp;Variable operations inside a subshell, even to a GLOBAL variable<br>
#+ do not affect the value of the variable outside the subshell!<br>
exit 0<br>
# &nbsp;Question:<br>
# &nbsp;--------<br>
# &nbsp;Once having exited a subshell,<br>
#+ is there any way to reenter that very same subshell<br>
#+ to modify or access the subshell variables?<br>
<a href="abs-guides.html#91">See also $BASHPID and Example 34-2.</a><br>
<b>Definition:</b>&nbsp;The<i>&nbsp;scope</i>&nbsp;of a variable is the context in which it has meaning, in which it has a<i>&nbsp;value</i>&nbsp;that<br><a href="abs-guides.html#413">can be referenced. For example, the scope of a local variable lies only within the function, block of code, or<br></a>subshell within which it is defined, while the scope of a<i>&nbsp;global</i>&nbsp;variable is the entire script in which it<br>appears.<br>
<a href="abs-guides.html#91">While the $BASH_SUBSHELL internal variable indicates the nesting level of a subshell, the $SHLVL<br></a>variable<i>&nbsp;shows no change</i>&nbsp;within a subshell.<br>
echo &quot; \$BASH_SUBSHELL outside subshell &nbsp; &nbsp; &nbsp; = $BASH_SUBSHELL&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0<br>
&nbsp; ( echo &quot; \$BASH_SUBSHELL inside subshell &nbsp; &nbsp; &nbsp; &nbsp;= $BASH_SUBSHELL&quot; ) &nbsp; &nbsp; # 1<br>
&nbsp; ( ( echo &quot; \$BASH_SUBSHELL inside nested subshell = $BASH_SUBSHELL&quot; ) ) # 2<br>
# ^ ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *** nested *** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ ^<br>
echo<br>
echo &quot; \$SHLVL outside subshell = $SHLVL&quot; &nbsp; &nbsp; &nbsp; # 3<br>
( echo &quot; \$SHLVL inside subshell &nbsp;= $SHLVL&quot; ) &nbsp; # 3 (No change!)<br>
Directory changes made in a subshell do not carry over to the parent shell.<br>
<b>Example 21-2. List User Profiles</b><br>
#!/bin/bash<br>
# allprofs.sh: Print all user profiles.<br>
# This script written by Heiner Steven, and modified by the document author.<br>
FILE=.bashrc &nbsp;# &nbsp;File containing user profile,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ was &quot;.profile&quot; in original script.<br>
for home in `awk -F: '{print $6}' /etc/passwd`<br>
do<br>
&nbsp; [ -d &quot;$home&quot; ] || continue &nbsp; &nbsp;# If no home directory, go to next.<br>
&nbsp; [ -r &quot;$home&quot; ] || continue &nbsp; &nbsp;# If not readable, go to next.<br>
&nbsp; (cd $home; [ -e $FILE ] &amp;&amp; less $FILE)<br>
Chapter 21. Subshells<br>
383<br>
<hr>
<A name=390></a>Advanced Bash-Scripting Guide<br>
done<br>
# &nbsp;When script terminates, there is no need to 'cd' back to original directory,<br>
#+ because 'cd $home' takes place in a subshell.<br>
exit 0<br>
A subshell may be used to set up a &quot;dedicated environment&quot; for a command group.<br>
COMMAND1<br>
COMMAND2<br>
COMMAND3<br>
(<br>
&nbsp; IFS=:<br>
&nbsp; PATH=/bin<br>
&nbsp; unset TERMINFO<br>
&nbsp; set -C<br>
&nbsp; shift 5<br>
&nbsp; COMMAND4<br>
&nbsp; COMMAND5<br>
&nbsp; exit 3 # Only exits the subshell!<br>
)<br>
# The parent shell has not been affected, and the environment is preserved.<br>
COMMAND6<br>
COMMAND7<br>
<a href="abs-guides.html#212">As seen here, the exit command only terminates the subshell in which it is running,</a><i>&nbsp;not</i>&nbsp;the parent shell or<br>script.<br>
One application of such a &quot;dedicated environment&quot; is testing whether a variable is defined.<br>
if (set -u; : $variable) 2&gt; /dev/null<br>
then<br>
&nbsp; echo &quot;Variable is set.&quot;<br>
fi &nbsp; &nbsp; # &nbsp;Variable has been set in current script,<br>
&nbsp; &nbsp; &nbsp; &nbsp;#+ or is an an internal Bash variable,<br>
&nbsp; &nbsp; &nbsp; &nbsp;#+ or is present in environment (has been exported).<br>
# Could also be written [[ ${variable-x} != x || ${variable-y} != y ]]<br>
# or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[[ ${variable-x} != x$variable ]]<br>
# or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[[ ${variable+x} = x ]]<br>
# or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[[ ${variable-x} != x ]]<br>
Another application is checking for a lock file:<br>
if (set -C; : &gt; lock_file) 2&gt; /dev/null<br>
then<br>
&nbsp; : &nbsp; # lock_file didn't exist: no user running the script<br>
else<br>
&nbsp; echo &quot;Another user is already running that script.&quot;<br>
exit 65<br>
fi<br>
# &nbsp;Code snippet by Stéphane Chazelas,<br>
#+ with modifications by Paulo Marcel Coelho Aragao.<br>
+<br>
Processes may execute in parallel within different subshells. This permits breaking a complex task into<br>subcomponents processed concurrently.<br>
Chapter 21. Subshells<br>
384<br>
<hr>
<A name=391></a><IMG src="abs-guide-391_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>Example 21-3. Running parallel processes in subshells</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; (cat list1 list2 list3 | sort | uniq &gt; list123) &amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; (cat list4 list5 list6 | sort | uniq &gt; list456) &amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Merges and sorts both sets of lists simultaneously.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Running in background ensures parallel execution.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Same effect as<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; cat list1 list2 list3 | sort | uniq &gt; list123 &amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; cat list4 list5 list6 | sort | uniq &gt; list456 &amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; wait &nbsp; # Don't execute the next command until subshells finish.<br>
&nbsp; &nbsp; &nbsp; &nbsp; diff list123 list456<br>
Redirecting I/O to a subshell uses the &quot;|&quot; pipe operator, as in&nbsp;<b>ls -al | (command)</b>.<br>
<a href="abs-guides.html#20">A code block between curly brackets does</a><i>&nbsp;not</i>&nbsp;launch a subshell.<br>
{ command1; command2; command3; . . . commandN; }<br>
var1=23<br>
echo &quot;$var1&quot; &nbsp; # 23<br>
{ var1=76; }<br>
echo &quot;$var1&quot; &nbsp; # 76<br>
Chapter 21. Subshells<br>
385<br>
<hr>
<A name=392></a><b>Chapter 22. Restricted Shells</b><br>
<b>Disabled commands in restricted shells</b><br>
<b>.</b>&nbsp;Running a script or portion of a script in<i>&nbsp;restricted mode</i>&nbsp;disables certain commands that would<br>otherwise be available. This is a security measure intended to limit the privileges of the script user and<br>to minimize possible damage from running the script.<br>
The following commands and actions are disabled:<br>
Using&nbsp;<br>
•&nbsp;<br>
<i>cd</i>&nbsp;to change the working directory.<br>
Changing the values of the&nbsp;<br>
•&nbsp;<br>
<i>$PATH</i>,&nbsp;<i>$SHELL</i>,&nbsp;<i>$BASH_ENV</i>, or&nbsp;<i>$ENV</i><a href="abs-guides.html#41">&nbsp;environmental variables.</a><br>
Reading or changing the&nbsp;<br>
•&nbsp;<br>
<i>$SHELLOPTS</i>, shell environmental options.<br>
Output redirection.<br>
•&nbsp;<br>
Invoking commands containing one or more /'s.<br>
•&nbsp;<br>
<a href="abs-guides.html#212">Invoking exec to substitute a different process for the shell.</a><br>
•&nbsp;<br>
Various other commands that would enable monkeying with or attempting to subvert the script for an<br>
•&nbsp;<br>
unintended purpose.<br>Getting out of restricted mode within the script.<br>
•&nbsp;<br>
<b>Example 22-1. Running a script in restricted mode</b><br>
#!/bin/bash<br>
# &nbsp;Starting the script with &quot;#!/bin/bash -r&quot;<br>
#+ runs entire script in restricted mode.<br>
echo<br>
echo &quot;Changing directory.&quot;<br>
cd /usr/local<br>
echo &quot;Now in `pwd`&quot;<br>
echo &quot;Coming back home.&quot;<br>
cd<br>
echo &quot;Now in `pwd`&quot;<br>
echo<br>
# Everything up to here in normal, unrestricted mode.<br>
set -r<br>
# set --restricted &nbsp; &nbsp;has same effect.<br>
echo &quot;==&gt; Now in restricted mode. &lt;==&quot;<br>
echo<br>
echo<br>
echo &quot;Attempting directory change in restricted mode.&quot;<br>
cd ..<br>
echo &quot;Still in `pwd`&quot;<br>
echo<br>
echo<br>
echo &quot;\$SHELL = $SHELL&quot;<br>
echo &quot;Attempting to change shell in restricted mode.&quot;<br>
Chapter 22. Restricted Shells<br>
386<br>
<hr>
<A name=393></a>Advanced Bash-Scripting Guide<br>
SHELL=&quot;/bin/ash&quot;<br>
echo<br>
echo &quot;\$SHELL= $SHELL&quot;<br>
echo<br>
echo<br>
echo &quot;Attempting to redirect output in restricted mode.&quot;<br>
ls -l /usr/bin &gt; bin.files<br>
ls -l bin.files &nbsp; &nbsp;# Try to list attempted file creation effort.<br>
echo<br>
exit 0<br>
Chapter 22. Restricted Shells<br>
387<br>
<hr>
<A name=394></a><IMG src="abs-guide-394_1.png"><br>
<IMG src="abs-guide-394_2.png"><br>
<b>Chapter 23. Process Substitution</b><br>
<a href="abs-guides.html#24">Piping the&nbsp;</a>stdout&nbsp;of a command into the&nbsp;stdin&nbsp;of another is a powerful technique. But, what if you need<br>to pipe the&nbsp;stdout&nbsp;of<i>&nbsp;multiple</i>&nbsp;commands? This is where&nbsp;<i>process substitution</i>&nbsp;comes in.<br>
<i>Process substitution</i><a href="abs-guides.html#882">&nbsp;feeds the output of a process (or processes) into the&nbsp;</a>stdin&nbsp;of another process.<br>
<b>Template</b><br>
Command list enclosed within parentheses<br>
<b>&gt;(command_list)</b><br>
<b>&lt;(command_list)</b><br>
Process substitution uses&nbsp;/dev/fd/&lt;n&gt;&nbsp;files to send the results of the process(es) within<br>parentheses to another process.&nbsp;[105]<br>
There is<i>&nbsp;no</i>&nbsp;space between the the &quot;&lt;&quot; or &quot;&gt;&quot; and the parentheses. Space there would<br>give an error message.<br>
bash$&nbsp;<b>echo &gt;(true)<br></b>/dev/fd/63<br>
bash$&nbsp;<b>echo &lt;(true)<br></b>/dev/fd/63<br>
bash$&nbsp;<b>echo &gt;(true) &lt;(true)<br></b>/dev/fd/63 /dev/fd/62<br>
bash$&nbsp;<b>wc &lt;(cat /usr/share/dict/linux.words)</b><br>
483523 &nbsp;483523 4992010 /dev/fd/63<br>
bash$&nbsp;<b>grep script /usr/share/dict/linux.words | wc</b><br>
&nbsp; &nbsp;262 &nbsp; &nbsp; 262 &nbsp; &nbsp;3601<br>
bash$&nbsp;<b>wc &lt;(grep script /usr/share/dict/linux.words)</b><br>
&nbsp; &nbsp;262 &nbsp; &nbsp; 262 &nbsp; &nbsp;3601 /dev/fd/63<br>
<a href="abs-guides.html#374">Bash creates a pipe with two file descriptors,&nbsp;</a>--fIn&nbsp;and&nbsp;fOut--. The&nbsp;stdin<a href="abs-guides.html#214">&nbsp;of true connects to<br></a>fOut&nbsp;(dup2(fOut, 0)), then Bash passes a&nbsp;/dev/fd/fIn&nbsp;argument to<b>&nbsp;echo</b>. On systems lacking<br>/dev/fd/&lt;n&gt;&nbsp;files, Bash may use temporary files. (Thanks, S.C.)<br>
Process substitution can compare the output of two different commands, or even the output of different<br>options to the same command.<br>
bash$&nbsp;<b>comm &lt;(ls -l) &lt;(ls -al)<br></b>total 12<br>
-rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp; 78 Mar 10 12:58 File0<br>
-rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp; 42 Mar 10 12:58 File2<br>
-rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp;103 Mar 10 12:58 t2.sh<br>
&nbsp; &nbsp; &nbsp; &nbsp; total 20<br>
&nbsp; &nbsp; &nbsp; &nbsp; drwxrwxrwx &nbsp; &nbsp;2 bozo bozo &nbsp; &nbsp; 4096 Mar 10 18:10 .<br>
Chapter 23. Process Substitution<br>
388<br>
<hr>
<A name=395></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; drwx------ &nbsp; 72 bozo bozo &nbsp; &nbsp; 4096 Mar 10 17:58 ..<br>
&nbsp; &nbsp; &nbsp; &nbsp; -rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp; 78 Mar 10 12:58 File0<br>
&nbsp; &nbsp; &nbsp; &nbsp; -rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp; 42 Mar 10 12:58 File2<br>
&nbsp; &nbsp; &nbsp; &nbsp; -rw-rw-r-- &nbsp; &nbsp;1 bozo bozo &nbsp; &nbsp; &nbsp;103 Mar 10 12:58 t2.sh<br>
Process substitution can compare the contents of two directories -- to see which filenames are in one, but not<br>the other.<br>
diff &lt;(ls $first_directory) &lt;(ls $second_directory)<br>
Some other usages and uses of process substitution:<br>
read -a list &lt; &lt;( od -Ad -w24 -t u2 /dev/urandom )<br>
# &nbsp;Read a list of random numbers from /dev/urandom,<br>
#+ process with &quot;od&quot;<br>
#+ and feed into stdin of &quot;read&quot; . . .<br>
# &nbsp;From &quot;insertion-sort.bash&quot; example script.<br>
# &nbsp;Courtesy of JuanJo Ciarlante.<br>
PORT=6881 &nbsp; # bittorrent<br>
# Scan the port to make sure nothing nefarious is going on.<br>
netcat -l $PORT | tee&gt;(md5sum -&gt;mydata-orig.md5) |<br>
gzip | tee&gt;(md5sum - | sed 's/-$/mydata.lz2/'&gt;mydata-gz.md5)&gt;mydata.gz<br>
# Check the decompression:<br>
&nbsp; gzip -d&lt;mydata.gz | md5sum -c mydata-orig.md5)<br>
# The MD5sum of the original checks stdin and detects compression issues.<br>
# &nbsp;Bill Davidsen contributed this example<br>
#+ (with light edits by the ABS Guide author).<br>
cat &lt;(ls -l)<br>
# Same as &nbsp; &nbsp; ls -l | cat<br>
sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)<br>
# Lists all the files in the 3 main 'bin' directories, and sorts by filename.<br>
# Note that three (count 'em) distinct commands are fed to 'sort'.<br>
diff &lt;(command1) &lt;(command2) &nbsp; &nbsp;# Gives difference in command output.<br>
tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name<br>
# Calls &quot;tar cf /dev/fd/?? $directory_name&quot;, and &quot;bzip2 -c &gt; file.tar.bz2&quot;.<br>
#<br>
# Because of the /dev/fd/&lt;n&gt; system feature,<br>
# the pipe between both commands does not need to be named.<br>
#<br>
# This can be emulated.<br>
#<br>
bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;<br>
tar cf pipe $directory_name<br>
rm pipe<br>
# &nbsp; &nbsp; &nbsp; &nbsp;or<br>
exec 3&gt;&amp;1<br>
tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-<br>
exec 3&gt;&amp;-<br>
Chapter 23. Process Substitution<br>
389<br>
<hr>
<A name=396></a>Advanced Bash-Scripting Guide<br>
# Thanks, Stéphane Chazelas<br>
Here is a method of circumventing the problem of an&nbsp;<a href="abs-guides.html#495"><i>echo</i>&nbsp;piped to a<i>&nbsp;while-read loop</i></a>&nbsp;running in a subshell.<br>
<b>Example 23-1. Code block redirection without forking</b><br>
#!/bin/bash<br>
# wr-ps.bash: while-read loop with process substitution.<br>
# This example contributed by Tomas Pospisek.<br>
# (Heavily edited by the ABS Guide author.)<br>
echo<br>
echo &quot;random input&quot; | while read i<br>
do<br>
&nbsp; global=3D&quot;: Not available outside the loop.&quot;<br>
&nbsp; # ... because it runs in a subshell.<br>
done<br>
echo &quot;\$global (from outside the subprocess) = $global&quot;<br>
# $global (from outside the subprocess) =<br>
echo; echo &quot;--&quot;; echo<br>
while read i<br>
do<br>
&nbsp; echo $i<br>
&nbsp; global=3D&quot;: Available outside the loop.&quot;<br>
&nbsp; # ... because it does *not* run in a subshell.<br>
done &lt; &lt;( echo &quot;random input&quot; )<br>
# &nbsp; &nbsp;^ ^<br>
echo &quot;\$global (using process substitution) = $global&quot;<br>
# Random input<br>
# $global (using process substitution) = 3D: Available outside the loop.<br>
echo; echo &quot;##########&quot;; echo<br>
# And likewise . . .<br>
declare -a inloop<br>
index=0<br>
cat $0 | while read line<br>
do<br>
&nbsp; inloop[$index]=&quot;$line&quot;<br>
&nbsp; ((index++))<br>
&nbsp; # It runs in a subshell, so ...<br>
done<br>
echo &quot;OUTPUT = &quot;<br>
echo ${inloop[*]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ... nothing echoes.<br>
echo; echo &quot;--&quot;; echo<br>
declare -a outloop<br>
Chapter 23. Process Substitution<br>
390<br>
<hr>
<A name=397></a>Advanced Bash-Scripting Guide<br>
index=0<br>
while read line<br>
do<br>
&nbsp; outloop[$index]=&quot;$line&quot;<br>
&nbsp; ((index++))<br>
&nbsp; # It does *not* run in a subshell, so ...<br>
done &lt; &lt;( cat $0 )<br>
echo &quot;OUTPUT = &quot;<br>
echo ${outloop[*]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ... the entire script echoes.<br>
exit $?<br>
This is a similar example.<br>
<b>Example 23-2. Redirecting the output of<i>&nbsp;process substitution</i></b><b>&nbsp;into a loop.</b><br>
#!/bin/bash<br>
# psub.bash<br>
# As inspired by Diego Molina (thanks!).<br>
declare -a array0<br>
while read<br>
do<br>
&nbsp; array0[${#array0[@]}]=&quot;$REPLY&quot;<br>
done &lt; &lt;( sed -e 's/bash/CRASH-BANG!/' $0 | grep bin | awk '{print $1}' )<br>
# &nbsp;Sets the default 'read' variable, $REPLY, by process substitution,<br>
#+ then copies it into an array.<br>
echo &quot;${array0[@]}&quot;<br>
exit $?<br>
# ====================================== #<br>
bash psub.bash<br>
#!/bin/CRASH-BANG! done #!/bin/CRASH-BANG!<br>
A reader sent in the following interesting example of process substitution.<br>
# Script fragment taken from SuSE distribution:<br>
# --------------------------------------------------------------#<br>
while read &nbsp;des what mask iface; do<br>
# Some commands ...<br>
done &lt; &lt;(route -n) &nbsp;<br>
# &nbsp; &nbsp;^ ^ &nbsp;First &lt; is redirection, second is process substitution.<br>
# To test it, let's make it do something.<br>
while read &nbsp;des what mask iface; do<br>
&nbsp; echo $des $what $mask $iface<br>
done &lt; &lt;(route -n) &nbsp;<br>
# Output:<br>
# Kernel IP routing table<br>
# Destination Gateway Genmask Flags Metric Ref Use Iface<br>
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo<br>
# --------------------------------------------------------------#<br>
# &nbsp;As Stéphane Chazelas points out,<br>
Chapter 23. Process Substitution<br>
391<br>
<hr>
<A name=398></a>Advanced Bash-Scripting Guide<br>
#+ an easier-to-understand equivalent is:<br>
route -n |<br>
&nbsp; while read des what mask iface; do &nbsp; # Variables set from output of pipe.<br>
&nbsp; &nbsp; echo $des $what $mask $iface<br>
&nbsp; done &nbsp;# &nbsp;This yields the same output as above.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;However, as Ulrich Gayer points out . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ this simplified equivalent uses a subshell for the while loop,<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ and therefore the variables disappear when the pipe terminates.<br>
# --------------------------------------------------------------#<br>
# &nbsp;However, Filip Moritz comments that there is a subtle difference<br>
#+ between the above two examples, as the following shows.<br>
(<br>
route -n | while read x; do ((y++)); done<br>
echo $y # $y is still unset<br>
while read x; do ((y++)); done &lt; &lt;(route -n)<br>
echo $y # $y has the number of lines of output of route -n<br>
)<br>
More generally spoken<br>
(<br>
: | x=x<br>
# seems to start a subshell like<br>
: | ( x=x )<br>
# while<br>
x=x &lt; &lt;(:)<br>
# does not<br>
)<br>
# This is useful, when parsing csv and the like.<br>
# That is, in effect, what the original SuSE code fragment does.<br>
Chapter 23. Process Substitution<br>
392<br>
<hr>
<A name=399></a><IMG src="abs-guide-399_1.png"><br>
<b>Chapter 24. Functions</b><br>
Like &quot;real&quot; programming languages, Bash has functions, though in a somewhat limited implementation. A<br><a href="abs-guides.html#20">function is a subroutine, a code block that implements a set of operations, a &quot;black box&quot; that performs a<br></a>specified task. Wherever there is repetitive code, when a task repeats with only slight variations in procedure,<br>then consider using a function.<br>
<b>function&nbsp;</b><i>function_name</i>&nbsp;{<br><i>command</i>...<br>}<br>
or<br>
<i>function_name</i>&nbsp;() {<br><i>command</i>...<br>}<br>
<a href="abs-guides.html#538">This second form will cheer the hearts of C programmers (and is more portable).</a><br>
As in C, the function's opening bracket may optionally appear on the second line.<br>
<i>function_name</i>&nbsp;()<br>{<br><i>command</i>...<br>}<br>
A function may be &quot;compacted&quot; into a single line.<br>
fun () { echo &quot;This is a function&quot;; echo; }<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; ^<br>
In this case, however, a<i>&nbsp;semicolon</i>&nbsp;must follow the final command in the function.<br>
fun () { echo &quot;This is a function&quot;; echo } # Error!<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
fun2 () { echo &quot;Even a single-command function? Yes!&quot;; }<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
Functions are called,<i>&nbsp;triggered</i>, simply by invoking their names.<i>&nbsp;A function call is equivalent to a command.</i><br>
<b>Example 24-1. Simple functions</b><br>
#!/bin/bash<br>
JUST_A_SECOND=1<br>
funky ()<br>
{ # This is about as simple as functions get.<br>
&nbsp; echo &quot;This is a funky function.&quot;<br>
&nbsp; echo &quot;Now exiting funky function.&quot;<br>
} # Function declaration must precede call.<br>
Chapter 24. Functions<br>
393<br>
<hr>
<A name=400></a><IMG src="abs-guide-400_1.png"><br>
Advanced Bash-Scripting Guide<br>
fun ()<br>
{ # A somewhat more complex function.<br>
&nbsp; i=0<br>
&nbsp; REPEATS=30<br>
&nbsp; echo<br>
&nbsp; echo &quot;And now the fun really begins.&quot;<br>
&nbsp; echo<br>
&nbsp; sleep $JUST_A_SECOND &nbsp; &nbsp;# Hey, wait a second!<br>
&nbsp; while [ $i -lt $REPEATS ]<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;----------FUNCTIONS----------&gt;&quot;<br>
&nbsp; &nbsp; echo &quot;&lt;------------ARE-------------&quot;<br>
&nbsp; &nbsp; echo &quot;&lt;------------FUN------------&gt;&quot;<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; let &quot;i+=1&quot;<br>
&nbsp; done<br>
}<br>
&nbsp; # Now, call the functions.<br>
funky<br>
fun<br>
exit 0<br>
The function definition must precede the first call to it. There is no method of &quot;declaring&quot; the function, as, for<br>example, in C.<br>
f1<br>
# Will give an error message, since function &quot;f1&quot; not yet defined.<br>
declare -f f1 &nbsp; &nbsp; &nbsp;# This doesn't help either.<br>
f1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Still an error message.<br>
# However...<br>
f1 ()<br>
{<br>
&nbsp; echo &quot;Calling function \&quot;f2\&quot; from within function \&quot;f1\&quot;.&quot;<br>
&nbsp; f2<br>
}<br>
f2 ()<br>
{<br>
&nbsp; echo &quot;Function \&quot;f2\&quot;.&quot;<br>
}<br>
f1 &nbsp;# &nbsp;Function &quot;f2&quot; is not actually called until this point,<br>
&nbsp; &nbsp; #+ although it is referenced before its definition.<br>
&nbsp; &nbsp; # &nbsp;This is permissible.<br>
&nbsp; &nbsp; # Thanks, S.C.<br>
Functions may not be empty!<br>
Chapter 24. Functions<br>
394<br>
<hr>
<A name=401></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# empty-function.sh<br>
empty ()<br>
{<br>
}<br>
exit 0 &nbsp;# Will not exit here!<br>
# $ sh empty-function.sh<br>
# empty-function.sh: line 6: syntax error near unexpected token `}'<br>
# empty-function.sh: line 6: `}'<br>
# $ echo $?<br>
# 2<br>
# Note that a function containing only comments is empty.<br>
func ()<br>
{<br>
&nbsp; # Comment 1.<br>
&nbsp; # Comment 2.<br>
&nbsp; # This is still an empty function.<br>
&nbsp; # Thank you, Mark Bova, for pointing this out.<br>
}<br>
# Results in same error message as above.<br>
# However ...<br>
not_quite_empty ()<br>
{<br>
&nbsp; illegal_command<br>
} # &nbsp;A script containing this function will *not* bomb<br>
&nbsp; #+ as long as the function is not called.<br>
# Thank you, Thiemo Kellner, for pointing this out.<br>
It is even possible to nest a function within another function, although this is not very useful.<br>
f1 ()<br>
{<br>
&nbsp; f2 () # nested<br>
&nbsp; {<br>
&nbsp; &nbsp; echo &quot;Function \&quot;f2\&quot;, inside \&quot;f1\&quot;.&quot;<br>
&nbsp; }<br>
} &nbsp;<br>
f2 &nbsp;# &nbsp;Gives an error message.<br>
&nbsp; &nbsp; # &nbsp;Even a preceding &quot;declare -f f2&quot; wouldn't help.<br>
echo &nbsp; &nbsp;<br>
f1 &nbsp;# &nbsp;Does nothing, since calling &quot;f1&quot; does not automatically call &quot;f2&quot;.<br>
f2 &nbsp;# &nbsp;Now, it's all right to call &quot;f2&quot;,<br>
&nbsp; &nbsp; #+ since its definition has been made visible by calling &quot;f1&quot;.<br>
&nbsp; &nbsp; # Thanks, S.C.<br>
Chapter 24. Functions<br>
395<br>
<hr>
<A name=402></a>Advanced Bash-Scripting Guide<br>
Function declarations can appear in unlikely places, even where a command would otherwise go.<br>
ls -l | foo() { echo &quot;foo&quot;; } &nbsp;# Permissible, but useless.<br>
if [ &quot;$USER&quot; = bozo ]<br>
then<br>
&nbsp; bozo_greet () &nbsp; # Function definition embedded in an if/then construct.<br>
&nbsp; {<br>
&nbsp; &nbsp; echo &quot;Hello, Bozo.&quot;<br>
&nbsp; }<br>
fi &nbsp;<br>
bozo_greet &nbsp; &nbsp; &nbsp; &nbsp;# Works only for Bozo, and other users get an error.<br>
# Something like this might be useful in some contexts.<br>
NO_EXIT=1 &nbsp; # Will enable function definition below.<br>
[[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; } &nbsp; &nbsp; # Function definition in an &quot;and-list&quot;.<br>
# If $NO_EXIT is 1, declares &quot;exit ()&quot;.<br>
# This disables the &quot;exit&quot; builtin by aliasing it to &quot;true&quot;.<br>
exit &nbsp;# Invokes &quot;exit ()&quot; function, not &quot;exit&quot; builtin.<br>
# Or, similarly:<br>
filename=file1<br>
[ -f &quot;$filename&quot; ] &amp;&amp;<br>
foo () { rm -f &quot;$filename&quot;; echo &quot;File &quot;$filename&quot; deleted.&quot;; } ||<br>
foo () { echo &quot;File &quot;$filename&quot; not found.&quot;; touch bar; }<br>
foo<br>
# Thanks, S.C. and Christopher Head<br>
Function names can take strange forms.<br>
&nbsp; _(){ for i in {1..10}; do echo -n &quot;$FUNCNAME&quot;; done; echo; }<br>
# ^^^ &nbsp; &nbsp; &nbsp; &nbsp; No space between function name and parentheses.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This doesn't always work. Why not?<br>
# Now, let's invoke the function.<br>
&nbsp; _ &nbsp; &nbsp; &nbsp; &nbsp; # __________<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^ &nbsp; 10 underscores (10 x function name)! &nbsp;<br>
# A &quot;naked&quot; underscore is an acceptable function name.<br>
# In fact, a colon is likewise an acceptable function name.<br>
:(){ echo &quot;:&quot;; }; :<br>
# Of what use is this?<br>
# It's a devious way to obfuscate the code in a script.<br>
<a href="abs-guides.html#756">See also Example A-55</a><br>
Chapter 24. Functions<br>
396<br>
<hr>
<A name=403></a><IMG src="abs-guide-403_1.png"><br>
Advanced Bash-Scripting Guide<br>
What happens when different versions of the same function appear in a script?<br>
# &nbsp;As Yan Chen points out,<br>
# &nbsp;when a function is defined multiple times,<br>
# &nbsp;the final version is what is invoked.<br>
# &nbsp;This is not, however, particularly useful.<br>
func ()<br>
{<br>
&nbsp; echo &quot;First version of func ().&quot;<br>
}<br>
func ()<br>
{<br>
&nbsp; echo &quot;Second version of func ().&quot;<br>
}<br>
func &nbsp; # Second version of func ().<br>
exit $?<br>
# &nbsp;It is even possible to use functions to override<br>
#+ or preempt system commands.<br>
# &nbsp;Of course, this is *not* advisable.<br>
<b>24.1. Complex Functions and Function Complexities</b><br>
<a href="abs-guides.html#57">Functions may process arguments passed to them and return an exit status to the script for further processing.</a><br>
function_name $arg1 $arg2<br>
<a href="abs-guides.html#104">The function refers to the passed arguments by position (as if they were positional parameters), that is,&nbsp;</a>$1,<br>$2, and so forth.<br>
<b>Example 24-2. Function Taking Parameters</b><br>
#!/bin/bash<br>
# Functions and parameters<br>
DEFAULT=default &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Default param value.<br>
func2 () {<br>
&nbsp; &nbsp;if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Is parameter #1 zero length?<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;echo &quot;-Parameter #1 is zero length.-&quot; &nbsp;# Or no parameter passed.<br>
&nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp;echo &quot;-Param #1 is \&quot;$1\&quot;.-&quot;<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;variable=${1-$DEFAULT} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;What does<br>
&nbsp; &nbsp;echo &quot;variable = $variable&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ parameter substitution show?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;---------------------------<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;It distinguishes between<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ no param and a null param.<br>
&nbsp; &nbsp;if [ &quot;$2&quot; ]<br>
Chapter 24. Functions<br>
397<br>
<hr>
<A name=404></a><IMG src="abs-guide-404_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;echo &quot;-Parameter #2 is \&quot;$2\&quot;.-&quot;<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;return 0<br>
}<br>
echo<br>
echo &quot;Nothing passed.&quot; &nbsp;&nbsp;<br>
func2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Called with no params<br>
echo<br>
echo &quot;Zero-length parameter passed.&quot;<br>
func2 &quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Called with zero-length param<br>
echo<br>
echo &quot;Null parameter passed.&quot;<br>
func2 &quot;$uninitialized_param&quot; &nbsp; # Called with uninitialized param<br>
echo<br>
echo &quot;One parameter passed.&quot; &nbsp;&nbsp;<br>
func2 first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Called with one param<br>
echo<br>
echo &quot;Two parameters passed.&quot; &nbsp;&nbsp;<br>
func2 first second &nbsp; &nbsp;# Called with two params<br>
echo<br>
echo &quot;\&quot;\&quot; \&quot;second\&quot; passed.&quot;<br>
func2 &quot;&quot; second &nbsp; &nbsp; &nbsp; # Called with zero-length first parameter<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# and ASCII string as a second one.<br>
exit 0<br>
<a href="abs-guides.html#45">The shift command works on arguments passed to functions (see Example 36-16).</a><br>
But, what about command-line arguments passed to the script? Does a function see them? Well, let's clear up<br>the confusion.<br>
<b>Example 24-3. Functions and command-line args passed to the script</b><br>
#!/bin/bash<br>
# func-cmdlinearg.sh<br>
# &nbsp;Call this script with a command-line argument,<br>
#+ something like $0 arg1.<br>
func ()<br>
{<br>
echo &quot;$1&quot;<br>
}<br>
echo &quot;First call to function: no arg passed.&quot;<br>
echo &quot;See if command-line arg is seen.&quot;<br>
func<br>
# No! Command-line arg not seen.<br>
Chapter 24. Functions<br>
398<br>
<hr>
<A name=405></a>Advanced Bash-Scripting Guide<br>
echo &quot;============================================================&quot;<br>
echo<br>
echo &quot;Second call to function: command-line arg passed explicitly.&quot;<br>
func $1<br>
# Now it's seen!<br>
exit 0<br>
In contrast to certain other programming languages, shell scripts normally pass only value parameters to<br>functions. Variable names (which are actually<i>&nbsp;pointers</i>), if passed as parameters to functions, will be treated<br>as string literals.<i>&nbsp;Functions interpret their arguments literally.</i><br>
<a href="abs-guides.html#456">Indirect variable references (see Example 37-2) provide a clumsy sort of mechanism for passing variable<br></a>pointers to functions.<br>
<b>Example 24-4. Passing an indirect reference to a function</b><br>
#!/bin/bash<br>
# ind-func.sh: Passing an indirect reference to a function.<br>
echo_var ()<br>
{<br>
echo &quot;$1&quot;<br>
}<br>
message=Hello<br>
Hello=Goodbye<br>
echo_var &quot;$message&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Hello<br>
# Now, let's pass an indirect reference to the function.<br>
echo_var &quot;${!message}&quot; &nbsp; &nbsp; # Goodbye<br>
echo &quot;-------------&quot;<br>
# What happens if we change the contents of &quot;hello&quot; variable?<br>
Hello=&quot;Hello, again!&quot;<br>
echo_var &quot;$message&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Hello<br>
echo_var &quot;${!message}&quot; &nbsp; &nbsp; # Hello, again!<br>
exit 0<br>
The next logical question is whether parameters can be dereferenced<i>&nbsp;after</i>&nbsp;being passed to a function.<br>
<b>Example 24-5. Dereferencing a parameter passed to a function</b><br>
#!/bin/bash<br>
# dereference.sh<br>
# Dereferencing parameter passed to a function.<br>
# Script by Bruce W. Clare.<br>
dereference ()<br>
{<br>
&nbsp; &nbsp; &nbsp;y=\$&quot;$1&quot; &nbsp; # Name of variable (not value!).<br>
&nbsp; &nbsp; &nbsp;echo $y &nbsp; &nbsp;# $Junk<br>
&nbsp; &nbsp; &nbsp;x=`eval &quot;expr \&quot;$y\&quot; &quot;`<br>
Chapter 24. Functions<br>
399<br>
<hr>
<A name=406></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp;echo $1=$x<br>
&nbsp; &nbsp; &nbsp;eval &quot;$1=\&quot;Some Different Text \&quot;&quot; &nbsp;# Assign new value.<br>
}<br>
Junk=&quot;Some Text&quot;<br>
echo $Junk &quot;before&quot; &nbsp; &nbsp;# Some Text before<br>
dereference Junk<br>
echo $Junk &quot;after&quot; &nbsp; &nbsp; # Some Different Text after<br>
exit 0<br>
<b>Example 24-6. Again, dereferencing a parameter passed to a function</b><br>
#!/bin/bash<br>
# ref-params.sh: Dereferencing a parameter passed to a function.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Complex Example)<br>
ITERATIONS=3 &nbsp;# How many times to get input.<br>
icount=1<br>
my_read () {<br>
&nbsp; # &nbsp;Called with my_read varname,<br>
&nbsp; #+ outputs the previous value between brackets as the default value,<br>
&nbsp; #+ then asks for a new value.<br>
&nbsp; local local_var<br>
&nbsp; echo -n &quot;Enter a value &quot;<br>
&nbsp; eval 'echo -n &quot;[$'$1'] &quot;' &nbsp;# &nbsp;Previous value.<br>
# eval echo -n &quot;[\$$1] &quot; &nbsp; &nbsp; # &nbsp;Easier to understand,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ but loses trailing space in user prompt.<br>
&nbsp; read local_var<br>
&nbsp; [ -n &quot;$local_var&quot; ] &amp;&amp; eval $1=\$local_var<br>
&nbsp; # &quot;And-list&quot;: if &quot;local_var&quot; then set &quot;$1&quot; to its value.<br>
}<br>
echo<br>
while [ &quot;$icount&quot; -le &quot;$ITERATIONS&quot; ]<br>
do<br>
&nbsp; my_read var<br>
&nbsp; echo &quot;Entry #$icount = $var&quot;<br>
&nbsp; let &quot;icount += 1&quot;<br>
&nbsp; echo<br>
done &nbsp;<br>
# Thanks to Stephane Chazelas for providing this instructive example.<br>
exit 0<br>
<b>Exit and Return</b><br>
<b>exit status</b><br>
Functions return a value, called an<i>&nbsp;exit status</i><a href="abs-guides.html#57">. This is analogous to the exit status returned by a<br></a>command. The exit status may be explicitly specified by a<b>&nbsp;return</b>&nbsp;statement, otherwise it is the exit<br><a href="abs-guides.html#57">status of the last command in the function (0 if successful, and a non-zero error code if not). This exit</a><br>
Chapter 24. Functions<br>
400<br>
<hr>
<A name=407></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#57">status may be used in the script by referencing it as $?. This mechanism effectively permits script<br></a>functions to have a &quot;return value&quot; similar to C functions.<br>
<b>return</b><br>
Terminates a function. A<b>&nbsp;return</b>&nbsp;command&nbsp;[106] optionally takes an<i>&nbsp;integer</i>&nbsp;argument, which is<br>returned to the calling script as the &quot;exit status&quot; of the function, and this exit status is assigned to the<br><a href="abs-guides.html#109">variable $?.</a><br>
<b>Example 24-7. Maximum of two numbers</b><br>
#!/bin/bash<br>
# max.sh: Maximum of two integers.<br>
E_PARAM_ERR=250 &nbsp; &nbsp;# If less than 2 params passed to function.<br>
EQUAL=251 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Return value if both params equal.<br>
# &nbsp;Error values out of range of any<br>
#+ params that might be fed to the function.<br>
max2 () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Returns larger of two numbers.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Note: numbers compared must be less than 250.<br>
if [ -z &quot;$2&quot; ]<br>
then<br>
&nbsp; return $E_PARAM_ERR<br>
fi<br>
if [ &quot;$1&quot; -eq &quot;$2&quot; ]<br>
then<br>
&nbsp; return $EQUAL<br>
else<br>
&nbsp; if [ &quot;$1&quot; -gt &quot;$2&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $1<br>
&nbsp; else<br>
&nbsp; &nbsp; return $2<br>
&nbsp; fi<br>
fi<br>
}<br>
max2 33 34<br>
return_val=$?<br>
if [ &quot;$return_val&quot; -eq $E_PARAM_ERR ]<br>
then<br>
&nbsp; echo &quot;Need to pass two parameters to the function.&quot;<br>
elif [ &quot;$return_val&quot; -eq $EQUAL ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;The two numbers are equal.&quot;<br>
else<br>
&nbsp; &nbsp; echo &quot;The larger of the two numbers is $return_val.&quot;<br>
fi &nbsp;<br>
exit 0<br>
# &nbsp;Exercise (easy):<br>
# &nbsp;---------------<br>
# &nbsp;Convert this to an interactive script,<br>
#+ that is, have the script ask for input (two numbers).<br>
Chapter 24. Functions<br>
401<br>
<hr>
<A name=408></a><IMG src="abs-guide-408_1.png"><br>
Advanced Bash-Scripting Guide<br>
For a function to return a string or array, use a dedicated variable.<br>
count_lines_in_etc_passwd()<br>
{<br>
&nbsp; [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))<br>
&nbsp; # &nbsp;If /etc/passwd is readable, set REPLY to line count.<br>
&nbsp; # &nbsp;Returns both a parameter value and status information.<br>
&nbsp; # &nbsp;The 'echo' seems unnecessary, but . . .<br>
&nbsp; #+ it removes excess whitespace from the output.<br>
}<br>
if count_lines_in_etc_passwd<br>
then<br>
&nbsp; echo &quot;There are $REPLY lines in /etc/passwd.&quot;<br>
else<br>
&nbsp; echo &quot;Cannot count lines in /etc/passwd.&quot;<br>
fi &nbsp;<br>
# Thanks, S.C.<br>
<b>Example 24-8. Converting numbers to Roman numerals</b><br>
#!/bin/bash<br>
# Arabic number to Roman numeral conversion<br>
# Range: 0 - 200<br>
# It's crude, but it works.<br>
# Extending the range and otherwise improving the script is left as an exercise.<br>
# Usage: roman number-to-convert<br>
LIMIT=200<br>
E_ARG_ERR=65<br>
E_OUT_OF_RANGE=66<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` number-to-convert&quot;<br>
&nbsp; exit $E_ARG_ERR<br>
fi &nbsp;<br>
num=$1<br>
if [ &quot;$num&quot; -gt $LIMIT ]<br>
then<br>
&nbsp; echo &quot;Out of range!&quot;<br>
&nbsp; exit $E_OUT_OF_RANGE<br>
fi &nbsp;<br>
to_roman () &nbsp; # Must declare function before first call to it.<br>
{<br>
number=$1<br>
factor=$2<br>
rchar=$3<br>
let &quot;remainder = number - factor&quot;<br>
while [ &quot;$remainder&quot; -ge 0 ]<br>
do<br>
&nbsp; echo -n $rchar<br>
&nbsp; let &quot;number -= factor&quot;<br>
&nbsp; let &quot;remainder = number - factor&quot;<br>
Chapter 24. Functions<br>
402<br>
<hr>
<A name=409></a><IMG src="abs-guide-409_1.png"><br>
Advanced Bash-Scripting Guide<br>
done &nbsp;<br>
return $number<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Exercises:<br>
&nbsp; &nbsp; &nbsp; &nbsp;# ---------<br>
&nbsp; &nbsp; &nbsp; &nbsp;# 1) Explain how this function works.<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp;Hint: division by successive subtraction.<br>
&nbsp; &nbsp; &nbsp; &nbsp;# 2) Extend to range of the function.<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; &nbsp;Hint: use &quot;echo&quot; and command-substitution capture.<br>
}<br>
to_roman $num 100 C<br>
num=$?<br>
to_roman $num 90 LXXXX<br>
num=$?<br>
to_roman $num 50 L<br>
num=$?<br>
to_roman $num 40 XL<br>
num=$?<br>
to_roman $num 10 X<br>
num=$?<br>
to_roman $num 9 IX<br>
num=$?<br>
to_roman $num 5 V<br>
num=$?<br>
to_roman $num 4 IV<br>
num=$?<br>
to_roman $num 1 I<br>
# Successive calls to conversion function!<br>
# Is this really necessary??? Can it be simplified?<br>
echo<br>
exit<br>
<a href="abs-guides.html#166">See also Example 11-28.</a><br>
The largest positive integer a function can return is 255. The<b>&nbsp;return</b>&nbsp;command is closely<br><a href="abs-guides.html#57">tied to the concept of exit status, which accounts for this particular limitation. Fortunately,<br></a><a href="abs-guides.html#530">there are various workarounds for those situations requiring a large integer return value<br></a>from a function.<br>
<b>Example 24-9. Testing large return values in a function</b><br>
#!/bin/bash<br>
# return-test.sh<br>
# The largest positive value a function can return is 255.<br>
return_test () &nbsp; &nbsp; &nbsp; &nbsp; # Returns whatever passed to it.<br>
{<br>
&nbsp; return $1<br>
}<br>
return_test 27 &nbsp; &nbsp; &nbsp; &nbsp; # o.k.<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Returns 27.<br>
return_test 255 &nbsp; &nbsp; &nbsp; &nbsp;# Still o.k.<br>
Chapter 24. Functions<br>
403<br>
<hr>
<A name=410></a>Advanced Bash-Scripting Guide<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Returns 255.<br>
return_test 257 &nbsp; &nbsp; &nbsp; &nbsp;# Error!<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Returns 1 (return code for miscellaneous error).<br>
# ======================================================<br>
return_test -151896 &nbsp; &nbsp;# Do large negative numbers work?<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Will this return -151896?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No! It returns 168.<br>
# &nbsp;Version of Bash before 2.05b permitted<br>
#+ large negative integer return values.<br>
# &nbsp;Newer versions of Bash plug this loophole.<br>
# &nbsp;This may break older scripts.<br>
# &nbsp;Caution!<br>
# ======================================================<br>
exit 0<br>
A workaround for obtaining large integer &quot;return values&quot; is to simply assign the &quot;return<br>value&quot; to a global variable.<br>
Return_Val= &nbsp; # Global variable to hold oversize return value of function.<br>
alt_return_test ()<br>
{<br>
&nbsp; fvar=$1<br>
&nbsp; Return_Val=$fvar<br>
&nbsp; return &nbsp; # Returns 0 (success).<br>
}<br>
alt_return_test 1<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0<br>
echo &quot;return value = $Return_Val&quot; &nbsp; &nbsp;# 1<br>
alt_return_test 256<br>
echo &quot;return value = $Return_Val&quot; &nbsp; &nbsp;# 256<br>
alt_return_test 257<br>
echo &quot;return value = $Return_Val&quot; &nbsp; &nbsp;# 257<br>
alt_return_test 25701<br>
echo &quot;return value = $Return_Val&quot; &nbsp; &nbsp;#25701<br>
A more elegant method is to have the function<b>&nbsp;echo</b>&nbsp;its &quot;return value to&nbsp;stdout,&quot; and then<br><a href="abs-guides.html#170">capture it by command substitution. See the discussion of this in Section 36.7.</a><br>
<b>Example 24-10. Comparing two large integers</b><br>
#!/bin/bash<br>
# max2.sh: Maximum of two LARGE integers.<br>
# &nbsp;This is the previous &quot;max.sh&quot; example,<br>
#+ modified to permit comparing large integers.<br>
EQUAL=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Return value if both params equal.<br>
E_PARAM_ERR=-99999 &nbsp;# Not enough params passed to function.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^ &nbsp; &nbsp;Out of range of any params that might be passed.<br>
max2 () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;Returns&quot; larger of two numbers.<br>
Chapter 24. Functions<br>
404<br>
<hr>
<A name=411></a>Advanced Bash-Scripting Guide<br>
{<br>
if [ -z &quot;$2&quot; ]<br>
then<br>
&nbsp; echo $E_PARAM_ERR<br>
&nbsp; return<br>
fi<br>
if [ &quot;$1&quot; -eq &quot;$2&quot; ]<br>
then<br>
&nbsp; echo $EQUAL<br>
&nbsp; return<br>
else<br>
&nbsp; if [ &quot;$1&quot; -gt &quot;$2&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; retval=$1<br>
&nbsp; else<br>
&nbsp; &nbsp; retval=$2<br>
&nbsp; fi<br>
fi<br>
echo $retval &nbsp; &nbsp; &nbsp; &nbsp;# Echoes (to stdout), rather than returning value.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why?<br>
}<br>
return_val=$(max2 33001 33997)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Function name<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^ ^^^^^ Params passed<br>
# &nbsp;This is actually a form of command substitution:<br>
#+ treating a function as if it were a command,<br>
#+ and assigning the stdout of the function to the variable &quot;return_val.&quot;<br>
# ========================= OUTPUT ========================<br>
if [ &quot;$return_val&quot; -eq &quot;$E_PARAM_ERR&quot; ]<br>
&nbsp; then<br>
&nbsp; echo &quot;Error in parameters passed to comparison function!&quot;<br>
elif [ &quot;$return_val&quot; -eq &quot;$EQUAL&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;The two numbers are equal.&quot;<br>
else<br>
&nbsp; &nbsp; echo &quot;The larger of the two numbers is $return_val.&quot;<br>
fi<br>
# =========================================================<br>
exit 0<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;1) Find a more elegant way of testing<br>
#+ &nbsp; &nbsp;the parameters passed to the function.<br>
# &nbsp;2) Simplify the if/then structure at &quot;OUTPUT.&quot;<br>
# &nbsp;3) Rewrite the script to take input from command-line parameters.<br>
Here is another example of capturing a function &quot;return value.&quot; Understanding it requires<br><a href="abs-guides.html#784">some knowledge of awk.</a><br>
month_length () &nbsp;# Takes month number as an argument.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Returns number of days in month.<br>
monthD=&quot;31 28 31 30 31 30 31 31 30 31 30 31&quot; &nbsp;# Declare as local?<br>
echo &quot;$monthD&quot; | awk '{ print $'&quot;${1}&quot;' }' &nbsp; &nbsp;# Tricky.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^<br>
Chapter 24. Functions<br>
405<br>
<hr>
<A name=412></a>Advanced Bash-Scripting Guide<br>
# Parameter passed to function &nbsp;($1 -- month number), then to awk.<br>
# Awk sees this as &quot;print $1 . . . print $12&quot; (depending on month number)<br>
# Template for passing a parameter to embedded awk script:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $'&quot;${script_parameter}&quot;'<br>
# &nbsp;Needs error checking for correct parameter range (1-12)<br>
#+ and for February in leap year.<br>
}<br>
# ----------------------------------------------<br>
# Usage example:<br>
month=4 &nbsp; &nbsp; &nbsp; &nbsp;# April, for example (4th month).<br>
days_in=$(month_length $month)<br>
echo $days_in &nbsp;# 30<br>
# ----------------------------------------------<br>
<a href="abs-guides.html#577">See also Example A-7 and Example A-37.</a><br>
<b>Exercise:</b><a href="abs-guides.html#408">&nbsp;Using what we have just learned, extend the previous Roman numerals<br>example to accept arbitrarily large input.</a><br>
<b>Redirection</b><br>
<i>Redirecting the stdin of a function</i><br>
<a href="abs-guides.html#20">A function is essentially a code block, which means its&nbsp;</a>stdin<a href="abs-guides.html#21">&nbsp;can be redirected (as in Example 3-1).</a><br>
<b>Example 24-11. Real name from username</b><br>
#!/bin/bash<br>
# realname.sh<br>
#<br>
# From username, gets &quot;real name&quot; from /etc/passwd.<br>
ARGCOUNT=1 &nbsp; &nbsp; &nbsp; # Expect one arg.<br>
E_WRONGARGS=85<br>
file=/etc/passwd<br>
pattern=$1<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` USERNAME&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi &nbsp;<br>
file_excerpt () &nbsp; &nbsp;# &nbsp;Scan file for pattern,<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then print relevant portion of line.<br>
&nbsp; while read line &nbsp;# &quot;while&quot; does not necessarily need [ condition ]<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;$line&quot; | grep $1 | awk -F&quot;:&quot; '{ print $5 }'<br>
&nbsp; &nbsp; # Have awk use &quot;:&quot; delimiter.<br>
&nbsp; done<br>
} &lt;$file &nbsp;# Redirect into function's stdin.<br>
file_excerpt $pattern<br>
# Yes, this entire script could be reduced to<br>
# &nbsp; &nbsp; &nbsp; grep PATTERN /etc/passwd | awk -F&quot;:&quot; '{ print $5 }'<br>
Chapter 24. Functions<br>
406<br>
<hr>
<A name=413></a><IMG src="abs-guide-413_1.png"><br>
Advanced Bash-Scripting Guide<br>
# or<br>
# &nbsp; &nbsp; &nbsp; awk -F: '/PATTERN/ {print $5}'<br>
# or<br>
# &nbsp; &nbsp; &nbsp; awk -F: '($1 == &quot;username&quot;) { print $5 }' # real name from username<br>
# However, it might not be as instructive.<br>
exit 0<br>
There is an alternate, and perhaps less confusing method of redirecting a function's&nbsp;stdin. This<br>involves redirecting the&nbsp;stdin&nbsp;to an embedded bracketed code block within the function.<br>
# Instead of:<br>
Function ()<br>
{<br>
&nbsp;...<br>
&nbsp;} &lt; file<br>
# Try this:<br>
Function ()<br>
{<br>
&nbsp; {<br>
&nbsp; &nbsp; ...<br>
&nbsp; &nbsp;} &lt; file<br>
}<br>
# Similarly,<br>
Function () &nbsp;# This works.<br>
{<br>
&nbsp; {<br>
&nbsp; &nbsp;echo $*<br>
&nbsp; } | tr a b<br>
}<br>
Function () &nbsp;# This doesn't work.<br>
{<br>
&nbsp; echo $*<br>
} | tr a b &nbsp; # A nested code block is mandatory here.<br>
# Thanks, S.C.<br>
<a href="abs-guides.html#804">Emmanuel Rouat's sample&nbsp;bashrc&nbsp;file contains some instructive examples of<br></a>functions.<br>
<b>24.2. Local Variables</b><br>
<b>What makes a variable<i>&nbsp;local</i></b><b>?</b><br>
local variables<br>
A variable declared as<i>&nbsp;local</i><a href="abs-guides.html#20">&nbsp;is one that is visible only within the block of code in which it appears. It<br></a><a href="abs-guides.html#389">has local scope. In a function, a</a><i>&nbsp;local variable</i>&nbsp;has meaning only within that function block.&nbsp;[107]<br>
<b>Example 24-12. Local variable visibility</b><br>
#!/bin/bash<br>
Chapter 24. Functions<br>
407<br>
<hr>
<A name=414></a><IMG src="abs-guide-414_1.png"><br>
<IMG src="abs-guide-414_2.png"><br>
Advanced Bash-Scripting Guide<br>
# Global and local variables inside a function.<br>
func ()<br>
{<br>
&nbsp; local loc_var=23 &nbsp; &nbsp; &nbsp; # Declared as local variable.<br>
&nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Uses the 'local' builtin.<br>
&nbsp; echo &quot;\&quot;loc_var\&quot; in function = $loc_var&quot;<br>
&nbsp; global_var=999 &nbsp; &nbsp; &nbsp; &nbsp; # Not declared as local.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Defaults to global.&nbsp;<br>
&nbsp; echo &quot;\&quot;global_var\&quot; in function = $global_var&quot;<br>
} &nbsp;<br>
func<br>
# Now, to see if local variable &quot;loc_var&quot; exists outside function.<br>
echo<br>
echo &quot;\&quot;loc_var\&quot; outside function = $loc_var&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $loc_var outside function =&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No, $loc_var not visible globally.<br>
echo &quot;\&quot;global_var\&quot; outside function = $global_var&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $global_var outside function = 999<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $global_var is visible globally.<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
exit 0<br>
# &nbsp;In contrast to C, a Bash variable declared inside a function<br>
#+ is local *only* if declared as such.<br>
Before a function is called,<i>&nbsp;all</i>&nbsp;variables declared within the function are invisible outside the<br>body of the function, not just those explicitly declared as<i>&nbsp;local</i>.<br>
#!/bin/bash<br>
func ()<br>
{<br>
global_var=37 &nbsp; &nbsp;# &nbsp;Visible only within the function block<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ before the function has been called.&nbsp;<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;END OF FUNCTION<br>
echo &quot;global_var = $global_var&quot; &nbsp;# global_var =<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Function &quot;func&quot; has not yet been called,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ so $global_var is not visible here.<br>
func<br>
echo &quot;global_var = $global_var&quot; &nbsp;# global_var = 37<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Has been set by function call.<br>
As Evgeniy Ivanov points out, when declaring and setting a local variable in a single<br>command, apparently the order of operations is to<i>&nbsp;first set the variable, and only<br>afterwards restrict it to local scope</i><a href="abs-guides.html#57">. This is reflected in the return value.</a><br>
#!/bin/bash<br>
echo &quot;==OUTSIDE Function (global)==&quot;<br>
t=$(exit 1)<br>
echo $? &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# As expected.<br>
Chapter 24. Functions<br>
408<br>
<hr>
<A name=415></a>Advanced Bash-Scripting Guide<br>
echo<br>
function0 ()<br>
{<br>
echo &quot;==INSIDE Function==&quot;<br>
echo &quot;Global&quot;<br>
t0=$(exit 1)<br>
echo $? &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# As expected.<br>
echo<br>
echo &quot;Local declared &amp; assigned in same command.&quot;<br>
local t1=$(exit 1)<br>
echo $? &nbsp; &nbsp; &nbsp;# 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Unexpected!<br>
# &nbsp;Apparently, the variable assignment takes place before<br>
#+ the local declaration.<br>
#+ The return value is for the latter.<br>
echo<br>
echo &quot;Local declared, then assigned (separate commands).&quot;<br>
local t2<br>
t2=$(exit 1)<br>
echo $? &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# As expected.<br>
}<br>
function0<br>
<b>24.2.1. Local variables and recursion.</b><br>
<i>Recursion</i>&nbsp;is an interesting and sometimes useful form of<i>&nbsp;self-reference</i><a href="abs-guides.html#566">. Herbert Mayer defines it as &quot;. . .<br></a>expressing an algorithm by using a simpler version of that same algorithm . . .&quot;<br>
Consider a definition defined in terms of itself,&nbsp;[108] an expression implicit in its own expression,&nbsp;[109]<i>&nbsp;a<br>snake swallowing its own tail</i>,&nbsp;[110] or . . . a function that calls itself.&nbsp;[111]<br>
<b>Example 24-13. Demonstration of a simple recursive function</b><br>
#!/bin/bash<br>
# recursion-demo.sh<br>
# Demonstration of recursion.<br>
RECURSIONS=9 &nbsp; # How many times to recurse.<br>
r_count=0 &nbsp; &nbsp; &nbsp;# Must be global. Why?<br>
recurse ()<br>
{<br>
&nbsp; var=&quot;$1&quot;<br>
Chapter 24. Functions<br>
409<br>
<hr>
<A name=416></a>Advanced Bash-Scripting Guide<br>
&nbsp; while [ &quot;$var&quot; -ge 0 ]<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;Recursion count = &quot;$r_count&quot; &nbsp;+-+ &nbsp;\$var = &quot;$var&quot;&quot;<br>
&nbsp; &nbsp; (( var-- )); (( r_count++ ))<br>
&nbsp; &nbsp; recurse &quot;$var&quot; &nbsp;# &nbsp;Function calls itself (recurses)<br>
&nbsp; done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ until what condition is met?<br>
}<br>
recurse $RECURSIONS<br>
exit $?<br>
<b>Example 24-14. Another simple demonstration</b><br>
#!/bin/bash<br>
# recursion-def.sh<br>
# A script that defines &quot;recursion&quot; in a rather graphic way.<br>
RECURSIONS=10<br>
r_count=0<br>
sp=&quot; &quot;<br>
define_recursion ()<br>
{<br>
&nbsp; ((r_count++))<br>
&nbsp; sp=&quot;$sp&quot;&quot; &quot;<br>
&nbsp; echo -n &quot;$sp&quot;<br>
&nbsp; echo &quot;\&quot;The act of recurring ... \&quot;&quot; &nbsp; # Per 1913 Webster's dictionary.<br>
&nbsp; while [ $r_count -le $RECURSIONS ]<br>
&nbsp; do<br>
&nbsp; &nbsp; define_recursion<br>
&nbsp; done<br>
}<br>
echo<br>
echo &quot;Recursion: &quot;<br>
define_recursion<br>
echo<br>
exit $?<br>
Local variables are a useful tool for writing recursive code, but this practice generally involves a great deal of<br>computational overhead and is definitely<i>&nbsp;not</i>&nbsp;recommended in a shell script.&nbsp;[112]<br>
<b>Example 24-15. Recursion, using a local variable</b><br>
#!/bin/bash<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; factorial<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------<br>
# Does bash permit recursion?<br>
# Well, yes, but...<br>
# It's so slow that you gotta have rocks in your head to try it.<br>
Chapter 24. Functions<br>
410<br>
<hr>
<A name=417></a>Advanced Bash-Scripting Guide<br>
MAX_ARG=5<br>
E_WRONG_ARGS=85<br>
E_RANGE_ERR=86<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` number&quot;<br>
&nbsp; exit $E_WRONG_ARGS<br>
fi<br>
if [ &quot;$1&quot; -gt $MAX_ARG ]<br>
then<br>
&nbsp; echo &quot;Out of range ($MAX_ARG is maximum).&quot;<br>
&nbsp; # &nbsp;Let's get real now.<br>
&nbsp; # &nbsp;If you want greater range than this,<br>
&nbsp; #+ rewrite it in a Real Programming Language.<br>
&nbsp; exit $E_RANGE_ERR<br>
fi &nbsp;<br>
fact ()<br>
{<br>
&nbsp; local number=$1<br>
&nbsp; # &nbsp;Variable &quot;number&quot; must be declared as local,<br>
&nbsp; #+ otherwise this doesn't work.<br>
&nbsp; if [ &quot;$number&quot; -eq 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; factorial=1 &nbsp; &nbsp;# Factorial of 0 = 1.<br>
&nbsp; else<br>
&nbsp; &nbsp; let &quot;decrnum = number - 1&quot;<br>
&nbsp; &nbsp; fact $decrnum &nbsp;# Recursive function call (the function calls itself).<br>
&nbsp; &nbsp; let &quot;factorial = $number * $?&quot;<br>
&nbsp; fi<br>
&nbsp; return $factorial<br>
}<br>
fact $1<br>
echo &quot;Factorial of $1 is $?.&quot;<br>
exit 0<br>
<a href="abs-guides.html#592">Also see Example A-15 for an example of recursion in a script. Be aware that recursion is resource-intensive<br></a>and executes slowly, and is therefore generally not appropriate in a script.<br>
<b>24.3. Recursion Without Local Variables</b><br>
A function may recursively call itself even without use of local variables.<br>
<b>Example 24-16.<i>&nbsp;The Fibonacci Sequence</i></b><br>
#!/bin/bash<br>
# fibo.sh : Fibonacci sequence (recursive)<br>
# Author: M. Cooper<br>
# License: GPL3<br>
Chapter 24. Functions<br>
411<br>
<hr>
<A name=418></a>Advanced Bash-Scripting Guide<br>
# ---------------------------------<br>
# Fibo(0) = 0<br>
# Fibo(1) = 1<br>
# else<br>
# &nbsp; Fibo(j) = Fibo(j-1) + Fibo(j-2)<br>
# ---------------------------------<br>
MAXTERM=15 &nbsp; &nbsp; &nbsp; # Number of terms (+1) to generate.<br>
MINIDX=2 &nbsp; &nbsp; &nbsp; &nbsp; # If idx is less than 2, then Fibo(idx) = idx.<br>
Fibonacci ()<br>
{<br>
&nbsp; idx=$1 &nbsp; # Doesn't need to be local. Why not?<br>
&nbsp; if [ &quot;$idx&quot; -lt &quot;$MINIDX&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$idx&quot; &nbsp;# First two terms are 0 1 ... see above.<br>
&nbsp; else<br>
&nbsp; &nbsp; (( --idx )) &nbsp;# j-1<br>
&nbsp; &nbsp; term1=$( Fibonacci $idx ) &nbsp; # &nbsp;Fibo(j-1)<br>
&nbsp; &nbsp; (( --idx )) &nbsp;# j-2<br>
&nbsp; &nbsp; term2=$( Fibonacci $idx ) &nbsp; # &nbsp;Fibo(j-2)<br>
&nbsp; &nbsp; echo $(( term1 + term2 ))<br>
&nbsp; fi<br>
&nbsp; # &nbsp;An ugly, ugly kludge.<br>
&nbsp; # &nbsp;The more elegant implementation of recursive fibo in C<br>
&nbsp; #+ is a straightforward translation of the algorithm in lines 7 - 10.<br>
}<br>
for i in $(seq 0 $MAXTERM)<br>
do &nbsp;# Calculate $MAXTERM+1 terms.<br>
&nbsp; FIBO=$(Fibonacci $i)<br>
&nbsp; echo -n &quot;$FIBO &quot;<br>
done<br>
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610<br>
# Takes a while, doesn't it? Recursion in a script is slow.<br>
echo<br>
exit 0<br>
<b>Example 24-17.<i>&nbsp;The Towers of Hanoi</i></b><br>
#! /bin/bash<br>
#<br>
# The Towers Of Hanoi<br>
# Bash script<br>
# Copyright (C) 2000 Amit Singh. All Rights Reserved.<br>
# http://hanoi.kernelthread.com<br>
#<br>
# Tested under Bash version 2.05b.0(13)-release.<br>
# Also works under Bash version 3.x.<br>
#<br>
# &nbsp;Used in &quot;Advanced Bash Scripting Guide&quot;<br>
#+ with permission of script author.<br>
# &nbsp;Slightly modified and commented by ABS author.<br>
#=================================================================#<br>
Chapter 24. Functions<br>
412<br>
<hr>
<A name=419></a>Advanced Bash-Scripting Guide<br>
# &nbsp;The Tower of Hanoi is a mathematical puzzle attributed to<br>
#+ Edouard Lucas, a nineteenth-century French mathematician.<br>
#<br>
# &nbsp;There are three vertical posts set in a base.<br>
# &nbsp;The first post has a set of annular rings stacked on it.<br>
# &nbsp;These rings are disks with a hole drilled out of the center,<br>
#+ so they can slip over the posts and rest flat.<br>
# &nbsp;The rings have different diameters, and they stack in ascending<br>
#+ order, according to size.<br>
# &nbsp;The smallest ring is on top, and the largest on the bottom.<br>
#<br>
# &nbsp;The task is to transfer the stack of rings<br>
#+ to one of the other posts.<br>
# &nbsp;You can move only one ring at a time to another post.<br>
# &nbsp;You are permitted to move rings back to the original post.<br>
# &nbsp;You may place a smaller ring atop a larger one,<br>
#+ but *not* vice versa.<br>
# &nbsp;Again, it is forbidden to place a larger ring atop a smaller one.<br>
#<br>
# &nbsp;For a small number of rings, only a few moves are required.<br>
#+ For each additional ring,<br>
#+ the required number of moves approximately doubles,<br>
#+ and the &quot;strategy&quot; becomes increasingly complicated.<br>
#<br>
# &nbsp;For more information, see http://hanoi.kernelthread.com<br>
#+ or pp. 186-92 of _The Armchair Universe_ by A.K. Dewdney.<br>
#<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<br>
# &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; &nbsp; &nbsp; &nbsp;_|_|_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; &nbsp; &nbsp; |_____| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; &nbsp; &nbsp;|_______| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; &nbsp; |_________| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; &nbsp;|___________| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| |<br>
# .--------------------------------------------------------------.<br>
# |**************************************************************|<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#3<br>
#<br>
#=================================================================#<br>
E_NOPARAM=66 &nbsp;# No parameter passed to script.<br>
E_BADPARAM=67 # Illegal number of disks passed to script.<br>
Moves= &nbsp; &nbsp; &nbsp; &nbsp;# Global variable holding number of moves.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Modification to original script.<br>
dohanoi() { &nbsp; # Recursive function.<br>
&nbsp; &nbsp; case $1 in<br>
&nbsp; &nbsp; 0)<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $2 $4 $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo move $2 &quot;--&gt;&quot; $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((Moves++)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Modification to original script.<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $4 $3 $2<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
case $# in<br>
Chapter 24. Functions<br>
413<br>
<hr>
<A name=420></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; 1) case $(($1&gt;0)) in &nbsp; &nbsp; # Must have at least one disk.<br>
&nbsp; &nbsp; &nbsp; &nbsp;1) &nbsp;# Nested case statement.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dohanoi $1 1 3 2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Total moves = $Moves&quot; &nbsp; # 2^n - 1, where n = # of disks.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit 0;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$0: illegal value for number of disks&quot;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit $E_BADPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;usage: $0 N&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp; Where \&quot;N\&quot; is the number of disks.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;exit $E_NOPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp;;;<br>
esac<br>
# Exercises:<br>
# ---------<br>
# 1) Would commands beyond this point ever be executed?<br>
# &nbsp; &nbsp;Why not? (Easy)<br>
# 2) Explain the workings of the workings of the &quot;dohanoi&quot; function.<br>
# &nbsp; &nbsp;(Difficult -- see the Dewdney reference, above.)<br>
Chapter 24. Functions<br>
414<br>
<hr>
<A name=421></a><b>Chapter 25. Aliases</b><br>
A Bash<i>&nbsp;alias</i>&nbsp;is essentially nothing more than a keyboard shortcut, an abbreviation, a means of avoiding<br>typing a long command sequence. If, for example, we include<b>&nbsp;alias lm=&quot;ls -l | more&quot;</b>&nbsp;in the&nbsp;<a href="abs-guides.html#804">~/.bashrc<br>file, then each&nbsp;</a><b>lm&nbsp;</b>[113] typed at the command-line will automatically be replaced by a<b>&nbsp;ls -l | more</b>. This can<br>save a great deal of typing at the command-line and avoid having to remember complex combinations of<br>commands and options. Setting<b>&nbsp;alias rm=&quot;rm -i&quot;</b>&nbsp;(interactive mode delete) may save a good deal of grief,<br>since it can prevent inadvertently deleting important files.<br>
In a script, aliases have very limited usefulness. It would be nice if aliases could assume some of the<br>functionality of the<b>&nbsp;C</b>&nbsp;preprocessor, such as macro expansion, but unfortunately Bash does not expand<br>arguments within the alias body.&nbsp;[114] Moreover, a script fails to expand an alias itself within &quot;compound<br><a href="abs-guides.html#60">constructs,&quot; such as if/then statements, loops, and functions. An added limitation is that an alias will not<br></a>expand recursively. Almost invariably, whatever we would like an alias to do could be accomplished much<br><a href="abs-guides.html#399">more effectively with a function.</a><br>
<b>Example 25-1. Aliases within a script</b><br>
#!/bin/bash<br>
# alias.sh<br>
shopt -s expand_aliases<br>
# Must set this option, else script will not expand aliases.<br>
# First, some fun.<br>
alias Jesse_James='echo &quot;\&quot;Alias Jesse James\&quot; was a 1959 comedy starring Bob Hope.&quot;'<br>
Jesse_James<br>
echo; echo; echo;<br>
alias ll=&quot;ls -l&quot;<br>
# May use either single (') or double (&quot;) quotes to define an alias.<br>
echo &quot;Trying aliased \&quot;ll\&quot;:&quot;<br>
ll /usr/X11R6/bin/mk* &nbsp; #* Alias works.<br>
echo<br>
directory=/usr/X11R6/bin/<br>
prefix=mk* &nbsp;# See if wild card causes problems.<br>
echo &quot;Variables \&quot;directory\&quot; + \&quot;prefix\&quot; = $directory$prefix&quot;<br>
echo<br>
alias lll=&quot;ls -l $directory$prefix&quot;<br>
echo &quot;Trying aliased \&quot;lll\&quot;:&quot;<br>
lll &nbsp; &nbsp; &nbsp; &nbsp; # Long listing of all files in /usr/X11R6/bin stating with mk.<br>
# An alias can handle concatenated variables -- including wild card -- o.k.<br>
TRUE=1<br>
Chapter 25. Aliases<br>
415<br>
<hr>
<A name=422></a>Advanced Bash-Scripting Guide<br>
echo<br>
if [ TRUE ]<br>
then<br>
&nbsp; alias rr=&quot;ls -l&quot;<br>
&nbsp; echo &quot;Trying aliased \&quot;rr\&quot; within if/then statement:&quot;<br>
&nbsp; rr /usr/X11R6/bin/mk* &nbsp; #* Error message results!<br>
&nbsp; # Aliases not expanded within compound statements.<br>
&nbsp; echo &quot;However, previously expanded alias still recognized:&quot;<br>
&nbsp; ll /usr/X11R6/bin/mk*<br>
fi &nbsp;<br>
echo<br>
count=0<br>
while [ $count -lt 3 ]<br>
do<br>
&nbsp; alias rrr=&quot;ls -l&quot;<br>
&nbsp; echo &quot;Trying aliased \&quot;rrr\&quot; within \&quot;while\&quot; loop:&quot;<br>
&nbsp; rrr /usr/X11R6/bin/mk* &nbsp; #* Alias will not expand here either.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;alias.sh: line 57: rrr: command not found<br>
&nbsp; let count+=1<br>
done&nbsp;<br>
echo; echo<br>
alias xyz='cat $0' &nbsp; # Script lists itself.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Note strong quotes.<br>
xyz<br>
# &nbsp;This seems to work,<br>
#+ although the Bash documentation suggests that it shouldn't.<br>
#<br>
# &nbsp;However, as Steve Jacobson points out,<br>
#+ the &quot;$0&quot; parameter expands immediately upon declaration of the alias.<br>
exit 0<br>
The<b>&nbsp;unalias</b>&nbsp;command removes a previously set<i>&nbsp;alias</i>.<br>
<b>Example 25-2.<i>&nbsp;unalias</i></b><b>: Setting and unsetting an alias</b><br>
#!/bin/bash<br>
# unalias.sh<br>
shopt -s expand_aliases &nbsp;# Enables alias expansion.<br>
alias llm='ls -al | more'<br>
llm<br>
echo<br>
unalias llm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Unset alias.<br>
llm<br>
# Error message results, since 'llm' no longer recognized.<br>
exit 0<br>
bash$&nbsp;<b>./unalias.sh<br></b>total 6<br>
drwxrwxr-x &nbsp; &nbsp;2 bozo &nbsp; &nbsp; bozo &nbsp; &nbsp; &nbsp; &nbsp; 3072 Feb &nbsp;6 14:04 .<br>
Chapter 25. Aliases<br>
416<br>
<hr>
<A name=423></a>Advanced Bash-Scripting Guide<br>
drwxr-xr-x &nbsp; 40 bozo &nbsp; &nbsp; bozo &nbsp; &nbsp; &nbsp; &nbsp; 2048 Feb &nbsp;6 14:04 ..<br>
-rwxr-xr-x &nbsp; &nbsp;1 bozo &nbsp; &nbsp; bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;199 Feb &nbsp;6 14:04 unalias.sh<br>
./unalias.sh: llm: command not found<br>
Chapter 25. Aliases<br>
417<br>
<hr>
<A name=424></a><b>Chapter 26. List Constructs</b><br>
The<i>&nbsp;and list</i>&nbsp;and<i>&nbsp;or list</i>&nbsp;constructs provide a means of processing a number of commands consecutively. These<br><a href="abs-guides.html#60">can effectively replace complex nested if/then or even case statements.</a><br>
<b>Chaining together commands</b><br>
and list<br>
command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-n<br>
Each command executes in turn, provided that the previous command has given a return value of<br><i>true</i>&nbsp;(zero). At the first&nbsp;<i>false</i>&nbsp;(non-zero) return, the command chain terminates (the first command<br>returning&nbsp;<i>false</i>&nbsp;is the last one to execute).<br>
<b>Example 26-1. Using an<i>&nbsp;and list</i></b><b>&nbsp;to test for command-line arguments</b><br>
#!/bin/bash<br>
# and list<br>
if [ ! -z &quot;$1&quot; ] &amp;&amp; echo &quot;Argument #1 = $1&quot; &amp;&amp; [ ! -z &quot;$2&quot; ] &amp;&amp; \<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
echo &quot;Argument #2 = $2&quot;<br>
then<br>
&nbsp; echo &quot;At least 2 arguments passed to script.&quot;<br>
&nbsp; # All the chained commands return true.<br>
else<br>
&nbsp; echo &quot;Fewer than 2 arguments passed to script.&quot;<br>
&nbsp; # At least one of the chained commands returns false.<br>
fi &nbsp;<br>
# Note that &quot;if [ ! -z $1 ]&quot; works, but its alleged equivalent,<br>
# &nbsp; &quot;if [ -n $1 ]&quot; does not.<br>
# &nbsp; &nbsp; However, quoting fixes this.<br>
# &nbsp;if &quot;[ -n &quot;$1&quot; ]&quot; works.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp;^ &nbsp; &nbsp;Careful!<br>
# It is always best to QUOTE the variables being tested.<br>
# This accomplishes the same thing, using &quot;pure&quot; if/then statements.<br>
if [ ! -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Argument #1 = $1&quot;<br>
fi<br>
if [ ! -z &quot;$2&quot; ]<br>
then<br>
&nbsp; echo &quot;Argument #2 = $2&quot;<br>
&nbsp; echo &quot;At least 2 arguments passed to script.&quot;<br>
else<br>
&nbsp; echo &quot;Fewer than 2 arguments passed to script.&quot;<br>
fi<br>
# It's longer and more ponderous than using an &quot;and list&quot;.<br>
exit $?<br>
<b>Example 26-2. Another command-line arg test using an<i>&nbsp;and list</i></b><br>
Chapter 26. List Constructs<br>
418<br>
<hr>
<A name=425></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
ARGS=1 &nbsp; &nbsp; &nbsp; &nbsp;# Number of arguments expected.<br>
E_BADARGS=85 &nbsp;# Exit value if incorrect number of args passed.<br>
test $# -ne $ARGS &amp;&amp; \<br>
# &nbsp; &nbsp;^^^^^^^^^^^^ condition #1<br>
echo &quot;Usage: `basename $0` $ARGS argument(s)&quot; &amp;&amp; exit $E_BADARGS<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^<br>
# &nbsp;If condition #1 tests true (wrong number of args passed to script),<br>
#+ then the rest of the line executes, and script terminates.<br>
# Line below executes only if the above test fails.<br>
echo &quot;Correct number of arguments passed to this script.&quot;<br>
exit 0<br>
# To check exit value, do a &quot;echo $?&quot; after script termination.<br>
Of course, an<i>&nbsp;and list</i>&nbsp;can also<i>&nbsp;set</i>&nbsp;variables to a default value.<br>
arg1=$@ &amp;&amp; [ -z &quot;$arg1&quot; ] &amp;&amp; arg1=DEFAULT<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set $arg1 to command-line arguments, if any.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # But . . . set to DEFAULT if not specified on command-line.<br>
or list<br>
command-1 || command-2 || command-3 || ... command-n<br>
Each command executes in turn for as long as the previous command returns false. At the first true<br>return, the command chain terminates (the first command returning true is the last one to execute).<br>This is obviously the inverse of the &quot;and list&quot;.<br>
<b>Example 26-3. Using<i>&nbsp;or lists</i></b><b>&nbsp;in combination with an<i>&nbsp;and list</i></b><br>
#!/bin/bash<br>
# &nbsp;delete.sh, a not-so-cunning file deletion utility.<br>
# &nbsp;Usage: delete filename<br>
E_BADARGS=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS &nbsp;# No arg? Bail out.<br>
else &nbsp;<br>
&nbsp; file=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Set filename.<br>
fi &nbsp;<br>
[ ! -f &quot;$file&quot; ] &amp;&amp; echo &quot;File \&quot;$file\&quot; not found. \<br>
Cowardly refusing to delete a nonexistent file.&quot;<br>
# AND LIST, to give error message if file not present.<br>
# Note echo message continuing on to a second line after an escape.<br>
[ ! -f &quot;$file&quot; ] || (rm -f $file; echo &quot;File \&quot;$file\&quot; deleted.&quot;)<br>
# OR LIST, to delete file if present.<br>
# Note logic inversion above.<br>
Chapter 26. List Constructs<br>
419<br>
<hr>
<A name=426></a><IMG src="abs-guide-426_1.png"><br>
<IMG src="abs-guide-426_2.png"><br>
Advanced Bash-Scripting Guide<br>
# AND LIST executes on true, OR LIST on false.<br>
exit $?<br>
If the first command in an<i>&nbsp;or list</i>&nbsp;returns true, it&nbsp;<i>will</i>&nbsp;execute.<br>
# ==&gt; The following snippets from the /etc/rc.d/init.d/single<br>
#+==&gt; script by Miquel van Smoorenburg<br>
#+==&gt; illustrate use of &quot;and&quot; and &quot;or&quot; lists.<br>
# ==&gt; &quot;Arrowed&quot; comments added by document author.<br>
[ -x /usr/bin/clear ] &amp;&amp; /usr/bin/clear<br>
&nbsp; # ==&gt; If /usr/bin/clear exists, then invoke it.<br>
&nbsp; # ==&gt; Checking for the existence of a command before calling it<br>
&nbsp; #+==&gt; avoids error messages and other awkward consequences.<br>
&nbsp; # ==&gt; . . .<br>
# If they want to run something in single user mode, might as well run it...<br>
for i in /etc/rc1.d/S[0-9][0-9]* ; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Check if the script is there.<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ -x &quot;$i&quot; ] || continue<br>
&nbsp; # ==&gt; If corresponding file in $PWD *not* found,<br>
&nbsp; #+==&gt; then &quot;continue&quot; by jumping to the top of the loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Reject backup files and files generated by rpm.<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ &quot;$i&quot; = &quot;/etc/rc1.d/S00single&quot; ] &amp;&amp; continue<br>
&nbsp; # ==&gt; Set script name, but don't execute it yet.<br>
&nbsp; &nbsp; &nbsp; &nbsp; $i start<br>
done<br>
&nbsp; # ==&gt; . . .<br>
<a href="abs-guides.html#57">The exit status of an&nbsp;</a><b>and list</b>&nbsp;or an&nbsp;<b>or list</b>&nbsp;is the exit status of the last command executed.<br>
Clever combinations of<i>&nbsp;and</i>&nbsp;and<i>&nbsp;or</i>&nbsp;lists are possible, but the logic may easily become convoluted and require<br><a href="abs-guides.html#87">close attention to operator precedence rules, and possibly extensive debugging.</a><br>
false &amp;&amp; true || echo false &nbsp; &nbsp; &nbsp; &nbsp; # false<br>
# Same result as<br>
( false &amp;&amp; true ) || echo false &nbsp; &nbsp; # false<br>
# But NOT<br>
false &amp;&amp; ( true || echo false ) &nbsp; &nbsp; # (nothing echoed)<br>
# &nbsp;Note left-to-right grouping and evaluation of statements,<br>
#+ since the logic operators &quot;&amp;&amp;&quot; and &quot;||&quot; have equal precedence.<br>
# &nbsp;It's usually best to avoid such complexities.<br>
# &nbsp;Thanks, S.C.<br>
<a href="abs-guides.html#577">See Example A-7 and Example 7-4 for illustrations of using&nbsp;</a><b>and / or list</b>&nbsp;constructs to test variables.<br>
Chapter 26. List Constructs<br>
420<br>
<hr>
<A name=427></a><b>Chapter 27. Arrays</b><br>
Newer versions of Bash support one-dimensional arrays.&nbsp;&nbsp;Array elements may be initialized with the<br><b>variable[xx]</b>&nbsp;notation. Alternatively, a script may introduce the entire array by an explicit&nbsp;<b>declare -a<br>variable</b>&nbsp;statement. To dereference (retrieve the contents of) an array element, use<i>&nbsp;curly bracket</i>&nbsp;notation,<br>that is,&nbsp;<b>${element[xx]}</b>.<br>
<b>Example 27-1. Simple array usage</b><br>
#!/bin/bash<br>
area[11]=23<br>
area[13]=37<br>
area[51]=UFOs<br>
# &nbsp;Array members need not be consecutive or contiguous.<br>
# &nbsp;Some members of the array can be left uninitialized.<br>
# &nbsp;Gaps in the array are okay.<br>
# &nbsp;In fact, arrays with sparse data (&quot;sparse arrays&quot;)<br>
#+ are useful in spreadsheet-processing software.<br>
echo -n &quot;area[11] = &quot;<br>
echo ${area[11]} &nbsp; &nbsp;# &nbsp;{curly brackets} needed.<br>
echo -n &quot;area[13] = &quot;<br>
echo ${area[13]}<br>
echo &quot;Contents of area[51] are ${area[51]}.&quot;<br>
# Contents of uninitialized array variable print blank (null variable).<br>
echo -n &quot;area[43] = &quot;<br>
echo ${area[43]}<br>
echo &quot;(area[43] unassigned)&quot;<br>
echo<br>
# Sum of two array variables assigned to third<br>
area[5]=`expr ${area[11]} + ${area[13]}`<br>
echo &quot;area[5] = area[11] + area[13]&quot;<br>
echo -n &quot;area[5] = &quot;<br>
echo ${area[5]}<br>
area[6]=`expr ${area[11]} + ${area[51]}`<br>
echo &quot;area[6] = area[11] + area[51]&quot;<br>
echo -n &quot;area[6] = &quot;<br>
echo ${area[6]}<br>
# This fails because adding an integer to a string is not permitted.<br>
echo; echo; echo<br>
# -----------------------------------------------------------------<br>
# Another array, &quot;area2&quot;.<br>
Chapter 27. Arrays<br>
421<br>
<hr>
<A name=428></a>Advanced Bash-Scripting Guide<br>
# Another way of assigning array variables...<br>
# array_name=( XXX YYY ZZZ ... )<br>
area2=( zero one two three four )<br>
echo -n &quot;area2[0] = &quot;<br>
echo ${area2[0]}<br>
# Aha, zero-based indexing (first element of array is [0], not [1]).<br>
echo -n &quot;area2[1] = &quot;<br>
echo ${area2[1]} &nbsp; &nbsp;# [1] is second element of array.<br>
# -----------------------------------------------------------------<br>
echo; echo; echo<br>
# -----------------------------------------------<br>
# Yet another array, &quot;area3&quot;.<br>
# Yet another way of assigning array variables...<br>
# array_name=([xx]=XXX [yy]=YYY ...)<br>
area3=([17]=seventeen [24]=twenty-four)<br>
echo -n &quot;area3[17] = &quot;<br>
echo ${area3[17]}<br>
echo -n &quot;area3[24] = &quot;<br>
echo ${area3[24]}<br>
# -----------------------------------------------<br>
exit 0<br>
As we have seen, a convenient way of initializing an entire array is the&nbsp;array=( element1 element2<br>... elementN )&nbsp;notation.<br>
base64_charset=( {A..Z} {a..z} {0..9} + / = )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Using extended brace expansion<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to initialize the elements of the array. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Excerpted from vladz's &quot;base64.sh&quot; script<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ in the &quot;Contributed Scripts&quot; appendix.<br>
Bash permits array operations on variables, even if the variables are not explicitly declared as arrays.<br>
string=abcABC123ABCabc<br>
echo ${string[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabc<br>
echo ${string[*]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabc&nbsp;<br>
echo ${string[0]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabc<br>
echo ${string[1]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No output!<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why?<br>
echo ${#string[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # One element in the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The string itself.<br>
# Thank you, Michael Zick, for pointing this out.<br>
<a href="abs-guides.html#40">Once again this demonstrates that Bash variables are untyped.</a><br>
<b>Example 27-2. Formatting a poem</b><br>
Chapter 27. Arrays<br>
422<br>
<hr>
<A name=429></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# poem.sh: Pretty-prints one of the ABS Guide author's favorite poems.<br>
# Lines of the poem (single stanza).<br>
Line[1]=&quot;I do not know which to prefer,&quot;<br>
Line[2]=&quot;The beauty of inflections&quot;<br>
Line[3]=&quot;Or the beauty of innuendoes,&quot;<br>
Line[4]=&quot;The blackbird whistling&quot;<br>
Line[5]=&quot;Or just after.&quot;<br>
# Note that quoting permits embedding whitespace.<br>
# Attribution.<br>
Attrib[1]=&quot; Wallace Stevens&quot;<br>
Attrib[2]=&quot;\&quot;Thirteen Ways of Looking at a Blackbird\&quot;&quot;<br>
# This poem is in the Public Domain (copyright expired).<br>
echo<br>
tput bold &nbsp; # Bold print.<br>
for index in 1 2 3 4 5 &nbsp; &nbsp;# Five lines.<br>
do<br>
&nbsp; printf &quot; &nbsp; &nbsp; %s\n&quot; &quot;${Line[index]}&quot;<br>
done<br>
for index in 1 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Two attribution lines.<br>
do<br>
&nbsp; printf &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%s\n&quot; &quot;${Attrib[index]}&quot;<br>
done<br>
tput sgr0 &nbsp; # Reset terminal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # See 'tput' docs.<br>
echo<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# Modify this script to pretty-print a poem from a text data file.<br>
Array variables have a syntax all their own, and even standard Bash commands and operators have special<br>options adapted for array use.<br>
<b>Example 27-3. Various array operations</b><br>
#!/bin/bash<br>
# array-ops.sh: More fun with arrays.<br>
array=( zero one two three four five )<br>
# Element 0 &nbsp; 1 &nbsp; 2 &nbsp; &nbsp;3 &nbsp; &nbsp; 4 &nbsp; &nbsp;5<br>
echo ${array[0]} &nbsp; &nbsp; &nbsp; # &nbsp;zero<br>
echo ${array:0} &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;zero<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Parameter expansion of first element,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ starting at position # 0 (1st character).<br>
echo ${array:1} &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;ero<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Parameter expansion of first element,<br>
Chapter 27. Arrays<br>
423<br>
<hr>
<A name=430></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ starting at position # 1 (2nd character).<br>
echo &quot;--------------&quot;<br>
echo ${#array[0]} &nbsp; &nbsp; &nbsp;# &nbsp;4<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Length of first element of array.<br>
echo ${#array} &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;4<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Length of first element of array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;(Alternate notation)<br>
echo ${#array[1]} &nbsp; &nbsp; &nbsp;# &nbsp;3<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Length of second element of array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Arrays in Bash have zero-based indexing.<br>
echo ${#array[*]} &nbsp; &nbsp; &nbsp;# &nbsp;6<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Number of elements in array.<br>
echo ${#array[@]} &nbsp; &nbsp; &nbsp;# &nbsp;6<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Number of elements in array.<br>
echo &quot;--------------&quot;<br>
array2=( [0]=&quot;first element&quot; [1]=&quot;second element&quot; [3]=&quot;fourth element&quot; )<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; ^<br>
# Quoting permits embedding whitespace within individual array elements.<br>
echo ${array2[0]} &nbsp; &nbsp; &nbsp;# first element<br>
echo ${array2[1]} &nbsp; &nbsp; &nbsp;# second element<br>
echo ${array2[2]} &nbsp; &nbsp; &nbsp;#<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Skipped in initialization, and therefore null.<br>
echo ${array2[3]} &nbsp; &nbsp; &nbsp;# fourth element<br>
echo ${#array2[0]} &nbsp; &nbsp; # 13 &nbsp; &nbsp;(length of first element)<br>
echo ${#array2[*]} &nbsp; &nbsp; # 3 &nbsp; &nbsp; (number of elements in array)<br>
exit<br>
<a href="abs-guides.html#125">Many of the standard string operations work on arrays.</a><br>
<b>Example 27-4. String operations on arrays</b><br>
#!/bin/bash<br>
# array-strops.sh: String operations on arrays.<br>
# Script by Michael Zick.<br>
# Used in ABS Guide with permission.<br>
# Fixups: 05 May 08, 04 Aug 08.<br>
# &nbsp;In general, any string operation using the ${name ... } notation<br>
#+ can be applied to all string elements in an array,<br>
#+ with the ${name[@] ... } or ${name[*] ...} notation.<br>
arrayZ=( one two three four five five )<br>
echo<br>
# Trailing Substring Extraction<br>
echo ${arrayZ[@]:0} &nbsp; &nbsp; # one two three four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp;All elements.<br>
Chapter 27. Arrays<br>
424<br>
<hr>
<A name=431></a>Advanced Bash-Scripting Guide<br>
echo ${arrayZ[@]:1} &nbsp; &nbsp; # two three four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp;All elements following element[0].<br>
echo ${arrayZ[@]:1:2} &nbsp; # two three<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp;Only the two elements after element[0].<br>
echo &quot;---------&quot;<br>
# Substring Removal<br>
# Removes shortest match from front of string(s).<br>
echo ${arrayZ[@]#f*r} &nbsp; # one two three five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; # Applied to all elements of the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Matches &quot;four&quot; and removes it.<br>
# Longest match from front of string(s)<br>
echo ${arrayZ[@]##t*e} &nbsp;# one two four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;# Applied to all elements of the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Matches &quot;three&quot; and removes it.<br>
# Shortest match from back of string(s)<br>
echo ${arrayZ[@]%h*e} &nbsp; # one two t four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; # Applied to all elements of the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Matches &quot;hree&quot; and removes it.<br>
# Longest match from back of string(s)<br>
echo ${arrayZ[@]%%t*e} &nbsp;# one two four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;# Applied to all elements of the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Matches &quot;three&quot; and removes it.<br>
echo &quot;----------------------&quot;<br>
# Substring Replacement<br>
# Replace first occurrence of substring with replacement.<br>
echo ${arrayZ[@]/fiv/XYZ} &nbsp; # one two three four XYZe XYZe<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to all elements of the array.<br>
# Replace all occurrences of substring.<br>
echo ${arrayZ[@]//iv/YY} &nbsp; &nbsp;# one two three four fYYe fYYe<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to all elements of the array.<br>
# Delete all occurrences of substring.<br>
# Not specifing a replacement defaults to 'delete' ...<br>
echo ${arrayZ[@]//fi/} &nbsp; &nbsp; &nbsp;# one two three four ve ve<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to all elements of the array.<br>
# Replace front-end occurrences of substring.<br>
echo ${arrayZ[@]/#fi/XY} &nbsp; &nbsp;# one two three four XYve XYve<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to all elements of the array.<br>
# Replace back-end occurrences of substring.<br>
echo ${arrayZ[@]/%ve/ZZ} &nbsp; &nbsp;# one two three four fiZZ fiZZ<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to all elements of the array.<br>
echo ${arrayZ[@]/%o/XX} &nbsp; &nbsp; # one twXX three four five five<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Why?<br>
echo &quot;-----------------------------&quot;<br>
Chapter 27. Arrays<br>
425<br>
<hr>
<A name=432></a>Advanced Bash-Scripting Guide<br>
replacement() {<br>
&nbsp; &nbsp; echo -n &quot;!!!&quot;<br>
}<br>
echo ${arrayZ[@]/%e/$(replacement)}<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp;^^^^^^^^^^^^^^<br>
# on!!! two thre!!! four fiv!!! fiv!!!<br>
# The stdout of replacement() is the replacement string.<br>
# Q.E.D: The replacement action is, in effect, an 'assignment.'<br>
echo &quot;------------------------------------&quot;<br>
# &nbsp;Accessing the &quot;for-each&quot;:<br>
echo ${arrayZ[@]//*/$(replacement optional_arguments)}<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^ ^^^^^^^^^^^^^<br>
# !!! !!! !!! !!! !!! !!!<br>
# &nbsp;Now, if Bash would only pass the matched string<br>
#+ to the function being called . . .<br>
echo<br>
exit 0<br>
# &nbsp;Before reaching for a Big Hammer -- Perl, Python, or all the rest --<br>
# &nbsp;recall:<br>
# &nbsp; &nbsp;$( ... ) is command substitution.<br>
# &nbsp; &nbsp;A function runs as a sub-process.<br>
# &nbsp; &nbsp;A function writes its output (if echo-ed) to stdout.<br>
# &nbsp; &nbsp;Assignment, in conjunction with &quot;echo&quot; and command substitution,<br>
#+ &nbsp; can read a function's stdout.<br>
# &nbsp; &nbsp;The name[@] notation specifies (the equivalent of) a &quot;for-each&quot;<br>
#+ &nbsp; operation.<br>
# &nbsp;Bash is more powerful than you think!<br>
<a href="abs-guides.html#170">Command substitution can construct the individual elements of an array.</a><br>
<b>Example 27-5. Loading the contents of a script into an array</b><br>
#!/bin/bash<br>
# script-array.sh: Loads this script into an array.<br>
# Inspired by an e-mail from Chris Martin (thanks!).<br>
script_contents=( $(cat &quot;$0&quot;) ) &nbsp;# &nbsp;Stores contents of this script ($0)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ in an array.<br>
for element in $(seq 0 $((${#script_contents[@]} - 1)))<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;${#script_contents[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ gives number of elements in the array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Question:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Why is &nbsp;seq 0 &nbsp;necessary?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Try changing it to seq 1.<br>
&nbsp; echo -n &quot;${script_contents[$element]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # List each field of this script on a single line.<br>
# echo -n &quot;${script_contents[element]}&quot; also works because of ${ ... }.<br>
&nbsp; echo -n &quot; -- &quot; &nbsp; &nbsp;# Use &quot; -- &quot; as a field separator.<br>
done<br>
Chapter 27. Arrays<br>
426<br>
<hr>
<A name=433></a>Advanced Bash-Scripting Guide<br>
echo<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# &nbsp;Modify this script so it lists itself<br>
#+ in its original format,<br>
#+ complete with whitespace, line breaks, etc.<br>
<a href="abs-guides.html#186">In an array context, some Bash builtins have a slightly altered meaning.&nbsp;</a><a href="abs-guides.html#206">For example, unset deletes array<br></a>elements, or even an entire array.<br>
<b>Example 27-6. Some special properties of arrays</b><br>
#!/bin/bash<br>
declare -a colors<br>
# &nbsp;All subsequent commands in this script will treat<br>
#+ the variable &quot;colors&quot; as an array.<br>
echo &quot;Enter your favorite colors (separated from each other by a space).&quot;<br>
read -a colors &nbsp; &nbsp;# Enter at least 3 colors to demonstrate features below.<br>
# &nbsp;Special option to 'read' command,<br>
#+ allowing assignment of elements in an array.<br>
echo<br>
element_count=${#colors[@]}<br>
# Special syntax to extract number of elements in array.<br>
# &nbsp; &nbsp; element_count=${#colors[*]} works also.<br>
#<br>
# &nbsp;The &quot;@&quot; variable allows word splitting within quotes<br>
#+ (extracts variables separated by whitespace).<br>
#<br>
# &nbsp;This corresponds to the behavior of &quot;$@&quot; and &quot;$*&quot;<br>
#+ in positional parameters.&nbsp;<br>
index=0<br>
while [ &quot;$index&quot; -lt &quot;$element_count&quot; ]<br>
do &nbsp; &nbsp;# List all the elements in the array.<br>
&nbsp; echo ${colors[$index]}<br>
&nbsp; # &nbsp; &nbsp;${colors[index]} also works because it's within ${ ... } brackets.<br>
&nbsp; let &quot;index = $index + 1&quot;<br>
&nbsp; # Or:<br>
&nbsp; # &nbsp; &nbsp;((index++))<br>
done<br>
# Each array element listed on a separate line.<br>
# If this is not desired, use &nbsp;echo -n &quot;${colors[$index]} &quot;<br>
#<br>
# Doing it with a &quot;for&quot; loop instead:<br>
# &nbsp; for i in &quot;${colors[@]}&quot;<br>
# &nbsp; do<br>
# &nbsp; &nbsp; echo &quot;$i&quot;<br>
# &nbsp; done<br>
# (Thanks, S.C.)<br>
Chapter 27. Arrays<br>
427<br>
<hr>
<A name=434></a>Advanced Bash-Scripting Guide<br>
echo<br>
# Again, list all the elements in the array, but using a more elegant method.<br>
&nbsp; echo ${colors[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# echo ${colors[*]} also works.<br>
echo<br>
# The &quot;unset&quot; command deletes elements of an array, or entire array.<br>
unset colors[1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Remove 2nd element of array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Same effect as &nbsp; colors[1]=<br>
echo &nbsp;${colors[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # List array again, missing 2nd element.<br>
unset colors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Delete entire array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;unset colors[*] and<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ unset colors[@] also work.<br>
echo; echo -n &quot;Colors gone.&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
echo ${colors[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# List array again, now empty.<br>
exit 0<br>
As seen in the previous example, either<b>&nbsp;${array_name[@]}</b>&nbsp;or<b>&nbsp;${array_name[*]}</b>&nbsp;refers to<i>&nbsp;all</i>&nbsp;the elements<br>of the array. Similarly, to get a count of the number of elements in an array, use either<b>&nbsp;${#array_name[@]}<br></b>or<b>&nbsp;${#array_name[*]}</b>.<b>&nbsp;${#array_name}</b>&nbsp;is the length (number of characters) of<b>&nbsp;${array_name[0]}</b>, the first<br>element of the array.<br>
<b>Example 27-7. Of empty arrays and empty elements</b><br>
#!/bin/bash<br>
# empty-array.sh<br>
# &nbsp;Thanks to Stephane Chazelas for the original example,<br>
#+ and to Michael Zick and Omair Eshkenazi, for extending it.<br>
# &nbsp;And to Nathan Coulter for clarifications and corrections.<br>
# An empty array is not the same as an array with empty elements.<br>
&nbsp; array0=( first second third )<br>
&nbsp; array1=( '' ) &nbsp; # &quot;array1&quot; consists of one empty element.<br>
&nbsp; array2=( ) &nbsp; &nbsp; &nbsp;# No elements . . . &quot;array2&quot; is empty.<br>
&nbsp; array3=( &nbsp; ) &nbsp; &nbsp;# What about this array?<br>
echo<br>
ListArray()<br>
{<br>
echo<br>
echo &quot;Elements in array0: &nbsp;${array0[@]}&quot;<br>
echo &quot;Elements in array1: &nbsp;${array1[@]}&quot;<br>
echo &quot;Elements in array2: &nbsp;${array2[@]}&quot;<br>
echo &quot;Elements in array3: &nbsp;${array3[@]}&quot;<br>
echo<br>
echo &quot;Length of first element in array0 = ${#array0}&quot;<br>
echo &quot;Length of first element in array1 = ${#array1}&quot;<br>
echo &quot;Length of first element in array2 = ${#array2}&quot;<br>
echo &quot;Length of first element in array3 = ${#array3}&quot;<br>
echo<br>
echo &quot;Number of elements in array0 = ${#array0[*]}&quot; &nbsp;# 3<br>
Chapter 27. Arrays<br>
428<br>
<hr>
<A name=435></a>Advanced Bash-Scripting Guide<br>
echo &quot;Number of elements in array1 = ${#array1[*]}&quot; &nbsp;# 1 &nbsp;(Surprise!)<br>
echo &quot;Number of elements in array2 = ${#array2[*]}&quot; &nbsp;# 0<br>
echo &quot;Number of elements in array3 = ${#array3[*]}&quot; &nbsp;# 0<br>
}<br>
# ===================================================================<br>
ListArray<br>
# Try extending those arrays.<br>
# Adding an element to an array.<br>
array0=( &quot;${array0[@]}&quot; &quot;new1&quot; )<br>
array1=( &quot;${array1[@]}&quot; &quot;new1&quot; )<br>
array2=( &quot;${array2[@]}&quot; &quot;new1&quot; )<br>
array3=( &quot;${array3[@]}&quot; &quot;new1&quot; )<br>
ListArray<br>
# or<br>
array0[${#array0[*]}]=&quot;new2&quot;<br>
array1[${#array1[*]}]=&quot;new2&quot;<br>
array2[${#array2[*]}]=&quot;new2&quot;<br>
array3[${#array3[*]}]=&quot;new2&quot;<br>
ListArray<br>
# When extended as above, arrays are 'stacks' ...<br>
# Above is the 'push' ...<br>
# The stack 'height' is:<br>
height=${#array2[@]}<br>
echo<br>
echo &quot;Stack height for array2 = $height&quot;<br>
# The 'pop' is:<br>
unset array2[${#array2[@]}-1] &nbsp; # &nbsp;Arrays are zero-based,<br>
height=${#array2[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ which means first element has index 0.<br>
echo<br>
echo &quot;POP&quot;<br>
echo &quot;New stack height for array2 = $height&quot;<br>
ListArray<br>
# List only 2nd and 3rd elements of array0.<br>
from=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Zero-based numbering.<br>
to=2<br>
array3=( ${array0[@]:1:2} )<br>
echo<br>
echo &quot;Elements in array3: &nbsp;${array3[@]}&quot;<br>
# Works like a string (array of characters).<br>
# Try some other &quot;string&quot; forms.<br>
# Replacement:<br>
array4=( ${array0[@]/second/2nd} )<br>
echo<br>
echo &quot;Elements in array4: &nbsp;${array4[@]}&quot;<br>
# Replace all matching wildcarded string.<br>
array5=( ${array0[@]//new?/old} )<br>
echo<br>
echo &quot;Elements in array5: &nbsp;${array5[@]}&quot;<br>
Chapter 27. Arrays<br>
429<br>
<hr>
<A name=436></a>Advanced Bash-Scripting Guide<br>
# Just when you are getting the feel for this . . .<br>
array6=( ${array0[@]#*new} )<br>
echo # This one might surprise you.<br>
echo &quot;Elements in array6: &nbsp;${array6[@]}&quot;<br>
array7=( ${array0[@]#new1} )<br>
echo # After array6 this should not be a surprise.<br>
echo &quot;Elements in array7: &nbsp;${array7[@]}&quot;<br>
# Which looks a lot like . . .<br>
array8=( ${array0[@]/new1/} )<br>
echo<br>
echo &quot;Elements in array8: &nbsp;${array8[@]}&quot;<br>
# &nbsp;So what can one say about this?<br>
# &nbsp;The string operations are performed on<br>
#+ each of the elements in var[@] in succession.<br>
# &nbsp;Therefore : Bash supports string vector operations.<br>
# &nbsp;If the result is a zero length string,<br>
#+ that element disappears in the resulting assignment.<br>
# &nbsp;However, if the expansion is in quotes, the null elements remain.<br>
# &nbsp;Michael Zick: &nbsp; &nbsp;Question, are those strings hard or soft quotes?<br>
# &nbsp;Nathan Coulter: &nbsp;There is no such thing as &quot;soft quotes.&quot;<br>
#! &nbsp; &nbsp;What's really happening is that<br>
#!+ &nbsp; the pattern matching happens after<br>
#!+ &nbsp; all the other expansions of [word]<br>
#!+ &nbsp; in cases like ${parameter#word}.<br>
zap='new*'<br>
array9=( ${array0[@]/$zap/} )<br>
echo<br>
echo &quot;Number of elements in array9: &nbsp;${#array9[@]}&quot;<br>
array9=( &quot;${array0[@]/$zap/}&quot; )<br>
echo &quot;Elements in array9: &nbsp;${array9[@]}&quot;<br>
# This time the null elements remain.<br>
echo &quot;Number of elements in array9: &nbsp;${#array9[@]}&quot;<br>
# Just when you thought you were still in Kansas . . .<br>
array10=( ${array0[@]#$zap} )<br>
echo<br>
echo &quot;Elements in array10: &nbsp;${array10[@]}&quot;<br>
# But, the asterisk in zap won't be interpreted if quoted.<br>
array10=( ${array0[@]#&quot;$zap&quot;} )<br>
echo<br>
echo &quot;Elements in array10: &nbsp;${array10[@]}&quot;<br>
# Well, maybe we _are_ still in Kansas . . .<br>
# (Revisions to above code block by Nathan Coulter.)<br>
# &nbsp;Compare array7 with array10.<br>
# &nbsp;Compare array8 with array9.<br>
# &nbsp;Reiterating: No such thing as soft quotes!<br>
# &nbsp;Nathan Coulter explains:<br>
# &nbsp;Pattern matching of 'word' in ${parameter#word} is done after<br>
#+ parameter expansion and *before* quote removal.<br>
# &nbsp;In the normal case, pattern matching is done *after* quote removal.<br>
Chapter 27. Arrays<br>
430<br>
<hr>
<A name=437></a><IMG src="abs-guide-437_1.png"><br>
Advanced Bash-Scripting Guide<br>
exit<br>
The relationship of<b>&nbsp;${array_name[@]}</b>&nbsp;and<b>&nbsp;${array_name[*]}</b><a href="abs-guides.html#104">&nbsp;is analogous to that between $@ and $*. This<br></a>powerful array notation has a number of uses.<br>
# Copying an array.<br>
array2=( &quot;${array1[@]}&quot; )<br>
# or<br>
array2=&quot;${array1[@]}&quot;<br>
#<br>
# &nbsp;However, this fails with &quot;sparse&quot; arrays,<br>
#+ arrays with holes (missing elements) in them,<br>
#+ as Jochen DeSmet points out.<br>
# ------------------------------------------<br>
&nbsp; array1[0]=0<br>
# array1[1] not assigned<br>
&nbsp; array1[2]=2<br>
&nbsp; array2=( &quot;${array1[@]}&quot; ) &nbsp; &nbsp; &nbsp; # Copy it?<br>
echo ${array2[0]} &nbsp; &nbsp; &nbsp;# 0<br>
echo ${array2[2]} &nbsp; &nbsp; &nbsp;# (null), should be 2<br>
# ------------------------------------------<br>
# Adding an element to an array.<br>
array=( &quot;${array[@]}&quot; &quot;new element&quot; )<br>
# or<br>
array[${#array[*]}]=&quot;new element&quot;<br>
# Thanks, S.C.<br>
The<b>&nbsp;array=( element1 element2 ... elementN )</b><a href="abs-guides.html#170">&nbsp;initialization operation, with the help of command<br>substitution, makes it possible to load the contents of a text file into an array.</a><br>
#!/bin/bash<br>
filename=sample_file<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cat sample_file<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 a b c<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 d e fg<br>
declare -a array1<br>
array1=( `cat &quot;$filename&quot;`) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Loads contents<br>
# &nbsp; &nbsp; &nbsp; &nbsp; List file to stdout &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ of $filename into array1.<br>
#<br>
# &nbsp;array1=( `cat &quot;$filename&quot; | tr '\n' ' '`)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;change linefeeds in file to spaces.&nbsp;<br>
# &nbsp;Not necessary because Bash does word splitting,<br>
#+ changing linefeeds to spaces.<br>
echo ${array1[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# List the array.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 a b c 2 d e fg<br>
#<br>
Chapter 27. Arrays<br>
431<br>
<hr>
<A name=438></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Each whitespace-separated &quot;word&quot; in the file<br>
#+ has been assigned to an element of the array.<br>
element_count=${#array1[*]}<br>
echo $element_count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 8<br>
Clever scripting makes it possible to add array operations.<br>
<b>Example 27-8. Initializing arrays</b><br>
#! /bin/bash<br>
# array-assign.bash<br>
# &nbsp;Array operations are Bash-specific,<br>
#+ hence the &quot;.bash&quot; in the script name.<br>
# Copyright (c) Michael S. Zick, 2003, All rights reserved.<br>
# License: Unrestricted reuse in any form, for any purpose.<br>
# Version: $ID$<br>
#<br>
# Clarification and additional comments by William Park.<br>
# &nbsp;Based on an example provided by Stephane Chazelas<br>
#+ which appeared in an earlier version of the<br>
#+ Advanced Bash Scripting Guide.<br>
# Output format of the 'times' command:<br>
# User CPU &lt;space&gt; System CPU<br>
# User CPU of dead children &lt;space&gt; System CPU of dead children<br>
# &nbsp;Bash has two versions of assigning all elements of an array<br>
#+ to a new array variable.<br>
# &nbsp;Both drop 'null reference' elements<br>
#+ in Bash versions 2.04 and later.<br>
# &nbsp;An additional array assignment that maintains the relationship of<br>
#+ [subscript]=value for arrays may be added to newer versions.<br>
# &nbsp;Constructs a large array using an internal command,<br>
#+ but anything creating an array of several thousand elements<br>
#+ will do just fine.<br>
declare -a bigOne=( /dev/* ) &nbsp;# All the files in /dev . . .<br>
echo<br>
echo 'Conditions: Unquoted, default IFS, All-Elements-Of'<br>
echo &quot;Number of elements in array is ${#bigOne[@]}&quot;<br>
# set -vx<br>
echo<br>
echo '- - testing: =( ${array[@]} ) - -'<br>
times<br>
declare -a bigTwo=( ${bigOne[@]} )<br>
# Note parens: &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
times<br>
echo<br>
Chapter 27. Arrays<br>
432<br>
<hr>
<A name=439></a><IMG src="abs-guide-439_1.png"><br>
Advanced Bash-Scripting Guide<br>
echo '- - testing: =${array[@]} - -'<br>
times<br>
declare -a bigThree=${bigOne[@]}<br>
# No parentheses this time.<br>
times<br>
# &nbsp;Comparing the numbers shows that the second form, pointed out<br>
#+ by Stephane Chazelas, is faster.<br>
#<br>
# &nbsp;As William Park explains:<br>
#+ The bigTwo array assigned element by element (because of parentheses),<br>
#+ whereas bigThree assigned as a single string.<br>
# &nbsp;So, in essence, you have:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bigTwo=( [0]=&quot;...&quot; [1]=&quot;...&quot; [2]=&quot;...&quot; ... )<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bigThree=( [0]=&quot;... ... ...&quot; )<br>
#<br>
# &nbsp;Verify this by: &nbsp;echo ${bigTwo[0]}<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ${bigThree[0]}<br>
# &nbsp;I will continue to use the first form in my example descriptions<br>
#+ because I think it is a better illustration of what is happening.<br>
# &nbsp;The reusable portions of my examples will actual contain<br>
#+ the second form where appropriate because of the speedup.<br>
# MSZ: Sorry about that earlier oversight folks.<br>
# &nbsp;Note:<br>
# &nbsp;----<br>
# &nbsp;The &quot;declare -a&quot; statements in lines 32 and 44<br>
#+ are not strictly necessary, since it is implicit<br>
#+ in the &nbsp;Array=( ... ) &nbsp;assignment form.<br>
# &nbsp;However, eliminating these declarations slows down<br>
#+ the execution of the following sections of the script.<br>
# &nbsp;Try it, and see.<br>
exit 0<br>
Adding a superfluous<b>&nbsp;declare -a</b>&nbsp;statement to an array declaration may speed up execution of subsequent<br>operations on the array.<br>
<b>Example 27-9. Copying and concatenating arrays</b><br>
#! /bin/bash<br>
# CopyArray.sh<br>
#<br>
# This script written by Michael Zick.<br>
# Used here with permission.<br>
# &nbsp;How-To &quot;Pass by Name &amp; Return by Name&quot;<br>
#+ or &quot;Building your own assignment statement&quot;.<br>
CpArray_Mac() {<br>
# Assignment Command Statement Builder<br>
Chapter 27. Arrays<br>
433<br>
<hr>
<A name=440></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; echo -n 'eval '<br>
&nbsp; &nbsp; echo -n &quot;$2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Destination name<br>
&nbsp; &nbsp; echo -n '=( ${'<br>
&nbsp; &nbsp; echo -n &quot;$1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Source name<br>
&nbsp; &nbsp; echo -n '[@]} )'<br>
# That could all be a single command.<br>
# Matter of style only.<br>
}<br>
declare -f CopyArray &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Function &quot;Pointer&quot;<br>
CopyArray=CpArray_Mac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Statement Builder<br>
Hype()<br>
{<br>
# Hype the array named $1.<br>
# (Splice it together with array containing &quot;Really Rocks&quot;.)<br>
# Return in array named $2.<br>
&nbsp; &nbsp; local -a TMP<br>
&nbsp; &nbsp; local -a hype=( Really Rocks )<br>
&nbsp; &nbsp; $($CopyArray $1 TMP)<br>
&nbsp; &nbsp; TMP=( ${TMP[@]} ${hype[@]} )<br>
&nbsp; &nbsp; $($CopyArray TMP $2)<br>
}<br>
declare -a before=( Advanced Bash Scripting )<br>
declare -a after<br>
echo &quot;Array Before = ${before[@]}&quot;<br>
Hype before after<br>
echo &quot;Array After = ${after[@]}&quot;<br>
# Too much hype?<br>
echo &quot;What ${after[@]:3:2}?&quot;<br>
declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;---- substring extraction ----<br>
echo &quot;Array Modest = ${modest[@]}&quot;<br>
# What happened to 'before' ?<br>
echo &quot;Array Before = ${before[@]}&quot;<br>
exit 0<br>
<b>Example 27-10. More on concatenating arrays</b><br>
#! /bin/bash<br>
# array-append.bash<br>
# Copyright (c) Michael S. Zick, 2003, All rights reserved.<br>
# License: Unrestricted reuse in any form, for any purpose.<br>
# Version: $ID$<br>
#<br>
Chapter 27. Arrays<br>
434<br>
<hr>
<A name=441></a>Advanced Bash-Scripting Guide<br>
# Slightly modified in formatting by M.C.<br>
# Array operations are Bash-specific.<br>
# Legacy UNIX /bin/sh lacks equivalents.<br>
# &nbsp;Pipe the output of this script to 'more'<br>
#+ so it doesn't scroll off the terminal.<br>
# &nbsp;Or, redirect output to a file.<br>
declare -a array1=( zero1 one1 two1 )<br>
# Subscript packed.<br>
declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )<br>
# Subscript sparse -- [1] is not defined.<br>
echo<br>
echo '- Confirm that the array is really subscript sparse. -'<br>
echo &quot;Number of elements: 4&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Hard-coded for illustration.<br>
for (( i = 0 ; i &lt; 4 ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &quot;Element [$i]: ${array2[$i]}&quot;<br>
done<br>
# See also the more general code example in basics-reviewed.bash.<br>
declare -a dest<br>
# Combine (append) two arrays into a third array.<br>
echo<br>
echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'<br>
echo '- Undefined elements not present, subscripts not maintained. -'<br>
# # The undefined elements do not exist; they are not being dropped.<br>
dest=( ${array1[@]} ${array2[@]} )<br>
# dest=${array1[@]}${array2[@]} &nbsp; &nbsp; # Strange results, possibly a bug.<br>
# Now, list the result.<br>
echo<br>
echo '- - Testing Array Append - -'<br>
cnt=${#dest[@]}<br>
echo &quot;Number of elements: $cnt&quot;<br>
for (( i = 0 ; i &lt; cnt ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &quot;Element [$i]: ${dest[$i]}&quot;<br>
done<br>
# Assign an array to a single array element (twice).<br>
dest[0]=${array1[@]}<br>
dest[1]=${array2[@]}<br>
# List the result.<br>
echo<br>
echo '- - Testing modified array - -'<br>
cnt=${#dest[@]}<br>
echo &quot;Number of elements: $cnt&quot;<br>
for (( i = 0 ; i &lt; cnt ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &quot;Element [$i]: ${dest[$i]}&quot;<br>
Chapter 27. Arrays<br>
435<br>
<hr>
<A name=442></a>Advanced Bash-Scripting Guide<br>
done<br>
# Examine the modified second element.<br>
echo<br>
echo '- - Reassign and list second element - -'<br>
declare -a subArray=${dest[1]}<br>
cnt=${#subArray[@]}<br>
echo &quot;Number of elements: $cnt&quot;<br>
for (( i = 0 ; i &lt; cnt ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &quot;Element [$i]: ${subArray[$i]}&quot;<br>
done<br>
# &nbsp;The assignment of an entire array to a single element<br>
#+ of another array using the '=${ ... }' array assignment<br>
#+ has converted the array being assigned into a string,<br>
#+ with the elements separated by a space (the first character of IFS).<br>
# If the original elements didn't contain whitespace . . .<br>
# If the original array isn't subscript sparse . . .<br>
# Then we could get the original array structure back again.<br>
# Restore from the modified second element.<br>
echo<br>
echo '- - Listing restored element - -'<br>
declare -a subArray=( ${dest[1]} )<br>
cnt=${#subArray[@]}<br>
echo &quot;Number of elements: $cnt&quot;<br>
for (( i = 0 ; i &lt; cnt ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &quot;Element [$i]: ${subArray[$i]}&quot;<br>
done<br>
echo '- - Do not depend on this behavior. - -'<br>
echo '- - This behavior is subject to change - -'<br>
echo '- - in versions of Bash newer than version 2.05b - -'<br>
# MSZ: Sorry about any earlier confusion folks.<br>
exit 0<br>
--<br>
Arrays permit deploying old familiar algorithms as shell scripts. Whether this is necessarily a good idea is left<br>for the reader to decide.<br>
<b>Example 27-11. The Bubble Sort</b><br>
#!/bin/bash<br>
# bubble.sh: Bubble sort, of sorts.<br>
# Recall the algorithm for a bubble sort. In this particular version...<br>
# &nbsp;With each successive pass through the array to be sorted,<br>
#+ compare two adjacent elements, and swap them if out of order.<br>
# &nbsp;At the end of the first pass, the &quot;heaviest&quot; element has sunk to bottom.<br>
Chapter 27. Arrays<br>
436<br>
<hr>
<A name=443></a>Advanced Bash-Scripting Guide<br>
# &nbsp;At the end of the second pass, the next &quot;heaviest&quot; one has sunk next to bottom.<br>
# &nbsp;And so forth.<br>
# &nbsp;This means that each successive pass needs to traverse less of the array.<br>
# &nbsp;You will therefore notice a speeding up in the printing of the later passes.<br>
exchange()<br>
{<br>
&nbsp; # Swaps two members of the array.<br>
&nbsp; local temp=${Countries[$1]} # &nbsp;Temporary storage<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ for element getting swapped out.<br>
&nbsp; Countries[$1]=${Countries[$2]}<br>
&nbsp; Countries[$2]=$temp<br>
&nbsp; return<br>
} &nbsp;<br>
declare -a Countries &nbsp;# &nbsp;Declare array,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ optional here since it's initialized below.<br>
# &nbsp;Is it permissable to split an array variable over multiple lines<br>
#+ using an escape (\)?<br>
# &nbsp;Yes.<br>
Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \<br>
Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \<br>
Israel Peru Canada Oman Denmark Wales France Kenya \<br>
Xanadu Qatar Liechtenstein Hungary)<br>
# &quot;Xanadu&quot; is the mythical place where, according to Coleridge,<br>
#+ Kubla Khan did a pleasure dome decree.<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Clear the screen to start with.&nbsp;<br>
echo &quot;0: ${Countries[*]}&quot; &nbsp;# List entire array at pass 0.<br>
number_of_elements=${#Countries[@]}<br>
let &quot;comparisons = $number_of_elements - 1&quot;<br>
count=1 # Pass number.<br>
while [ &quot;$comparisons&quot; -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Beginning of outer loop<br>
do<br>
&nbsp; index=0 &nbsp;# Reset index to start of array after each pass.<br>
&nbsp; while [ &quot;$index&quot; -lt &quot;$comparisons&quot; ] # Beginning of inner loop<br>
&nbsp; do<br>
&nbsp; &nbsp; if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]<br>
&nbsp; &nbsp; # &nbsp;If out of order...<br>
&nbsp; &nbsp; # &nbsp;Recalling that \&gt; is ASCII comparison operator<br>
&nbsp; &nbsp; #+ within single brackets.<br>
&nbsp; &nbsp; # &nbsp;if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]<br>
&nbsp; &nbsp; #+ also works.<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; exchange $index `expr $index + 1` &nbsp;# Swap.<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; &nbsp; let &quot;index += 1&quot; &nbsp;# Or, &nbsp; index+=1 &nbsp; on Bash, ver. 3.1 or newer.<br>
&nbsp; done # End of inner loop<br>
Chapter 27. Arrays<br>
437<br>
<hr>
<A name=444></a>Advanced Bash-Scripting Guide<br>
# ----------------------------------------------------------------------<br>
# Paulo Marcel Coelho Aragao suggests for-loops as a simpler altenative.<br>
#<br>
# for (( last = $number_of_elements - 1 ; last &gt; 0 ; last-- ))<br>
## &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Fix by C.Y. Hunt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; (Thanks!)<br>
# do<br>
# &nbsp; &nbsp; for (( i = 0 ; i &lt; last ; i++ ))<br>
# &nbsp; &nbsp; do<br>
# &nbsp; &nbsp; &nbsp; &nbsp; [[ &quot;${Countries[$i]}&quot; &gt; &quot;${Countries[$((i+1))]}&quot; ]] \<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; exchange $i $((i+1))<br>
# &nbsp; &nbsp; done<br>
# done<br>
# ----------------------------------------------------------------------<br>
let &quot;comparisons -= 1&quot; # &nbsp;Since &quot;heaviest&quot; element bubbles to bottom,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ we need do one less comparison each pass.<br>
echo<br>
echo &quot;$count: ${Countries[@]}&quot; &nbsp;# Print resultant array at end of each pass.<br>
echo<br>
let &quot;count += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Increment pass count.<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# End of outer loop<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # All done.<br>
exit 0<br>
--<br>
Is it possible to nest arrays within arrays?<br>
#!/bin/bash<br>
# &quot;Nested&quot; array.<br>
# &nbsp;Michael Zick provided this example,<br>
#+ with corrections and clarifications by William Park.<br>
AnArray=( $(ls --inode --ignore-backups --almost-all \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --directory --full-time --color=none --time=status \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --sort=time -l ${PWD} ) ) &nbsp;# Commands and options.<br>
# Spaces are significant . . . and don't quote anything in the above.<br>
SubArray=( ${AnArray[@]:11:1} &nbsp;${AnArray[@]:6:5} )<br>
# &nbsp;This array has six elements:<br>
#+ &nbsp; &nbsp; SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}<br>
# &nbsp; &nbsp; &nbsp;[3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )<br>
#<br>
# &nbsp;Arrays in Bash are (circularly) linked lists<br>
#+ of type string (char *).<br>
# &nbsp;So, this isn't actually a nested array,<br>
#+ but it's functionally similar.<br>
echo &quot;Current directory and date of last status change:&quot;<br>
echo &quot;${SubArray[@]}&quot;<br>
exit 0<br>
--<br>
Chapter 27. Arrays<br>
438<br>
<hr>
<A name=445></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#541">Embedded arrays in combination with indirect references create some fascinating possibilities</a><br>
<b>Example 27-12. Embedded arrays and indirect references</b><br>
#!/bin/bash<br>
# embedded-arrays.sh<br>
# Embedded arrays and indirect references.<br>
# This script by Dennis Leeuw.<br>
# Used with permission.<br>
# Modified by document author.<br>
ARRAY1=(<br>
&nbsp; &nbsp; &nbsp; &nbsp; VAR1_1=value11<br>
&nbsp; &nbsp; &nbsp; &nbsp; VAR1_2=value12<br>
&nbsp; &nbsp; &nbsp; &nbsp; VAR1_3=value13<br>
)<br>
ARRAY2=(<br>
&nbsp; &nbsp; &nbsp; &nbsp; VARIABLE=&quot;test&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; STRING=&quot;VAR1=value1 VAR2=value2 VAR3=value3&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ARRAY21=${ARRAY1[*]}<br>
) &nbsp; &nbsp; &nbsp; # Embed ARRAY1 within this second array.<br>
function print () {<br>
&nbsp; &nbsp; &nbsp; &nbsp; OLD_IFS=&quot;$IFS&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=$'\n' &nbsp; &nbsp; &nbsp; # &nbsp;To print each array element<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ on a separate line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; TEST1=&quot;ARRAY2[*]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; local ${!TEST1} # See what happens if you delete this line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Indirect reference.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This makes the components of $TEST1<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ accessible to this function.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Let's see what we've got so far.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;\$TEST1 = $TEST1&quot; &nbsp; &nbsp; &nbsp; # &nbsp;Just the name of the variable.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;{\$TEST1} = ${!TEST1}&quot; &nbsp;# &nbsp;Contents of the variable.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;That's what an indirect<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ reference does.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;-------------------------------------------&quot;; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Print variable<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Variable VARIABLE: $VARIABLE&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Print a string element<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=&quot;$OLD_IFS&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; TEST2=&quot;STRING[*]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; local ${!TEST2} &nbsp; &nbsp; &nbsp;# Indirect reference (as above).<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;String element VAR2: $VAR2 from STRING&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Print an array element<br>
&nbsp; &nbsp; &nbsp; &nbsp; TEST2=&quot;ARRAY21[*]&quot;<br>
Chapter 27. Arrays<br>
439<br>
<hr>
<A name=446></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; local ${!TEST2} &nbsp; &nbsp; &nbsp;# Indirect reference (as above).<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Array element VAR1_1: $VAR1_1 from ARRAY21&quot;<br>
}<br>
print<br>
echo<br>
exit 0<br>
# &nbsp; As the author of the script notes,<br>
#+ &quot;you can easily expand it to create named-hashes in bash.&quot;<br>
# &nbsp; (Difficult) exercise for the reader: implement this.<br>
--<br>
Arrays enable implementing a shell script version of the<i>&nbsp;Sieve of Eratosthenes</i>. Of course, a resource-intensive<br>application of this nature should really be written in a compiled language, such as C. It runs excruciatingly<br>slowly as a script.<br>
<b>Example 27-13. The Sieve of Eratosthenes</b><br>
#!/bin/bash<br>
# sieve.sh (ex68.sh)<br>
# Sieve of Eratosthenes<br>
# Ancient algorithm for finding prime numbers.<br>
# &nbsp;This runs a couple of orders of magnitude slower<br>
#+ than the equivalent program written in C.<br>
LOWER_LIMIT=1 &nbsp; &nbsp; &nbsp; # Starting with 1.<br>
UPPER_LIMIT=1000 &nbsp; &nbsp;# Up to 1000.<br>
# (You may set this higher . . . if you have time on your hands.)<br>
PRIME=1<br>
NON_PRIME=0<br>
let SPLIT=UPPER_LIMIT/2<br>
# Optimization:<br>
# Need to test numbers only halfway to upper limit. Why?<br>
declare -a Primes<br>
# Primes[] is an array.<br>
initialize ()<br>
{<br>
# Initialize the array.<br>
i=$LOWER_LIMIT<br>
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]<br>
do<br>
&nbsp; Primes[i]=$PRIME<br>
&nbsp; let &quot;i += 1&quot;<br>
done<br>
# &nbsp;Assume all array members guilty (prime)<br>
#+ until proven innocent.<br>
}<br>
Chapter 27. Arrays<br>
440<br>
<hr>
<A name=447></a>Advanced Bash-Scripting Guide<br>
print_primes ()<br>
{<br>
# Print out the members of the Primes[] array tagged as prime.<br>
i=$LOWER_LIMIT<br>
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]<br>
do<br>
&nbsp; if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; printf &quot;%8d&quot; $i<br>
&nbsp; &nbsp; # 8 spaces per number gives nice, even columns.<br>
&nbsp; fi<br>
&nbsp; let &quot;i += 1&quot;<br>
done<br>
}<br>
sift () # Sift out the non-primes.<br>
{<br>
let i=$LOWER_LIMIT+1<br>
# Let's start with 2.<br>
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]<br>
do<br>
if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]<br>
# Don't bother sieving numbers already sieved (tagged as non-prime).<br>
then<br>
&nbsp; t=$i<br>
&nbsp; while [ &quot;$t&quot; -le &quot;$UPPER_LIMIT&quot; ]<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;t += $i &quot;<br>
&nbsp; &nbsp; Primes[t]=$NON_PRIME<br>
&nbsp; &nbsp; # Tag as non-prime all multiples.<br>
&nbsp; done<br>
fi &nbsp;<br>
&nbsp; let &quot;i += 1&quot;<br>
done &nbsp;<br>
}<br>
# ==============================================<br>
# main ()<br>
# Invoke the functions sequentially.<br>
initialize<br>
sift<br>
print_primes<br>
# This is what they call structured programming.<br>
# ==============================================<br>
Chapter 27. Arrays<br>
441<br>
<hr>
<A name=448></a>Advanced Bash-Scripting Guide<br>
echo<br>
exit 0<br>
# -------------------------------------------------------- #<br>
# Code below line will not execute, because of 'exit.'<br>
# &nbsp;This improved version of the Sieve, by Stephane Chazelas,<br>
#+ executes somewhat faster.<br>
# Must invoke with command-line argument (limit of primes).<br>
UPPER_LIMIT=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# From command-line.<br>
let SPLIT=UPPER_LIMIT/2 &nbsp; &nbsp; &nbsp; &nbsp; # Halfway to max number.<br>
Primes=( '' $(seq $UPPER_LIMIT) )<br>
i=1<br>
until (( ( i += 1 ) &gt; SPLIT )) &nbsp;# Need check only halfway.<br>
do<br>
&nbsp; if [[ -n $Primes[i] ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; t=$i<br>
&nbsp; &nbsp; until (( ( t += i ) &gt; UPPER_LIMIT ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; Primes[t]=<br>
&nbsp; &nbsp; done<br>
&nbsp; fi &nbsp;<br>
done &nbsp;<br>
echo ${Primes[*]}<br>
exit $?<br>
<b>Example 27-14. The Sieve of Eratosthenes, Optimized</b><br>
#!/bin/bash<br>
# Optimized Sieve of Eratosthenes<br>
# Script by Jared Martin, with very minor changes by ABS Guide author.<br>
# Used in ABS Guide with permission (thanks!).<br>
# Based on script in Advanced Bash Scripting Guide.<br>
# http://tldp.org/LDP/abs/html/arrays.html#PRIMES0 (ex68.sh).<br>
# http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf (reference)<br>
# Check results against http://primes.utm.edu/lists/small/1000.txt<br>
# Necessary but not sufficient would be, e.g.,<br>
# &nbsp; &nbsp; (($(sieve 7919 | wc -w) == 1000)) &amp;&amp; echo &quot;7919 is the 1000th prime&quot;<br>
UPPER_LIMIT=${1:?&quot;Need an upper limit of primes to search.&quot;}<br>
Primes=( '' $(seq ${UPPER_LIMIT}) )<br>
typeset -i i t<br>
Primes[i=1]='' # 1 is not a prime.<br>
until (( ( i += 1 ) &gt; (${UPPER_LIMIT}/i) )) &nbsp;# Need check only ith-way.<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why?<br>
&nbsp; &nbsp; if ((${Primes[t=i*(i-1), i]}))<br>
&nbsp; &nbsp; # Obscure, but instructive, use of arithmetic expansion in subscript.<br>
Chapter 27. Arrays<br>
442<br>
<hr>
<A name=449></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; until (( ( t += i ) &gt; ${UPPER_LIMIT} ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do Primes[t]=; done<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
# echo ${Primes[*]}<br>
echo &nbsp; # Change to original script for pretty-printing (80-col. display).<br>
printf &quot;%8d&quot; ${Primes[*]}<br>
echo; echo<br>
exit $?<br>
<a href="abs-guides.html#592">Compare these array-based prime number generators with alternatives that do not use arrays, Example A-15,<br></a><a href="abs-guides.html#296">and Example 16-46.</a><br>
--<br>
Arrays lend themselves, to some extent, to emulating data structures for which Bash has no native support.<br>
<b>Example 27-15. Emulating a push-down stack</b><br>
#!/bin/bash<br>
# stack.sh: push-down stack simulation<br>
# &nbsp;Similar to the CPU stack, a push-down stack stores data items<br>
#+ sequentially, but releases them in reverse order, last-in first-out.<br>
BP=100 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Base Pointer of stack array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Begin at element 100.<br>
SP=$BP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Stack Pointer.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Initialize it to &quot;base&quot; (bottom) of stack.<br>
Data= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Contents of stack location. &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Must use global variable,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ because of limitation on function return range.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 100 &nbsp; &nbsp; Base pointer &nbsp; &nbsp; &nbsp; &lt;-- Base Pointer<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;99 &nbsp; &nbsp; First data item<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;98 &nbsp; &nbsp; Second data item<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ... &nbsp; &nbsp; More data<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; Last data item &nbsp; &nbsp; &lt;-- Stack pointer<br>
declare -a stack<br>
push() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Push item on stack.<br>
{<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp;# Nothing to push?<br>
then<br>
&nbsp; return<br>
fi<br>
let &quot;SP -= 1&quot; &nbsp; &nbsp; # Bump stack pointer.<br>
Chapter 27. Arrays<br>
443<br>
<hr>
<A name=450></a>Advanced Bash-Scripting Guide<br>
stack[$SP]=$1<br>
return<br>
}<br>
pop() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Pop item off stack.<br>
{<br>
Data= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Empty out data item.<br>
if [ &quot;$SP&quot; -eq &quot;$BP&quot; ] &nbsp; # Stack empty?<br>
then<br>
&nbsp; return<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This also keeps SP from getting past 100,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ i.e., prevents a runaway stack.<br>
Data=${stack[$SP]}<br>
let &quot;SP += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Bump stack pointer.<br>
return<br>
}<br>
status_report() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Find out what's happening.<br>
{<br>
echo &quot;-------------------------------------&quot;<br>
echo &quot;REPORT&quot;<br>
echo &quot;Stack Pointer = $SP&quot;<br>
echo &quot;Just popped \&quot;&quot;$Data&quot;\&quot; off the stack.&quot;<br>
echo &quot;-------------------------------------&quot;<br>
echo<br>
}<br>
# =======================================================<br>
# Now, for some fun.<br>
echo<br>
# See if you can pop anything off empty stack.<br>
pop<br>
status_report<br>
echo<br>
push garbage<br>
pop<br>
status_report &nbsp; &nbsp; # Garbage in, garbage out. &nbsp; &nbsp; &nbsp;<br>
value1=23; &nbsp; &nbsp; &nbsp; &nbsp;push $value1<br>
value2=skidoo; &nbsp; &nbsp;push $value2<br>
value3=LAST; &nbsp; &nbsp; &nbsp;push $value3<br>
pop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # LAST<br>
status_report<br>
pop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # skidoo<br>
status_report<br>
pop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 23<br>
status_report &nbsp; &nbsp; # Last-in, first-out!<br>
# &nbsp;Notice how the stack pointer decrements with each push,<br>
#+ and increments with each pop.<br>
echo<br>
Chapter 27. Arrays<br>
444<br>
<hr>
<A name=451></a>Advanced Bash-Scripting Guide<br>
exit 0<br>
# =======================================================<br>
# Exercises:<br>
# ---------<br>
# 1) &nbsp;Modify the &quot;push()&quot; function to permit pushing<br>
# &nbsp; + multiple element on the stack with a single function call.<br>
# 2) &nbsp;Modify the &quot;pop()&quot; function to permit popping<br>
# &nbsp; + multiple element from the stack with a single function call.<br>
# 3) &nbsp;Add error checking to the critical functions.<br>
# &nbsp; &nbsp; That is, return an error code, depending on<br>
# &nbsp; + successful or unsuccessful completion of the operation,<br>
# &nbsp; + and take appropriate action.<br>
# 4) &nbsp;Using this script as a starting point,<br>
# &nbsp; + write a stack-based 4-function calculator.<br>
--<br>
Fancy manipulation of array &quot;subscripts&quot; may require intermediate variables. For projects involving this,<br>again consider using a more powerful programming language, such as Perl or C.<br>
<b>Example 27-16. Complex array application:<i>&nbsp;Exploring a weird mathematical series</i></b><br>
#!/bin/bash<br>
# Douglas Hofstadter's notorious &quot;Q-series&quot;:<br>
# Q(1) = Q(2) = 1<br>
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), for n&gt;2<br>
# &nbsp;This is a &quot;chaotic&quot; integer series with strange<br>
#+ and unpredictable behavior.<br>
# &nbsp;The first 20 terms of the series are:<br>
# &nbsp;1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12&nbsp;<br>
# &nbsp;See Hofstadter's book, _Goedel, Escher, Bach: An Eternal Golden Braid_,<br>
#+ p. 137, ff.<br>
LIMIT=100 &nbsp; &nbsp; # Number of terms to calculate.<br>
LINEWIDTH=20 &nbsp;# Number of terms printed per line.<br>
Q[1]=1 &nbsp; &nbsp; &nbsp; &nbsp;# First two terms of series are 1.<br>
Q[2]=1<br>
echo<br>
echo &quot;Q-series [$LIMIT terms]:&quot;<br>
echo -n &quot;${Q[1]} &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Output first two terms.<br>
echo -n &quot;${Q[2]} &quot;<br>
for ((n=3; n &lt;= $LIMIT; n++)) &nbsp;# C-like loop expression.<br>
do &nbsp; # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]] &nbsp;for n&gt;2<br>
# &nbsp; &nbsp;Need to break the expression into intermediate terms,<br>
#+ &nbsp; since Bash doesn't handle complex array arithmetic very well.<br>
Chapter 27. Arrays<br>
445<br>
<hr>
<A name=452></a>Advanced Bash-Scripting Guide<br>
&nbsp; let &quot;n1 = $n - 1&quot; &nbsp; &nbsp; &nbsp; &nbsp;# n-1<br>
&nbsp; let &quot;n2 = $n - 2&quot; &nbsp; &nbsp; &nbsp; &nbsp;# n-2<br>
&nbsp; t0=`expr $n - ${Q[n1]}` &nbsp;# n - Q[n-1]<br>
&nbsp; t1=`expr $n - ${Q[n2]}` &nbsp;# n - Q[n-2]<br>
&nbsp; T0=${Q[t0]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Q[n - Q[n-1]]<br>
&nbsp; T1=${Q[t1]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Q[n - Q[n-2]]<br>
Q[n]=`expr $T0 + $T1` &nbsp; &nbsp; &nbsp;# Q[n - Q[n-1]] + Q[n - Q[n-2]]<br>
echo -n &quot;${Q[n]} &quot;<br>
if [ `expr $n % $LINEWIDTH` -eq 0 ] &nbsp; &nbsp;# Format output.<br>
then &nbsp; # &nbsp; &nbsp; &nbsp;^ modulo<br>
&nbsp; echo # Break lines into neat chunks.<br>
fi<br>
done<br>
echo<br>
exit 0<br>
# &nbsp;This is an iterative implementation of the Q-series.<br>
# &nbsp;The more intuitive recursive implementation is left as an exercise.<br>
# &nbsp;Warning: calculating this series recursively takes a VERY long time<br>
#+ via a script. C/C++ would be orders of magnitude faster.<br>
--<br>
Bash supports only one-dimensional arrays, though a little trickery permits simulating multi-dimensional<br>ones.<br>
<b>Example 27-17. Simulating a two-dimensional array, then tilting it</b><br>
#!/bin/bash<br>
# twodim.sh: Simulating a two-dimensional array.<br>
# A one-dimensional array consists of a single row.<br>
# A two-dimensional array stores rows sequentially.<br>
Rows=5<br>
Columns=5<br>
# 5 X 5 Array.<br>
declare -a alpha &nbsp; &nbsp; # char alpha [Rows] [Columns];<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Unnecessary declaration. Why?<br>
load_alpha ()<br>
{<br>
local rc=0<br>
local index<br>
for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y<br>
do &nbsp; &nbsp; # Use different symbols if you like.<br>
&nbsp; local row=`expr $rc / $Columns`<br>
&nbsp; local column=`expr $rc % $Rows`<br>
&nbsp; let &quot;index = $row * $Rows + $column&quot;<br>
Chapter 27. Arrays<br>
446<br>
<hr>
<A name=453></a>Advanced Bash-Scripting Guide<br>
&nbsp; alpha[$index]=$i<br>
# alpha[$row][$column]<br>
&nbsp; let &quot;rc += 1&quot;<br>
done &nbsp;<br>
# &nbsp;Simpler would be<br>
#+ &nbsp; declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )<br>
#+ but this somehow lacks the &quot;flavor&quot; of a two-dimensional array.<br>
}<br>
print_alpha ()<br>
{<br>
local row=0<br>
local index<br>
echo<br>
while [ &quot;$row&quot; -lt &quot;$Rows&quot; ] &nbsp; # &nbsp;Print out in &quot;row major&quot; order:<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ columns vary,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ while row (outer loop) remains the same.<br>
&nbsp; local column=0<br>
&nbsp; echo -n &quot; &nbsp; &nbsp; &nbsp; &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Lines up &quot;square&quot; array with rotated one.<br>
&nbsp; while [ &quot;$column&quot; -lt &quot;$Columns&quot; ]<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;index = $row * $Rows + $column&quot;<br>
&nbsp; &nbsp; echo -n &quot;${alpha[index]} &quot; &nbsp;# alpha[$row][$column]<br>
&nbsp; &nbsp; let &quot;column += 1&quot;<br>
&nbsp; done<br>
&nbsp; let &quot;row += 1&quot;<br>
&nbsp; echo<br>
done &nbsp;<br>
# The simpler equivalent is<br>
# &nbsp; &nbsp; echo ${alpha[*]} | xargs -n $Columns<br>
echo<br>
}<br>
filter () &nbsp; &nbsp; # Filter out negative array indices.<br>
{<br>
echo -n &quot; &nbsp;&quot; &nbsp;# Provides the tilt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Explain how.<br>
if [[ &quot;$1&quot; -ge 0 &amp;&amp; &nbsp;&quot;$1&quot; -lt &quot;$Rows&quot; &amp;&amp; &quot;$2&quot; -ge 0 &amp;&amp; &quot;$2&quot; -lt &quot;$Columns&quot; ]]<br>
then<br>
&nbsp; &nbsp; let &quot;index = $1 * $Rows + $2&quot;<br>
&nbsp; &nbsp; # Now, print it rotated.<br>
&nbsp; &nbsp; echo -n &quot; ${alpha[index]}&quot;<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alpha[$row][$column]<br>
fi &nbsp; &nbsp;<br>
}<br>
rotate () &nbsp;# &nbsp;Rotate the array 45 degrees --<br>
Chapter 27. Arrays<br>
447<br>
<hr>
<A name=454></a>Advanced Bash-Scripting Guide<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ &quot;balance&quot; it on its lower lefthand corner.<br>
local row<br>
local column<br>
for (( row = Rows; row &gt; -Rows; row-- ))<br>
&nbsp; do &nbsp; &nbsp; &nbsp; # Step through the array backwards. Why?<br>
&nbsp; for (( column = 0; column &lt; Columns; column++ ))<br>
&nbsp; do<br>
&nbsp; &nbsp; if [ &quot;$row&quot; -ge 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; let &quot;t1 = $column - $row&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;t2 = $column&quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; let &quot;t1 = $column&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;t2 = $column + $row&quot;<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; &nbsp; filter $t1 $t2 &nbsp; # Filter out negative array indices.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# What happens if you don't do this?<br>
&nbsp; done<br>
&nbsp; echo; echo<br>
done&nbsp;<br>
# &nbsp;Array rotation inspired by examples (pp. 143-146) in<br>
#+ &quot;Advanced C Programming on the IBM PC,&quot; by Herbert Mayer<br>
#+ (see bibliography).<br>
# &nbsp;This just goes to show that much of what can be done in C<br>
#+ can also be done in shell scripting.<br>
}<br>
#--------------- Now, let the show begin. ------------#<br>
load_alpha &nbsp; &nbsp; # Load the array.<br>
print_alpha &nbsp; &nbsp;# Print it out. &nbsp;<br>
rotate &nbsp; &nbsp; &nbsp; &nbsp; # Rotate it 45 degrees counterclockwise.<br>
#-----------------------------------------------------#<br>
exit 0<br>
# This is a rather contrived, not to mention inelegant simulation.<br>
# Exercises:<br>
# ---------<br>
# 1) &nbsp;Rewrite the array loading and printing functions<br>
# &nbsp; &nbsp; in a more intuitive and less kludgy fashion.<br>
#<br>
# 2) &nbsp;Figure out how the array rotation functions work.<br>
# &nbsp; &nbsp; Hint: think about the implications of backwards-indexing an array.<br>
#<br>
# 3) &nbsp;Rewrite this script to handle a non-square array,<br>
# &nbsp; &nbsp; such as a 6 X 4 one.<br>
# &nbsp; &nbsp; Try to minimize &quot;distortion&quot; when the array is rotated.<br>
A two-dimensional array is essentially equivalent to a one-dimensional one, but with additional addressing<br>modes for referencing and manipulating the individual elements by<i>&nbsp;row</i>&nbsp;and<i>&nbsp;column</i>&nbsp;position.<br>
<a href="abs-guides.html#583">For an even more elaborate example of simulating a two-dimensional array, see Example A-10.</a><br>
Chapter 27. Arrays<br>
448<br>
<hr>
<A name=455></a>Advanced Bash-Scripting Guide<br>
--<br>
For more interesting scripts using arrays, see:<br>
<a href="abs-guides.html#174">Example 12-3</a><br>
•&nbsp;<br>
<a href="abs-guides.html#296">Example 16-46</a><br>
•&nbsp;<br>
<a href="abs-guides.html#614">Example A-22</a><br>
•&nbsp;<br>
<a href="abs-guides.html#724">Example A-44</a><br>
•&nbsp;<br>
<a href="abs-guides.html#709">Example A-41</a><br>
•&nbsp;<br>
<a href="abs-guides.html#717">Example A-42</a><br>
•&nbsp;<br>
Chapter 27. Arrays<br>
449<br>
<hr>
<A name=456></a><b>Chapter 28. Indirect References</b><br>
<a href="abs-guides.html#36">We have seen that referencing a variable,&nbsp;</a>$var, fetches its<i>&nbsp;value</i>.&nbsp;But, what about the<i>&nbsp;value of a value</i>? What<br>about&nbsp;$$var?<br>
The actual notation is&nbsp;<i>\$$var</i><a href="abs-guides.html#199">, usually preceded by an eval (and sometimes an echo). This is called an<br></a><i>indirect reference</i>.<br>
<b>Example 28-1. Indirect Variable References</b><br>
#!/bin/bash<br>
# ind-ref.sh: Indirect variable referencing.<br>
# Accessing the contents of the contents of a variable.<br>
# First, let's fool around a little.<br>
var=23<br>
echo &quot;\$var &nbsp; = $var&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $var &nbsp; = 23<br>
# So far, everything as expected. But ...<br>
echo &quot;\$\$var &nbsp;= $$var&quot; &nbsp; &nbsp; &nbsp; &nbsp; # $$var &nbsp;= 4570var<br>
# &nbsp;Not useful ...<br>
# &nbsp;\$\$ expanded to PID of the script<br>
# &nbsp;-- refer to the entry on the $$ variable --<br>
#+ and &quot;var&quot; is echoed as plain text.<br>
# &nbsp;(Thank you, Jakob Bohm, for pointing this out.)<br>
echo &quot;\\\$\$var = \$$var&quot; &nbsp; &nbsp; &nbsp; # \$$var = $23<br>
# &nbsp;As expected. The first $ is escaped and pasted on to<br>
#+ the value of var ($var = 23 ).<br>
# &nbsp;Meaningful, but still not useful.&nbsp;<br>
# Now, let's start over and do it the right way.<br>
# ============================================== #<br>
a=letter_of_alphabet &nbsp; # Variable &quot;a&quot; holds the name of another variable.<br>
letter_of_alphabet=z<br>
echo<br>
# Direct reference.<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# a = letter_of_alphabet<br>
# Indirect reference.<br>
&nbsp; eval a=\$$a<br>
# ^^^ &nbsp; &nbsp; &nbsp; &nbsp;Forcing an eval(uation), and ...<br>
# &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; Escaping the first $ ...<br>
# ------------------------------------------------------------------------<br>
# The 'eval' forces an update of $a, sets it to the updated value of \$$a.<br>
# So, we see why 'eval' so often shows up in indirect reference notation.<br>
# ------------------------------------------------------------------------<br>
&nbsp; echo &quot;Now a = $a&quot; &nbsp; &nbsp;# Now a = z<br>
Chapter 28. Indirect References<br>
450<br>
<hr>
<A name=457></a>Advanced Bash-Scripting Guide<br>
echo<br>
# Now, let's try changing the second-order reference.<br>
t=table_cell_3<br>
table_cell_3=24<br>
echo &quot;\&quot;table_cell_3\&quot; = $table_cell_3&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;table_cell_3&quot; = 24<br>
echo -n &quot;dereferenced \&quot;t\&quot; = &quot;; eval echo \$$t &nbsp; &nbsp;# dereferenced &quot;t&quot; = 24<br>
# In this simple case, the following also works (why?).<br>
# &nbsp; &nbsp; &nbsp; &nbsp; eval t=\$$t; echo &quot;\&quot;t\&quot; = $t&quot;<br>
echo<br>
t=table_cell_3<br>
NEW_VAL=387<br>
table_cell_3=$NEW_VAL<br>
echo &quot;Changing value of \&quot;table_cell_3\&quot; to $NEW_VAL.&quot;<br>
echo &quot;\&quot;table_cell_3\&quot; now $table_cell_3&quot;<br>
echo -n &quot;dereferenced \&quot;t\&quot; now &quot;; eval echo \$$t<br>
# &quot;eval&quot; takes the two arguments &quot;echo&quot; and &quot;\$$t&quot; (set equal to $table_cell_3)<br>
echo<br>
# (Thanks, Stephane Chazelas, for clearing up the above behavior.)<br>
# &nbsp; A more straightforward method is the ${!t} notation, discussed in the<br>
#+ &quot;Bash, version 2&quot; section.<br>
# &nbsp; See also ex78.sh.<br>
exit 0<br>
Indirect referencing in Bash is a multi-step process. First, take the name of a variable:&nbsp;varname. Then,<br>reference it:&nbsp;$varname. Then, reference the reference:&nbsp;$$varname. Then,<i>&nbsp;escape</i>&nbsp;the first $:<br>\$$varname. Finally, force a reevaluation of the expression and assign it:<b>&nbsp;eval newvar=\$$varname</b>.<br>
<a href="abs-guides.html#882">Of what practical use is indirect referencing of variables? It gives Bash a little of the functionality of pointers<br></a>in<i>&nbsp;C</i><a href="abs-guides.html#542">, for instance, in table lookup. And, it also has some other very interesting applications. . . .</a><br>
Nils Radtke shows how to build &quot;dynamic&quot; variable names and evaluate their contents. This can be useful<br><a href="abs-guides.html#210">when sourcing configuration files.</a><br>
#!/bin/bash<br>
# ---------------------------------------------<br>
# This could be &quot;sourced&quot; from a separate file.<br>
isdnMyProviderRemoteNet=172.16.0.100<br>
isdnYourProviderRemoteNet=10.0.0.10<br>
isdnOnlineService=&quot;MyProvider&quot;<br>
# ---------------------------------------------<br>
remoteNet=$(eval &quot;echo \$$(echo isdn${isdnOnlineService}RemoteNet)&quot;)<br>
remoteNet=$(eval &quot;echo \$$(echo isdnMyProviderRemoteNet)&quot;)<br>
remoteNet=$(eval &quot;echo \$isdnMyProviderRemoteNet&quot;)<br>
Chapter 28. Indirect References<br>
451<br>
<hr>
<A name=458></a>Advanced Bash-Scripting Guide<br>
remoteNet=$(eval &quot;echo $isdnMyProviderRemoteNet&quot;)<br>
echo &quot;$remoteNet&quot; &nbsp; &nbsp;# 172.16.0.100<br>
# ================================================================<br>
# &nbsp;And, it gets even better.<br>
# &nbsp;Consider the following snippet given a variable named getSparc,<br>
#+ but no such variable getIa64:<br>
chkMirrorArchs () {&nbsp;<br>
&nbsp; arch=&quot;$1&quot;;<br>
&nbsp; if [ &quot;$(eval &quot;echo \${$(echo get$(echo -ne $arch |<br>
&nbsp; &nbsp; &nbsp; &nbsp;sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |<br>
&nbsp; &nbsp; &nbsp; &nbsp;sed 's/^.\(.*\)/\1/g')):-false}&quot;)&quot; = true ]<br>
&nbsp; then<br>
&nbsp; &nbsp; &nbsp;return 0;<br>
&nbsp; else<br>
&nbsp; &nbsp; &nbsp;return 1;<br>
&nbsp; fi;<br>
}<br>
getSparc=&quot;true&quot;<br>
unset getIa64<br>
chkMirrorArchs sparc<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp;# 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# True<br>
chkMirrorArchs Ia64<br>
echo $? &nbsp; &nbsp; &nbsp; &nbsp;# 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# False<br>
# Notes:<br>
# -----<br>
# Even the to-be-substituted variable name part is built explicitly.<br>
# The parameters to the chkMirrorArchs calls are all lower case.<br>
# The variable name is composed of two parts: &quot;get&quot; and &quot;Sparc&quot; . . .<br>
<b>Example 28-2. Passing an indirect reference to<i>&nbsp;awk</i></b><br>
#!/bin/bash<br>
# &nbsp;Another version of the &quot;column totaler&quot; script<br>
#+ that adds up a specified column (of numbers) in the target file.<br>
# &nbsp;This one uses indirect references.<br>
ARGS=2<br>
E_WRONGARGS=85<br>
if [ $# -ne &quot;$ARGS&quot; ] # Check for proper number of command-line args.<br>
then<br>
&nbsp; &nbsp;echo &quot;Usage: `basename $0` filename column-number&quot;<br>
&nbsp; &nbsp;exit $E_WRONGARGS<br>
fi<br>
filename=$1 &nbsp; &nbsp; &nbsp; &nbsp; # Name of file to operate on.<br>
column_number=$2 &nbsp; &nbsp;# Which column to total up.<br>
#===== Same as original script, up to this point =====#<br>
Chapter 28. Indirect References<br>
452<br>
<hr>
<A name=459></a><IMG src="abs-guide-459_1.png"><br>
Advanced Bash-Scripting Guide<br>
# A multi-line awk script is invoked by<br>
# &nbsp; awk &quot;<br>
# &nbsp; ...<br>
# &nbsp; ...<br>
# &nbsp; ...<br>
# &nbsp; &quot;<br>
# Begin awk script.<br>
# -------------------------------------------------<br>
awk &quot;<br>
{ total += \$${column_number} # Indirect reference<br>
}<br>
END {<br>
&nbsp; &nbsp; &nbsp;print total<br>
&nbsp; &nbsp; &nbsp;}<br>
&nbsp; &nbsp; &nbsp;&quot; &quot;$filename&quot;<br>
# Note that awk doesn't need an eval preceding \$$.<br>
# -------------------------------------------------<br>
# End awk script.<br>
# &nbsp;Indirect variable reference avoids the hassles<br>
#+ of referencing a shell variable within the embedded awk script.<br>
# &nbsp;Thanks, Stephane Chazelas.<br>
exit $?<br>
This method of indirect referencing is a bit tricky. If the second order variable changes its value,<br>then the first order variable must be properly dereferenced (as in the above example).<br>Fortunately, the&nbsp;<i>${!variable}</i><a href="abs-guides.html#541">&nbsp;notation introduced with version 2 of Bash (see Example<br>37-2 and Example A-22) makes indirect referencing more intuitive.</a><br>
Bash does not support pointer arithmetic, and this severely limits the usefulness of indirect referencing. In<br>fact, indirect referencing in a scripting language is, at best, something of an afterthought.<br>
Chapter 28. Indirect References<br>
453<br>
<hr>
<A name=460></a><b>Chapter 29.&nbsp;/dev&nbsp;and&nbsp;/proc</b><br>
A Linux or UNIX filesystem typically has the&nbsp;/dev&nbsp;and&nbsp;/proc&nbsp;special-purpose directories.<br>
<b>29.1.&nbsp;/dev</b><br>
The&nbsp;/dev&nbsp;directory contains entries for the<i>&nbsp;physical devices</i>&nbsp;that may or may not be present in the hardware.<br>[115] Appropriately enough, these are called<i>&nbsp;device files</i>. As an example, the hard drive partitions containing<br>the mounted filesystem(s) have entries in&nbsp;/dev<a href="abs-guides.html#332">, as df shows.</a><br>
bash$&nbsp;<b>df<br></b>Filesystem &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1k-blocks &nbsp; &nbsp; &nbsp;Used Available Use%<br>
&nbsp;Mounted on<br>
&nbsp;/dev/hda6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 495876 &nbsp; &nbsp;222748 &nbsp; &nbsp;247527 &nbsp;48% /<br>
&nbsp;/dev/hda1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;50755 &nbsp; &nbsp; &nbsp;3887 &nbsp; &nbsp; 44248 &nbsp; 9% /boot<br>
&nbsp;/dev/hda8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 367013 &nbsp; &nbsp; 13262 &nbsp; &nbsp;334803 &nbsp; 4% /home<br>
&nbsp;/dev/hda5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1714416 &nbsp; 1123624 &nbsp; &nbsp;503704 &nbsp;70% /usr<br>
Among other things, the&nbsp;/dev&nbsp;directory contains<i>&nbsp;loopback</i>&nbsp;devices, such as&nbsp;/dev/loop0. A loopback<br>device is a gimmick that allows an ordinary file to be accessed as if it were a block device.&nbsp;[116] This permits<br><a href="abs-guides.html#343">mounting an entire filesystem within a single large file. See Example 17-8 and Example 17-7.</a><br>
A few of the pseudo-devices in&nbsp;/dev&nbsp;have other specialized uses, such as&nbsp;<a href="abs-guides.html#472">/dev/null</a>,&nbsp;<a href="abs-guides.html#473">/dev/zero</a>,<br><a href="abs-guides.html#123">/dev/urandom</a>,&nbsp;/dev/sda1&nbsp;(hard drive partition),&nbsp;/dev/udp&nbsp;(<i>User Datagram Packet</i>&nbsp;port), and<br><a href="abs-guides.html#461">/dev/tcp.</a><br>
For instance:<br>
<a href="abs-guides.html#342">To manually mount a USB flash drive, append the following line to&nbsp;/etc/fstab</a>.&nbsp;[117]<br>
/dev/sda1 &nbsp; &nbsp;/mnt/flashdrive &nbsp; &nbsp;auto &nbsp; &nbsp;noauto,user,noatime &nbsp; &nbsp;0 0<br>
<a href="abs-guides.html#616">(See also Example A-23.)</a><br>
Checking whether a disk is in the CD-burner (soft-linked to&nbsp;/dev/hdc):<br>
head -1 /dev/hdc<br>
# &nbsp;head: cannot open '/dev/hdc' for reading: No medium found<br>
# &nbsp;(No disc in the drive.)<br>
# &nbsp;head: error reading '/dev/hdc': Input/output error<br>
# &nbsp;(There is a disk in the drive, but it can't be read;<br>
#+ &nbsp;possibly it's an unrecorded CDR blank.) &nbsp;&nbsp;<br>
# &nbsp;Stream of characters and assorted gibberish<br>
# &nbsp;(There is a pre-recorded disk in the drive,<br>
#+ and this is raw output -- a stream of ASCII and binary data.)<br>
# &nbsp;Here we see the wisdom of using 'head' to limit the output<br>
#+ to manageable proportions, rather than 'cat' or something similar.<br>
# &nbsp;Now, it's just a matter of checking/parsing the output and taking<br>
Chapter 29. /dev and /proc<br>
454<br>
<hr>
<A name=461></a>Advanced Bash-Scripting Guide<br>
#+ appropriate action.<br>
When executing a command on a&nbsp;/dev/tcp/$host/$port&nbsp;pseudo-device file, Bash opens a TCP<br>connection to the associated<i>&nbsp;socket</i>.<br>
A<i>&nbsp;socket</i>&nbsp;is a communications node associated with a specific I/O port. (This is analogous to a<i>&nbsp;hardware<br>socket</i>, or<i>&nbsp;receptacle</i>, for a connecting cable.) It permits data transfer between hardware devices on the same<br>machine, between machines on the same network, between machines across different networks, and, of<br>course, between machines at different locations on the Internet.<br>
The following examples assume an active Internet connection.<br>
Getting the time from&nbsp;nist.gov:<br>
bash$&nbsp;<b>cat &lt;/dev/tcp/time.nist.gov/13<br></b>53082 04-03-18 04:26:54 68 0 0 502.3 UTC(NIST) *<br>
[Mark contributed this example.]<br>
Generalizing the above into a script:<br>
#!/bin/bash<br>
# This script must run with root permissions.<br>
URL=&quot;time.nist.gov/13&quot;<br>
Time=$(cat &lt;/dev/tcp/&quot;$URL&quot;)<br>
UTC=$(echo &quot;$Time&quot; | awk '{print$3}') &nbsp; # Third field is UTC (GMT) time.<br>
# Exercise: modify this for different time zones.<br>
echo &quot;UTC Time = &quot;$UTC&quot;&quot;<br>
Downloading a URL:<br>
bash$&nbsp;<b>exec 5&lt;&gt;/dev/tcp/www.net.cn/80<br></b>bash$&nbsp;<b>echo -e &quot;GET / HTTP/1.0\n&quot; &gt;&amp;5<br></b>bash$&nbsp;<b>cat &lt;&amp;5</b><br>
[Thanks, Mark and Mihai Maties.]<br>
<b>Example 29-1. Using&nbsp;/dev/tcp&nbsp;for troubleshooting</b><br>
#!/bin/bash<br>
# dev-tcp.sh: /dev/tcp redirection to check Internet connection.<br>
# Script by Troy Engel.<br>
# Used with permission.<br>
TCP_HOST=www.dns-diy.com &nbsp; # A known spam-friendly ISP.<br>
TCP_PORT=80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Port 80 is http.<br>
# Try to connect. (Somewhat similar to a 'ping' . . .)&nbsp;<br>
echo &quot;HEAD / HTTP/1.0&quot; &gt;/dev/tcp/${TCP_HOST}/${TCP_PORT}<br>
MYEXIT=$?<br>
Chapter 29. /dev and /proc<br>
455<br>
<hr>
<A name=462></a>Advanced Bash-Scripting Guide<br>
: &lt;&lt;EXPLANATION<br>
If bash was compiled with --enable-net-redirections, it has the capability of<br>
using a special character device for both TCP and UDP redirections. These<br>
redirections are used identically as STDIN/STDOUT/STDERR. The device entries<br>
are 30,36 for /dev/tcp:<br>
&nbsp; mknod /dev/tcp c 30 36<br>
&gt;From the bash reference:<br>
/dev/tcp/host/port<br>
&nbsp; &nbsp; If host is a valid hostname or Internet address, and port is an integer<br>
port number or service name, Bash attempts to open a TCP connection to the<br>
corresponding socket.<br>
EXPLANATION<br>
if [ &quot;X$MYEXIT&quot; = &quot;X0&quot; ]; then<br>
&nbsp; echo &quot;Connection successful. Exit code: $MYEXIT&quot;<br>
else<br>
&nbsp; echo &quot;Connection unsuccessful. Exit code: $MYEXIT&quot;<br>
fi<br>
exit $MYEXIT<br>
<b>Example 29-2. Playing music</b><br>
#!/bin/bash<br>
# music.sh<br>
# MUSIC WITHOUT EXTERNAL FILES<br>
# Author: Antonio Macchi<br>
# Used in ABS Guide with permission<br>
# &nbsp;/dev/dsp default = 8000 frames per second, 8 bits per frame (1 byte),<br>
#+ 1 channel (mono)<br>
duration=2000 &nbsp; &nbsp; &nbsp; # If 8000 bytes = 1 second, then 2000 = 1/4 second.<br>
volume=$'\xc0' &nbsp; &nbsp; &nbsp;# Max volume = \xff (or \x00).<br>
mute=$'\x80' &nbsp; &nbsp; &nbsp; &nbsp;# No volume = \x80 (the middle).<br>
function mknote () &nbsp;# $1=Note Hz in bytes (e.g. A = 440Hz ::<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ 8000 fps / 440 = 16 :: A = 16 bytes per second)<br>
&nbsp; for t in `seq 0 $duration`<br>
&nbsp; do<br>
&nbsp; &nbsp; test $(( $t % $1 )) = 0 &amp;&amp; echo -n $volume || echo -n $mute<br>
&nbsp; done<br>
}<br>
e=`mknote 49`<br>
g=`mknote 41`<br>
a=`mknote 36`<br>
b=`mknote 32`<br>
c=`mknote 30`<br>
cis=`mknote 29`<br>
d=`mknote 27`<br>
e2=`mknote 24`<br>
n=`mknote 32767`<br>
# European notation.<br>
Chapter 29. /dev and /proc<br>
456<br>
<hr>
<A name=463></a>Advanced Bash-Scripting Guide<br>
echo -n &quot;$g$e2$d$c$d$c$a$g$n$g$e$n$g$e2$d$c$c$b$c$cis$n$cis$d \<br>
$n$g$e2$d$c$d$c$a$g$n$g$e$n$g$a$d$c$b$a$b$c&quot; &gt; /dev/dsp<br>
# dsp = Digital Signal Processor<br>
exit &nbsp; &nbsp; &nbsp;# A &quot;bonny&quot; example of a shell script!<br>
<b>29.2.&nbsp;/proc</b><br>
The&nbsp;/proc&nbsp;directory is actually a pseudo-filesystem. The files in&nbsp;/proc&nbsp;mirror currently running system and<br><a href="abs-guides.html#882">kernel processes and contain information and statistics about them.</a><br>
bash$&nbsp;<b>cat /proc/devices<br></b>Character devices:<br>
&nbsp; &nbsp;1 mem<br>
&nbsp; &nbsp;2 pty<br>
&nbsp; &nbsp;3 ttyp<br>
&nbsp; &nbsp;4 ttyS<br>
&nbsp; &nbsp;5 cua<br>
&nbsp; &nbsp;7 vcs<br>
&nbsp; 10 misc<br>
&nbsp; 14 sound<br>
&nbsp; 29 fb<br>
&nbsp; 36 netlink<br>
&nbsp;128 ptm<br>
&nbsp;136 pts<br>
&nbsp;162 raw<br>
&nbsp;254 pcmcia<br>
&nbsp;Block devices:<br>
&nbsp; &nbsp;1 ramdisk<br>
&nbsp; &nbsp;2 fd<br>
&nbsp; &nbsp;3 ide0<br>
&nbsp; &nbsp;9 md<br>
bash$&nbsp;<b>cat /proc/interrupts</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CPU0 &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp;0: &nbsp; &nbsp; &nbsp;84505 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;timer<br>
&nbsp; &nbsp;1: &nbsp; &nbsp; &nbsp; 3375 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;keyboard<br>
&nbsp; &nbsp;2: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;cascade<br>
&nbsp; &nbsp;5: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;soundblaster<br>
&nbsp; &nbsp;8: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;rtc<br>
&nbsp; 12: &nbsp; &nbsp; &nbsp; 4231 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;PS/2 Mouse<br>
&nbsp; 14: &nbsp; &nbsp; 109373 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XT-PIC &nbsp;ide0<br>
&nbsp;NMI: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0&nbsp;<br>
&nbsp;ERR: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br>
bash$&nbsp;<b>cat /proc/partitions<br></b>major minor &nbsp;#blocks &nbsp;name &nbsp; &nbsp; rio rmerge rsect ruse wio wmerge wsect wuse running use aveq<br>
&nbsp; &nbsp; 3 &nbsp; &nbsp; 0 &nbsp; &nbsp;3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030<br>
&nbsp; &nbsp; 3 &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp;52416 hda1 27 395 844 960 4 2 14 180 0 800 1140<br>
&nbsp; &nbsp; 3 &nbsp; &nbsp; 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 hda2 0 0 0 0 0 0 0 0 0 0 0<br>
&nbsp; &nbsp; 3 &nbsp; &nbsp; 4 &nbsp; &nbsp; 165280 hda4 10 0 20 210 0 0 0 0 0 210 210<br>
&nbsp; &nbsp; ...<br>
Chapter 29. /dev and /proc<br>
457<br>
<hr>
<A name=464></a>Advanced Bash-Scripting Guide<br>
bash$&nbsp;<b>cat /proc/loadavg<br></b>0.13 0.42 0.27 2/44 1119<br>
bash$&nbsp;<b>cat /proc/apm<br></b>1.16 1.2 0x03 0x01 0xff 0x80 -1% -1 ?<br>
bash$&nbsp;<b>cat /proc/acpi/battery/BAT0/info<br></b>present: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yes<br>
&nbsp;design capacity: &nbsp; &nbsp; &nbsp; &nbsp; 43200 mWh<br>
&nbsp;last full capacity: &nbsp; &nbsp; &nbsp;36640 mWh<br>
&nbsp;battery technology: &nbsp; &nbsp; &nbsp;rechargeable<br>
&nbsp;design voltage: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10800 mV<br>
&nbsp;design capacity warning: 1832 mWh<br>
&nbsp;design capacity low: &nbsp; &nbsp; 200 mWh<br>
&nbsp;capacity granularity 1: &nbsp;1 mWh<br>
&nbsp;capacity granularity 2: &nbsp;1 mWh<br>
&nbsp;model number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IBM-02K6897<br>
&nbsp;serial number: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1133<br>
&nbsp;battery type: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LION<br>
&nbsp;OEM info: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Panasonic<br>
bash$&nbsp;<b>fgrep Mem /proc/meminfo<br></b>MemTotal: &nbsp; &nbsp; &nbsp; 515216 kB<br>
&nbsp;MemFree: &nbsp; &nbsp; &nbsp; &nbsp;266248 kB<br>
Shell scripts may extract data from certain of the files in&nbsp;/proc.&nbsp;[118]<br>
FS=iso &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ISO filesystem support in kernel?<br>
grep $FS /proc/filesystems &nbsp; # iso9660<br>
kernel_version=$( awk '{ print $3 }' /proc/version )<br>
CPU=$( awk '/model name/ {print $5}' &lt; /proc/cpuinfo )<br>
if [ &quot;$CPU&quot; = &quot;Pentium(R)&quot; ]<br>
then<br>
&nbsp; run_some_commands<br>
&nbsp; ...<br>
else<br>
&nbsp; run_other_commands<br>
&nbsp; ...<br>
fi<br>
cpu_speed=$( fgrep &quot;cpu MHz&quot; /proc/cpuinfo | awk '{print $4}' )<br>
# &nbsp;Current operating speed (in MHz) of the cpu on your machine.<br>
# &nbsp;On a laptop this may vary, depending on use of battery<br>
#+ or AC power.<br>
Chapter 29. /dev and /proc<br>
458<br>
<hr>
<A name=465></a><IMG src="abs-guide-465_1.png"><br>
Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# get-commandline.sh<br>
# Get the command-line parameters of a process.<br>
OPTION=cmdline<br>
# Identify PID.<br>
pid=$( echo $(pidof &quot;$1&quot;) | awk '{ print $1 }' )<br>
# Get only first &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^^^^^ of multiple instances.<br>
echo<br>
echo &quot;Process ID of (first instance of) &quot;$1&quot; = $pid&quot;<br>
echo -n &quot;Command-line arguments: &quot;<br>
cat /proc/&quot;$pid&quot;/&quot;$OPTION&quot; | xargs -0 echo<br>
# &nbsp; Formats output: &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^^<br>
# &nbsp; (Thanks, Han Holl, for the fixup!)<br>
echo; echo<br>
# For example:<br>
# sh get-commandline.sh xterm<br>
+<br>
devfile=&quot;/proc/bus/usb/devices&quot;<br>
text=&quot;Spd&quot;<br>
USB1=&quot;Spd=12&quot;<br>
USB2=&quot;Spd=480&quot;<br>
bus_speed=$(fgrep -m 1 &quot;$text&quot; $devfile | awk '{print $9}')<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^ Stop after first match.<br>
if [ &quot;$bus_speed&quot; = &quot;$USB1&quot; ]<br>
then<br>
&nbsp; echo &quot;USB 1.1 port found.&quot;<br>
&nbsp; # Do something appropriate for USB 1.1.<br>
fi<br>
It is even possible to control certain peripherals with commands sent to the&nbsp;/proc&nbsp;directory.<br>
root#&nbsp;<b>echo on &gt; /proc/acpi/ibm/light</b><br>
This turns on the<i>&nbsp;Thinklight</i>&nbsp;in certain models of IBM/Lenovo Thinkpads. (May not work on all Linux<br>distros.)<br>
Of course, caution is advised when writing to&nbsp;/proc.<br>
The&nbsp;/proc&nbsp;directory contains subdirectories with unusual numerical names. Every one of these names maps<br><a href="abs-guides.html#98">to the process ID of a currently running process. Within each of these subdirectories, there are a number of<br></a>files that hold useful information about the corresponding process. The&nbsp;stat&nbsp;and&nbsp;status&nbsp;files keep running<br>statistics on the process, the&nbsp;cmdline&nbsp;file holds the command-line arguments the process was invoked with,<br>and the&nbsp;exe&nbsp;file is a symbolic link to the complete path name of the invoking process. There are a few more<br>such files, but these seem to be the most interesting from a scripting standpoint.<br>
<b>Example 29-3. Finding the process associated with a PID</b><br>
Chapter 29. /dev and /proc<br>
459<br>
<hr>
<A name=466></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# pid-identifier.sh:<br>
# Gives complete path name to process associated with pid.<br>
ARGNO=1 &nbsp;# Number of arguments the script expects.<br>
E_WRONGARGS=65<br>
E_BADPID=66<br>
E_NOSUCHPROCESS=67<br>
E_NOPERMISSION=68<br>
PROCFILE=exe<br>
if [ $# -ne $ARGNO ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` PID-number&quot; &gt;&amp;2 &nbsp;# Error message &gt;stderr.<br>
&nbsp; exit $E_WRONGARGS<br>
fi &nbsp;<br>
pidno=$( ps ax | grep $1 | awk '{ print $1 }' | grep $1 )<br>
# Checks for pid in &quot;ps&quot; listing, field #1.<br>
# Then makes sure it is the actual process, not the process invoked by this script.<br>
# The last &quot;grep $1&quot; filters out this possibility.<br>
#<br>
# &nbsp; &nbsp;pidno=$( ps ax | awk '{ print $1 }' | grep $1 )<br>
# &nbsp; &nbsp;also works, as Teemu Huovila, points out.<br>
if [ -z &quot;$pidno&quot; ] &nbsp;# &nbsp;If, after all the filtering, the result is a zero-length string,<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ no running process corresponds to the pid given.<br>
&nbsp; echo &quot;No such process running.&quot;<br>
&nbsp; exit $E_NOSUCHPROCESS<br>
fi &nbsp;<br>
# Alternatively:<br>
# &nbsp; if ! ps $1 &gt; /dev/null 2&gt;&amp;1<br>
# &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# no running process corresponds to the pid given.<br>
# &nbsp; &nbsp; echo &quot;No such process running.&quot;<br>
# &nbsp; &nbsp; exit $E_NOSUCHPROCESS<br>
# &nbsp; &nbsp;fi<br>
# To simplify the entire process, use &quot;pidof&quot;.<br>
if [ ! -r &quot;/proc/$1/$PROCFILE&quot; ] &nbsp;# Check for read permission.<br>
then<br>
&nbsp; echo &quot;Process $1 running, but...&quot;<br>
&nbsp; echo &quot;Can't get read permission on /proc/$1/$PROCFILE.&quot;<br>
&nbsp; exit $E_NOPERMISSION &nbsp;# Ordinary user can't access some files in /proc.<br>
fi &nbsp;<br>
# The last two tests may be replaced by:<br>
# &nbsp; &nbsp;if ! kill -0 $1 &gt; /dev/null 2&gt;&amp;1 # '0' is not a signal, but<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # this will test whether it is possible<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # to send a signal to the process.<br>
# &nbsp; &nbsp;then echo &quot;PID doesn't exist or you're not its owner&quot; &gt;&amp;2<br>
# &nbsp; &nbsp;exit $E_BADPID<br>
# &nbsp; &nbsp;fi<br>
exe_file=$( ls -l /proc/$1 | grep &quot;exe&quot; | awk '{ print $11 }' )<br>
# Or &nbsp; &nbsp; &nbsp; exe_file=$( ls -l /proc/$1/exe | awk '{print $11}' )<br>
#<br>
# &nbsp;/proc/pid-number/exe is a symbolic link<br>
Chapter 29. /dev and /proc<br>
460<br>
<hr>
<A name=467></a>Advanced Bash-Scripting Guide<br>
#+ to the complete path name of the invoking process.<br>
if [ -e &quot;$exe_file&quot; ] &nbsp;# &nbsp;If /proc/pid-number/exe exists,<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ then the corresponding process exists.<br>
&nbsp; echo &quot;Process #$1 invoked by $exe_file.&quot;<br>
else<br>
&nbsp; echo &quot;No such process running.&quot;<br>
fi &nbsp;<br>
# &nbsp;This elaborate script can *almost* be replaced by<br>
# &nbsp; &nbsp; &nbsp; ps ax | grep $1 | awk '{ print $5 }'<br>
# &nbsp;However, this will not work...<br>
#+ because the fifth field of 'ps' is argv[0] of the process,<br>
#+ not the executable file path.<br>
#<br>
# However, either of the following would work.<br>
# &nbsp; &nbsp; &nbsp; find /proc/$1/exe -printf '%l\n'<br>
# &nbsp; &nbsp; &nbsp; lsof -aFn -p $1 -d txt | sed -ne 's/^n//p'<br>
# Additional commentary by Stephane Chazelas.<br>
exit 0<br>
<b>Example 29-4. On-line connect status</b><br>
#!/bin/bash<br>
# connect-stat.sh<br>
# &nbsp;Note that this script may need modification<br>
#+ to work with a wireless connection.<br>
PROCNAME=pppd &nbsp; &nbsp; &nbsp; &nbsp;# ppp daemon<br>
PROCFILENAME=status &nbsp;# Where to look.<br>
NOTCONNECTED=85<br>
INTERVAL=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Update every 2 seconds.<br>
pidno=$( ps ax | grep -v &quot;ps ax&quot; | grep -v grep | grep $PROCNAME |<br>
awk '{ print $1 }' )<br>
# Finding the process number of 'pppd', the 'ppp daemon'.<br>
# Have to filter out the process lines generated by the search itself.<br>
#<br>
# &nbsp;However, as Oleg Philon points out,<br>
#+ this could have been considerably simplified by using &quot;pidof&quot;.<br>
# &nbsp;pidno=$( pidof $PROCNAME )<br>
#<br>
# &nbsp;Moral of the story:<br>
#+ When a command sequence gets too complex, look for a shortcut.<br>
if [ -z &quot;$pidno&quot; ] &nbsp; # If no pid, then process is not running.<br>
then<br>
&nbsp; echo &quot;Not connected.&quot;<br>
# exit $NOTCONNECTED<br>
else<br>
&nbsp; echo &quot;Connected.&quot;; echo<br>
fi<br>
while [ true ] &nbsp; &nbsp; &nbsp; # Endless loop, script can be improved here.<br>
do<br>
Chapter 29. /dev and /proc<br>
461<br>
<hr>
<A name=468></a><IMG src="abs-guide-468_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; if [ ! -e &quot;/proc/$pidno/$PROCFILENAME&quot; ]<br>
&nbsp; # While process running, then &quot;status&quot; file exists.<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Disconnected.&quot;<br>
# &nbsp; exit $NOTCONNECTED<br>
&nbsp; fi<br>
netstat -s | grep &quot;packets received&quot; &nbsp;# Get some connect statistics.<br>
netstat -s | grep &quot;packets delivered&quot;<br>
&nbsp; sleep $INTERVAL<br>
&nbsp; echo; echo<br>
done<br>
exit 0<br>
# As it stands, this script must be terminated with a Control-C.<br>
# &nbsp; &nbsp;Exercises:<br>
# &nbsp; &nbsp;---------<br>
# &nbsp; &nbsp;Improve the script so it exits on a &quot;q&quot; keystroke.<br>
# &nbsp; &nbsp;Make the script more user-friendly in other ways.<br>
# &nbsp; &nbsp;Fix the script to work with wireless/DSL connections.<br>
In general, it is dangerous to<i>&nbsp;write</i>&nbsp;to the files in&nbsp;/proc, as this can corrupt the filesystem or crash the<br>machine.<br>
Chapter 29. /dev and /proc<br>
462<br>
<hr>
<A name=469></a><b>Chapter 30. Network Programming</b><br>
<i>The Net's a cross between an elephant and a<br>white elephant sale: it never forgets, and it's<br>always crap.</i><br>
<i>--Nemo</i><br>
A Linux system has quite a number of tools for accessing, manipulating, and troubleshooting network<br>connections. We can incorporate some of these tools into scripts -- scripts that expand our knowledge of<br>networking, useful scripts that can facilitate the administration of a network.<br>
Here is a simple CGI script that demonstrates connecting to a remote server.<br>
<b>Example 30-1. Print the server environment</b><br>
#!/bin/bash<br>
# test-cgi.sh<br>
# by Michael Zick<br>
# Used with permission<br>
# May have to change the location for your site.<br>
# (At the ISP's servers, Bash may not be in the usual place.)<br>
# Other places: /usr/bin or /usr/local/bin<br>
# Might even try it without any path in sha-bang.<br>
# Disable filename globbing.<br>
set -f<br>
# Header tells browser what to expect.<br>
echo Content-type: text/plain<br>
echo<br>
echo CGI/1.0 test script report:<br>
echo<br>
echo environment settings:<br>
set<br>
echo<br>
echo whereis bash?<br>
whereis bash<br>
echo<br>
echo who are we?<br>
echo ${BASH_VERSINFO[*]}<br>
echo<br>
echo argc is $#. argv is &quot;$*&quot;.<br>
echo<br>
# CGI/1.0 expected environment variables.<br>
echo SERVER_SOFTWARE = $SERVER_SOFTWARE<br>
echo SERVER_NAME = $SERVER_NAME<br>
echo GATEWAY_INTERFACE = $GATEWAY_INTERFACE<br>
Chapter 30. Network Programming<br>
463<br>
<hr>
<A name=470></a>Advanced Bash-Scripting Guide<br>
echo SERVER_PROTOCOL = $SERVER_PROTOCOL<br>
echo SERVER_PORT = $SERVER_PORT<br>
echo REQUEST_METHOD = $REQUEST_METHOD<br>
echo HTTP_ACCEPT = &quot;$HTTP_ACCEPT&quot;<br>
echo PATH_INFO = &quot;$PATH_INFO&quot;<br>
echo PATH_TRANSLATED = &quot;$PATH_TRANSLATED&quot;<br>
echo SCRIPT_NAME = &quot;$SCRIPT_NAME&quot;<br>
echo QUERY_STRING = &quot;$QUERY_STRING&quot;<br>
echo REMOTE_HOST = $REMOTE_HOST<br>
echo REMOTE_ADDR = $REMOTE_ADDR<br>
echo REMOTE_USER = $REMOTE_USER<br>
echo AUTH_TYPE = $AUTH_TYPE<br>
echo CONTENT_TYPE = $CONTENT_TYPE<br>
echo CONTENT_LENGTH = $CONTENT_LENGTH<br>
exit 0<br>
# Here document to give short instructions.<br>
:&lt;&lt;-'_test_CGI_'<br>
1) Drop this in your http://domain.name/cgi-bin directory.<br>
2) Then, open http://domain.name/cgi-bin/test-cgi.sh.<br>
_test_CGI_<br>
For security purposes, it may be helpful to identify the IP addresses a computer is accessing.<br>
<b>Example 30-2. IP addresses</b><br>
#!/bin/bash<br>
# ip-addresses.sh<br>
# List the IP addresses your computer is connected to.<br>
# &nbsp;Inspired by Greg Bledsoe's ddos.sh script,<br>
# &nbsp;Linux Journal, 09 March 2011.<br>
# &nbsp; &nbsp;URL:<br>
# &nbsp;http://www.linuxjournal.com/content/back-dead-simple-bash-complex-ddos<br>
# &nbsp;Greg licensed his script under the GPL2,<br>
#+ and as a derivative, this script is likewise GPL2.<br>
connection_type=TCP &nbsp; &nbsp; &nbsp;# Also try UDP.<br>
field=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Which field of the output we're interested in.<br>
no_match=LISTEN &nbsp; # Filter out records containing this. Why?<br>
lsof_args=-ni &nbsp; &nbsp; # -i lists Internet-associated files.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # -n preserves numerical IP addresses.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # What happens without the -n option? Try it.<br>
router=&quot;[0-9][0-9][0-9][0-9][0-9]-&gt;&quot;<br>
# &nbsp; &nbsp; &nbsp; Delete the router info.<br>
lsof &quot;$lsof_args&quot; | grep $connection_type | grep -v &quot;$no_match&quot; |<br>
&nbsp; &nbsp; &nbsp; awk '{print $9}' | cut -d : -f $field | sort | uniq |<br>
&nbsp; &nbsp; &nbsp; sed s/&quot;^$router&quot;//<br>
# &nbsp;Bledsoe's script assigns the output of a filtered IP list,<br>
# &nbsp;(similar to lines 19-22, above) to a variable.<br>
# &nbsp;He checks for multiple connections to a single IP address,<br>
# &nbsp;then uses:<br>
#<br>
# &nbsp; &nbsp;iptables -I INPUT -s $ip -p tcp -j REJECT --reject-with tcp-reset<br>
Chapter 30. Network Programming<br>
464<br>
<hr>
<A name=471></a>Advanced Bash-Scripting Guide<br>
#<br>
# &nbsp;... within a 60-second delay loop to bounce packets from DDOS attacks.<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Use the 'iptables' command to extend this script<br>
#+ to reject connection attempts from well-known spammer IP domains.<br>
More examples of network programming:<br>
<a href="abs-guides.html#461">Getting the time from</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#461"><i>&nbsp;nist.gov</i></a><br>
<a href="abs-guides.html#461">Downloading a URL</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#340">A GRE tunnel</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#285">Checking if an Internet server is up</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#282">Example 16-41</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#626">Example A-28</a><br>
6.&nbsp;<br>
<a href="abs-guides.html#662">Example A-29</a><br>
7.&nbsp;<br>
<a href="abs-guides.html#461">Example 29-1</a><br>
8.&nbsp;<br>
<a href="abs-guides.html#339">See also the networking commands in the System and Administrative Commands chapter and the<br></a><a href="abs-guides.html#280">communications commands in the External Filters, Programs and Commands chapter.</a><br>
Chapter 30. Network Programming<br>
465<br>
<hr>
<A name=472></a><b>Chapter 31. Of Zeros and Nulls</b><br>
<i>Faultily faultless, icily regular, splendidly null</i><br>
<i>Dead perfection; no more.</i><br>
<i>--Alfred Lord Tennyson</i><br>
<b>/dev/zero&nbsp;...&nbsp;/dev/null</b><br>
Uses of&nbsp;/dev/null<br>
Think of&nbsp;/dev/null&nbsp;as a<i>&nbsp;black hole</i>. It is essentially the equivalent of a write-only file. Everything<br>written to it disappears. Attempts to read or output from it result in nothing. All the same,<br>/dev/null&nbsp;can be quite useful from both the command-line and in scripts.<br>
Suppressing&nbsp;stdout.<br>
cat $filename &gt;/dev/null<br>
# Contents of the file will not list to stdout.<br>
Suppressing&nbsp;stderr<a href="abs-guides.html#226">&nbsp;(from Example 16-3).</a><br>
rm $badname 2&gt;/dev/null<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; So error messages [stderr] deep-sixed.<br>
Suppressing output from<i>&nbsp;both&nbsp;</i>stdout&nbsp;and&nbsp;stderr.<br>
cat $filename 2&gt;/dev/null &gt;/dev/null<br>
# If &quot;$filename&quot; does not exist, there will be no error message output.<br>
# If &quot;$filename&quot; does exist, the contents of the file will not list to stdout.<br>
# Therefore, no output at all will result from the above line of code.<br>
#<br>
# &nbsp;This can be useful in situations where the return code from a command<br>
#+ needs to be tested, but no output is desired.<br>
#<br>
# cat $filename &amp;&gt;/dev/null<br>
# &nbsp; &nbsp; also works, as Baris Cicek points out.<br>
<a href="abs-guides.html#9">Deleting contents of a file, but preserving the file itself, with all attendant permissions (from Example<br>2-1 and Example 2-3):</a><br>
cat /dev/null &gt; /var/log/messages<br>
# &nbsp;: &gt; /var/log/messages &nbsp; has same effect, but does not spawn a new process.<br>
cat /dev/null &gt; /var/log/wtmp<br>
Automatically emptying the contents of a logfile (especially good for dealing with those nasty<br>&quot;cookies&quot; sent by commercial Web sites):<br>
<b>Example 31-1. Hiding the cookie jar</b><br>
# Obsolete Netscape browser.<br>
# Same principle applies to newer browsers.<br>
if [ -f ~/.netscape/cookies ] &nbsp;# Remove, if exists.<br>
then<br>
Chapter 31. Of Zeros and Nulls<br>
466<br>
<hr>
<A name=473></a>Advanced Bash-Scripting Guide<br>
&nbsp; rm -f ~/.netscape/cookies<br>
fi<br>
ln -s /dev/null ~/.netscape/cookies<br>
# All cookies now get sent to a black hole, rather than saved to disk.<br>
Uses of&nbsp;/dev/zero<br>
Like&nbsp;/dev/null,&nbsp;/dev/zero&nbsp;is a pseudo-device file, but it actually produces a stream of nulls<br>(<i>binary</i><a href="abs-guides.html#882">&nbsp;zeros, not the ASCII kind). Output written to&nbsp;</a>/dev/zero&nbsp;disappears, and it is fairly difficult<br><a href="abs-guides.html#317">to actually read the nulls emitted there, though it can be done with od or a hex editor.&nbsp;</a>The chief use of<br>/dev/zero&nbsp;is creating an initialized dummy file of predetermined length intended as a temporary<br>swap file.<br>
<b>Example 31-2. Setting up a swapfile using&nbsp;/dev/zero</b><br>
#!/bin/bash<br>
# Creating a swap file.<br>
# &nbsp;A swap file provides a temporary storage cache<br>
#+ which helps speed up certain filesystem operations.<br>
ROOT_UID=0 &nbsp; &nbsp; &nbsp; &nbsp; # Root has $UID 0.<br>
E_WRONG_USER=85 &nbsp; &nbsp;# Not root?<br>
FILE=/swap<br>
BLOCKSIZE=1024<br>
MINBLOCKS=40<br>
SUCCESS=0<br>
# This script must be run as root.<br>
if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
then<br>
&nbsp; echo; echo &quot;You must be root to run this script.&quot;; echo<br>
&nbsp; exit $E_WRONG_USER<br>
fi &nbsp;<br>
blocks=${1:-$MINBLOCKS} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Set to default of 40 blocks,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ if nothing specified on command-line.<br>
# This is the equivalent of the command block below.<br>
# --------------------------------------------------<br>
# if [ -n &quot;$1&quot; ]<br>
# then<br>
# &nbsp; blocks=$1<br>
# else<br>
# &nbsp; blocks=$MINBLOCKS<br>
# fi<br>
# --------------------------------------------------<br>
if [ &quot;$blocks&quot; -lt $MINBLOCKS ]<br>
then<br>
&nbsp; blocks=$MINBLOCKS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Must be at least 40 blocks long.<br>
fi &nbsp;<br>
######################################################################<br>
echo &quot;Creating swap file of size $blocks blocks (KB).&quot;<br>
dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks &nbsp;# Zero out file.<br>
Chapter 31. Of Zeros and Nulls<br>
467<br>
<hr>
<A name=474></a>Advanced Bash-Scripting Guide<br>
mkswap $FILE $blocks &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Designate it a swap file.<br>
swapon $FILE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Activate swap file.<br>
retcode=$? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Everything worked?<br>
# &nbsp;Note that if one or more of these commands fails,<br>
#+ then it could cause nasty problems.<br>
######################################################################<br>
# &nbsp;Exercise:<br>
# &nbsp;Rewrite the above block of code so that if it does not execute<br>
#+ successfully, then:<br>
# &nbsp; &nbsp;1) an error message is echoed to stderr,<br>
# &nbsp; &nbsp;2) all temporary files are cleaned up, and<br>
# &nbsp; &nbsp;3) the script exits in an orderly fashion with an<br>
#+ &nbsp; &nbsp; &nbsp;appropriate error code.<br>
echo &quot;Swap file created and activated.&quot;<br>
exit $retcode<br>
Another application of&nbsp;/dev/zero&nbsp;is to &quot;zero out&quot; a file of a designated size for a special purpose,<br><a href="abs-guides.html#460">such as mounting a filesystem on a loopback device (see Example 17-8) or &quot;securely&quot; deleting a file<br></a><a href="abs-guides.html#315">(see Example 16-60).</a><br>
<b>Example 31-3. Creating a ramdisk</b><br>
#!/bin/bash<br>
# ramdisk.sh<br>
# &nbsp;A &quot;ramdisk&quot; is a segment of system RAM memory<br>
#+ which acts as if it were a filesystem.<br>
# &nbsp;Its advantage is very fast access (read/write time).<br>
# &nbsp;Disadvantages: volatility, loss of data on reboot or powerdown.<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;less RAM available to system.<br>
#<br>
# &nbsp;Of what use is a ramdisk?<br>
# &nbsp;Keeping a large dataset, such as a table or dictionary on ramdisk,<br>
#+ speeds up data lookup, since memory access is much faster than disk access.<br>
E_NON_ROOT_USER=70 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Must run as root.<br>
ROOTUSER_NAME=root<br>
MOUNTPT=/mnt/ramdisk<br>
SIZE=2000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 2K blocks (change as appropriate)<br>
BLOCKSIZE=1024 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 1K (1024 byte) block size<br>
DEVICE=/dev/ram0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # First ram device<br>
username=`id -nu`<br>
if [ &quot;$username&quot; != &quot;$ROOTUSER_NAME&quot; ]<br>
then<br>
&nbsp; echo &quot;Must be root to run \&quot;`basename $0`\&quot;.&quot;<br>
&nbsp; exit $E_NON_ROOT_USER<br>
fi<br>
if [ ! -d &quot;$MOUNTPT&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Test whether mount point already there,<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ so no error if this script is run<br>
&nbsp; mkdir $MOUNTPT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ multiple times.<br>
fi<br>
##############################################################################<br>
Chapter 31. Of Zeros and Nulls<br>
468<br>
<hr>
<A name=475></a>Advanced Bash-Scripting Guide<br>
dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE &nbsp;# Zero out RAM device.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Why is this necessary?<br>
mke2fs $DEVICE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Create an ext2 filesystem on it.<br>
mount $DEVICE $MOUNTPT &nbsp; &nbsp; &nbsp; &nbsp; # Mount it.<br>
chmod 777 $MOUNTPT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Enables ordinary user to access ramdisk.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# However, must be root to unmount it.<br>
##############################################################################<br>
# Need to test whether above commands succeed. Could cause problems otherwise.<br>
# Exercise: modify this script to make it safer.<br>
echo &quot;\&quot;$MOUNTPT\&quot; now available for use.&quot;<br>
# The ramdisk is now accessible for storing files, even by an ordinary user.<br>
# &nbsp;Caution, the ramdisk is volatile, and its contents will disappear<br>
#+ on reboot or power loss.<br>
# &nbsp;Copy anything you want saved to a regular directory.<br>
# After reboot, run this script to again set up ramdisk.<br>
# Remounting /mnt/ramdisk without the other steps will not work.<br>
# &nbsp;Suitably modified, this script can by invoked in /etc/rc.d/rc.local,<br>
#+ to set up ramdisk automatically at bootup.<br>
# &nbsp;That may be appropriate on, for example, a database server.<br>
exit 0<br>
In addition to all the above,&nbsp;/dev/zero&nbsp;is needed by ELF (<i>Executable and Linking Format</i>)<br>UNIX/Linux binaries.<br>
Chapter 31. Of Zeros and Nulls<br>
469<br>
<hr>
<A name=476></a><b>Chapter 32. Debugging</b><br>
<i>Debugging is twice as hard as writing the code in<br>the first place. Therefore, if you write the code as<br>cleverly as possible, you are, by definition, not<br>smart enough to debug it.</i><br>
<i>--Brian Kernighan</i><br>
The Bash shell contains no built-in debugger, and only bare-bones debugging-specific commands and<br>constructs. Syntax errors or outright typos in the script generate cryptic error messages that are often of no<br>help in debugging a non-functional script.<br>
<b>Example 32-1. A buggy script</b><br>
#!/bin/bash<br>
# ex74.sh<br>
# This is a buggy script.<br>
# Where, oh where is the error?<br>
a=37<br>
if [$a -gt 27 ]<br>
then<br>
&nbsp; echo $a<br>
fi &nbsp;<br>
exit 0<br>
Output from script:<br>
./ex74.sh: [37: command not found<br>
What's wrong with the above script? Hint: after the<i>&nbsp;if</i>.<br>
<a href="abs-guides.html#187"><b>Example 32-2. Missing keyword</b></a><br>
#!/bin/bash<br>
# missing-keyword.sh: What error message will this generate?<br>
for a in 1 2 3<br>
do<br>
&nbsp; echo &quot;$a&quot;<br>
# done &nbsp; &nbsp; # Required keyword 'done' commented out in line 7.<br>
exit 0 &nbsp;<br>
Output from script:<br>
missing-keyword.sh: line 10: syntax error: unexpected end of file<br>
Note that the error message does<i>&nbsp;not</i>&nbsp;necessarily reference the line in which the error occurs, but the line<br>where the Bash interpreter finally becomes aware of the error.<br>
Error messages may disregard comment lines in a script when reporting the line number of a syntax error.<br>
Chapter 32. Debugging<br>
470<br>
<hr>
<A name=477></a><IMG src="abs-guide-477_1.png"><br>
Advanced Bash-Scripting Guide<br>
What if the script executes, but does not work as expected? This is the all too familiar logic error.<br>
<b>Example 32-3.<i>&nbsp;test24</i></b><b>: another buggy script</b><br>
#!/bin/bash<br>
# &nbsp;This script is supposed to delete all filenames in current directory<br>
#+ containing embedded spaces.<br>
# &nbsp;It doesn't work.<br>
# &nbsp;Why not?<br>
badname=`ls | grep ' '`<br>
# Try this:<br>
# echo &quot;$badname&quot;<br>
rm &quot;$badname&quot;<br>
exit 0<br>
<a href="abs-guides.html#477">Try to find out what's wrong with Example 32-3 by uncommenting the&nbsp;</a><b>echo &quot;$badname&quot;</b>&nbsp;line. Echo<br>statements are useful for seeing whether what you expect is actually what you get.<br>
In this particular case,&nbsp;<b>rm &quot;$badname&quot;</b>&nbsp;will not give the desired results because&nbsp;$badname&nbsp;should not be<br>quoted. Placing it in quotes ensures that<b>&nbsp;rm</b>&nbsp;has only one argument (it will match only one filename). A partial<br>fix is to remove to quotes from&nbsp;$badname&nbsp;and to reset&nbsp;$IFS&nbsp;to contain only a newline,&nbsp;<b>IFS=$'\n'</b>.<br>However, there are simpler ways of going about it.<br>
# Correct methods of deleting filenames containing spaces.<br>
rm *\ *<br>
rm *&quot; &quot;*<br>
rm *' '*<br>
# Thank you. S.C.<br>
Summarizing the symptoms of a buggy script,<br>
It bombs with a &quot;syntax error&quot; message, or<br>
1.&nbsp;<br>
It runs, but does not work as expected (logic error).<br>
2.&nbsp;<br>
It runs, works as expected, but has nasty side effects (logic bomb).<br>
3.&nbsp;<br>
Tools for debugging non-working scripts include<br>
1.&nbsp;<a href="abs-guides.html#187">Inserting echo statements at critical points in the script to trace the variables, and otherwise give a</a><br>
snapshot of what is going on.<br>
Even better is an<b>&nbsp;echo</b>&nbsp;that echoes only when<i>&nbsp;debug</i>&nbsp;is on.<br>
### debecho (debug-echo), by Stefano Falsetto ###<br>
### Will echo passed parameters only if DEBUG is set to a value. ###<br>
debecho () {<br>
&nbsp; if [ ! -z &quot;$DEBUG&quot; ]; then<br>
&nbsp; &nbsp; &nbsp;echo &quot;$1&quot; &gt;&amp;2<br>
&nbsp; &nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; ^^^ to stderr<br>
&nbsp; fi<br>
Chapter 32. Debugging<br>
471<br>
<hr>
<A name=478></a>Advanced Bash-Scripting Guide<br>
}<br>
DEBUG=on<br>
Whatever=whatnot<br>
debecho $Whatever &nbsp; # whatnot<br>
DEBUG=<br>
Whatever=notwhat<br>
debecho $Whatever &nbsp; # (Will not echo.)<br>
<a href="abs-guides.html#312">Using the tee filter to check processes or data flows at critical points.</a><br>
2.&nbsp;<br>
Setting option flags&nbsp;<br>
3.&nbsp;<br>
-n -v -x<br>
<b>sh -n scriptname</b>&nbsp;checks for syntax errors without actually running the script. This is the<br>equivalent of inserting&nbsp;<b>set -n</b>&nbsp;or&nbsp;<b>set -o noexec</b>&nbsp;into the script. Note that certain types of<br>syntax errors can slip past this check.<br>
<b>sh -v scriptname</b>&nbsp;echoes each command before executing it. This is the equivalent of inserting<br><b>set -v</b>&nbsp;or&nbsp;<b>set -o verbose</b>&nbsp;in the script.<br>
The&nbsp;-n&nbsp;and&nbsp;-v&nbsp;flags work well together.&nbsp;<b>sh -nv scriptname</b>&nbsp;gives a verbose syntax check.<br>
<b>sh -x scriptname</b>&nbsp;echoes the result each command, but in an abbreviated manner. This is the<br>equivalent of inserting&nbsp;<b>set -x</b>&nbsp;or&nbsp;<b>set -o xtrace</b>&nbsp;in the script.<br>
Inserting&nbsp;<b>set -u</b>&nbsp;or&nbsp;<b>set -o nounset</b>&nbsp;in the script runs it, but gives an unbound variable error<br>message and aborts the script.<br>
set -u &nbsp; # Or &nbsp; set -o nounset<br>
# Setting a variable to null will not trigger the error/abort.<br>
# unset_var=<br>
echo $unset_var &nbsp; # Unset (and undeclared) variable.<br>
echo &quot;Should not echo!&quot;<br>
# sh t2.sh<br>
# t2.sh: line 6: unset_var: unbound variable<br>
Using an &quot;assert&quot; function to test a variable or condition at critical points in a script. (This is an idea<br>
4.&nbsp;<br>
borrowed from C.)<br>
<b>Example 32-4. Testing a condition with an<i>&nbsp;assert</i></b><br>
#!/bin/bash<br>
# assert.sh<br>
#######################################################################<br>
assert () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;If condition false,<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ exit from script<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ with appropriate error message.<br>
&nbsp; E_PARAM_ERR=98<br>
&nbsp; E_ASSERT_FAILED=99<br>
&nbsp; if [ -z &quot;$2&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Not enough parameters passed<br>
Chapter 32. Debugging<br>
472<br>
<hr>
<A name=479></a>Advanced Bash-Scripting Guide<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to assert() function.<br>
&nbsp; &nbsp; return $E_PARAM_ERR &nbsp; # &nbsp;No damage done.<br>
&nbsp; fi<br>
&nbsp; lineno=$2<br>
&nbsp; if [ ! $1 ]&nbsp;<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Assertion failed: &nbsp;\&quot;$1\&quot;&quot;<br>
&nbsp; &nbsp; echo &quot;File \&quot;$0\&quot;, line $lineno&quot; &nbsp; &nbsp;# Give name of file and line number.<br>
&nbsp; &nbsp; exit $E_ASSERT_FAILED<br>
&nbsp; # else<br>
&nbsp; # &nbsp; return<br>
&nbsp; # &nbsp; and continue executing the script.<br>
&nbsp; fi &nbsp;<br>
} # Insert a similar assert() function into a script you need to debug. &nbsp; &nbsp;<br>
#######################################################################<br>
a=5<br>
b=4<br>
condition=&quot;$a -lt $b&quot; &nbsp; &nbsp; # &nbsp;Error message and exit from script.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Try setting &quot;condition&quot; to something else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and see what happens.<br>
assert &quot;$condition&quot; $LINENO<br>
# The remainder of the script executes only if the &quot;assert&quot; does not fail.<br>
# Some commands.<br>
# Some more commands . . .<br>
echo &quot;This statement echoes only if the \&quot;assert\&quot; does not fail.&quot;<br>
# . . .<br>
# More commands . . .<br>
exit $?<br>
<a href="abs-guides.html#96">Using the $LINENO variable and the caller builtin.</a><br>
5.&nbsp;<br>
Trapping at exit.<br>
6.&nbsp;<br>
<a href="abs-guides.html#212">The exit command in a script triggers a signal 0, terminating the process, that is, the script itself.&nbsp;</a>[119]<br>It is often useful to trap the<i>&nbsp;exit</i>, forcing a &quot;printout&quot; of variables, for example. The<i>&nbsp;trap</i>&nbsp;must be the<br>first command in the script.<br>
<b>Trapping signals</b><br>
<b>trap</b><br>
Specifies an action on receipt of a signal; also useful for debugging.<br>
A<i>&nbsp;signal</i>&nbsp;is a message sent to a process, either by the kernel or another process, telling it to take<br><a href="abs-guides.html#31">some specified action (usually to terminate). For example, hitting a Control-C sends a user interrupt,<br></a>an INT signal, to a running program.<br>
<i>A simple instance:</i><br>
trap '' 2<br>
# Ignore interrupt 2 (Control-C), with no action specified.&nbsp;<br>
Chapter 32. Debugging<br>
473<br>
<hr>
<A name=480></a>Advanced Bash-Scripting Guide<br>
trap 'echo &quot;Control-C disabled.&quot;' 2<br>
# Message when Control-C pressed.<br>
<b>Example 32-5. Trapping at exit</b><br>
#!/bin/bash<br>
# Hunting variables with a trap.<br>
trap 'echo Variable Listing --- a = $a &nbsp;b = $b' EXIT<br>
# &nbsp;EXIT is the name of the signal generated upon exit from a script.<br>
#<br>
# &nbsp;The command specified by the &quot;trap&quot; doesn't execute until<br>
#+ the appropriate signal is sent.<br>
echo &quot;This prints before the \&quot;trap\&quot; --&quot;<br>
echo &quot;even though the script sees the \&quot;trap\&quot; first.&quot;<br>
echo<br>
a=39<br>
b=36<br>
exit 0<br>
# &nbsp;Note that commenting out the 'exit' command makes no difference,<br>
#+ since the script exits in any case after running out of commands.<br>
<b>Example 32-6. Cleaning up after Control-C</b><br>
#!/bin/bash<br>
# logon.sh: A quick 'n dirty script to check whether you are on-line yet.<br>
umask 177 &nbsp;# Make sure temp files are not world readable.<br>
TRUE=1<br>
LOGFILE=/var/log/messages<br>
# &nbsp;Note that $LOGFILE must be readable<br>
#+ (as root, chmod 644 /var/log/messages).<br>
TEMPFILE=temp.$$<br>
# &nbsp;Create a &quot;unique&quot; temp file name, using process id of the script.<br>
# &nbsp; &nbsp; Using 'mktemp' is an alternative.<br>
# &nbsp; &nbsp; For example:<br>
# &nbsp; &nbsp; TEMPFILE=`mktemp temp.XXXXXX`<br>
KEYWORD=address<br>
# &nbsp;At logon, the line &quot;remote IP address xxx.xxx.xxx.xxx&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;appended to /var/log/messages.<br>
ONLINE=22<br>
USER_INTERRUPT=13<br>
CHECK_LINES=100<br>
# &nbsp;How many lines in log file to check.<br>
trap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT<br>
# &nbsp;Cleans up the temp file if script interrupted by control-c.<br>
echo<br>
while [ $TRUE ] &nbsp;#Endless loop.<br>
do<br>
Chapter 32. Debugging<br>
474<br>
<hr>
<A name=481></a>Advanced Bash-Scripting Guide<br>
&nbsp; tail -n $CHECK_LINES $LOGFILE&gt; $TEMPFILE<br>
&nbsp; # &nbsp;Saves last 100 lines of system log file as temp file.<br>
&nbsp; # &nbsp;Necessary, since newer kernels generate many log messages at log on.<br>
&nbsp; search=`grep $KEYWORD $TEMPFILE`<br>
&nbsp; # &nbsp;Checks for presence of the &quot;IP address&quot; phrase,<br>
&nbsp; #+ indicating a successful logon.<br>
&nbsp; if [ ! -z &quot;$search&quot; ] # &nbsp;Quotes necessary because of possible spaces.<br>
&nbsp; then<br>
&nbsp; &nbsp; &nbsp;echo &quot;On-line&quot;<br>
&nbsp; &nbsp; &nbsp;rm -f $TEMPFILE &nbsp; &nbsp;# &nbsp;Clean up temp file.<br>
&nbsp; &nbsp; &nbsp;exit $ONLINE<br>
&nbsp; else<br>
&nbsp; &nbsp; &nbsp;echo -n &quot;.&quot; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;The -n option to echo suppresses newline,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ so you get continuous rows of dots.<br>
&nbsp; fi<br>
&nbsp; sleep 1 &nbsp;<br>
done &nbsp;<br>
# &nbsp;Note: if you change the KEYWORD variable to &quot;Exit&quot;,<br>
#+ this script can be used while on-line<br>
#+ to check for an unexpected logoff.<br>
# Exercise: Change the script, per the above note,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and prettify it.<br>
exit 0<br>
# Nick Drage suggests an alternate method:<br>
while true<br>
&nbsp; do ifconfig ppp0 | grep UP 1&gt; /dev/null &amp;&amp; echo &quot;connected&quot; &amp;&amp; exit 0<br>
&nbsp; echo -n &quot;.&quot; &nbsp; # Prints dots (.....) until connected.<br>
&nbsp; sleep 2<br>
done<br>
# Problem: Hitting Control-C to terminate this process may be insufficient.<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; (Dots may keep on echoing.)<br>
# Exercise: Fix this.<br>
# Stephane Chazelas has yet another alternative:<br>
CHECK_INTERVAL=1<br>
while ! tail -n 1 &quot;$LOGFILE&quot; | grep -q &quot;$KEYWORD&quot;<br>
do echo -n .<br>
&nbsp; &nbsp;sleep $CHECK_INTERVAL<br>
done<br>
echo &quot;On-line&quot;<br>
# Exercise: Discuss the relative strengths and weaknesses<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of each of these various approaches.<br>
<b>Example 32-7. A Simple Implementation of a Progress Bar</b><br>
#! /bin/bash<br>
Chapter 32. Debugging<br>
475<br>
<hr>
<A name=482></a><IMG src="abs-guide-482_1.png"><br>
Advanced Bash-Scripting Guide<br>
# progress-bar2.sh<br>
# Author: Graham Ewart (with reformatting by ABS Guide author).<br>
# Used in ABS Guide with permission (thanks!).<br>
# Invoke this script with bash. It doesn't work with sh.<br>
interval=1<br>
long_interval=10<br>
{<br>
&nbsp; &nbsp; &nbsp;trap &quot;exit&quot; SIGUSR1<br>
&nbsp; &nbsp; &nbsp;sleep $interval; sleep $interval<br>
&nbsp; &nbsp; &nbsp;while true<br>
&nbsp; &nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo -n '.' &nbsp; &nbsp; # Use dots.<br>
&nbsp; &nbsp; &nbsp; &nbsp;sleep $interval<br>
&nbsp; &nbsp; &nbsp;done; } &amp; &nbsp; &nbsp; &nbsp; &nbsp; # Start a progress bar as a background process.<br>
pid=$!<br>
trap &quot;echo !; kill -USR1 $pid; wait $pid&quot; &nbsp;EXIT &nbsp; &nbsp; &nbsp; &nbsp;# To handle ^C.<br>
echo -n 'Long-running process '<br>
sleep $long_interval<br>
echo ' Finished!'<br>
kill -USR1 $pid<br>
wait $pid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Stop the progress bar.<br>
trap EXIT<br>
exit $?<br>
The&nbsp;DEBUG&nbsp;argument to<b>&nbsp;trap</b>&nbsp;causes a specified action to execute after every command in a script. This<br>permits tracing variables, for example.<br>
<b>Example 32-8. Tracing a variable</b><br>
#!/bin/bash<br>
trap 'echo &quot;VARIABLE-TRACE&gt; \$variable = \&quot;$variable\&quot;&quot;' DEBUG<br>
# Echoes the value of $variable after every command.<br>
variable=29<br>
echo &quot; &nbsp;Just initialized \$variable to $variable.&quot;<br>
let &quot;variable *= 3&quot;<br>
echo &quot; &nbsp;Just multiplied \$variable by 3.&quot;<br>
exit<br>
# &nbsp;The &quot;trap 'command1 . . . command2 . . .' DEBUG&quot; construct is<br>
#+ more appropriate in the context of a complex script,<br>
#+ where inserting multiple &quot;echo $variable&quot; statements might be<br>
#+ awkward and time-consuming.<br>
# Thanks, Stephane Chazelas for the pointer.<br>
Output of script:<br>
Chapter 32. Debugging<br>
476<br>
<hr>
<A name=483></a>Advanced Bash-Scripting Guide<br>
VARIABLE-TRACE&gt; $variable = &quot;&quot;<br>
VARIABLE-TRACE&gt; $variable = &quot;29&quot;<br>
&nbsp; Just initialized $variable to 29.<br>
VARIABLE-TRACE&gt; $variable = &quot;29&quot;<br>
VARIABLE-TRACE&gt; $variable = &quot;87&quot;<br>
&nbsp; Just multiplied $variable by 3.<br>
VARIABLE-TRACE&gt; $variable = &quot;87&quot;<br>
Of course, the<b>&nbsp;trap</b>&nbsp;command has other uses aside from debugging, such as disabling certain keystrokes<br><a href="abs-guides.html#721">within a script (see Example A-43).</a><br>
<b>Example 32-9. Running multiple processes (on an SMP box)</b><br>
#!/bin/bash<br>
# parent.sh<br>
# Running multiple processes on an SMP box.<br>
# Author: Tedman Eng<br>
# &nbsp;This is the first of two scripts,<br>
#+ both of which must be present in the current working directory.<br>
LIMIT=$1 &nbsp; &nbsp; &nbsp; &nbsp; # Total number of process to start<br>
NUMPROC=4 &nbsp; &nbsp; &nbsp; &nbsp;# Number of concurrent threads (forks?)<br>
PROCID=1 &nbsp; &nbsp; &nbsp; &nbsp; # Starting Process ID<br>
echo &quot;My PID is $$&quot;<br>
function start_thread() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ $PROCID -le $LIMIT ] ; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ./child.sh $PROCID&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let &quot;PROCID++&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Limit reached.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wait<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
}<br>
while [ &quot;$NUMPROC&quot; -gt 0 ]; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; start_thread;<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;NUMPROC--&quot;<br>
done<br>
while true<br>
do<br>
trap &quot;start_thread&quot; SIGRTMIN<br>
done<br>
exit 0<br>
# ======== Second script follows ========<br>
Chapter 32. Debugging<br>
477<br>
<hr>
<A name=484></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# child.sh<br>
# Running multiple processes on an SMP box.<br>
# This script is called by parent.sh.<br>
# Author: Tedman Eng<br>
temp=$RANDOM<br>
index=$1<br>
shift<br>
let &quot;temp %= 5&quot;<br>
let &quot;temp += 4&quot;<br>
echo &quot;Starting $index &nbsp;Time:$temp&quot; &quot;$@&quot;<br>
sleep ${temp}<br>
echo &quot;Ending $index&quot;<br>
kill -s SIGRTMIN $PPID<br>
exit 0<br>
# ======================= SCRIPT AUTHOR'S NOTES ======================= #<br>
# &nbsp;It's not completely bug free.<br>
# &nbsp;I ran it with limit = 500 and after the first few hundred iterations,<br>
#+ one of the concurrent threads disappeared!<br>
# &nbsp;Not sure if this is collisions from trap signals or something else.<br>
# &nbsp;Once the trap is received, there's a brief moment while executing the<br>
#+ trap handler but before the next trap is set. &nbsp;During this time, it may<br>
#+ be possible to miss a trap signal, thus miss spawning a child process.<br>
# &nbsp;No doubt someone may spot the bug and will be writing&nbsp;<br>
#+ . . . in the future.<br>
# ===================================================================== #<br>
# ----------------------------------------------------------------------#<br>
#################################################################<br>
# The following is the original script written by Vernia Damiano.<br>
# Unfortunately, it doesn't work properly.<br>
#################################################################<br>
#!/bin/bash<br>
# &nbsp;Must call script with at least one integer parameter<br>
#+ (number of concurrent processes).<br>
# &nbsp;All other parameters are passed through to the processes started.<br>
INDICE=8 &nbsp; &nbsp; &nbsp; &nbsp;# Total number of process to start<br>
TEMPO=5 &nbsp; &nbsp; &nbsp; &nbsp; # Maximum sleep time per process<br>
E_BADARGS=65 &nbsp; &nbsp;# No arg(s) passed to script.<br>
if [ $# -eq 0 ] # Check for at least one argument passed to script.<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` number_of_processes [passed params]&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
Chapter 32. Debugging<br>
478<br>
<hr>
<A name=485></a><IMG src="abs-guide-485_1.png"><br>
Advanced Bash-Scripting Guide<br>
NUMPROC=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Number of concurrent process<br>
shift<br>
PARAMETRI=( &quot;$@&quot; ) &nbsp; &nbsp; &nbsp;# Parameters of each process<br>
function avvia() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local temp<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;local index<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp=$RANDOM<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;index=$1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let &quot;temp %= $TEMPO&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let &quot;temp += 1&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Starting $index Time:$temp&quot; &quot;$@&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sleep ${temp}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Ending $index&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kill -s SIGRTMIN $$<br>
}<br>
function parti() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if [ $INDICE -gt 0 ] ; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avvia $INDICE &quot;${PARAMETRI[@]}&quot; &amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let &quot;INDICE--&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trap : SIGRTMIN<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
}<br>
trap parti SIGRTMIN<br>
while [ &quot;$NUMPROC&quot; -gt 0 ]; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parti;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let &quot;NUMPROC--&quot;<br>
done<br>
wait<br>
trap - SIGRTMIN<br>
exit $?<br>
: &lt;&lt;SCRIPT_AUTHOR_COMMENTS<br>
I had the need to run a program, with specified options, on a number of<br>
different files, using a SMP machine. So I thought [I'd] keep running<br>
a specified number of processes and start a new one each time . . . one<br>
of these terminates.<br>
The &quot;wait&quot; instruction does not help, since it waits for a given process<br>
or *all* process started in background. So I wrote [this] bash script<br>
that can do the job, using the &quot;trap&quot; instruction.<br>
&nbsp; --Vernia Damiano<br>
SCRIPT_AUTHOR_COMMENTS<br>
<b>trap '' SIGNAL</b>&nbsp;(two adjacent apostrophes) disables SIGNAL for the remainder of the script.&nbsp;<b>trap<br>SIGNAL</b>&nbsp;restores the functioning of SIGNAL once more. This is useful to protect a critical portion of a<br>script from an undesirable interrupt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; trap '' 2 &nbsp;# Signal 2 is Control-C, now disabled.<br>
&nbsp; &nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; &nbsp; command<br>
Chapter 32. Debugging<br>
479<br>
<hr>
<A name=486></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; trap 2 &nbsp; &nbsp; # Reenables Control-C<br>
<a href="abs-guides.html#545">Version 3 of Bash adds the following internal variables for use by the debugger.</a><br>
$BASH_ARGC<br>
1.&nbsp;<br>
Number of command-line arguments passed to script, similar to&nbsp;<a href="abs-guides.html#104">$#</a>.<br>$BASH_ARGV<br>
2.&nbsp;<br>
Final command-line parameter passed to script, equivalent&nbsp;<a href="abs-guides.html#43">${!#}.<br></a>$BASH_COMMAND<br>
3.&nbsp;<br>
Command currently executing.<br>$BASH_EXECUTION_STRING<br>
4.&nbsp;<br>
The<i>&nbsp;option string</i>&nbsp;following the&nbsp;-c<a href="abs-guides.html#791">&nbsp;option to Bash.<br></a>$BASH_LINENO<br>
5.&nbsp;<br>
<a href="abs-guides.html#399">In a function, indicates the line number of the function call.<br></a>$BASH_REMATCH<br>
6.&nbsp;<br>
Array variable associated with<b>&nbsp;=~</b><a href="abs-guides.html#547">&nbsp;conditional regex matching.</a><br>
7.&nbsp;<br>
$BASH_SOURCE<br>
<a href="abs-guides.html#882">This is the name of the script, usually the same as $0.<br></a><a href="abs-guides.html#91">$BASH_SUBSHELL</a><br>
<a href="abs-guides.html#91">8.&nbsp;</a><br>
Chapter 32. Debugging<br>
480<br>
<hr>
<A name=487></a><IMG src="abs-guide-487_1.png"><br>
<b>Chapter 33. Options</b><br>
Options are settings that change shell and/or script behavior.<br>
<a href="abs-guides.html#203">The set command enables options within a script. At the point in the script where you want the options to take<br></a>effect, use<b>&nbsp;set -o option-name</b>&nbsp;or, in short form,<b>&nbsp;set -option-abbrev</b>. These two forms are equivalent.<br>
&nbsp; &nbsp; &nbsp; #!/bin/bash<br>
&nbsp; &nbsp; &nbsp; set -o verbose<br>
&nbsp; &nbsp; &nbsp; # Echoes all commands before executing.<br>
&nbsp; &nbsp; &nbsp; #!/bin/bash<br>
&nbsp; &nbsp; &nbsp; set -v<br>
&nbsp; &nbsp; &nbsp; # Exact same effect as above.<br>
To<i>&nbsp;disable</i>&nbsp;an option within a script, use<b>&nbsp;set +o option-name</b>&nbsp;or<b>&nbsp;set +option-abbrev</b>.<br>
&nbsp; &nbsp; &nbsp; #!/bin/bash<br>
&nbsp; &nbsp; &nbsp; set -o verbose<br>
&nbsp; &nbsp; &nbsp; # Command echoing on.<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; ...<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; set +o verbose<br>
&nbsp; &nbsp; &nbsp; # Command echoing off.<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; # Not echoed.<br>
&nbsp; &nbsp; &nbsp; set -v<br>
&nbsp; &nbsp; &nbsp; # Command echoing on.<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; ...<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; set +v<br>
&nbsp; &nbsp; &nbsp; # Command echoing off.<br>
&nbsp; &nbsp; &nbsp; command<br>
&nbsp; &nbsp; &nbsp; exit 0<br>
An alternate method of enabling options in a script is to specify them immediately following the&nbsp;<i>#!</i>&nbsp;script<br>header.<br>
&nbsp; &nbsp; &nbsp; #!/bin/bash -x<br>
&nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; # Body of script follows.<br>
Chapter 33. Options<br>
481<br>
<hr>
<A name=488></a>Advanced Bash-Scripting Guide<br>
It is also possible to enable script options from the command line. Some options that will not work with<b>&nbsp;set<br></b>are available this way. Among these are&nbsp;<i>-i</i>, force script to run interactive.<br>
<b>bash -v script-name</b><br>
<b>bash -o verbose script-name</b><br>
The following is a listing of some useful options. They may be specified in either abbreviated form (preceded<br>by a single dash) or by complete name (preceded by a<i>&nbsp;double</i>&nbsp;dash or by&nbsp;-o).<br>
<b>Table 33-1. Bash options</b><br>
<b>Abbreviation</b><br>
<b>Name</b><br>
<b>Effect</b><br>
-B<br>
brace<br>
<i>Enable</i><a href="abs-guides.html#20">&nbsp;brace expansion (default setting =</a><i>&nbsp;on</i>)<br>
expansion<br>
+B<br>
brace<br>
<i>Disable</i>&nbsp;brace expansion<br>
expansion<br>
-C<br>
noclobber<br>
Prevent overwriting of files by redirection (may be overridden by &gt;|)<br>
-D<br>
(none)<br>
List double-quoted strings prefixed by $, but do not execute commands in<br>script<br>
-a<br>
allexport<br>
Export all defined variables<br>
-b<br>
notify<br>
Notify when jobs running in background terminate (not of much use in a<br>script)<br>
-c ...<br>
(none)<br>
Read commands from<b>&nbsp;...</b><br>
checkjobs<br>
<a href="abs-guides.html#215">Informs user of any open jobs upon shell exit. Introduced in version 4 of<br></a>Bash, and still &quot;experimental.&quot;<i>&nbsp;Usage:</i>&nbsp;shopt -s checkjobs (<i>Caution:</i>&nbsp;may<br>hang!)<br>
-e<br>
errexit<br>
Abort script at first error, when a command exits with non-zero status<br><a href="abs-guides.html#156">(except in until or while loops, if-tests, list constructs)</a><br>
-f<br>
noglob<br>
Filename expansion (globbing) disabled<br>
globstar<br>
<a href="abs-guides.html#555"><i>globbing</i></a><br>
<a href="abs-guides.html#358">Enables the ** globbing operator (version 4+ of Bash).</a><i>&nbsp;Usage:</i>&nbsp;shopt -s<br>
<a href="abs-guides.html#555">star-match</a><br>
globstar<br>
-i<br>
interactive<br>
Script runs in<i>&nbsp;interactive</i>&nbsp;mode<br>
-n<br>
noexec<br>
Read commands in script, but do not execute them (syntax check)<br>
-o<br>
(none)<br>
Invoke the<i>&nbsp;Option-Name</i>&nbsp;option<br>
Option-Name<br>
-o posix<br>
POSIX<br>
<a href="abs-guides.html#881">Change the behavior of Bash, or invoked script, to conform to POSIX<br></a>standard.<br>
-o pipefail<br>
pipe failure<br>
<a href="abs-guides.html#57">Causes a pipeline to return the exit status of the last command in the pipe<br></a>that returned a non-zero return value.<br>
-p<br>
privileged<br>
Script runs as &quot;suid&quot; (caution!)<br>
-r<br>
restricted<br>
Script runs in<i>&nbsp;restricted</i><a href="abs-guides.html#392">&nbsp;mode (see Chapter 22).</a><br>
-s<br>
stdin<br>
Read commands from&nbsp;stdin<br>
-t<br>
(none)<br>
Exit after first command<br>
Chapter 33. Options<br>
482<br>
<hr>
<A name=489></a>Advanced Bash-Scripting Guide<br>
-u<br>
nounset<br>
Attempt to use undefined variable outputs error message, and forces an<br>exit<br>
-v<br>
verbose<br>
Print each command to&nbsp;stdout&nbsp;before executing it<br>
-x<br>
xtrace<br>
Similar to&nbsp;-v, but expands commands<br>
-<br>
(none)<br>
<a href="abs-guides.html#104">End of options flag. All other arguments are positional parameters.</a><br>
--<br>
(none)<br>
Unset positional parameters. If arguments given (<i>-- arg1 arg2</i>),<br>positional parameters set to arguments.<br>
Chapter 33. Options<br>
483<br>
<hr>
<A name=490></a><b>Chapter 34. Gotchas</b><br>
<i>Turandot: Gli enigmi sono tre, la morte una!</i><br>
<i>Caleph: No, no! Gli enigmi sono tre, una la vita!</i><br>
<i>--Puccini</i><br>
Here are some (non-recommended!) scripting practices that will bring excitement into an otherwise dull life.<br>
•&nbsp;<br>
Assigning reserved words or characters to variable names.<br>
case=value0 &nbsp; &nbsp; &nbsp; # Causes problems.<br>
23skidoo=value1 &nbsp; # Also problems.<br>
# Variable names starting with a digit are reserved by the shell.<br>
# Try _23skidoo=value1. Starting variables with an underscore is okay.<br>
# However . . . &nbsp; using just an underscore will not work.<br>
_=25<br>
echo $_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $_ is a special variable set to last arg of last command.<br>
# But . . . &nbsp; &nbsp; &nbsp; _ is a valid function name!<br>
xyz((!*=value2 &nbsp; &nbsp;# Causes severe problems.<br>
# As of version 3 of Bash, periods are not allowed within variable names.<br>
Using a hyphen or other reserved characters in a variable name (or function name).<br>
•&nbsp;<br>
var-1=23<br>
# Use 'var_1' instead.<br>
function-whatever () &nbsp; # Error<br>
# Use 'function_whatever ()' instead.<br>
# As of version 3 of Bash, periods are not allowed within function names.<br>
function.whatever () &nbsp; # Error<br>
# Use 'functionWhatever ()' instead.<br>
Using the same name for a variable and a function. This can make a script difficult to understand.<br>
•&nbsp;<br>
do_something ()<br>
{<br>
&nbsp; echo &quot;This function does something with \&quot;$1\&quot;.&quot;<br>
}<br>
do_something=do_something<br>
do_something do_something<br>
# All this is legal, but highly confusing.<br>
<a href="abs-guides.html#34">Using whitespace inappropriately. In contrast to other programming languages, Bash can be quite</a><br>
•&nbsp;<br>
finicky about whitespace.<br>
var1 = 23 &nbsp; # 'var1=23' is correct.<br>
# On line above, Bash attempts to execute command &quot;var1&quot;<br>
# with the arguments &quot;=&quot; and &quot;23&quot;.<br>
Chapter 34. Gotchas<br>
484<br>
<hr>
<A name=491></a>Advanced Bash-Scripting Guide<br>
let c = $a - $b &nbsp; # Instead: &nbsp; let c=$a-$b &nbsp; or &nbsp; let &quot;c = $a - $b&quot;<br>
if [ $a -le 5] &nbsp; &nbsp;# if [ $a -le 5 ] &nbsp; is correct.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ &nbsp; &nbsp; &nbsp;if [ &quot;$a&quot; -le 5 ] &nbsp; is even better.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # [[ $a -le 5 ]] also works.<br>
•&nbsp;<br>
<a href="abs-guides.html#14">Not terminating with a semicolon the final command in a code block within curly brackets.</a><br>
{ ls -l; df; echo &quot;Done.&quot; }<br>
# bash: syntax error: unexpected end of file<br>
{ ls -l; df; echo &quot;Done.&quot;; }<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; ### Final command needs semicolon.<br>
•&nbsp;<br>
Assuming uninitialized variables (variables before a value is assigned to them) are &quot;zeroed out&quot;. An<br>uninitialized variable has a value of<i>&nbsp;null</i>,<i>&nbsp;not</i>&nbsp;zero.<br>
#!/bin/bash<br>
echo &quot;uninitialized_var = $uninitialized_var&quot;<br>
# uninitialized_var =<br>
# However . . .<br>
# if $BASH_VERSION ≥ 4.2; then<br>
if [[ ! -v uninitialized_var ]]<br>
then<br>
&nbsp; uninitialized_var=0 &nbsp; # Initialize it to zero!<br>
fi<br>
•&nbsp;<br>
Mixing up<i>&nbsp;=</i>&nbsp;and<i>&nbsp;-eq</i>&nbsp;in a test. Remember,<i>&nbsp;=</i>&nbsp;is for comparing literal variables and<i>&nbsp;-eq</i>&nbsp;for integers.<br>
if [ &quot;$a&quot; = 273 ] &nbsp; &nbsp; &nbsp;# Is $a an integer or string?<br>
if [ &quot;$a&quot; -eq 273 ] &nbsp; &nbsp;# If $a is an integer.<br>
# Sometimes you can interchange -eq and = without adverse consequences.<br>
# However . . .<br>
a=273.0 &nbsp; # Not an integer.<br>
if [ &quot;$a&quot; = 273 ]<br>
then<br>
&nbsp; echo &quot;Comparison works.&quot;<br>
else &nbsp;<br>
&nbsp; echo &quot;Comparison does not work.&quot;<br>
fi &nbsp; &nbsp;# Comparison does not work.<br>
# Same with &nbsp; a=&quot; 273&quot; &nbsp;and a=&quot;0273&quot;.<br>
# Likewise, problems trying to use &quot;-eq&quot; with non-integer values.<br>
if [ &quot;$a&quot; -eq 273.0 ]<br>
then<br>
&nbsp; echo &quot;a = $a&quot;<br>
fi &nbsp;# Aborts with an error message. &nbsp;<br>
# test.sh: [: 273.0: integer expression expected<br>
Chapter 34. Gotchas<br>
485<br>
<hr>
<A name=492></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#72">Misusing string comparison operators.</a><br>
•&nbsp;<br>
<b>Example 34-1. Numerical and string comparison are not equivalent</b><br>
#!/bin/bash<br>
# bad-op.sh: Trying to use a string comparison on integers.<br>
echo<br>
number=1<br>
# &nbsp;The following while-loop has two errors:<br>
#+ one blatant, and the other subtle.<br>
while [ &quot;$number&quot; &lt; 5 ] &nbsp; &nbsp;# Wrong! Should be: &nbsp;while [ &quot;$number&quot; -lt 5 ]<br>
do<br>
&nbsp; echo -n &quot;$number &quot;<br>
&nbsp; let &quot;number += 1&quot;<br>
done &nbsp;<br>
# &nbsp;Attempt to run this bombs with the error message:<br>
#+ bad-op.sh: line 10: 5: No such file or directory<br>
# &nbsp;Within single brackets, &quot;&lt;&quot; must be escaped,<br>
#+ and even then, it's still wrong for comparing integers.<br>
echo &quot;---------------------&quot;<br>
while [ &quot;$number&quot; \&lt; 5 ] &nbsp; &nbsp;# &nbsp;1 2 3 4<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
&nbsp; echo -n &quot;$number &quot; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;It *seems* to work, but . . .<br>
&nbsp; let &quot;number += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; #+ it actually does an ASCII comparison,<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ rather than a numerical one.<br>
echo; echo &quot;---------------------&quot;<br>
# This can cause problems. For example:<br>
lesser=5<br>
greater=105<br>
if [ &quot;$greater&quot; \&lt; &quot;$lesser&quot; ]<br>
then<br>
&nbsp; echo &quot;$greater is less than $lesser&quot;<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 105 is less than 5<br>
# &nbsp;In fact, &quot;105&quot; actually is less than &quot;5&quot;<br>
#+ in a string comparison (ASCII sort order).<br>
echo<br>
exit 0<br>
•&nbsp;<br>
<a href="abs-guides.html#198">Attempting to use let to set string variables.</a><br>
let &quot;a = hello, you&quot;<br>
echo &quot;$a&quot; &nbsp; # 0<br>
•&nbsp;<br>
Sometimes variables within &quot;test&quot; brackets ([ ]) need to be quoted (double quotes). Failure to do so<br><a href="abs-guides.html#74">may cause unexpected behavior. See Example 7-6, Example 20-5, and Example 9-6.</a><br>
Chapter 34. Gotchas<br>
486<br>
<hr>
<A name=493></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#47">Quoting a variable containing whitespace prevents splitting. Sometimes this produces unintended</a><br>
•&nbsp;<br>
<a href="abs-guides.html#47">consequences.</a><br>
•&nbsp;<br>
Commands issued from a script may fail to execute because the script owner lacks execute permission<br>for them. If a user cannot invoke a command from the command-line, then putting it into a script will<br>likewise fail. Try changing the attributes of the command in question, perhaps even setting the suid bit<br>(as<i>&nbsp;root</i>, of course).<br>
•&nbsp;<br>
Attempting to use<b>&nbsp;-</b>&nbsp;as a redirection operator (which it is not) will usually result in an unpleasant<br>surprise.<br>
command1 2&gt; - | command2<br>
# Trying to redirect error output of command1 into a pipe . . .<br>
# . . . will not work. &nbsp;<br>
command1 2&gt;&amp; - | command2 &nbsp;# Also futile.<br>
Thanks, S.C.<br>
•&nbsp;<br>
<a href="abs-guides.html#541">Using Bash version 2+ functionality may cause a bailout with error messages. Older Linux machines<br></a>may have version 1.XX of Bash as the default installation.<br>
#!/bin/bash<br>
minimum_version=2<br>
# Since Chet Ramey is constantly adding features to Bash,<br>
# you may set $minimum_version to 2.XX, 3.XX, or whatever is appropriate.<br>
E_BAD_VERSION=80<br>
if [ &quot;$BASH_VERSION&quot; \&lt; &quot;$minimum_version&quot; ]<br>
then<br>
&nbsp; echo &quot;This script works only with Bash, version $minimum or greater.&quot;<br>
&nbsp; echo &quot;Upgrade strongly recommended.&quot;<br>
&nbsp; exit $E_BAD_VERSION<br>
fi<br>
...<br>
<a href="abs-guides.html#8">Using Bash-specific functionality in a Bourne shell script (</a><br>
•&nbsp;<br>
<b>#!/bin/sh</b>) on a non-Linux machine<br>
<a href="abs-guides.html#494">may cause unexpected behavior. A Linux system usually aliases</a><b>&nbsp;sh</b>&nbsp;to<b>&nbsp;bash</b>, but this does not<br>necessarily hold true for a generic UNIX machine.<br>
•&nbsp;<br>
Using undocumented features in Bash turns out to be a dangerous practice. In previous releases of this<br>book there were several scripts that depended on the &quot;feature&quot; that, although the maximum value of<br><a href="abs-guides.html#57">an exit or return value was 255, that limit did not apply to</a><i>&nbsp;negative</i>&nbsp;integers. Unfortunately, in version<br><a href="abs-guides.html#409">2.05b and later, that loophole disappeared. See Example 24-9.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#57">In certain contexts, a misleading exit status may be returned. This may occur when setting a local<br></a><a href="abs-guides.html#414">variable within a function or when assigning an arithmetic value to a variable.<br></a><a href="abs-guides.html#61">The exit status of an arithmetic expression is</a><br>
•&nbsp;<br>
<i>&nbsp;not</i>&nbsp;equivalent to an<i>&nbsp;error code</i>.<br>
var=1 &amp;&amp; ((--var)) &amp;&amp; echo $var<br>
# &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^ Here the and-list terminates with exit status 1.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $var doesn't echo!<br>
echo $? &nbsp; # 1<br>
Chapter 34. Gotchas<br>
487<br>
<hr>
<A name=494></a>Advanced Bash-Scripting Guide<br>
A script with DOS-type newlines (<br>
•&nbsp;<br>
<i>\r\n</i>) will fail to execute, since&nbsp;<b>#!/bin/bash\r\n</b>&nbsp;is<i>&nbsp;not</i><br>
recognized,<i>&nbsp;not</i>&nbsp;the same as the expected&nbsp;<b>#!/bin/bash\n</b>. The fix is to convert the script to<br>UNIX-style newlines.<br>
#!/bin/bash<br>
echo &quot;Here&quot;<br>
unix2dos $0 &nbsp; &nbsp;# Script changes itself to DOS format.<br>
chmod 755 $0 &nbsp; # Change back to execute permission.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The 'unix2dos' command removes execute permission.<br>
./$0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Script tries to run itself again.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# But it won't work as a DOS file.<br>
echo &quot;There&quot;<br>
exit 0<br>
•&nbsp;<br>
A shell script headed by&nbsp;<b>#!/bin/sh</b>&nbsp;will not run in full Bash-compatibility mode. Some<br>Bash-specific functions might be disabled. Scripts that need complete access to all the Bash-specific<br>extensions should start with&nbsp;<b>#!/bin/bash</b>.<br><a href="abs-guides.html#369">Putting whitespace in front of the terminating limit string of a here document will cause unexpected</a><br>
•&nbsp;<br>
behavior in a script.<br>Putting more than one<br>
•&nbsp;<br>
<i>&nbsp;echo</i><a href="abs-guides.html#530">&nbsp;statement in a function whose output is captured.</a><br>
add2 ()<br>
{<br>
&nbsp; echo &quot;Whatever ... &quot; &nbsp; # Delete this line!<br>
&nbsp; let &quot;retval = $1 + $2&quot;<br>
&nbsp; &nbsp; echo $retval<br>
&nbsp; &nbsp; }<br>
&nbsp; &nbsp; num1=12<br>
&nbsp; &nbsp; num2=43<br>
&nbsp; &nbsp; echo &quot;Sum of $num1 and $num2 = $(add2 $num1 $num2)&quot;<br>
# &nbsp; Sum of 12 and 43 = Whatever ...&nbsp;<br>
# &nbsp; 55<br>
# &nbsp; &nbsp; &nbsp; &nbsp;The &quot;echoes&quot; concatenate.<br>
<a href="abs-guides.html#531">This will not work.</a><br>
•&nbsp;<br>
A script may not<b>&nbsp;export</b><a href="abs-guides.html#186">&nbsp;variables back to its parent process, the shell, or to the environment. Just as<br></a>we learned in biology, a child process can inherit from a parent, but not vice versa.<br>
WHATEVER=/home/bozo<br>
export WHATEVER<br>
exit 0<br>
bash$&nbsp;<b>echo $WHATEVER</b><br>
bash$&nbsp;<br>
Sure enough, back at the command prompt, $WHATEVER remains unset.<br>
•&nbsp;<br>
<a href="abs-guides.html#387">Setting and manipulating variables in a subshell, then attempting to use those same variables outside<br></a>the scope of the subshell will result an unpleasant surprise.<br>
Chapter 34. Gotchas<br>
488<br>
<hr>
<A name=495></a>Advanced Bash-Scripting Guide<br>
<b>Example 34-2. Subshell Pitfalls</b><br>
#!/bin/bash<br>
# Pitfalls of variables in a subshell.<br>
outer_variable=outer<br>
echo<br>
echo &quot;outer_variable = $outer_variable&quot;<br>
echo<br>
(<br>
# Begin subshell<br>
echo &quot;outer_variable inside subshell = $outer_variable&quot;<br>
inner_variable=inner &nbsp;# Set<br>
echo &quot;inner_variable inside subshell = $inner_variable&quot;<br>
outer_variable=inner &nbsp;# Will value change globally?<br>
echo &quot;outer_variable inside subshell = $outer_variable&quot;<br>
# Will 'exporting' make a difference?<br>
# &nbsp; &nbsp;export inner_variable<br>
# &nbsp; &nbsp;export outer_variable<br>
# Try it and see.<br>
# End subshell<br>
)<br>
echo<br>
echo &quot;inner_variable outside subshell = $inner_variable&quot; &nbsp;# Unset.<br>
echo &quot;outer_variable outside subshell = $outer_variable&quot; &nbsp;# Unchanged.<br>
echo<br>
exit 0<br>
# What happens if you uncomment lines 19 and 20?<br>
# Does it make a difference?<br>
•&nbsp;<br>
<a href="abs-guides.html#24">Piping<b>&nbsp;echo</b></a><a href="abs-guides.html#190">&nbsp;output to a read may produce unexpected results. In this scenario, the</a><b>&nbsp;read</b>&nbsp;acts as if it<br><a href="abs-guides.html#203">were running in a subshell. Instead, use the set command (as in Example 15-18).</a><br>
<b>Example 34-3. Piping the output of<i>&nbsp;echo</i></b><b>&nbsp;to a<i>&nbsp;read</i></b><br>
#!/bin/bash<br>
# &nbsp;badread.sh:<br>
# &nbsp;Attempting to use 'echo and 'read'<br>
#+ to assign variables non-interactively.<br>
# &nbsp; shopt -s lastpipe<br>
a=aaa<br>
b=bbb<br>
c=ccc<br>
echo &quot;one two three&quot; | read a b c<br>
# Try to reassign a, b, and c.<br>
echo<br>
echo &quot;a = $a&quot; &nbsp;# a = aaa<br>
echo &quot;b = $b&quot; &nbsp;# b = bbb<br>
Chapter 34. Gotchas<br>
489<br>
<hr>
<A name=496></a>Advanced Bash-Scripting Guide<br>
echo &quot;c = $c&quot; &nbsp;# c = ccc<br>
# Reassignment failed.<br>
### However . . .<br>
## &nbsp;Uncommenting line 6:<br>
# &nbsp; shopt -s lastpipe<br>
##+ fixes the problem!<br>
### This is a new feature in Bash, version 4.2.<br>
# ------------------------------<br>
# Try the following alternative.<br>
var=`echo &quot;one two three&quot;`<br>
set -- $var<br>
a=$1; b=$2; c=$3<br>
echo &quot;-------&quot;<br>
echo &quot;a = $a&quot; &nbsp;# a = one<br>
echo &quot;b = $b&quot; &nbsp;# b = two<br>
echo &quot;c = $c&quot; &nbsp;# c = three&nbsp;<br>
# Reassignment succeeded.<br>
# ------------------------------<br>
# &nbsp;Note also that an echo to a 'read' works within a subshell.<br>
# &nbsp;However, the value of the variable changes *only* within the subshell.<br>
a=aaa &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Starting all over again.<br>
b=bbb<br>
c=ccc<br>
echo; echo<br>
echo &quot;one two three&quot; | ( read a b c;<br>
echo &quot;Inside subshell: &quot;; echo &quot;a = $a&quot;; echo &quot;b = $b&quot;; echo &quot;c = $c&quot; )<br>
# a = one<br>
# b = two<br>
# c = three<br>
echo &quot;-----------------&quot;<br>
echo &quot;Outside subshell: &quot;<br>
echo &quot;a = $a&quot; &nbsp;# a = aaa<br>
echo &quot;b = $b&quot; &nbsp;# b = bbb<br>
echo &quot;c = $c&quot; &nbsp;# c = ccc<br>
echo<br>
exit 0<br>
In fact, as Anthony Richardson points out, piping to<i>&nbsp;any</i>&nbsp;loop can cause a similar problem.<br>
# Loop piping troubles.<br>
# &nbsp;This example by Anthony Richardson,<br>
#+ with addendum by Wilbert Berendsen.<br>
foundone=false<br>
find $HOME -type f -atime +30 -size 100k |<br>
while true<br>
do<br>
&nbsp; &nbsp;read f<br>
&nbsp; &nbsp;echo &quot;$f is over 100KB and has not been accessed in over 30 days&quot;<br>
&nbsp; &nbsp;echo &quot;Consider moving the file to archives.&quot;<br>
Chapter 34. Gotchas<br>
490<br>
<hr>
<A name=497></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;foundone=true<br>
&nbsp; &nbsp;# ------------------------------------<br>
&nbsp; &nbsp; &nbsp;echo &quot;Subshell level = $BASH_SUBSHELL&quot;<br>
&nbsp; &nbsp;# Subshell level = 1<br>
&nbsp; &nbsp;# Yes, we're inside a subshell.<br>
&nbsp; &nbsp;# ------------------------------------<br>
done<br>
# &nbsp;foundone will always be false here since it is<br>
#+ set to true inside a subshell<br>
if [ $foundone = false ]<br>
then<br>
&nbsp; &nbsp;echo &quot;No files need archiving.&quot;<br>
fi<br>
# =====================Now, here is the correct way:=================<br>
foundone=false<br>
for f in $(find $HOME -type f -atime +30 -size 100k) &nbsp;# No pipe here.<br>
do<br>
&nbsp; &nbsp;echo &quot;$f is over 100KB and has not been accessed in over 30 days&quot;<br>
&nbsp; &nbsp;echo &quot;Consider moving the file to archives.&quot;<br>
&nbsp; &nbsp;foundone=true<br>
done<br>
if [ $foundone = false ]<br>
then<br>
&nbsp; &nbsp;echo &quot;No files need archiving.&quot;<br>
fi<br>
# ==================And here is another alternative==================<br>
# &nbsp;Places the part of the script that reads the variables<br>
#+ within a code block, so they share the same subshell.<br>
# &nbsp;Thank you, W.B.<br>
find $HOME -type f -atime +30 -size 100k | {<br>
&nbsp; &nbsp; &nbsp;foundone=false<br>
&nbsp; &nbsp; &nbsp;while read f<br>
&nbsp; &nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$f is over 100KB and has not been accessed in over 30 days&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Consider moving the file to archives.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;foundone=true<br>
&nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp; &nbsp;if ! $foundone<br>
&nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;No files need archiving.&quot;<br>
&nbsp; &nbsp; &nbsp;fi<br>
}<br>
A lookalike problem occurs when trying to write the&nbsp;stdout&nbsp;of a<b>&nbsp;tail -f</b><a href="abs-guides.html#246">&nbsp;piped to grep.</a><br>
tail -f /var/log/messages | grep &quot;$ERROR_MSG&quot; &gt;&gt; error.log<br>
# &nbsp;The &quot;error.log&quot; file will not have anything written to it.<br>
# &nbsp;As Samuli Kaipiainen points out, this results from grep<br>
#+ buffering its output.<br>
# &nbsp;The fix is to add the &quot;--line-buffered&quot; parameter to grep.<br>
•&nbsp;<br>
Using &quot;suid&quot; commands within scripts is risky, as it may compromise system security.&nbsp;[120]<br>
Chapter 34. Gotchas<br>
491<br>
<hr>
<A name=498></a>Advanced Bash-Scripting Guide<br>
Using shell scripts for CGI programming may be problematic. Shell script variables are not<br>
•&nbsp;<br>
&quot;typesafe,&quot; and this can cause undesirable behavior as far as CGI is concerned. Moreover, it is<br>difficult to &quot;cracker-proof&quot; shell scripts.<br><a href="abs-guides.html#197">Bash does not handle the double slash (//) string correctly.</a><br>
•&nbsp;<br>•&nbsp;<br>
Bash scripts written for Linux or BSD systems may need fixups to run on a commercial UNIX (or<br>Apple OSX) machine. Such scripts often employ the GNU set of commands and filters, which have<br>greater functionality than their generic UNIX counterparts. This is particularly true of such text<br><a href="abs-guides.html#254">processing utilites as tr.</a><br>
<i>Danger is near thee --</i><br>
<i>Beware, beware, beware, beware.</i><br>
<i>Many brave hearts are asleep in the deep.</i><br>
<i>So beware --</i><br>
<i>Beware.</i><br>
<i>--A.J. Lamb and H.W. Petrie</i><br>
Chapter 34. Gotchas<br>
492<br>
<hr>
<A name=499></a><b>Chapter 35. Scripting With Style</b><br>
Get into the habit of writing shell scripts in a structured and systematic manner. Even on-the-fly and &quot;written<br>on the back of an envelope&quot; scripts will benefit if you take a few minutes to plan and organize your thoughts<br>before sitting down and coding.<br>
Herewith are a few stylistic guidelines. This is not (necessarily) intended as an<i>&nbsp;Official Shell Scripting<br>Stylesheet</i>.<br>
<b>35.1. Unofficial Shell Scripting Stylesheet</b><br>
Comment your code. This makes it easier for others to understand (and appreciate), and easier for you<br>
•&nbsp;<br>
to maintain.<br>
PASS=&quot;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&quot;<br>
# &nbsp;It made perfect sense when you wrote it last year,<br>
#+ but now it's a complete mystery.<br>
# &nbsp;(From Antek Sawicki's &quot;pw.sh&quot; script.)<br>
Add descriptive headers to your scripts and functions.<br>
#!/bin/bash<br>
#************************************************#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xyz.sh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written by Bozo Bozeman &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;July 05, 2001 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Clean up project files. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
#************************************************#<br>
E_BADDIR=85 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No such directory.<br>
projectdir=/home/bozo/projects &nbsp; &nbsp;# Directory to clean up.<br>
# --------------------------------------------------------- #<br>
# cleanup_pfiles () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# Removes all files in designated directory. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# Parameter: $target_directory &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# Returns: 0 on success, $E_BADDIR if something went wrong. #<br>
# --------------------------------------------------------- #<br>
cleanup_pfiles ()<br>
{<br>
&nbsp; if [ ! -d &quot;$1&quot; ] &nbsp;# Test if target directory exists.<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$1 is not a directory.&quot;<br>
&nbsp; &nbsp; return $E_BADDIR<br>
&nbsp; fi<br>
&nbsp; rm -f &quot;$1&quot;/*<br>
&nbsp; return 0 &nbsp; # Success.<br>
} &nbsp;<br>
cleanup_pfiles $projectdir<br>
exit $?<br>
Avoid using &quot;magic numbers,&quot;&nbsp;<br>
•&nbsp;<br>
[121] that is, &quot;hard-wired&quot; literal constants. Use meaningful variable<br>
names instead. This makes the script easier to understand and permits making changes and updates<br>without breaking the application.<br>
Chapter 35. Scripting With Style<br>
493<br>
<hr>
<A name=500></a>Advanced Bash-Scripting Guide<br>
if [ -f /var/log/messages ]<br>
then<br>
&nbsp; ...<br>
fi<br>
# &nbsp;A year later, you decide to change the script to check /var/log/syslog.<br>
# &nbsp;It is now necessary to manually change the script, instance by instance,<br>
#+ and hope nothing breaks.<br>
# A better way:<br>
LOGFILE=/var/log/messages &nbsp;# Only line that needs to be changed.<br>
if [ -f &quot;$LOGFILE&quot; ]<br>
then<br>
&nbsp; ...<br>
fi<br>
Choose descriptive names for variables and functions.<br>
•&nbsp;<br>
fl=`ls -al $dirname` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Cryptic.<br>
file_listing=`ls -al $dirname` &nbsp; &nbsp; &nbsp; # Better.<br>
MAXVAL=10 &nbsp; # All caps used for a script constant.<br>
while [ &quot;$index&quot; -le &quot;$MAXVAL&quot; ]<br>
...<br>
E_NOTFOUND=95 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Uppercase for an errorcode,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ and name prefixed with E_.<br>
if [ ! -e &quot;$filename&quot; ]<br>
then<br>
&nbsp; echo &quot;File $filename not found.&quot;<br>
&nbsp; exit $E_NOTFOUND<br>
fi &nbsp;<br>
MAIL_DIRECTORY=/var/spool/mail/bozo &nbsp;# &nbsp;Uppercase for an environmental<br>
export MAIL_DIRECTORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ variable.<br>
GetAnswer () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Mixed case works well for a<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ function name, especially<br>
&nbsp; prompt=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ when it improves legibility.<br>
&nbsp; echo -n $prompt<br>
&nbsp; read answer<br>
&nbsp; return $answer<br>
} &nbsp;<br>
GetAnswer &quot;What is your favorite number? &quot;<br>
favorite_number=$?<br>
echo $favorite_number<br>
_uservariable=23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Permissible, but not recommended.<br>
# It's better for user-defined variables not to start with an underscore.<br>
# Leave that for system variables.<br>
<a href="abs-guides.html#57">Use exit codes in a systematic and meaningful way.</a><br>
•&nbsp;<br>
E_WRONG_ARGS=95<br>
...<br>
...<br>
exit $E_WRONG_ARGS<br>
<a href="abs-guides.html#787">See also Appendix D.</a><br>
Chapter 35. Scripting With Style<br>
494<br>
<hr>
<A name=501></a>Advanced Bash-Scripting Guide<br>
<i>Ender</i><a href="abs-guides.html#787">&nbsp;suggests using the exit codes in&nbsp;/usr/include/sysexits.h&nbsp;in shell scripts, though these<br></a>are primarily intended for C and C++ programming.<br>Use standardized parameter flags for script invocation.<br>
•&nbsp;<br>
<i>&nbsp;Ender</i>&nbsp;proposes the following set of flags.<br>
-a &nbsp; &nbsp; &nbsp;All: Return all information (including hidden file info).<br>
-b &nbsp; &nbsp; &nbsp;Brief: Short version, usually for other scripts.<br>
-c &nbsp; &nbsp; &nbsp;Copy, concatenate, etc.<br>
-d &nbsp; &nbsp; &nbsp;Daily: Use information from the whole day, and not merely<br>
&nbsp; &nbsp; &nbsp; &nbsp; information for a specific instance/user.<br>
-e &nbsp; &nbsp; &nbsp;Extended/Elaborate: (often does not include hidden file info).<br>
-h &nbsp; &nbsp; &nbsp;Help: Verbose usage w/descs, aux info, discussion, help.<br>
&nbsp; &nbsp; &nbsp; &nbsp; See also -V.<br>
-l &nbsp; &nbsp; &nbsp;Log output of script.<br>
-m &nbsp; &nbsp; &nbsp;Manual: Launch man-page for base command.<br>
-n &nbsp; &nbsp; &nbsp;Numbers: Numerical data only.<br>
-r &nbsp; &nbsp; &nbsp;Recursive: All files in a directory (and/or all sub-dirs).<br>
-s &nbsp; &nbsp; &nbsp;Setup &amp; File Maintenance: Config files for this script.<br>
-u &nbsp; &nbsp; &nbsp;Usage: List of invocation flags for the script.<br>
-v &nbsp; &nbsp; &nbsp;Verbose: Human readable output, more or less formatted.<br>
-V &nbsp; &nbsp; &nbsp;Version / License / Copy(right|left) / Contribs (email too).<br>
<a href="abs-guides.html#790">See also Section F.1.<br></a><a href="abs-guides.html#543">Break complex scripts into simpler modules. Use functions where appropriate. See Example 37-4.</a><br>
•&nbsp;<br>
Don't use a complex construct where a simpler one will do.<br>
•&nbsp;<br>
COMMAND<br>
if [ $? -eq 0 ]<br>
...<br>
# Redundant and non-intuitive.<br>
if COMMAND<br>
...<br>
# More concise (if perhaps not quite as legible).<br>
<i>... reading the UNIX source code to the Bourne<br>shell (/bin/sh). I was shocked at how much simple<br>algorithms could be made cryptic, and therefore<br>useless, by a poor choice of code style. I asked<br>myself, &quot;Could someone be proud of this code?&quot;</i><br>
<i>--Landon Noll</i><br>
Chapter 35. Scripting With Style<br>
495<br>
<hr>
<A name=502></a><b>Chapter 36. Miscellany</b><br>
<i>Nobody really knows what the Bourne shell's<br>grammar is. Even examination of the source code<br>is little help.</i><br>
<i>--Tom Duff</i><br>
<b>36.1. Interactive and non-interactive shells and scripts</b><br>
An<i>&nbsp;interactive</i>&nbsp;shell reads commands from user input on a&nbsp;tty. Among other things, such a shell reads startup<br>files on activation, displays a prompt, and enables job control by default. The user can<i>&nbsp;interact</i>&nbsp;with the shell.<br>
A shell running a script is always a non-interactive shell. All the same, the script can still access its&nbsp;tty. It is<br>even possible to emulate an interactive shell in a script.<br>
#!/bin/bash<br>
MY_PROMPT='$ '<br>
while :<br>
do<br>
&nbsp; echo -n &quot;$MY_PROMPT&quot;<br>
&nbsp; read line<br>
&nbsp; eval &quot;$line&quot;<br>
&nbsp; done<br>
exit 0<br>
# This example script, and much of the above explanation supplied by<br>
# Stéphane Chazelas (thanks again).<br>
Let us consider an<i>&nbsp;interactive</i><a href="abs-guides.html#190">&nbsp;script to be one that requires input from the user, usually with read statements<br>(see Example 15-3). &quot;Real life&quot; is actually a bit messier than that. For now, assume an interactive script is<br></a>bound to a tty, a script that a user has invoked from the console or an<i>&nbsp;xterm</i>.<br>
Init and startup scripts are necessarily non-interactive, since they must run without human intervention. Many<br>administrative and system maintenance scripts are likewise non-interactive. Unvarying repetitive tasks cry out<br>for automation by non-interactive scripts.<br>
Non-interactive scripts can run in the background, but interactive ones hang, waiting for input that never<br>comes. Handle that difficulty by having an<b>&nbsp;expect</b><a href="abs-guides.html#360">&nbsp;script or embedded here document feed input to an<br></a>interactive script running as a background job. In the simplest case, redirect a file to supply input to a<b>&nbsp;read<br></b>statement (<b>read variable &lt;file</b>). These particular workarounds make possible general purpose scripts that run<br>in either interactive or non-interactive modes.<br>
If a script needs to test whether it is running in an interactive shell, it is simply a matter of finding whether the<br><i>prompt</i><a href="abs-guides.html#98">&nbsp;variable, $PS1 is set. (If the user is being prompted for input, then the script needs to display a<br></a>prompt.)<br>
if [ -z $PS1 ] # no prompt?<br>
### if [ -v PS1 ] &nbsp; # On Bash 4.2+ ...<br>
then<br>
&nbsp; # non-interactive<br>
&nbsp; ...<br>
Chapter 36. Miscellany<br>
496<br>
<hr>
<A name=503></a><IMG src="abs-guide-503_1.png"><br>
Advanced Bash-Scripting Guide<br>
else<br>
&nbsp; # interactive<br>
&nbsp; ...<br>
fi<br>
<a href="abs-guides.html#108">Alternatively, the script can test for the presence of option &quot;i&quot; in the $- flag.</a><br>
case $- in<br>
*i*) &nbsp; &nbsp;# interactive shell<br>
;;<br>
*) &nbsp; &nbsp; &nbsp;# non-interactive shell<br>
;;<br>
# (Courtesy of &quot;UNIX F.A.Q.,&quot; 1993)<br>
<a href="abs-guides.html#69">However, John Lange describes an alternative method, using the -t<i>&nbsp;test</i>&nbsp;operator.</a><br>
# Test for a terminal!<br>
fd=0 &nbsp; # stdin<br>
# &nbsp;As we recall, the -t test option checks whether the stdin, [ -t 0 ],<br>
#+ or stdout, [ -t 1 ], in a given script is running in a terminal.<br>
if [ -t &quot;$fd&quot; ]<br>
then<br>
&nbsp; echo interactive<br>
else<br>
&nbsp; echo non-interactive<br>
fi<br>
# &nbsp;But, as John points out:<br>
# &nbsp; &nbsp;if [ -t 0 ] works ... when you're logged in locally<br>
# &nbsp; &nbsp;but fails when you invoke the command remotely via ssh.<br>
# &nbsp; &nbsp;So for a true test you also have to test for a socket.<br>
if [[ -t &quot;$fd&quot; || -p /dev/stdin ]]<br>
then<br>
&nbsp; echo interactive<br>
else<br>
&nbsp; echo non-interactive<br>
fi<br>
Scripts may be forced to run in interactive mode with the -i option or with a&nbsp;<b>#!/bin/bash -i</b>&nbsp;header.<br>Be aware that this can cause erratic script behavior or show error messages even when no error is<br>present.<br>
<b>36.2. Shell Wrappers</b><br>
A<i>&nbsp;wrapper</i>&nbsp;is a shell script that embeds a system command or utility, that accepts and passes a set of<br>parameters to that command.&nbsp;[122] Wrapping a script around a complex command-line simplifies invoking it.<br><a href="abs-guides.html#781">This is expecially useful with sed and awk.</a><br>
A<b>&nbsp;sed</b>&nbsp;or<b>&nbsp;awk</b>&nbsp;script would normally be invoked from the command-line by a&nbsp;<b>sed -e&nbsp;<i>'commands'</i></b>&nbsp;or<br><b>awk&nbsp;<i>'commands'</i></b>. Embedding such a script in a Bash script permits calling it more simply, and makes it<br><i>reusable</i>. This also enables combining the functionality of<i>&nbsp;sed</i>&nbsp;and<i>&nbsp;awk</i><a href="abs-guides.html#24">, for example piping the output of a set<br></a>of<i>&nbsp;sed</i>&nbsp;commands to<i>&nbsp;awk</i>. As a saved executable file, you can then repeatedly invoke it in its original form or<br>modified, without the inconvenience of retyping it on the command-line.<br>
Chapter 36. Miscellany<br>
497<br>
<hr>
<A name=504></a>Advanced Bash-Scripting Guide<br>
<b>Example 36-1.<i>&nbsp;shell wrapper</i></b><br>
#!/bin/bash<br>
# This simple script removes blank lines from a file.<br>
# No argument checking.<br>
#<br>
# You might wish to add something like:<br>
#<br>
# E_NOARGS=85<br>
# if [ -z &quot;$1&quot; ]<br>
# then<br>
# &nbsp;echo &quot;Usage: `basename $0` target-file&quot;<br>
# &nbsp;exit $E_NOARGS<br>
# fi<br>
sed -e /^$/d &quot;$1&quot;<br>
# Same as<br>
# &nbsp; &nbsp;sed -e '/^$/d' filename<br>
# invoked from the command-line.<br>
# &nbsp;The '-e' means an &quot;editing&quot; command follows (optional here).<br>
# &nbsp;'^' indicates the beginning of line, '$' the end.<br>
# &nbsp;This matches lines with nothing between the beginning and the end --<br>
#+ blank lines.<br>
# &nbsp;The 'd' is the delete command.<br>
# &nbsp;Quoting the command-line arg permits<br>
#+ whitespace and special characters in the filename.<br>
# &nbsp;Note that this script doesn't actually change the target file.<br>
# &nbsp;If you need to do that, redirect its output.<br>
exit<br>
<b>Example 36-2. A slightly more complex<i>&nbsp;shell wrapper</i></b><br>
#!/bin/bash<br>
# &nbsp;subst.sh: a script that substitutes one pattern for<br>
#+ another in a file,<br>
#+ i.e., &quot;sh subst.sh Smith Jones letter.txt&quot;.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Jones replaces Smith.<br>
ARGS=3 &nbsp; &nbsp; &nbsp; &nbsp; # Script requires 3 arguments.<br>
E_BADARGS=85 &nbsp; # Wrong number of arguments passed to script.<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` old-pattern new-pattern filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
old_pattern=$1<br>
new_pattern=$2<br>
if [ -f &quot;$3&quot; ]<br>
then<br>
&nbsp; &nbsp; file_name=$3<br>
Chapter 36. Miscellany<br>
498<br>
<hr>
<A name=505></a>Advanced Bash-Scripting Guide<br>
else<br>
&nbsp; &nbsp; echo &quot;File \&quot;$3\&quot; does not exist.&quot;<br>
&nbsp; &nbsp; exit $E_BADARGS<br>
fi<br>
# -----------------------------------------------<br>
# &nbsp;Here is where the heavy work gets done.<br>
sed -e &quot;s/$old_pattern/$new_pattern/g&quot; $file_name<br>
# -----------------------------------------------<br>
# &nbsp;'s' is, of course, the substitute command in sed,<br>
#+ and /pattern/ invokes address matching.<br>
# &nbsp;The 'g,' or global flag causes substitution for EVERY<br>
#+ occurence of $old_pattern on each line, not just the first.<br>
# &nbsp;Read the 'sed' docs for an in-depth explanation.<br>
exit $? &nbsp;# Redirect the output of this script to write to a file.<br>
<b>Example 36-3. A generic<i>&nbsp;shell wrapper</i></b><b>&nbsp;that writes to a logfile</b><br>
#!/bin/bash<br>
# &nbsp;Generic shell wrapper that performs an operation<br>
#+ and logs it.<br>
# Must set the following two variables.<br>
OPERATION=<br>
# &nbsp; &nbsp; &nbsp; &nbsp; Can be a complex chain of commands,<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp;for example an awk script or a pipe . . .<br>
LOGFILE=<br>
# &nbsp; &nbsp; &nbsp; &nbsp; Command-line arguments, if any, for the operation.<br>
OPTIONS=&quot;$@&quot;<br>
# Log it.<br>
echo &quot;`date` + `whoami` + $OPERATION &quot;$@&quot;&quot; &gt;&gt; $LOGFILE<br>
# Now, do it.<br>
exec $OPERATION &quot;$@&quot;<br>
# It's necessary to do the logging before the operation.<br>
# Why?<br>
<b>Example 36-4. A<i>&nbsp;shell wrapper</i></b><b>&nbsp;around an awk script</b><br>
#!/bin/bash<br>
# pr-ascii.sh: Prints a table of ASCII characters.<br>
START=33 &nbsp; # Range of printable ASCII characters (decimal).<br>
END=127 &nbsp; &nbsp;# Will not work for unprintable characters (&gt; 127).<br>
echo &quot; Decimal &nbsp; Hex &nbsp; &nbsp; Character&quot; &nbsp; # Header.<br>
echo &quot; ------- &nbsp; --- &nbsp; &nbsp; ---------&quot;<br>
for ((i=START; i&lt;=END; i++))<br>
do<br>
&nbsp; echo $i | awk '{printf(&quot; &nbsp;%3d &nbsp; &nbsp; &nbsp; %2x &nbsp; &nbsp; &nbsp; &nbsp; %c\n&quot;, $1, $1, $1)}'<br>
# The Bash printf builtin will not work in this context:<br>
# &nbsp; &nbsp; printf &quot;%c&quot; &quot;$i&quot;<br>
Chapter 36. Miscellany<br>
499<br>
<hr>
<A name=506></a>Advanced Bash-Scripting Guide<br>
done<br>
exit 0<br>
# &nbsp;Decimal &nbsp; Hex &nbsp; &nbsp; Character<br>
# &nbsp;------- &nbsp; --- &nbsp; &nbsp; ---------<br>
# &nbsp; &nbsp;33 &nbsp; &nbsp; &nbsp; 21 &nbsp; &nbsp; &nbsp; &nbsp; !<br>
# &nbsp; &nbsp;34 &nbsp; &nbsp; &nbsp; 22 &nbsp; &nbsp; &nbsp; &nbsp; &quot;<br>
# &nbsp; &nbsp;35 &nbsp; &nbsp; &nbsp; 23 &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp;36 &nbsp; &nbsp; &nbsp; 24 &nbsp; &nbsp; &nbsp; &nbsp; $<br>
#<br>
# &nbsp; &nbsp;. . .<br>
#<br>
# &nbsp; 122 &nbsp; &nbsp; &nbsp; 7a &nbsp; &nbsp; &nbsp; &nbsp; z<br>
# &nbsp; 123 &nbsp; &nbsp; &nbsp; 7b &nbsp; &nbsp; &nbsp; &nbsp; {<br>
# &nbsp; 124 &nbsp; &nbsp; &nbsp; 7c &nbsp; &nbsp; &nbsp; &nbsp; |<br>
# &nbsp; 125 &nbsp; &nbsp; &nbsp; 7d &nbsp; &nbsp; &nbsp; &nbsp; }<br>
# &nbsp;Redirect the output of this script to a file<br>
#+ or pipe it to &quot;more&quot;: &nbsp;sh pr-asc.sh | more<br>
<b>Example 36-5. A<i>&nbsp;shell wrapper</i></b><b>&nbsp;around another awk script</b><br>
#!/bin/bash<br>
# Adds up a specified column (of numbers) in the target file.<br>
# Floating-point (decimal) numbers okay, because awk can handle them.<br>
ARGS=2<br>
E_WRONGARGS=85<br>
if [ $# -ne &quot;$ARGS&quot; ] # Check for proper number of command-line args.<br>
then<br>
&nbsp; &nbsp;echo &quot;Usage: `basename $0` filename column-number&quot;<br>
&nbsp; &nbsp;exit $E_WRONGARGS<br>
fi<br>
filename=$1<br>
column_number=$2<br>
# &nbsp;Passing shell variables to the awk part of the script is a bit tricky.<br>
# &nbsp;One method is to strong-quote the Bash-script variable<br>
#+ within the awk script.<br>
# &nbsp; &nbsp; $'$BASH_SCRIPT_VAR'<br>
# &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
# &nbsp;This is done in the embedded awk script below.<br>
# &nbsp;See the awk documentation for more details.<br>
# A multi-line awk script is here invoked by<br>
# &nbsp; awk '<br>
# &nbsp; ...<br>
# &nbsp; ...<br>
# &nbsp; ...<br>
# &nbsp; '<br>
# Begin awk script.<br>
# -----------------------------<br>
awk '<br>
Chapter 36. Miscellany<br>
500<br>
<hr>
<A name=507></a>Advanced Bash-Scripting Guide<br>
{ total += $'&quot;${column_number}&quot;'<br>
}<br>
END {<br>
&nbsp; &nbsp; &nbsp;print total<br>
} &nbsp; &nbsp;&nbsp;<br>
' &quot;$filename&quot;<br>
# -----------------------------<br>
# End awk script.<br>
# &nbsp; It may not be safe to pass shell variables to an embedded awk script,<br>
#+ &nbsp;so Stephane Chazelas proposes the following alternative:<br>
# &nbsp; ---------------------------------------<br>
# &nbsp; awk -v column_number=&quot;$column_number&quot; '<br>
# &nbsp; { total += $column_number<br>
# &nbsp; }<br>
# &nbsp; END {<br>
# &nbsp; &nbsp; &nbsp; print total<br>
# &nbsp; }' &quot;$filename&quot;<br>
# &nbsp; ---------------------------------------<br>
exit 0<br>
For those scripts needing a single do-it-all tool, a Swiss army knife, there is<i>&nbsp;Perl</i>. Perl combines the<br><a href="abs-guides.html#781">capabilities of sed and awk, and throws in a large subset of</a><b>&nbsp;C</b>, to boot. It is modular and contains support for<br>everything ranging from object-oriented programming up to and including the kitchen sink. Short Perl scripts<br>lend themselves to embedding within shell scripts, and there may be some substance to the claim that Perl can<br>totally replace shell scripting (though the author of the<i>&nbsp;ABS Guide</i>&nbsp;remains skeptical).<br>
<b>Example 36-6. Perl embedded in a<i>&nbsp;Bash</i></b><b>&nbsp;script</b><br>
#!/bin/bash<br>
# Shell commands may precede the Perl script.<br>
echo &quot;This precedes the embedded Perl script within \&quot;$0\&quot;.&quot;<br>
echo &quot;===============================================================&quot;<br>
perl -e 'print &quot;This is an embedded Perl script.\n&quot;;'<br>
# Like sed, Perl also uses the &quot;-e&quot; option.<br>
echo &quot;===============================================================&quot;<br>
echo &quot;However, the script may also contain shell and system commands.&quot;<br>
exit<br>
It is even possible to combine a Bash script and Perl script within the same file. Depending on how the script<br>is invoked, either the Bash part or the Perl part will execute.<br>
<b>Example 36-7. Bash and Perl scripts combined</b><br>
#!/bin/bash<br>
# bashandperl.sh<br>
Chapter 36. Miscellany<br>
501<br>
<hr>
<A name=508></a>Advanced Bash-Scripting Guide<br>
echo &quot;Greetings from the Bash part of the script, $0.&quot;<br>
# More Bash commands may follow here.<br>
exit<br>
# End of Bash part of the script.<br>
# =======================================================<br>
#!/usr/bin/perl<br>
# This part of the script must be invoked with<br>
# &nbsp; &nbsp;perl -x bashandperl.sh<br>
print &quot;Greetings from the Perl part of the script, $0.\n&quot;;<br>
# &nbsp; &nbsp; &nbsp;Perl doesn't seem to like &quot;echo&quot; ...<br>
# More Perl commands may follow here.<br>
# End of Perl part of the script.<br>
bash$&nbsp;<b>bash bashandperl.sh<br></b>Greetings from the Bash part of the script.<br>
bash$&nbsp;<b>perl -x bashandperl.sh<br></b>Greetings from the Perl part of the script.<br>
One interesting example of a complex shell wrapper is Martin Matusiak's&nbsp;<a href="http://www.matusiak.eu/numerodix/blog/index.php/"><i>undvd</i>&nbsp;script, which provides an<br></a><a href="http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html">easy-to-use command-line interface to the complex mencoder utility. Another example is Itzchak Rehberg's<br></a><a href="http://projects.izzysoft.de/trac/ext3undel">Ext3Undel, a set of scripts to recover deleted file on an</a><i>&nbsp;ext3</i>&nbsp;filesystem.<br>
<b>36.3. Tests and Comparisons: Alternatives</b><br>
<a href="abs-guides.html#65">For tests, the [[ ]] construct may be more appropriate than&nbsp;</a><b>[ ]</b><a href="abs-guides.html#71">. Likewise, arithmetic comparisons might<br></a><a href="abs-guides.html#86">benefit from the (( )) construct.</a><br>
a=8<br>
# All of the comparisons below are equivalent.<br>
test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;yes, $a &lt; 16&quot; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;and list&quot;<br>
/bin/test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;yes, $a &lt; 16&quot;&nbsp;<br>
[ &quot;$a&quot; -lt 16 ] &amp;&amp; echo &quot;yes, $a &lt; 16&quot;&nbsp;<br>
[[ $a -lt 16 ]] &amp;&amp; echo &quot;yes, $a &lt; 16&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Quoting variables within<br>
(( a &lt; 16 )) &amp;&amp; echo &quot;yes, $a &lt; 16&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # [[ ]] and (( )) not necessary.<br>
city=&quot;New York&quot;<br>
# Again, all of the comparisons below are equivalent.<br>
test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Greater ASCII order.<br>
/bin/test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;&nbsp;<br>
[ &quot;$city&quot; \&lt; Paris ] &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;&nbsp;<br>
[[ $city &lt; Paris ]] &amp;&amp; echo &quot;Yes, Paris is greater than $city&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Need not quote $city.<br>
# Thank you, S.C.<br>
Chapter 36. Miscellany<br>
502<br>
<hr>
<A name=509></a>Advanced Bash-Scripting Guide<br>
<b>36.4. Recursion: a script calling itself</b><br>
<a href="abs-guides.html#415">Can a script recursively call itself? Indeed.</a><br>
<b>Example 36-8. A (useless) script that recursively calls itself</b><br>
#!/bin/bash<br>
# recurse.sh<br>
# &nbsp;Can a script recursively call itself?<br>
# &nbsp;Yes, but is this of any practical use?<br>
# &nbsp;(See the following.)<br>
RANGE=10<br>
MAXVAL=9<br>
i=$RANDOM<br>
let &quot;i %= $RANGE&quot; &nbsp;# Generate a random number between 0 and $RANGE - 1.<br>
if [ &quot;$i&quot; -lt &quot;$MAXVAL&quot; ]<br>
then<br>
&nbsp; echo &quot;i = $i&quot;<br>
&nbsp; ./$0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Script recursively spawns a new instance of itself.<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Each child script does the same, until<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ a generated $i equals $MAXVAL.<br>
# &nbsp;Using a &quot;while&quot; loop instead of an &quot;if/then&quot; test causes problems.<br>
# &nbsp;Explain why.<br>
exit 0<br>
# Note:<br>
# ----<br>
# This script must have execute permission for it to work properly.<br>
# This is the case even if it is invoked by an &quot;sh&quot; command.<br>
# Explain why.<br>
<b>Example 36-9. A (useful) script that recursively calls itself</b><br>
#!/bin/bash<br>
# pb.sh: phone book<br>
# Written by Rick Boivie, and used with permission.<br>
# Modifications by ABS Guide author.<br>
MINARGS=1 &nbsp; &nbsp; # &nbsp;Script needs at least one argument.<br>
DATAFILE=./phonebook<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;A data file in current working directory<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ named &quot;phonebook&quot; must exist.<br>
PROGNAME=$0<br>
E_NOARGS=70 &nbsp; # &nbsp;No arguments error.<br>
if [ $# -lt $MINARGS ]; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;Usage: &quot;$PROGNAME&quot; data-to-look-up&quot;<br>
&nbsp; &nbsp; &nbsp; exit $E_NOARGS<br>
fi &nbsp; &nbsp; &nbsp;<br>
Chapter 36. Miscellany<br>
503<br>
<hr>
<A name=510></a>Advanced Bash-Scripting Guide<br>
if [ $# -eq $MINARGS ]; then<br>
&nbsp; &nbsp; &nbsp; grep $1 &quot;$DATAFILE&quot;<br>
&nbsp; &nbsp; &nbsp; # 'grep' prints an error message if $DATAFILE not present.<br>
else<br>
&nbsp; &nbsp; &nbsp; ( shift; &quot;$PROGNAME&quot; $* ) | grep $1<br>
&nbsp; &nbsp; &nbsp; # Script recursively calls itself.<br>
fi<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Script exits here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Therefore, it's o.k. to put<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ non-hashmarked comments and data after this point.<br>
# ------------------------------------------------------------------------<br>
Sample &quot;phonebook&quot; datafile:<br>
John Doe &nbsp; &nbsp; &nbsp; &nbsp;1555 Main St., Baltimore, MD 21228 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(410) 222-3333<br>
Mary Moe &nbsp; &nbsp; &nbsp; &nbsp;9899 Jones Blvd., Warren, NH 03787 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(603) 898-3232<br>
Richard Roe &nbsp; &nbsp; 856 E. 7th St., New York, NY 10009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(212) 333-4567<br>
Sam Roe &nbsp; &nbsp; &nbsp; &nbsp; 956 E. 8th St., New York, NY 10009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(212) 444-5678<br>
Zoe Zenobia &nbsp; &nbsp; 4481 N. Baker St., San Francisco, SF 94338 &nbsp;(415) 501-1631<br>
# ------------------------------------------------------------------------<br>
$bash pb.sh Roe<br>
Richard Roe &nbsp; &nbsp; 856 E. 7th St., New York, NY 10009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(212) 333-4567<br>
Sam Roe &nbsp; &nbsp; &nbsp; &nbsp; 956 E. 8th St., New York, NY 10009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(212) 444-5678<br>
$bash pb.sh Roe Sam<br>
Sam Roe &nbsp; &nbsp; &nbsp; &nbsp; 956 E. 8th St., New York, NY 10009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(212) 444-5678<br>
# &nbsp;When more than one argument is passed to this script,<br>
#+ it prints *only* the line(s) containing all the arguments.<br>
<b>Example 36-10. Another (useful) script that recursively calls itself</b><br>
#!/bin/bash<br>
# usrmnt.sh, written by Anthony Richardson<br>
# Used with permission.<br>
# usage: &nbsp; &nbsp; &nbsp; usrmnt.sh<br>
# description: mount device, invoking user must be listed in the<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MNTUSERS group in the /etc/sudoers file.<br>
# ----------------------------------------------------------<br>
# &nbsp;This is a usermount script that reruns itself using sudo.<br>
# &nbsp;A user with the proper permissions only has to type<br>
# &nbsp; usermount /dev/fd0 /mnt/floppy<br>
# instead of<br>
# &nbsp; sudo usermount /dev/fd0 /mnt/floppy<br>
# &nbsp;I use this same technique for all of my<br>
#+ sudo scripts, because I find it convenient.<br>
# ----------------------------------------------------------<br>
# &nbsp;If SUDO_COMMAND variable is not set we are not being run through<br>
#+ sudo, so rerun ourselves. Pass the user's real and group id . . .<br>
if [ -z &quot;$SUDO_COMMAND&quot; ]<br>
Chapter 36. Miscellany<br>
504<br>
<hr>
<A name=511></a><IMG src="abs-guide-511_1.png"><br>
Advanced Bash-Scripting Guide<br>
then<br>
&nbsp; &nbsp;mntusr=$(id -u) grpusr=$(id -g) sudo $0 $*<br>
&nbsp; &nbsp;exit 0<br>
fi<br>
# We will only get here if we are being run by sudo.<br>
/bin/mount $* -o uid=$mntusr,gid=$grpusr<br>
exit 0<br>
# Additional notes (from the author of this script):&nbsp;<br>
# -------------------------------------------------<br>
# 1) Linux allows the &quot;users&quot; option in the /etc/fstab<br>
# &nbsp; &nbsp;file so that any user can mount removable media.<br>
# &nbsp; &nbsp;But, on a server, I like to allow only a few<br>
# &nbsp; &nbsp;individuals access to removable media.<br>
# &nbsp; &nbsp;I find using sudo gives me more control.<br>
# 2) I also find sudo to be more convenient than<br>
# &nbsp; &nbsp;accomplishing this task through groups.<br>
# 3) This method gives anyone with proper permissions<br>
# &nbsp; &nbsp;root access to the mount command, so be careful<br>
# &nbsp; &nbsp;about who you allow access.<br>
# &nbsp; &nbsp;You can get finer control over which access can be mounted<br>
# &nbsp; &nbsp;by using this same technique in separate mntfloppy, mntcdrom,<br>
# &nbsp; &nbsp;and mntsamba scripts.<br>
Too many levels of recursion can exhaust the script's stack space, causing a segfault.<br>
<b>36.5. &quot;Colorizing&quot; Scripts</b><br>
The ANSI&nbsp;[123] escape sequences set screen attributes, such as bold text, and color of foreground and<br><a href="abs-guides.html#819">background. DOS batch files commonly used ANSI escape codes for</a><i>&nbsp;color</i>&nbsp;output, and so can Bash scripts.<br>
<b>Example 36-11. A &quot;colorized&quot; address database</b><br>
#!/bin/bash<br>
# ex30a.sh: &quot;Colorized&quot; version of ex30.sh.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Crude address database<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Clear the screen.<br>
echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;<br>
echo -e '\E[37;44m'&quot;\033[1mContact List\033[0m&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # White on blue background<br>
echo; echo<br>
echo -e &quot;\033[1mChoose one of the following persons:\033[0m&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bold<br>
tput sgr0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reset attributes.<br>
echo &quot;(Enter only the first letter of name.)&quot;<br>
echo<br>
echo -en '\E[47;34m'&quot;\033[1mE\033[0m&quot; &nbsp; # Blue<br>
tput sgr0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reset colors to &quot;normal.&quot;<br>
Chapter 36. Miscellany<br>
505<br>
<hr>
<A name=512></a>Advanced Bash-Scripting Guide<br>
echo &quot;vans, Roland&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;[E]vans, Roland&quot;<br>
echo -en '\E[47;35m'&quot;\033[1mJ\033[0m&quot; &nbsp; # Magenta<br>
tput sgr0<br>
echo &quot;ones, Mildred&quot;<br>
echo -en '\E[47;32m'&quot;\033[1mS\033[0m&quot; &nbsp; # Green<br>
tput sgr0<br>
echo &quot;mith, Julie&quot;<br>
echo -en '\E[47;31m'&quot;\033[1mZ\033[0m&quot; &nbsp; # Red<br>
tput sgr0<br>
echo &quot;ane, Morris&quot;<br>
echo<br>
read person<br>
case &quot;$person&quot; in<br>
# Note variable is quoted.<br>
&nbsp; &quot;E&quot; | &quot;e&quot; )<br>
&nbsp; # Accept upper or lowercase input.<br>
&nbsp; echo<br>
&nbsp; echo &quot;Roland Evans&quot;<br>
&nbsp; echo &quot;4321 Flash Dr.&quot;<br>
&nbsp; echo &quot;Hardscrabble, CO 80753&quot;<br>
&nbsp; echo &quot;(303) 734-9874&quot;<br>
&nbsp; echo &quot;(303) 734-9892 fax&quot;<br>
&nbsp; echo &quot;revans@zzy.net&quot;<br>
&nbsp; echo &quot;Business partner &amp; old friend&quot;<br>
&nbsp; ;;<br>
&nbsp; &quot;J&quot; | &quot;j&quot; )<br>
&nbsp; echo<br>
&nbsp; echo &quot;Mildred Jones&quot;<br>
&nbsp; echo &quot;249 E. 7th St., Apt. 19&quot;<br>
&nbsp; echo &quot;New York, NY 10009&quot;<br>
&nbsp; echo &quot;(212) 533-2814&quot;<br>
&nbsp; echo &quot;(212) 533-9972 fax&quot;<br>
&nbsp; echo &quot;milliej@loisaida.com&quot;<br>
&nbsp; echo &quot;Girlfriend&quot;<br>
&nbsp; echo &quot;Birthday: Feb. 11&quot;<br>
&nbsp; ;;<br>
# Add info for Smith &amp; Zane later.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * )<br>
&nbsp; &nbsp;# Default option. &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp;# Empty input (hitting RETURN) fits here, too.<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;echo &quot;Not yet in database.&quot;<br>
&nbsp; ;;<br>
esac<br>
tput sgr0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Reset colors to &quot;normal.&quot;<br>
echo<br>
exit 0<br>
<b>Example 36-12. Drawing a box</b><br>
#!/bin/bash<br>
Chapter 36. Miscellany<br>
506<br>
<hr>
<A name=513></a>Advanced Bash-Scripting Guide<br>
# Draw-box.sh: Drawing a box using ASCII characters.<br>
# Script by Stefano Palmeri, with minor editing by document author.<br>
# Minor edits suggested by Jim Angstadt.<br>
# Used in the ABS Guide with permission.<br>
######################################################################<br>
### &nbsp;draw_box function doc &nbsp;###<br>
# &nbsp;The &quot;draw_box&quot; function lets the user<br>
#+ draw a box in a terminal. &nbsp; &nbsp; &nbsp;&nbsp;<br>
#<br>
# &nbsp;Usage: draw_box ROW COLUMN HEIGHT WIDTH [COLOR]&nbsp;<br>
# &nbsp;ROW and COLUMN represent the position &nbsp; &nbsp; &nbsp; &nbsp;<br>
#+ of the upper left angle of the box you're going to draw.<br>
# &nbsp;ROW and COLUMN must be greater than 0<br>
#+ and less than current terminal dimension.<br>
# &nbsp;HEIGHT is the number of rows of the box, and must be &gt; 0.&nbsp;<br>
# &nbsp;HEIGHT + ROW must be &lt;= than current terminal height.&nbsp;<br>
# &nbsp;WIDTH is the number of columns of the box and must be &gt; 0.<br>
# &nbsp;WIDTH + COLUMN must be &lt;= than current terminal width.<br>
#<br>
# E.g.: If your terminal dimension is 20x80,<br>
# &nbsp;draw_box 2 3 10 45 is good<br>
# &nbsp;draw_box 2 3 19 45 has bad HEIGHT value (19+2 &gt; 20)<br>
# &nbsp;draw_box 2 3 18 78 has bad WIDTH value (78+3 &gt; 80)<br>
#<br>
# &nbsp;COLOR is the color of the box frame.<br>
# &nbsp;This is the 5th argument and is optional.<br>
# &nbsp;0=black 1=red 2=green 3=tan 4=blue 5=purple 6=cyan 7=white.<br>
# &nbsp;If you pass the function bad arguments,<br>
#+ it will just exit with code 65,<br>
#+ and no messages will be printed on stderr.<br>
#<br>
# &nbsp;Clear the terminal before you start to draw a box.<br>
# &nbsp;The clear command is not contained within the function.<br>
# &nbsp;This allows the user to draw multiple boxes, even overlapping ones.<br>
### &nbsp;end of draw_box function doc &nbsp;###&nbsp;<br>
######################################################################<br>
draw_box(){<br>
#=============#<br>
HORZ=&quot;-&quot;<br>
VERT=&quot;|&quot;<br>
CORNER_CHAR=&quot;+&quot;<br>
MINARGS=4<br>
E_BADARGS=65<br>
#=============#<br>
if [ $# -lt &quot;$MINARGS&quot; ]; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If args are less than 4, exit.<br>
&nbsp; &nbsp; exit $E_BADARGS<br>
fi<br>
# Looking for non digit chars in arguments.<br>
# Probably it could be done better (exercise for the reader?).<br>
if echo $@ | tr -d [:blank:] | tr -d [:digit:] | grep . &amp;&gt; /dev/null; then<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
Chapter 36. Miscellany<br>
507<br>
<hr>
<A name=514></a>Advanced Bash-Scripting Guide<br>
fi<br>
BOX_HEIGHT=`expr $3 - 1` &nbsp; # &nbsp;-1 correction needed because angle char &quot;+&quot;<br>
BOX_WIDTH=`expr $4 - 1` &nbsp; &nbsp;#+ is a part of both box height and width.<br>
T_ROWS=`tput lines` &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Define current terminal dimension&nbsp;<br>
T_COLS=`tput cols` &nbsp; &nbsp; &nbsp; &nbsp; #+ in rows and columns.<br>
if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then &nbsp; &nbsp;# &nbsp;Start checking if arguments<br>
&nbsp; &nbsp;exit $E_BADARGS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ are correct.<br>
fi<br>
if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi<br>
if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi<br>
if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi<br>
if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then<br>
&nbsp; &nbsp;exit $E_BADARGS<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # End checking arguments.<br>
plot_char(){ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Function within a function.<br>
&nbsp; &nbsp;echo -e &quot;\E[${1};${2}H&quot;$3<br>
}<br>
echo -ne &quot;\E[3${5}m&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set box frame color, if defined.<br>
# start drawing the box<br>
count=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Draw vertical lines using<br>
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do &nbsp; &nbsp; &nbsp;#+ plot_char function.<br>
&nbsp; plot_char $r $2 $VERT<br>
&nbsp; let count=count+1<br>
done&nbsp;<br>
count=1<br>
c=`expr $2 + $BOX_WIDTH`<br>
for (( r=$1; count&lt;=$BOX_HEIGHT; r++)); do<br>
&nbsp; plot_char $r $c $VERT<br>
&nbsp; let count=count+1<br>
done&nbsp;<br>
count=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Draw horizontal lines using<br>
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do &nbsp; &nbsp; &nbsp;#+ plot_char function.<br>
&nbsp; plot_char $1 $c $HORZ<br>
&nbsp; let count=count+1<br>
done&nbsp;<br>
count=1<br>
r=`expr $1 + $BOX_HEIGHT`<br>
for (( c=$2; count&lt;=$BOX_WIDTH; c++)); do<br>
&nbsp; plot_char $r $c $HORZ<br>
&nbsp; let count=count+1<br>
done&nbsp;<br>
plot_char $1 $2 $CORNER_CHAR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Draw box angles.<br>
plot_char $1 `expr $2 + $BOX_WIDTH` $CORNER_CHAR<br>
plot_char `expr $1 + $BOX_HEIGHT` $2 $CORNER_CHAR<br>
plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` $CORNER_CHAR<br>
Chapter 36. Miscellany<br>
508<br>
<hr>
<A name=515></a><IMG src="abs-guide-515_1.png"><br>
<IMG src="abs-guide-515_2.png"><br>
<IMG src="abs-guide-515_3.png"><br>
Advanced Bash-Scripting Guide<br>
echo -ne &quot;\E[0m&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Restore old colors.<br>
P_ROWS=`expr $T_ROWS - 1` &nbsp; &nbsp;# &nbsp;Put the prompt at bottom of the terminal.<br>
echo -e &quot;\E[${P_ROWS};1H&quot;<br>
} &nbsp; &nbsp; &nbsp;<br>
# Now, let's try drawing a box.<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Clear the terminal.<br>
R=2 &nbsp; &nbsp; &nbsp;# Row<br>
C=3 &nbsp; &nbsp; &nbsp;# Column<br>
H=10 &nbsp; &nbsp; # Height<br>
W=45 &nbsp; &nbsp; # Width&nbsp;<br>
col=1 &nbsp; &nbsp;# Color (red)<br>
draw_box $R $C $H $W $col &nbsp; # Draw the box.<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# Add the option of printing text within the drawn box.<br>
The simplest, and perhaps most useful ANSI escape sequence is bold text,<b>&nbsp;\033[1m ... \033[0m</b>. The \033<br><a href="abs-guides.html#49">represents an escape, the &quot;[1&quot; turns on the bold attribute, while the &quot;[0&quot; switches it off. The &quot;m&quot; terminates<br></a>each term of the escape sequence.<br>
bash$&nbsp;<b>echo -e &quot;\033[1mThis is bold text.\033[0m&quot;</b><br>
A similar escape sequence switches on the underline attribute (on an<i>&nbsp;rxvt</i>&nbsp;and an<i>&nbsp;aterm</i>).<br>
bash$&nbsp;<b>echo -e &quot;\033[4mThis is underlined text.\033[0m&quot;</b><br>
With an<b>&nbsp;echo</b>, the&nbsp;-e&nbsp;option enables the escape sequences.<br>
Other escape sequences change the text and/or background color.<br>
bash$&nbsp;<b>echo -e '\E[34;47mThis prints in blue.'; tput sgr0</b><br>
bash$&nbsp;<b>echo -e '\E[33;44m'&quot;yellow text on blue background&quot;; tput sgr0</b><br>
bash$&nbsp;<b>echo -e '\E[1;33;44m'&quot;BOLD yellow text on blue background&quot;; tput sgr0</b><br>
It's usually advisable to set the<i>&nbsp;bold</i>&nbsp;attribute for light-colored foreground text.<br>
The<b>&nbsp;tput sgr0</b>&nbsp;restores the terminal settings to normal. Omitting this lets all subsequent output from that<br>particular terminal remain blue.<br>
Since<b>&nbsp;tput sgr0</b>&nbsp;fails to restore terminal settings under certain circumstances,<b>&nbsp;echo -ne \E[0m</b>&nbsp;may be a<br>better choice.<br>
Use the following template for writing colored text on a colored background.<br>
Chapter 36. Miscellany<br>
509<br>
<hr>
<A name=516></a>Advanced Bash-Scripting Guide<br>
<b>echo -e '\E[COLOR1;COLOR2mSome text goes here.'</b><br>
The &quot;\E[&quot; begins the escape sequence. The semicolon-separated numbers &quot;COLOR1&quot; and &quot;COLOR2&quot;<br>specify a foreground and a background color, according to the table below. (The order of the numbers does<br>not matter, since the foreground and background numbers fall in non-overlapping ranges.) The &quot;m&quot;<br>terminates the escape sequence, and the text begins immediately after that.<br>
<a href="abs-guides.html#36">Note also that single quotes enclose the remainder of the command sequence following the</a><b>&nbsp;echo -e</b>.<br>
The numbers in the following table work for an<i>&nbsp;rxvt</i>&nbsp;terminal. Results may vary for other terminal emulators.<br>
<b>Table 36-1. Numbers representing colors in Escape Sequences</b><br>
<b>Color</b><br>
<b>Foreground&nbsp;Background</b><br>
black<br>
30<br>
40<br>
red<br>
31<br>
41<br>
green<br>
32<br>
42<br>
yellow<br>
33<br>
43<br>
blue<br>
34<br>
44<br>
magenta&nbsp;35<br>
45<br>
cyan<br>
36<br>
46<br>
white<br>
37<br>
47<br>
<b>Example 36-13. Echoing colored text</b><br>
#!/bin/bash<br>
# color-echo.sh: Echoing text messages in color.<br>
# Modify this script for your own purposes.<br>
# It's easier than hand-coding color.<br>
black='\E[30;47m'<br>
red='\E[31;47m'<br>
green='\E[32;47m'<br>
yellow='\E[33;47m'<br>
blue='\E[34;47m'<br>
magenta='\E[35;47m'<br>
cyan='\E[36;47m'<br>
white='\E[37;47m'<br>
alias Reset=&quot;tput sgr0&quot; &nbsp; &nbsp; &nbsp;# &nbsp;Reset text attributes to normal<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ without clearing screen.<br>
cecho () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Color-echo.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Argument $1 = message<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Argument $2 = color<br>
{<br>
local default_msg=&quot;No message passed.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Doesn't really need to be a local variable.<br>
Chapter 36. Miscellany<br>
510<br>
<hr>
<A name=517></a>Advanced Bash-Scripting Guide<br>
message=${1:-$default_msg} &nbsp; # Defaults to default message.<br>
color=${2:-$black} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Defaults to black, if not specified.<br>
&nbsp; echo -e &quot;$color&quot;<br>
&nbsp; echo &quot;$message&quot;<br>
&nbsp; Reset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reset to normal.<br>
&nbsp; return<br>
} &nbsp;<br>
# Now, let's try it out.<br>
# ----------------------------------------------------<br>
cecho &quot;Feeling blue...&quot; $blue<br>
cecho &quot;Magenta looks more like purple.&quot; $magenta<br>
cecho &quot;Green with envy.&quot; $green<br>
cecho &quot;Seeing red?&quot; $red<br>
cecho &quot;Cyan, more familiarly known as aqua.&quot; $cyan<br>
cecho &quot;No color passed (defaults to black).&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Missing $color argument.<br>
cecho &quot;\&quot;Empty\&quot; color passed (defaults to black).&quot; &quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Empty $color argument.<br>
cecho<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Missing $message and $color arguments.<br>
cecho &quot;&quot; &quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Empty $message and $color arguments.<br>
# ----------------------------------------------------<br>
echo<br>
exit 0<br>
# Exercises:<br>
# ---------<br>
# 1) Add the &quot;bold&quot; attribute to the 'cecho ()' function.<br>
# 2) Add options for colored backgrounds.<br>
<b>Example 36-14. A &quot;horserace&quot; game</b><br>
#!/bin/bash<br>
# horserace.sh: Very simple horserace simulation.<br>
# Author: Stefano Palmeri<br>
# Used with permission.<br>
################################################################<br>
# &nbsp;Goals of the script:<br>
# &nbsp;playing with escape sequences and terminal colors.<br>
#<br>
# &nbsp;Exercise:<br>
# &nbsp;Edit the script to make it run less randomly,<br>
#+ set up a fake betting shop . . . &nbsp; &nbsp;&nbsp;<br>
# &nbsp;Um . . . um . . . it's starting to remind me of a movie . . .<br>
#<br>
# &nbsp;The script gives each horse a random handicap.<br>
# &nbsp;The odds are calculated upon horse handicap<br>
#+ and are expressed in European(?) style.<br>
# &nbsp;E.g., odds=3.75 means that if you bet $1 and win,<br>
#+ you receive $3.75.<br>
#&nbsp;<br>
# &nbsp;The script has been tested with a GNU/Linux OS,<br>
Chapter 36. Miscellany<br>
511<br>
<hr>
<A name=518></a>Advanced Bash-Scripting Guide<br>
#+ using xterm and rxvt, and konsole.<br>
# &nbsp;On a machine with an AMD 900 MHz processor,<br>
#+ the average race time is 75 seconds. &nbsp; &nbsp;<br>
# &nbsp;On faster computers the race time would be lower.<br>
# &nbsp;So, if you want more suspense, reset the USLEEP_ARG variable.<br>
#<br>
# &nbsp;Script by Stefano Palmeri.<br>
################################################################<br>
E_RUNERR=65<br>
# Check if md5sum and bc are installed.&nbsp;<br>
if ! which bc &amp;&gt; /dev/null; then<br>
&nbsp; &nbsp;echo bc is not installed. &nbsp;<br>
&nbsp; &nbsp;echo &quot;Can\'t run . . . &quot;<br>
&nbsp; &nbsp;exit $E_RUNERR<br>
fi<br>
if ! which md5sum &amp;&gt; /dev/null; then<br>
&nbsp; &nbsp;echo md5sum is not installed. &nbsp;<br>
&nbsp; &nbsp;echo &quot;Can\'t run . . . &quot;<br>
&nbsp; &nbsp;exit $E_RUNERR<br>
fi<br>
# &nbsp;Set the following variable to slow down script execution.<br>
# &nbsp;It will be passed as the argument for usleep (man usleep) &nbsp;<br>
#+ and is expressed in microseconds (500000 = half a second).<br>
USLEEP_ARG=0 &nbsp;<br>
# &nbsp;Clean up the temp directory, restore terminal cursor and&nbsp;<br>
#+ terminal colors -- if script interrupted by Ctl-C.<br>
trap 'echo -en &quot;\E[?25h&quot;; echo -en &quot;\E[0m&quot;; stty echo;\<br>
tput cup 20 0; rm -fr &nbsp;$HORSE_RACE_TMP_DIR' &nbsp;TERM EXIT<br>
# &nbsp;See the chapter on debugging for an explanation of 'trap.'<br>
# Set a unique (paranoid) name for the temp directory the script needs.<br>
HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom \<br>
| md5sum | head -c30`<br>
# Create the temp directory and move right in.<br>
mkdir $HORSE_RACE_TMP_DIR<br>
cd $HORSE_RACE_TMP_DIR<br>
# &nbsp;This function moves the cursor to line $1 column $2 and then prints $3.<br>
# &nbsp;E.g.: &quot;move_and_echo 5 10 linux&quot; is equivalent to<br>
#+ &quot;tput cup 4 9; echo linux&quot;, but with one command instead of two.<br>
# &nbsp;Note: &quot;tput cup&quot; defines 0 0 the upper left angle of the terminal,<br>
#+ echo defines 1 1 the upper left angle of the terminal.<br>
move_and_echo() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -ne &quot;\E[${1};${2}H&quot;&quot;$3&quot;&nbsp;<br>
}<br>
# Function to generate a pseudo-random number between 1 and 9.&nbsp;<br>
random_1_9 ()<br>
{<br>
&nbsp; &nbsp; head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1&nbsp;<br>
}<br>
# &nbsp;Two functions that simulate &quot;movement,&quot; when drawing the horses.&nbsp;<br>
draw_horse_one() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo -n &quot; &quot;//$MOVE_HORSE//<br>
}<br>
Chapter 36. Miscellany<br>
512<br>
<hr>
<A name=519></a>Advanced Bash-Scripting Guide<br>
draw_horse_two(){<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot; &quot;\\\\$MOVE_HORSE\\\\&nbsp;<br>
} &nbsp;&nbsp;<br>
# Define current terminal dimension.<br>
N_COLS=`tput cols`<br>
N_LINES=`tput lines`<br>
# Need at least a 20-LINES X 80-COLUMNS terminal. Check it.<br>
if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then<br>
&nbsp; &nbsp;echo &quot;`basename $0` needs a 80-cols X 20-lines terminal.&quot;<br>
&nbsp; &nbsp;echo &quot;Your terminal is ${N_COLS}-cols X ${N_LINES}-lines.&quot;<br>
&nbsp; &nbsp;exit $E_RUNERR<br>
fi<br>
# Start drawing the race field.<br>
# Need a string of 80 chars. See below.<br>
BLANK80=`seq -s &quot;&quot; 100 | head -c80`<br>
clear<br>
# Set foreground and background colors to white.<br>
echo -ne '\E[37;47m'<br>
# Move the cursor on the upper left angle of the terminal.<br>
tput cup 0 0&nbsp;<br>
# Draw six white lines.<br>
for n in `seq 5`; do<br>
&nbsp; &nbsp; &nbsp; echo $BLANK80 &nbsp; # Use the 80 chars string to colorize the terminal.<br>
done<br>
# Sets foreground color to black.&nbsp;<br>
echo -ne '\E[30m'<br>
move_and_echo 3 1 &quot;START &nbsp;1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
move_and_echo 3 75 FINISH<br>
move_and_echo 1 5 &quot;|&quot;<br>
move_and_echo 1 80 &quot;|&quot;<br>
move_and_echo 2 5 &quot;|&quot;<br>
move_and_echo 2 80 &quot;|&quot;<br>
move_and_echo 4 5 &quot;| &nbsp;2&quot;<br>
move_and_echo 4 80 &quot;|&quot;<br>
move_and_echo 5 5 &quot;V &nbsp;3&quot;<br>
move_and_echo 5 80 &quot;V&quot;<br>
# Set foreground color to red.&nbsp;<br>
echo -ne '\E[31m'<br>
# Some ASCII art.<br>
move_and_echo 1 8 &quot;..@@@..@@@@@...@@@@@.@...@..@@@@...&quot;<br>
move_and_echo 2 8 &quot;.@...@...@.......@...@...@.@.......&quot;<br>
move_and_echo 3 8 &quot;.@@@@@...@.......@...@@@@@.@@@@....&quot;<br>
move_and_echo 4 8 &quot;.@...@...@.......@...@...@.@.......&quot;<br>
move_and_echo 5 8 &quot;.@...@...@.......@...@...@..@@@@...&quot;<br>
move_and_echo 1 43 &quot;@@@@...@@@...@@@@..@@@@..@@@@.&quot;<br>
move_and_echo 2 43 &quot;@...@.@...@.@.....@.....@.....&quot;<br>
move_and_echo 3 43 &quot;@@@@..@@@@@.@.....@@@@...@@@..&quot;<br>
move_and_echo 4 43 &quot;@..@..@...@.@.....@.........@.&quot;<br>
Chapter 36. Miscellany<br>
513<br>
<hr>
<A name=520></a>Advanced Bash-Scripting Guide<br>
move_and_echo 5 43 &quot;@...@.@...@..@@@@..@@@@.@@@@..&quot;<br>
# Set foreground and background colors to green.<br>
echo -ne '\E[32;42m'<br>
# Draw &nbsp;eleven green lines.<br>
tput cup 5 0<br>
for n in `seq 11`; do<br>
&nbsp; &nbsp; &nbsp; echo $BLANK80<br>
done<br>
# Set foreground color to black.&nbsp;<br>
echo -ne '\E[30m'<br>
tput cup 5 0<br>
# Draw the fences.&nbsp;<br>
echo &quot;++++++++++++++++++++++++++++++++++++++\<br>
++++++++++++++++++++++++++++++++++++++++++&quot;<br>
tput cup 15 0<br>
echo &quot;++++++++++++++++++++++++++++++++++++++\<br>
++++++++++++++++++++++++++++++++++++++++++&quot;<br>
# Set foreground and background colors to white.<br>
echo -ne '\E[37;47m'<br>
# Draw three white lines.<br>
for n in `seq 3`; do<br>
&nbsp; &nbsp; &nbsp; echo $BLANK80<br>
done<br>
# Set foreground color to black.<br>
echo -ne '\E[30m'<br>
# Create 9 files to stores handicaps.<br>
for n in `seq 10 7 68`; do<br>
&nbsp; &nbsp; &nbsp; touch $n<br>
done &nbsp;<br>
# Set the first type of &quot;horse&quot; the script will draw.<br>
HORSE_TYPE=2<br>
# &nbsp;Create position-file and odds-file for every &quot;horse&quot;.<br>
#+ In these files, store the current position of the horse,<br>
#+ the type and the odds.<br>
for HN in `seq 9`; do<br>
&nbsp; &nbsp; &nbsp; touch horse_${HN}_position<br>
&nbsp; &nbsp; &nbsp; touch odds_${HN}<br>
&nbsp; &nbsp; &nbsp; echo \-1 &gt; horse_${HN}_position<br>
&nbsp; &nbsp; &nbsp; echo $HORSE_TYPE &gt;&gt; &nbsp;horse_${HN}_position<br>
&nbsp; &nbsp; &nbsp; # Define a random handicap for horse.<br>
&nbsp; &nbsp; &nbsp; &nbsp;HANDICAP=`random_1_9`<br>
&nbsp; &nbsp; &nbsp; # Check if the random_1_9 function returned a good value.<br>
&nbsp; &nbsp; &nbsp; while ! echo $HANDICAP | grep [1-9] &amp;&gt; /dev/null; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HANDICAP=`random_1_9`<br>
&nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; # Define last handicap position for horse.&nbsp;<br>
&nbsp; &nbsp; &nbsp; LHP=`expr $HANDICAP \* 7 + 3`<br>
&nbsp; &nbsp; &nbsp; for FILE in `seq 10 7 $LHP`; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $HN &gt;&gt; $FILE<br>
&nbsp; &nbsp; &nbsp; done &nbsp;&nbsp;<br>
Chapter 36. Miscellany<br>
514<br>
<hr>
<A name=521></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; # Calculate odds.<br>
&nbsp; &nbsp; &nbsp; case $HANDICAP in&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $ODDS &gt; odds_${HN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $ODDS &gt; odds_${HN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $ODDS &gt; odds_${HN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $ODDS &gt; odds_${HN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $ODDS &gt; odds_${HN}<br>
&nbsp; &nbsp; &nbsp; esac<br>
done<br>
# Print odds.<br>
print_odds() {<br>
tput cup 6 0<br>
echo -ne '\E[30;42m'<br>
for HN in `seq 9`; do<br>
&nbsp; &nbsp; &nbsp; echo &quot;#$HN odds-&gt;&quot; `cat odds_${HN}`<br>
done<br>
}<br>
# Draw the horses at starting line.<br>
draw_horses() {<br>
tput cup 6 0<br>
echo -ne '\E[30;42m'<br>
for HN in `seq 9`; do<br>
&nbsp; &nbsp; &nbsp; echo /\\$HN/\\&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;<br>
done<br>
}<br>
print_odds<br>
echo -ne '\E[47m'<br>
# Wait for a enter key press to start the race.<br>
# The escape sequence '\E[?25l' disables the cursor.<br>
tput cup 17 0<br>
echo -e '\E[?25l'Press [enter] key to start the race...<br>
read -s<br>
# &nbsp;Disable normal echoing in the terminal.<br>
# &nbsp;This avoids key presses that might &quot;contaminate&quot; the screen<br>
#+ during the race. &nbsp;<br>
stty -echo<br>
# --------------------------------------------------------<br>
# Start the race.<br>
draw_horses<br>
echo -ne '\E[37;47m'<br>
move_and_echo 18 1 $BLANK80<br>
echo -ne '\E[30m'<br>
Chapter 36. Miscellany<br>
515<br>
<hr>
<A name=522></a>Advanced Bash-Scripting Guide<br>
move_and_echo 18 1 Starting...<br>
sleep 1<br>
# Set the column of the finish line.<br>
WINNING_POS=74<br>
# Define the time the race started.<br>
START_TIME=`date +%s`<br>
# COL variable needed by following &quot;while&quot; construct.<br>
COL=0 &nbsp; &nbsp;<br>
while [ $COL -lt $WINNING_POS ]; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOVE_HORSE=0 &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Check if the random_1_9 function has returned a good value.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while ! echo $MOVE_HORSE | grep [1-9] &amp;&gt; /dev/null; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOVE_HORSE=`random_1_9`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Define old type and position of the &quot;randomized horse&quot;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HORSE_TYPE=`cat &nbsp;horse_${MOVE_HORSE}_position | tail -n 1`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COL=$(expr `cat &nbsp;horse_${MOVE_HORSE}_position | head -n 1`)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADD_POS=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Check if the current position is an handicap position.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if seq 10 7 68 | grep -w $COL &amp;&gt; /dev/null; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if grep -w $MOVE_HORSE $COL &amp;&gt; /dev/null; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADD_POS=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grep -v -w &nbsp;$MOVE_HORSE $COL &gt; ${COL}_new<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rm -f $COL<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mv -f ${COL}_new $COL<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else ADD_POS=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else ADD_POS=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COL=`expr $COL + $ADD_POS`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $COL &gt; &nbsp;horse_${MOVE_HORSE}_position &nbsp;# Store new position.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Choose the type of horse to draw. &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case $HORSE_TYPE in&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $HORSE_TYPE &gt;&gt; &nbsp;horse_${MOVE_HORSE}_position<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Store current type.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set foreground color to black and background to green.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -ne '\E[30;42m'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Move the cursor to new horse position.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tput cup `expr $MOVE_HORSE + 5` \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `cat &nbsp;horse_${MOVE_HORSE}_position | head -n 1`&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Draw the horse.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $DRAW_HORSE<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;usleep $USLEEP_ARG<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# When all horses have gone beyond field line 15, reprint odds.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;touch fieldline15<br>
Chapter 36. Miscellany<br>
516<br>
<hr>
<A name=523></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if [ $COL = 15 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo $MOVE_HORSE &gt;&gt; fieldline15 &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if [ `wc -l fieldline15 | cut -f1 -d &quot; &quot;` = 9 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print_odds<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: &gt; fieldline15<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Define the leading horse.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HIGHEST_POS=`cat *position | sort -n | tail -1` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set background color to white.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -ne '\E[47m'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tput cup 17 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`\<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;<br>
done &nbsp;<br>
# Define the time the race finished.<br>
FINISH_TIME=`date +%s`<br>
# Set background color to green and enable blinking text.<br>
echo -ne '\E[30;42m'<br>
echo -en '\E[5m'<br>
# Make the winning horse blink.<br>
tput cup `expr $MOVE_HORSE + 5` \<br>
`cat &nbsp;horse_${MOVE_HORSE}_position | head -n 1`<br>
$DRAW_HORSE<br>
# Disable blinking text.<br>
echo -en '\E[25m'<br>
# Set foreground and background color to white.<br>
echo -ne '\E[37;47m'<br>
move_and_echo 18 1 $BLANK80<br>
# Set foreground color to black.<br>
echo -ne '\E[30m'<br>
# Make winner blink.<br>
tput cup 17 0<br>
echo -e &quot;\E[5mWINNER: $MOVE_HORSE\E[25m&quot;&quot; &nbsp;Odds: `cat odds_${MOVE_HORSE}`&quot;\<br>
&quot; &nbsp;Race time: `expr $FINISH_TIME - $START_TIME` secs&quot;<br>
# Restore cursor and old colors.<br>
echo -en &quot;\E[?25h&quot;<br>
echo -en &quot;\E[0m&quot;<br>
# Restore echoing.<br>
stty echo<br>
# Remove race temp directory.<br>
rm -rf $HORSE_RACE_TMP_DIR<br>
tput cup 19 0<br>
exit 0<br>
<a href="abs-guides.html#612">See also Example A-21, Example A-44, Example A-52, and Example A-40.</a><br>
Chapter 36. Miscellany<br>
517<br>
<hr>
<A name=524></a><IMG src="abs-guide-524_1.png"><br>
Advanced Bash-Scripting Guide<br>
There is, however, a major problem with all this.<a href="abs-guides.html#538"><i>&nbsp;ANSI escape sequences are emphatically non-portable.<br></i></a>What works fine on some terminal emulators (or the console) may work differently, or not at all, on<br>others. A &quot;colorized&quot; script that looks stunning on the script author's machine may produce unreadable<br>output on someone else's. This somewhat compromises the usefulness of colorizing scripts, and possibly<br>relegates this technique to the status of a gimmick. Colorized scripts are probably inappropriate in a<br>commercial setting, i.e., your supervisor might disapprove.<br>
<a href="http://code.google.com/p/ansi-color/">Alister's &nbsp;ansi-color utility (based on Moshe Jacobson's color utility considerably simplifies using ANSI<br></a>escape sequences. It substitutes a clean and logical syntax for the clumsy constructs just discussed.<br>
<a href="http://scriptechocolor.sourceforge.net/">Henry/teikedvl has likewise created a utility (http://scriptechocolor.sourceforge.net/) to simplify creation of<br></a>colorized scripts.<br>
<b>36.6. Optimizations</b><br>
Most shell scripts are quick 'n dirty solutions to non-complex problems. As such, optimizing them for speed is<br>not much of an issue. Consider the case, though, where a script carries out an important task, does it well, but<br>runs too slowly. Rewriting it in a compiled language may not be a palatable option. The simplest fix would be<br>to rewrite the parts of the script that slow it down. Is it possible to apply principles of code optimization even<br>to a lowly shell script?<br>
Check the loops in the script. Time consumed by repetitive operations adds up quickly. If at all possible,<br>remove time-consuming operations from within loops.<br>
<a href="abs-guides.html#186">Use builtin commands in preference to system commands. Builtins execute faster and usually do not launch a<br></a>subshell when invoked.<br>
<a href="abs-guides.html#24">Avoid unnecessary commands, particularly in a pipe.</a><br>
cat &quot;$file&quot; | grep &quot;$word&quot;<br>
grep &quot;$word&quot; &quot;$file&quot;<br>
# &nbsp;The above command-lines have an identical effect,<br>
#+ but the second runs faster since it launches one fewer subprocess.<br>
<a href="abs-guides.html#221">The cat command seems especially prone to overuse in scripts.</a><br>
<a href="abs-guides.html#238">Use the time and times tools to profile computation-intensive commands. Consider rewriting time-critical<br></a>code sections in C, or even in assembler.<br>
Try to minimize file I/O. Bash is not particularly efficient at handling files, so consider using more<br><a href="abs-guides.html#784">appropriate tools for this within the script, such as awk or Perl.</a><br>
Write your scripts in a modular and coherent form,&nbsp;[124] so they can be reorganized and tightened up as<br>necessary. Some of the optimization techniques applicable to high-level languages may work for scripts, but<br>others, such as<i>&nbsp;loop unrolling</i>, are mostly irrelevant. Above all, use common sense.<br>
For an excellent demonstration of how optimization can dramatically reduce the execution time of a script, see<br><a href="abs-guides.html#297">Example 16-47.</a><br>
Chapter 36. Miscellany<br>
518<br>
<hr>
<A name=525></a>Advanced Bash-Scripting Guide<br>
<b>36.7. Assorted Tips</b><br>
<b>36.7.1. Ideas for more powerful scripts</b><br>
•&nbsp;<br>
You have a problem that you want to solve by writing a Bash script. Unfortunately, you don't know<br>quite where to start. One method is to plunge right in and code those parts of the script that come<br>easily, and write the hard parts as<i>&nbsp;pseudo-code</i>.<br>
#!/bin/bash<br>
ARGCOUNT=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Need name as argument.<br>
E_WRONGARGS=65<br>
if [ number-of-arguments is-not-equal-to &quot;$ARGCOUNT&quot; ]<br>
# &nbsp; &nbsp;^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^<br>
# &nbsp;Can't figure out how to code this . . .<br>
#+ . . . so write it in pseudo-code.<br>
then<br>
&nbsp; echo &quot;Usage: name-of-script name&quot;<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^^^ &nbsp; &nbsp; More pseudo-code.<br>
&nbsp; exit $E_WRONGARGS<br>
fi&nbsp;<br>
. . .<br>
exit 0<br>
# Later on, substitute working code for the pseudo-code.<br>
# Line 6 becomes:<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
# Line 12 becomes:<br>
&nbsp; echo &quot;Usage: `basename $0` name&quot;<br>
<a href="abs-guides.html#829">For an example of using pseudo-code, see the Square Root exercise.</a><br>
•&nbsp;<br>
To keep a record of which user scripts have run during a particular session or over a number of<br>sessions, add the following lines to each script you want to keep track of. This will keep a continuing<br>file record of the script names and invocation times.<br>
# Append (&gt;&gt;) following to end of each script tracked.<br>
whoami&gt;&gt; $SAVE_FILE &nbsp; &nbsp;# User invoking the script.<br>
echo $0&gt;&gt; $SAVE_FILE &nbsp; # Script name.<br>
date&gt;&gt; $SAVE_FILE &nbsp; &nbsp; &nbsp;# Date and time.<br>
echo&gt;&gt; $SAVE_FILE &nbsp; &nbsp; &nbsp;# Blank line as separator.<br>
# &nbsp;Of course, SAVE_FILE defined and exported as environmental variable in ~/.bashrc<br>
#+ (something like ~/.scripts-run)<br>
•&nbsp;<br>
The &gt;&gt; operator<i>&nbsp;appends</i>&nbsp;lines to a file. What if you wish to<i>&nbsp;prepend</i>&nbsp;a line to an existing file, that is,<br>to paste it in at the beginning?<br>
Chapter 36. Miscellany<br>
519<br>
<hr>
<A name=526></a>Advanced Bash-Scripting Guide<br>
file=data.txt<br>
title=&quot;***This is the title line of data text file***&quot;<br>
echo $title | cat - $file &gt;$file.new<br>
# &quot;cat -&quot; concatenates stdout to $file.<br>
# &nbsp;End result is<br>
#+ to write a new file with $title appended at *beginning*.<br>
<a href="abs-guides.html#371">This is a simplified variant of the Example 19-13 script given earlier. And, of course, sed can also do<br></a>this.<br>
•&nbsp;<br>
A shell script may act as an embedded command inside another shell script, a<i>&nbsp;Tcl</i>&nbsp;or<i>&nbsp;wish</i>&nbsp;script, or<br><a href="abs-guides.html#280">even a Makefile. It can be invoked as an external shell command in a C program using the<br></a><i>system()</i>&nbsp;call, i.e.,&nbsp;<i>system(&quot;script_name&quot;);</i>.<br>
•&nbsp;<br>
Setting a variable to the contents of an embedded<i>&nbsp;sed</i>&nbsp;or<i>&nbsp;awk</i>&nbsp;script increases the readability of the<br><a href="abs-guides.html#503">surrounding shell wrapper. See Example A-1 and Example 15-20.</a><br>
•&nbsp;<br>
Put together files containing your favorite and most useful definitions and functions. As necessary,<br><a href="abs-guides.html#15">&quot;include&quot; one or more of these &quot;library files&quot; in scripts with either the dot (</a><b>.</b><a href="abs-guides.html#210">) or source command.</a><br>
# SCRIPT LIBRARY<br>
# ------ -------<br>
# Note:<br>
# No &quot;#!&quot; here.<br>
# No &quot;live code&quot; either.<br>
# Useful variable definitions<br>
ROOT_UID=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Root has $UID 0.<br>
E_NOTROOT=101 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Not root user error.&nbsp;<br>
MAXRETVAL=255 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Maximum (positive) return value of a function.<br>
SUCCESS=0<br>
FAILURE=-1<br>
# Functions<br>
Usage () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &quot;Usage:&quot; message.<br>
{<br>
&nbsp; if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # No arg passed.<br>
&nbsp; then<br>
&nbsp; &nbsp; msg=filename<br>
&nbsp; else<br>
&nbsp; &nbsp; msg=$@<br>
&nbsp; fi<br>
&nbsp; echo &quot;Usage: `basename $0` &quot;$msg&quot;&quot;<br>
} &nbsp;<br>
Check_if_root () &nbsp; &nbsp; &nbsp; # Check if root running script.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# From &quot;ex39.sh&quot; example.<br>
&nbsp; if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Must be root to run this script.&quot;<br>
&nbsp; &nbsp; exit $E_NOTROOT<br>
Chapter 36. Miscellany<br>
520<br>
<hr>
<A name=527></a>Advanced Bash-Scripting Guide<br>
&nbsp; fi<br>
} &nbsp;<br>
CreateTempfileName () &nbsp;# Creates a &quot;unique&quot; temp filename.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# From &quot;ex51.sh&quot; example.<br>
&nbsp; prefix=temp<br>
&nbsp; suffix=`eval date +%s`<br>
&nbsp; Tempfilename=$prefix.$suffix<br>
}<br>
isalpha2 () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Tests whether *entire string* is alphabetic.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# From &quot;isalpha.sh&quot; example.<br>
&nbsp; [ $# -eq 1 ] || return $FAILURE<br>
&nbsp; case $1 in<br>
&nbsp; *[!a-zA-Z]*|&quot;&quot;) return $FAILURE;;<br>
&nbsp; *) return $SUCCESS;;<br>
&nbsp; esac &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Thanks, S.C.<br>
}<br>
abs () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Absolute value.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Caution: Max return value = 255.<br>
&nbsp; E_ARGERR=-999999<br>
&nbsp; if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Need arg passed.<br>
&nbsp; then<br>
&nbsp; &nbsp; return $E_ARGERR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Obvious error value returned.<br>
&nbsp; fi<br>
&nbsp; if [ &quot;$1&quot; -ge 0 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If non-negative,<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; absval=$1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# stays as-is.<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Otherwise,<br>
&nbsp; &nbsp; let &quot;absval = (( 0 - $1 ))&quot; &nbsp;# change sign.<br>
&nbsp; fi &nbsp;<br>
&nbsp; return $absval<br>
}<br>
tolower () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Converts string(s) passed as argument(s)<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to lowercase.<br>
&nbsp; if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # &nbsp;If no argument(s) passed,<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ send error message<br>
&nbsp; &nbsp; echo &quot;(null)&quot; &nbsp; &nbsp; &nbsp;#+ (C-style void-pointer error message)<br>
&nbsp; &nbsp; return &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and return from function.<br>
&nbsp; fi &nbsp;<br>
&nbsp; echo &quot;$@&quot; | tr A-Z a-z<br>
&nbsp; # Translate all passed arguments ($@).<br>
&nbsp; return<br>
# Use command substitution to set a variable to function output.<br>
# For example:<br>
# &nbsp; &nbsp;oldvar=&quot;A seT of miXed-caSe LEtTerS&quot;<br>
# &nbsp; &nbsp;newvar=`tolower &quot;$oldvar&quot;`<br>
# &nbsp; &nbsp;echo &quot;$newvar&quot; &nbsp; &nbsp;# a set of mixed-case letters<br>
Chapter 36. Miscellany<br>
521<br>
<hr>
<A name=528></a>Advanced Bash-Scripting Guide<br>
#<br>
# Exercise: Rewrite this function to change lowercase passed argument(s)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to uppercase ... toupper() &nbsp;[easy].<br>
}<br>
•&nbsp;<br>
Use special-purpose comment headers to increase clarity and legibility in scripts.<br>
## Caution.<br>
rm -rf *.zzy &nbsp; ## &nbsp;The &quot;-rf&quot; options to &quot;rm&quot; are very dangerous,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;##+ especially with wild cards.<br>
#+ Line continuation.<br>
# &nbsp;This is line 1<br>
#+ of a multi-line comment,<br>
#+ and this is the final line.<br>
#* Note.<br>
#o List item.<br>
#&gt; Another point of view.<br>
while [ &quot;$var1&quot; != &quot;end&quot; ] &nbsp; &nbsp;#&gt; while test &quot;$var1&quot; != &quot;end&quot;<br>
•&nbsp;<br>
Dotan Barak contributes template code for a<i>&nbsp;progress bar</i>&nbsp;in a script.<br>
<b>Example 36-15. A Progress Bar</b><br>
#!/bin/bash<br>
# progress-bar.sh<br>
# Author: Dotan Barak (very minor revisions by ABS Guide author).<br>
# Used in ABS Guide with permission (thanks!).<br>
BAR_WIDTH=50<br>
BAR_CHAR_START=&quot;[&quot;<br>
BAR_CHAR_END=&quot;]&quot;<br>
BAR_CHAR_EMPTY=&quot;.&quot;<br>
BAR_CHAR_FULL=&quot;=&quot;<br>
BRACKET_CHARS=2<br>
LIMIT=100<br>
print_progress_bar()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Calculate how many characters will be full.<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;full_limit = ((($1 - $BRACKET_CHARS) * $2) / $LIMIT)&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Calculate how many characters will be empty.<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;empty_limit = ($1 - $BRACKET_CHARS) - ${full_limit}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Prepare the bar.<br>
&nbsp; &nbsp; &nbsp; &nbsp; bar_line=&quot;${BAR_CHAR_START}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; for ((j=0; j&lt;full_limit; j++)); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bar_line=&quot;${bar_line}${BAR_CHAR_FULL}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; for ((j=0; j&lt;empty_limit; j++)); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bar_line=&quot;${bar_line}${BAR_CHAR_EMPTY}&quot;<br>
Chapter 36. Miscellany<br>
522<br>
<hr>
<A name=529></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; bar_line=&quot;${bar_line}${BAR_CHAR_END}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;%3d%% %s&quot; $2 ${bar_line}<br>
}<br>
# Here is a sample of code that uses it.<br>
MAX_PERCENT=100<br>
for ((i=0; i&lt;=MAX_PERCENT; i++)); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; usleep 10000<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ... Or run some other commands ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; print_progress_bar ${BAR_WIDTH} ${i}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -en &quot;\r&quot;<br>
done<br>
echo &quot;&quot;<br>
exit<br>
•&nbsp;<br>
<a href="abs-guides.html#60">A particularly clever use of if-test constructs is for comment blocks.</a><br>
#!/bin/bash<br>
COMMENT_BLOCK=<br>
# &nbsp;Try setting the above variable to some value<br>
#+ for an unpleasant surprise.<br>
if [ $COMMENT_BLOCK ]; then<br>
Comment block --<br>
=================================<br>
This is a comment line.<br>
This is another comment line.<br>
This is yet another comment line.<br>
=================================<br>
echo &quot;This will not echo.&quot;<br>
Comment blocks are error-free! Whee!<br>
fi<br>
echo &quot;No more comments, please.&quot;<br>
exit 0<br>
<a href="abs-guides.html#367">Compare this with using here documents to comment out code blocks.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#109">Using the $? exit status variable, a script may test if a parameter contains only digits, so it can be<br></a>treated as an integer.<br>
#!/bin/bash<br>
SUCCESS=0<br>
E_BADINPUT=85<br>
test &quot;$1&quot; -ne 0 -o &quot;$1&quot; -eq 0 2&gt;/dev/null<br>
# An integer is either equal to 0 or not equal to 0.<br>
Chapter 36. Miscellany<br>
523<br>
<hr>
<A name=530></a>Advanced Bash-Scripting Guide<br>
# 2&gt;/dev/null suppresses error message.<br>
if [ $? -ne &quot;$SUCCESS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` integer-input&quot;<br>
&nbsp; exit $E_BADINPUT<br>
fi<br>
let &quot;sum = $1 + 25&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Would give error if $1 not integer.<br>
echo &quot;Sum = $sum&quot;<br>
# Any variable, not just a command-line parameter, can be tested this way.<br>
exit 0<br>
The 0 - 255 range for function return values is a severe limitation. Global variables and other<br>
•&nbsp;<br>
workarounds are often problematic. An alternative method for a function to communicate a value<br>back to the main body of the script is to have the function write to&nbsp;stdout<a href="abs-guides.html#187">&nbsp;(usually with echo) the<br></a><a href="abs-guides.html#170">&quot;return value,&quot; and assign this to a variable. This is actually a variant of command substitution.</a><br>
<b>Example 36-16. Return value trickery</b><br>
#!/bin/bash<br>
# multiplication.sh<br>
multiply () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Multiplies params passed.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Will accept a variable number of args.<br>
&nbsp; local product=1<br>
&nbsp; until [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Until uses up arguments passed...<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;product *= $1&quot;<br>
&nbsp; &nbsp; shift<br>
&nbsp; done<br>
&nbsp; echo $product &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Will not echo to stdout,<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ since this will be assigned to a variable.<br>
mult1=15383; mult2=25211<br>
val1=`multiply $mult1 $mult2`<br>
# Assigns stdout (echo) of function to the variable val1.<br>
echo &quot;$mult1 X $mult2 = $val1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 387820813<br>
mult1=25; mult2=5; mult3=20<br>
val2=`multiply $mult1 $mult2 $mult3`<br>
echo &quot;$mult1 X $mult2 X $mult3 = $val2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 2500<br>
mult1=188; mult2=37; mult3=25; mult4=47<br>
val3=`multiply $mult1 $mult2 $mult3 $mult4`<br>
echo &quot;$mult1 X $mult2 X $mult3 X $mult4 = $val3&quot; # 8173300<br>
exit 0<br>
The same technique also works for alphanumeric strings. This means that a function can &quot;return&quot; a<br>non-numeric value.<br>
capitalize_ichar () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Capitalizes initial character<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ of argument string(s) passed.<br>
&nbsp; string0=&quot;$@&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Accepts multiple arguments.<br>
Chapter 36. Miscellany<br>
524<br>
<hr>
<A name=531></a><IMG src="abs-guide-531_1.png"><br>
Advanced Bash-Scripting Guide<br>
&nbsp; firstchar=${string0:0:1} &nbsp; # First character.<br>
&nbsp; string1=${string0:1} &nbsp; &nbsp; &nbsp; # Rest of string(s).<br>
&nbsp; FirstChar=`echo &quot;$firstchar&quot; | tr a-z A-Z`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Capitalize first character.<br>
&nbsp; echo &quot;$FirstChar$string1&quot; &nbsp;# Output to stdout.<br>
} &nbsp;<br>
newstring=`capitalize_ichar &quot;every sentence should start with a capital letter.&quot;`<br>
echo &quot;$newstring&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Every sentence should start with a capital letter.<br>
It is even possible for a function to &quot;return&quot; multiple values with this method.<br>
<b>Example 36-17. Even more return value trickery</b><br>
#!/bin/bash<br>
# sum-product.sh<br>
# A function may &quot;return&quot; more than one value.<br>
sum_and_product () &nbsp; # Calculates both sum and product of passed args.<br>
{<br>
&nbsp; echo $(( $1 + $2 )) $(( $1 * $2 ))<br>
# Echoes to stdout each calculated value, separated by space.<br>
}<br>
echo<br>
echo &quot;Enter first number &quot;<br>
read first<br>
echo<br>
echo &quot;Enter second number &quot;<br>
read second<br>
echo<br>
retval=`sum_and_product $first $second` &nbsp; &nbsp; &nbsp;# Assigns output of function.<br>
sum=`echo &quot;$retval&quot; | awk '{print $1}'` &nbsp; &nbsp; &nbsp;# Assigns first field.<br>
product=`echo &quot;$retval&quot; | awk '{print $2}'` &nbsp;# Assigns second field.<br>
echo &quot;$first + $second = $sum&quot;<br>
echo &quot;$first * $second = $product&quot;<br>
echo<br>
exit 0<br>
There can be only<b>&nbsp;one</b><i>&nbsp;echo</i>&nbsp;statement in the function for this to work. If you alter the<br>previous example:<br>
sum_and_product ()<br>
{<br>
&nbsp; echo &quot;This is the sum_and_product function.&quot; # This messes things up!<br>
&nbsp; echo $(( $1 + $2 )) $(( $1 * $2 ))<br>
}<br>
...<br>
retval=`sum_and_product $first $second` &nbsp; &nbsp; &nbsp;# Assigns output of function.<br>
# Now, this will not work correctly.<br>
Chapter 36. Miscellany<br>
525<br>
<hr>
<A name=532></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#427">Next in our bag of tricks are techniques for passing an array to a function, then &quot;returning&quot; an array<br></a>back to the main body of the script.<br>
Passing an array involves loading the space-separated elements of the array into a variable with<br><a href="abs-guides.html#170">command substitution.&nbsp;</a>Getting an array back as the &quot;return value&quot; from a function uses the previously<br><a href="abs-guides.html#187">mentioned strategem of echoing the array in the function, then invoking command substitution and<br></a>the<b>&nbsp;( ... )</b>&nbsp;operator to assign it to an array.<br>
<b>Example 36-18. Passing and returning arrays</b><br>
#!/bin/bash<br>
# array-function.sh: Passing an array to a function and ...<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;returning&quot; an array from a function<br>
Pass_Array ()<br>
{<br>
&nbsp; local passed_array &nbsp; # Local variable!<br>
&nbsp; passed_array=( `echo &quot;$1&quot;` )<br>
&nbsp; echo &quot;${passed_array[@]}&quot;<br>
&nbsp; # &nbsp;List all the elements of the new array<br>
&nbsp; #+ declared and set within the function.<br>
}<br>
original_array=( element1 element2 element3 element4 element5 )<br>
echo<br>
echo &quot;original_array = ${original_array[@]}&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List all elements of original array.<br>
# This is the trick that permits passing an array to a function.<br>
# **********************************<br>
argument=`echo ${original_array[@]}`<br>
# **********************************<br>
# &nbsp;Pack a variable<br>
#+ with all the space-separated elements of the original array.<br>
#<br>
# Attempting to just pass the array itself will not work.<br>
# This is the trick that allows grabbing an array as a &quot;return value&quot;.<br>
# *****************************************<br>
returned_array=( `Pass_Array &quot;$argument&quot;` )<br>
# *****************************************<br>
# Assign 'echoed' output of function to array variable.<br>
echo &quot;returned_array = ${returned_array[@]}&quot;<br>
echo &quot;=============================================================&quot;<br>
# &nbsp;Now, try it again,<br>
#+ attempting to access (list) the array from outside the function.<br>
Pass_Array &quot;$argument&quot;<br>
# The function itself lists the array, but ...<br>
#+ accessing the array from outside the function is forbidden.<br>
echo &quot;Passed array (within function) = ${passed_array[@]}&quot;<br>
Chapter 36. Miscellany<br>
526<br>
<hr>
<A name=533></a>Advanced Bash-Scripting Guide<br>
•&nbsp;&nbsp;# NULL VALUE since the array is a variable local to the function.<br>
echo<br>
############################################<br>
# And here is an even more explicit example:<br>
ret_array ()<br>
{<br>
&nbsp; for element in {11..20}<br>
&nbsp; do<br>
&nbsp; &nbsp; echo &quot;$element &quot; &nbsp; # &nbsp;Echo individual elements<br>
&nbsp; done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ of what will be assembled into an array.<br>
}<br>
arr=( $(ret_array) ) &nbsp; # &nbsp;Assemble into array.<br>
echo &quot;Capturing array \&quot;arr\&quot; from function ret_array () ...&quot;<br>
echo &quot;Third element of array \&quot;arr\&quot; is ${arr[2]}.&quot; &nbsp; # 13 &nbsp;(zero-indexed)<br>
echo -n &quot;Entire array is: &quot;<br>
echo ${arr[@]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 11 12 13 14 15 16 17 18 19 20<br>
echo<br>
exit 0<br>
<a href="abs-guides.html#583">For a more elaborate example of passing arrays to functions, see Example A-10.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#86">Using the double-parentheses construct, it is possible to use C-style syntax for setting and<br></a><a href="abs-guides.html#144">incrementing/decrementing variables and in for and while loops. See Example 11-12 and Example<br></a><a href="abs-guides.html#154">11-17.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#96">Setting the path and umask at the beginning of a script makes it more portable -- more likely to run on<br></a>a &quot;foreign&quot; machine whose user may have bollixed up the&nbsp;$PATH&nbsp;and<b>&nbsp;umask</b>.<br>
#!/bin/bash<br>
PATH=/bin:/usr/bin:/usr/local/bin ; export PATH<br>
umask 022 &nbsp; # Files that the script creates will have 755 permission.<br>
# Thanks to Ian D. Allen, for this tip.<br>
•&nbsp;<br>
A useful scripting technique is to<i>&nbsp;repeatedly</i>&nbsp;feed the output of a filter (by piping) back to the<i>&nbsp;same<br>filter</i><a href="abs-guides.html#254">, but with a different set of arguments and/or options. Especially suitable for this are tr and grep.</a><br>
# From &quot;wstrings.sh&quot; example.<br>
wlist=`strings &quot;$1&quot; | tr A-Z a-z | tr '[:space:]' Z | \<br>
tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`<br>
<b>Example 36-19. Fun with anagrams</b><br>
#!/bin/bash<br>
# agram.sh: Playing games with anagrams.<br>
# Find anagrams of...<br>
LETTERSET=etaoinshrdlu<br>
FILTER='.......' &nbsp; &nbsp; &nbsp; # How many letters minimum?<br>
# &nbsp; &nbsp; &nbsp; 1234567<br>
Chapter 36. Miscellany<br>
527<br>
<hr>
<A name=534></a>Advanced Bash-Scripting Guide<br>
anagram &quot;$LETTERSET&quot; | # Find all anagrams of the letterset...<br>
grep &quot;$FILTER&quot; | &nbsp; &nbsp; &nbsp; # With at least 7 letters,<br>
grep '^is' | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # starting with 'is'<br>
grep -v 's$' | &nbsp; &nbsp; &nbsp; &nbsp; # no plurals<br>
grep -v 'ed$' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# no past tense verbs<br>
# Possible to add many combinations of conditions and filters.<br>
# &nbsp;Uses &quot;anagram&quot; utility<br>
#+ that is part of the author's &quot;yawl&quot; word list package.<br>
# &nbsp;http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz<br>
# &nbsp;http://bash.webofcrafts.net/yawl-0.3.2.tar.gz<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # End of code.<br>
bash$ sh agram.sh<br>
islander<br>
isolate<br>
isolead<br>
isotheral<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;Modify this script to take the LETTERSET as a command-line parameter.<br>
# &nbsp;Parameterize the filters in lines 11 - 13 (as with $FILTER),<br>
#+ so that they can be specified by passing arguments to a function.<br>
# &nbsp;For a slightly different approach to anagramming,<br>
#+ see the agram2.sh script.<br>
<a href="abs-guides.html#467">See also Example 29-4, Example 16-25, and Example A-9.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#367">Use &quot;anonymous here documents&quot; to comment out blocks of code, to save having to individually<br>comment out each line with a #. See Example 19-11.</a><br>
•&nbsp;<br>
Running a script on a machine that relies on a command that might not be installed is dangerous. Use<br><a href="abs-guides.html#268">whatis to avoid potential problems with this.</a><br>
CMD=command1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # First choice.<br>
PlanB=command2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Fallback option.<br>
command_test=$(whatis &quot;$CMD&quot; | grep 'nothing appropriate')<br>
# &nbsp;If 'command1' not found on system , 'whatis' will return<br>
#+ &quot;command1: nothing appropriate.&quot;<br>
#<br>
# &nbsp;A safer alternative is:<br>
# &nbsp; &nbsp; command_test=$(whereis &quot;$CMD&quot; | grep \/)<br>
# &nbsp;But then the sense of the following test would have to be reversed,<br>
#+ since the $command_test variable holds content only if<br>
#+ the $CMD exists on the system.<br>
# &nbsp; &nbsp; (Thanks, bojster.)<br>
if [[ -z &quot;$command_test&quot; ]] &nbsp;# Check whether command present.<br>
then<br>
&nbsp; $CMD option1 option2 &nbsp; &nbsp; &nbsp; # &nbsp;Run command1 with options.<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Otherwise,<br>
&nbsp; $PlanB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ run command2.&nbsp;<br>
Chapter 36. Miscellany<br>
528<br>
<hr>
<A name=535></a>Advanced Bash-Scripting Guide<br>
fi<br>
•&nbsp;<br>
<a href="abs-guides.html#61">An if-grep test may not return expected results in an error case, when text is output to&nbsp;</a>stderr, rather<br>that&nbsp;stdout.<br>
if ls -l nonexistent_filename | grep -q 'No such file or directory'<br>
&nbsp; then echo &quot;File \&quot;nonexistent_filename\&quot; does not exist.&quot;<br>
fi<br>
<a href="abs-guides.html#374">Redirecting&nbsp;</a>stderr&nbsp;to&nbsp;stdout&nbsp;fixes this.<br>
if ls -l nonexistent_filename 2&gt;&amp;1 | grep -q 'No such file or directory'<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^<br>
&nbsp; then echo &quot;File \&quot;nonexistent_filename\&quot; does not exist.&quot;<br>
fi<br>
# Thanks, Chris Martin, for pointing this out.<br>
If you absolutely must access a subshell variable outside the subshell, here's a way to do it.<br>
•&nbsp;<br>
TMPFILE=tmpfile &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Create a temp file to store the variable.<br>
( &nbsp; # Inside the subshell ...<br>
inner_variable=Inner<br>
echo $inner_variable<br>
echo $inner_variable &gt;&gt;$TMPFILE &nbsp;# Append to temp file.<br>
)<br>
&nbsp; &nbsp; # Outside the subshell ...<br>
echo; echo &quot;-----&quot;; echo<br>
echo $inner_variable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Null, as expected.<br>
echo &quot;-----&quot;; echo<br>
# Now ...<br>
read inner_variable &lt;$TMPFILE &nbsp; &nbsp;# Read back shell variable.<br>
rm -f &quot;$TMPFILE&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Get rid of temp file.<br>
echo &quot;$inner_variable&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # It's an ugly kludge, but it works.<br>
•&nbsp;<br>
<a href="abs-guides.html#310">The run-parts command is handy for running a set of command scripts in a particular sequence,<br></a><a href="abs-guides.html#338">especially in combination with cron or at.</a><br>
•&nbsp;<br>
For doing multiple revisions on a complex script, use the<i>&nbsp;rcs</i>&nbsp;Revision Control System package.<br>
Among other benefits of this is automatically updated ID header tags. The<b>&nbsp;co</b>&nbsp;command in<i>&nbsp;rcs</i>&nbsp;does a<br>parameter replacement of certain reserved key words, for example, replacing&nbsp;<i># $Id$</i>&nbsp;in a script with<br>something like:<br>
# $Id: hello-world.sh,v 1.1 2004/10/16 02:43:05 bozo Exp $<br>
<b>36.7.2. Widgets</b><br>
It would be nice to be able to invoke X-Windows widgets from a shell script. There happen to exist several<br>packages that purport to do so, namely<i>&nbsp;Xscript</i>,<i>&nbsp;Xmenu</i>, and<i>&nbsp;widtools</i>. The first two of these no longer seem to<br>be maintained. Fortunately, it is still possible to obtain<i>&nbsp;widtools</i><a href="http://www.batse.msfc.nasa.gov/~mallozzi/home/software/xforms/src/widtools-2.0.tgz">&nbsp;here.</a><br>
Chapter 36. Miscellany<br>
529<br>
<hr>
<A name=536></a><IMG src="abs-guide-536_1.png"><br>
Advanced Bash-Scripting Guide<br>
The<i>&nbsp;widtools</i>&nbsp;(widget tools) package requires the<i>&nbsp;XForms</i>&nbsp;library to be installed. Additionally, the<br><a href="abs-guides.html#280">Makefile needs some judicious editing before the package will build on a typical Linux system. Finally,<br></a>three of the six widgets offered do not work (and, in fact, segfault).<br>
The<i>&nbsp;dialog</i>&nbsp;family of tools offers a method of calling &quot;dialog&quot; widgets from a shell script. The original<i>&nbsp;dialog<br></i>utility works in a text console, but its successors,<i>&nbsp;gdialog</i>,<i>&nbsp;Xdialog</i>, and<i>&nbsp;kdialog</i>&nbsp;use X-Windows-based widget<br>sets.<br>
<b>Example 36-20. Widgets invoked from a shell script</b><br>
#!/bin/bash<br>
# dialog.sh: Using 'gdialog' widgets.<br>
# Must have 'gdialog' installed on your system to run this script.<br>
# Or, you can replace all instance of 'gdialog' below with 'kdialog' ...<br>
# Version 1.1 (corrected 04/05/05)<br>
# This script was inspired by the following article.<br>
# &nbsp; &nbsp; &quot;Scripting for X Productivity,&quot; by Marco Fioretti,<br>
# &nbsp; &nbsp; &nbsp;LINUX JOURNAL, Issue 113, September 2003, pp. 86-9.<br>
# Thank you, all you good people at LJ.<br>
# Input error in dialog box.<br>
E_INPUT=65<br>
# Dimensions of display, input widgets.<br>
HEIGHT=50<br>
WIDTH=60<br>
# Output file name (constructed out of script name).<br>
OUTFILE=$0.output<br>
# Display this script in a text widget.<br>
gdialog --title &quot;Displaying: $0&quot; --textbox $0 $HEIGHT $WIDTH<br>
# Now, we'll try saving input in a file.<br>
echo -n &quot;VARIABLE=&quot; &gt; $OUTFILE<br>
gdialog --title &quot;User Input&quot; --inputbox &quot;Enter variable, please:&quot; \<br>
$HEIGHT $WIDTH 2&gt;&gt; $OUTFILE<br>
if [ &quot;$?&quot; -eq 0 ]<br>
# It's good practice to check exit status.<br>
then<br>
&nbsp; echo &quot;Executed \&quot;dialog box\&quot; without errors.&quot;<br>
else<br>
&nbsp; echo &quot;Error(s) in \&quot;dialog box\&quot; execution.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Or, clicked on &quot;Cancel&quot;, instead of &quot;OK&quot; button.<br>
&nbsp; rm $OUTFILE<br>
&nbsp; exit $E_INPUT<br>
fi<br>
# Now, we'll retrieve and display the saved variable.<br>
. $OUTFILE &nbsp; # 'Source' the saved file.<br>
Chapter 36. Miscellany<br>
530<br>
<hr>
<A name=537></a>Advanced Bash-Scripting Guide<br>
echo &quot;The variable input in the \&quot;input box\&quot; was: &quot;$VARIABLE&quot;&quot;<br>
rm $OUTFILE &nbsp;# Clean up by removing the temp file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Some applications may need to retain this file.<br>
exit $?<br>
# Exercise: Rewrite this script using the 'zenity' widget set.<br>
<a href="abs-guides.html#319">The xmessage command is a simple method of popping up a message/query window. For example:</a><br>
xmessage Fatal error in script! -button exit<br>
<a href="abs-guides.html#319">The latest entry in the widget sweepstakes is zenity. This utility pops up</a><i>&nbsp;GTK+</i>&nbsp;dialog widgets-and-windows,<br>and it works very nicely within a script.<br>
get_info ()<br>
{<br>
&nbsp; zenity --entry &nbsp; &nbsp; &nbsp; # &nbsp;Pops up query window . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ and prints user entry to stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Also try the --calendar and --scale options.<br>
}<br>
answer=$( get_info ) &nbsp; # &nbsp;Capture stdout in $answer variable.<br>
echo &quot;User entered: &quot;$answer&quot;&quot;<br>
For other methods of scripting with widgets, try<i>&nbsp;Tk</i>&nbsp;or<i>&nbsp;wish</i>&nbsp;(<i>Tcl</i>&nbsp;derivatives),<i>&nbsp;PerlTk</i>&nbsp;(<i>Perl</i>&nbsp;with<i>&nbsp;Tk<br></i>extensions),<i>&nbsp;tksh</i>&nbsp;(<i>ksh</i>&nbsp;with<i>&nbsp;Tk</i>&nbsp;extensions),<i>&nbsp;XForms4Perl</i>&nbsp;(<i>Perl</i>&nbsp;with<i>&nbsp;XForms</i>&nbsp;extensions),<i>&nbsp;Gtk-Perl</i>&nbsp;(<i>Perl</i>&nbsp;with<br><i>Gtk</i>&nbsp;extensions), or<i>&nbsp;PyQt</i>&nbsp;(<i>Python</i>&nbsp;with<i>&nbsp;Qt</i>&nbsp;extensions).<br>
<b>36.8. Security Issues</b><br>
<b>36.8.1. Infected Shell Scripts</b><br>
A brief warning about script security is indicated. A shell script may contain a<i>&nbsp;worm</i>,<i>&nbsp;trojan</i>, or even a<i>&nbsp;virus</i>.<br>For that reason, never run as<i>&nbsp;root</i>&nbsp;a script (or permit it to be inserted into the system startup scripts in<br>/etc/rc.d) unless you have obtained said script from a trusted source or you have carefully analyzed it to<br>make certain it does nothing harmful.<br>
Various researchers at Bell Labs and other sites, including M. Douglas McIlroy, Tom Duff, and Fred Cohen<br>have investigated the implications of shell script viruses. They conclude that it is all too easy for even a<br>novice, a &quot;script kiddie,&quot; to write one.&nbsp;[125]<br>
Here is yet another reason to learn scripting. Being able to look at and understand scripts may protect your<br>system from being compromised by a rogue script.<br>
<b>36.8.2. Hiding Shell Script Source</b><br>
For security purposes, it may be necessary to render a script unreadable. If only there were a utility to create a<br><a href="http://www.datsi.fi.upm.es/~frosal/sources/">stripped binary executable from a script. Francisco Rosales' shc -- generic shell script compiler does exactly<br></a>that.<br>
Chapter 36. Miscellany<br>
531<br>
<hr>
<A name=538></a>Advanced Bash-Scripting Guide<br>
<a href="http://www.linuxjournal.com/article/8256">Unfortunately, according to an article in the October, 2005</a><i>&nbsp;Linux Journal</i>, the binary can, in at least some<br>cases, be decrypted to recover the original script source. Still, this could be a useful method of keeping scripts<br>secure from all but the most skilled hackers.<br>
<b>36.8.3. Writing Secure Shell Scripts</b><br>
<i>Dan Stromberg</i>&nbsp;suggests the following guidelines for writing (relatively) secure shell scripts.<br>
<a href="abs-guides.html#41">Don't put secret data in environment variables.</a><br>
•&nbsp;<br>
<a href="abs-guides.html#24">Don't pass secret data in an external command's arguments (pass them in via a pipe or redirection</a><br>
•&nbsp;<br>
instead).<br><a href="abs-guides.html#96">Set your $PATH carefully. Don't just trust whatever path you inherit from the caller if your script is</a><br>
•&nbsp;<br>
running as<i>&nbsp;root</i>. In fact, whenever you use an environment variable inherited from the caller, think<br>about what could happen if the caller put something misleading in the variable, e.g., if the caller set<br><a href="abs-guides.html#93">$HOME to&nbsp;</a>/etc.<br>
<b>36.9. Portability Issues</b><br>
<i>It is easier to port a shell than a shell script.</i><br>
<i>--Larry Wall</i><br>
This book deals specifically with Bash scripting on a GNU/Linux system. All the same, users of<b>&nbsp;sh</b>&nbsp;and<b>&nbsp;ksh<br></b>will find much of value here.<br>
<a href="abs-guides.html#881">As it happens, many of the various shells and scripting languages seem to be converging toward the POSIX<br></a>1003.2 standard. Invoking Bash with the&nbsp;--posix&nbsp;option or inserting a<b>&nbsp;set -o posix</b>&nbsp;at the head of a script<br>causes Bash to conform very closely to this standard. Another alternative is to use a<i>&nbsp;#!/bin/sh</i><a href="abs-guides.html#11">&nbsp;sha-bang header<br></a>in the script, rather than<i>&nbsp;#!/bin/bash</i>.&nbsp;[126] Note that&nbsp;/bin/sh<a href="abs-guides.html#224">&nbsp;is a link to&nbsp;</a>/bin/bash&nbsp;in Linux and certain<br>other flavors of UNIX, and a script invoked this way disables extended Bash functionality.<br>
Most Bash scripts will run as-is under<b>&nbsp;ksh</b>, and vice-versa, since Chet Ramey has been busily porting<b>&nbsp;ksh<br></b>features to the latest versions of Bash.<br>
On a commercial UNIX machine, scripts using GNU-specific features of standard commands may not work.<br>This has become less of a problem in the last few years, as the GNU utilities have pretty much displaced their<br><a href="http://linux.oreillynet.com/pub/a/linux/2002/02/28/caldera.html">proprietary counterparts even on &quot;big-iron&quot; UNIX. Caldera's release of the source to many of the original<br></a>UNIX utilities has accelerated the trend.<br>
<a href="abs-guides.html#8">Bash has certain features that the traditional Bourne shell lacks. Among these are:</a><br>
<a href="abs-guides.html#487">Certain extended invocation options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170">Command substitution using</a><br>
•&nbsp;<br>
<b>&nbsp;$( )</b>&nbsp;notation<br>
<a href="abs-guides.html#546">Brace expansion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#427">Certain array operations, and associative arrays</a><br>
•&nbsp;<br>
<a href="abs-guides.html#65">The double brackets extended test construct</a><br>
•&nbsp;<br>
<a href="abs-guides.html#86">The double-parentheses arithmetic-evaluation construct</a><br>
•&nbsp;<br>
<a href="abs-guides.html#125">Certain string manipulation operations</a><br>
•&nbsp;<br>
<a href="abs-guides.html#394">Process substitution</a><br>
•&nbsp;<br>
Chapter 36. Miscellany<br>
532<br>
<hr>
<A name=539></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#547">A Regular Expression matching operator</a><br>
•&nbsp;<br>
<a href="abs-guides.html#186">Bash-specific builtins</a><br>
•&nbsp;<br>
<a href="abs-guides.html#551">Coprocesses</a><br>
•&nbsp;<br>
<a href="ftp://ftp.cwru.edu/pub/bash/FAQ">See the Bash F.A.Q. for a complete listing.</a><br>
<b>36.9.1. A Test Suite</b><br>
Let us illustrate some of the incompatibilities between Bash and the classic Bourne shell. Download and<br><a href="http://freshmeat.net/projects/bournesh">install the &quot;Heirloom Bourne Shell&quot; and run the following script, first using Bash, then the classic</a><i>&nbsp;sh</i>.<br>
<b>Example 36-21. Test Suite</b><br>
#!/bin/bash<br>
# test-suite.sh<br>
# A partial Bash compatibility test suite.<br>
# Run this on your version of Bash, or some other shell.<br>
default_option=FAIL &nbsp; &nbsp; &nbsp; &nbsp; # Tests below will fail unless . . .<br>
echo<br>
echo -n &quot;Testing &quot;<br>
sleep 1; echo -n &quot;. &quot;<br>
sleep 1; echo -n &quot;. &quot;<br>
sleep 1; echo &quot;. &quot;<br>
echo<br>
# Double brackets<br>
String=&quot;Double brackets supported?&quot;<br>
echo -n &quot;Double brackets test: &quot;<br>
if [[ &quot;$String&quot; = &quot;Double brackets supported?&quot; ]]<br>
then<br>
&nbsp; echo &quot;PASS&quot;<br>
else<br>
&nbsp; echo &quot;FAIL&quot;<br>
fi<br>
# Double brackets and regex matching<br>
String=&quot;Regex matching supported?&quot;<br>
echo -n &quot;Regex matching: &quot;<br>
if [[ &quot;$String&quot; =~ R.....matching* ]]<br>
then<br>
&nbsp; echo &quot;PASS&quot;<br>
else<br>
&nbsp; echo &quot;FAIL&quot;<br>
fi<br>
# Arrays<br>
test_arr=$default_option &nbsp; &nbsp; # FAIL<br>
Array=( If supports arrays will print PASS )<br>
test_arr=${Array[5]}<br>
echo &quot;Array test: $test_arr&quot;<br>
# Command Substitution<br>
Chapter 36. Miscellany<br>
533<br>
<hr>
<A name=540></a>Advanced Bash-Scripting Guide<br>
csub_test ()<br>
{<br>
&nbsp; echo &quot;PASS&quot;<br>
}<br>
test_csub=$default_option &nbsp; &nbsp;# FAIL<br>
test_csub=$(csub_test)<br>
echo &quot;Command substitution test: $test_csub&quot;<br>
echo<br>
# &nbsp;Completing this script is an exercise for the reader.<br>
# &nbsp;Add to the above similar tests for double parentheses,<br>
#+ brace expansion, process substitution, etc.<br>
exit $?<br>
<b>36.10. Shell Scripting Under Windows</b><br>
Even users running<i>&nbsp;that other</i>&nbsp;OS can run UNIX-like shell scripts, and therefore benefit from many of the<br><a href="http://sourceware.cygnus.com/cygwin/">lessons of this book. The &nbsp;Cygwin package from Cygnus and the MKS utilities from Mortice Kern Associates<br></a>add shell scripting capabilities to Windows.<br>
In 2006, Microsoft released the Windows Powershell®, which contains limited Bash-like command-line<br>scripting capabilities.<br>
Chapter 36. Miscellany<br>
534<br>
<hr>
<A name=541></a><b>Chapter 37. Bash, versions 2, 3, and 4</b><br>
<b>37.1. Bash, version 2</b><br>
The current version of<i>&nbsp;Bash</i>, the one you have running on your machine, is most likely version 2.xx.yy,<br>3.xx.yy, or 4.xx.yy.<br>
bash$&nbsp;<b>echo $BASH_VERSION<br></b>3.2.25(1)-release<br>
The version 2 update of the classic Bash scripting language added array variables, string and parameter<br>expansion, and a better method of indirect variable references, among other features.<br>
<b>Example 37-1. String expansion</b><br>
#!/bin/bash<br>
# String expansion.<br>
# Introduced with version 2 of Bash.<br>
# &nbsp;Strings of the form $'xxx'<br>
#+ have the standard escaped characters interpreted.&nbsp;<br>
echo $'Ringing bell 3 times \a \a \a'<br>
&nbsp; &nbsp; &nbsp;# May only ring once with certain terminals.<br>
&nbsp; &nbsp; &nbsp;# Or ...<br>
&nbsp; &nbsp; &nbsp;# May not ring at all, depending on terminal settings.<br>
echo $'Three form feeds \f \f \f'<br>
echo $'10 newlines \n\n\n\n\n\n\n\n\n\n'<br>
echo $'\102\141\163\150'<br>
&nbsp; &nbsp; &nbsp;# &nbsp; B &nbsp; a &nbsp; s &nbsp; h<br>
&nbsp; &nbsp; &nbsp;# Octal equivalent of characters.<br>
exit<br>
<b>Example 37-2. Indirect variable references - the new way</b><br>
#!/bin/bash<br>
# Indirect variable referencing.<br>
# This has a few of the attributes of references in C++.<br>
a=letter_of_alphabet<br>
letter_of_alphabet=z<br>
echo &quot;a = $a&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Direct reference.<br>
echo &quot;Now a = ${!a}&quot; &nbsp; &nbsp;# Indirect reference.<br>
# &nbsp;The ${!variable} notation is more intuitive than the old<br>
#+ eval var1=\$$var2<br>
echo<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
535<br>
<hr>
<A name=542></a>Advanced Bash-Scripting Guide<br>
t=table_cell_3<br>
table_cell_3=24<br>
echo &quot;t = ${!t}&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# t = 24<br>
table_cell_3=387<br>
echo &quot;Value of t changed to ${!t}&quot; &nbsp; &nbsp;# 387<br>
# No 'eval' necessary.<br>
# &nbsp;This is useful for referencing members of an array or table,<br>
#+ or for simulating a multi-dimensional array.<br>
# &nbsp;An indexing option (analogous to pointer arithmetic)<br>
#+ would have been nice. Sigh.<br>
exit 0<br>
# See also, ind-ref.sh example.<br>
<b>Example 37-3. Simple database application, using indirect variable referencing</b><br>
#!/bin/bash<br>
# resistor-inventory.sh<br>
# Simple database / table-lookup application.<br>
# ============================================================== #<br>
# Data<br>
B1723_value=470 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Ohms<br>
B1723_powerdissip=.25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Watts<br>
B1723_colorcode=&quot;yellow-violet-brown&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Color bands<br>
B1723_loc=173 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Where they are<br>
B1723_inventory=78 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# How many<br>
B1724_value=1000<br>
B1724_powerdissip=.25<br>
B1724_colorcode=&quot;brown-black-red&quot;<br>
B1724_loc=24N<br>
B1724_inventory=243<br>
B1725_value=10000<br>
B1725_powerdissip=.125<br>
B1725_colorcode=&quot;brown-black-orange&quot;<br>
B1725_loc=24N<br>
B1725_inventory=89<br>
# ============================================================== #<br>
echo<br>
PS3='Enter catalog number: '<br>
echo<br>
select catalog_number in &quot;B1723&quot; &quot;B1724&quot; &quot;B1725&quot;<br>
do<br>
&nbsp; Inv=${catalog_number}_inventory<br>
&nbsp; Val=${catalog_number}_value<br>
&nbsp; Pdissip=${catalog_number}_powerdissip<br>
&nbsp; Loc=${catalog_number}_loc<br>
&nbsp; Ccode=${catalog_number}_colorcode<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
536<br>
<hr>
<A name=543></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo<br>
&nbsp; echo &quot;Catalog number $catalog_number:&quot;<br>
&nbsp; # Now, retrieve value, using indirect referencing.<br>
&nbsp; echo &quot;There are ${!Inv} of &nbsp;[${!Val} ohm / ${!Pdissip} watt]\<br>
&nbsp; resistors in stock.&quot; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
&nbsp; # As of Bash 4.2, you can replace &quot;ohm&quot; with \u2126 (using echo -e).<br>
&nbsp; echo &quot;These are located in bin # ${!Loc}.&quot;<br>
&nbsp; echo &quot;Their color code is \&quot;${!Ccode}\&quot;.&quot;<br>
&nbsp; break<br>
done<br>
echo; echo<br>
# Exercises:<br>
# ---------<br>
# 1) Rewrite this script to read its data from an external file.<br>
# 2) Rewrite this script to use arrays,<br>
#+ &nbsp; rather than indirect variable referencing.<br>
# &nbsp; &nbsp;Which method is more straightforward and intuitive?<br>
# &nbsp; &nbsp;Which method is easier to code?<br>
# Notes:<br>
# -----<br>
# &nbsp;Shell scripts are inappropriate for anything except the most simple<br>
#+ database applications, and even then it involves workarounds and kludges.<br>
# &nbsp;Much better is to use a language with native support for data structures,<br>
#+ such as C++ or Java (or even Perl).<br>
exit 0<br>
<b>Example 37-4. Using arrays and other miscellaneous trickery to deal four random hands from a deck of<br>cards</b><br>
#!/bin/bash<br>
# cards.sh<br>
# Deals four random hands from a deck of cards.<br>
UNPICKED=0<br>
PICKED=1<br>
DUPE_CARD=99<br>
LOWER_LIMIT=0<br>
UPPER_LIMIT=51<br>
CARDS_IN_SUIT=13<br>
CARDS=52<br>
declare -a Deck<br>
declare -a Suits<br>
declare -a Cards<br>
# &nbsp;It would have been easier to implement and more intuitive<br>
#+ with a single, 3-dimensional array.<br>
# &nbsp;Perhaps a future version of Bash will support multidimensional arrays.<br>
initialize_Deck ()<br>
{<br>
i=$LOWER_LIMIT<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
537<br>
<hr>
<A name=544></a>Advanced Bash-Scripting Guide<br>
until [ &quot;$i&quot; -gt $UPPER_LIMIT ]<br>
do<br>
&nbsp; Deck[i]=$UNPICKED &nbsp; # Set each card of &quot;Deck&quot; as unpicked.<br>
&nbsp; let &quot;i += 1&quot;<br>
done<br>
echo<br>
}<br>
initialize_Suits ()<br>
{<br>
Suits[0]=C #Clubs<br>
Suits[1]=D #Diamonds<br>
Suits[2]=H #Hearts<br>
Suits[3]=S #Spades<br>
}<br>
initialize_Cards ()<br>
{<br>
Cards=(2 3 4 5 6 7 8 9 10 J Q K A)<br>
# Alternate method of initializing an array.<br>
}<br>
pick_a_card ()<br>
{<br>
card_number=$RANDOM<br>
let &quot;card_number %= $CARDS&quot; # Restrict range to 0 - 51, i.e., 52 cards.<br>
if [ &quot;${Deck[card_number]}&quot; -eq $UNPICKED ]<br>
then<br>
&nbsp; Deck[card_number]=$PICKED<br>
&nbsp; return $card_number<br>
else &nbsp;<br>
&nbsp; return $DUPE_CARD<br>
fi<br>
}<br>
parse_card ()<br>
{<br>
number=$1<br>
let &quot;suit_number = number / CARDS_IN_SUIT&quot;<br>
suit=${Suits[suit_number]}<br>
echo -n &quot;$suit-&quot;<br>
let &quot;card_no = number % CARDS_IN_SUIT&quot;<br>
Card=${Cards[card_no]}<br>
printf %-4s $Card<br>
# Print cards in neat columns.<br>
}<br>
seed_random () &nbsp;# Seed random number generator.<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # What happens if you don't do this?<br>
seed=`eval date +%s`<br>
let &quot;seed %= 32766&quot;<br>
RANDOM=$seed<br>
# &nbsp;What are some other methods<br>
#+ of seeding the random number generator?<br>
}<br>
deal_cards ()<br>
{<br>
echo<br>
cards_picked=0<br>
while [ &quot;$cards_picked&quot; -le $UPPER_LIMIT ]<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
538<br>
<hr>
<A name=545></a>Advanced Bash-Scripting Guide<br>
do<br>
&nbsp; pick_a_card<br>
&nbsp; t=$?<br>
&nbsp; if [ &quot;$t&quot; -ne $DUPE_CARD ]<br>
&nbsp; then<br>
&nbsp; &nbsp; parse_card $t<br>
&nbsp; &nbsp; u=$cards_picked+1<br>
&nbsp; &nbsp; # Change back to 1-based indexing (temporarily). Why?<br>
&nbsp; &nbsp; let &quot;u %= $CARDS_IN_SUIT&quot;<br>
&nbsp; &nbsp; if [ &quot;$u&quot; -eq 0 ] &nbsp; # Nested if/then condition test.<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Each hand set apart with a blank line.<br>
&nbsp; &nbsp; let &quot;cards_picked += 1&quot;<br>
&nbsp; fi &nbsp;<br>
done &nbsp;<br>
echo<br>
return 0<br>
}<br>
# Structured programming:<br>
# Entire program logic modularized in functions.<br>
#===============<br>
seed_random<br>
initialize_Deck<br>
initialize_Suits<br>
initialize_Cards<br>
deal_cards<br>
#===============<br>
exit<br>
# Exercise 1:<br>
# Add comments to thoroughly document this script.<br>
# Exercise 2:<br>
# Add a routine (function) to print out each hand sorted in suits.<br>
# You may add other bells and whistles if you like.<br>
# Exercise 3:<br>
# Simplify and streamline the logic of the script.<br>
<b>37.2. Bash, version 3</b><br>
On July 27, 2004, Chet Ramey released version 3 of Bash. This update fixed quite a number of bugs and<br>added new features.<br>
Some of the more important added features:<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
539<br>
<hr>
<A name=546></a>Advanced Bash-Scripting Guide<br>
A new, more generalized<br>
•&nbsp;<br>
<b>&nbsp;{a..z}</b><a href="abs-guides.html#20">&nbsp;brace expansion operator.</a><br>
#!/bin/bash<br>
for i in {1..10}<br>
# &nbsp;Simpler and more straightforward than<br>
#+ for i in $(seq 10)<br>
do<br>
&nbsp; echo -n &quot;$i &quot;<br>
done<br>
echo<br>
# 1 2 3 4 5 6 7 8 9 10<br>
# Or just . . .<br>
echo {a..z} &nbsp; &nbsp;# &nbsp;a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
echo {e..m} &nbsp; &nbsp;# &nbsp;e f g h i j k l m<br>
echo {z..a} &nbsp; &nbsp;# &nbsp;z y x w v u t s r q p o n m l k j i h g f e d c b a<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Works backwards, too.<br>
echo {25..30} &nbsp;# &nbsp;25 26 27 28 29 30<br>
echo {3..-2} &nbsp; # &nbsp;3 2 1 0 -1 -2<br>
echo {X..d} &nbsp; &nbsp;# &nbsp;X Y Z [ &nbsp;] ^ _ ` a b c d<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Shows (some of) the ASCII characters between Z and a,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ but don't rely on this type of behavior because . . .<br>
echo {]..a} &nbsp; &nbsp;# &nbsp;{]..a}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Why?<br>
# You can tack on prefixes and suffixes.<br>
echo &quot;Number #&quot;{1..4}, &quot;...&quot;<br>
&nbsp; &nbsp; &nbsp;# Number #1, Number #2, Number #3, Number #4, ...<br>
# You can concatenate brace-expansion sets.<br>
echo {1..3}{x..z}&quot; +&quot; &quot;...&quot;<br>
&nbsp; &nbsp; &nbsp;# 1x + 1y + 1z + 2x + 2y + 2z + 3x + 3y + 3z + ...<br>
&nbsp; &nbsp; &nbsp;# Generates an algebraic expression.<br>
&nbsp; &nbsp; &nbsp;# This could be used to find permutations.<br>
# You can nest brace-expansion sets.<br>
echo {{a..c},{1..3}}<br>
&nbsp; &nbsp; &nbsp;# a b c 1 2 3<br>
&nbsp; &nbsp; &nbsp;# The &quot;comma operator&quot; splices together strings.<br>
# Unfortunately, brace expansion does not lend itself to parameterization.<br>
var1=1<br>
var2=5<br>
echo {$var1..$var2} &nbsp; # {1..5}<br>
The<br>
•&nbsp;<br>
<b>&nbsp;${!array[@]}</b><a href="abs-guides.html#427">&nbsp;operator, which expands to all the indices of a given array.</a><br>
#!/bin/bash<br>
Array=(element-zero element-one element-two element-three)<br>
echo ${Array[0]} &nbsp; # element-zero<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# First element of array.<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
540<br>
<hr>
<A name=547></a><IMG src="abs-guide-547_1.png"><br>
Advanced Bash-Scripting Guide<br>
echo ${!Array[@]} &nbsp;# 0 1 2 3<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# All the indices of Array.<br>
for i in ${!Array[@]}<br>
do<br>
&nbsp; echo ${Array[i]} # element-zero<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# element-one<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# element-two<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# element-three<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# All the elements in Array.<br>
done<br>
•&nbsp;<br>
The<b>&nbsp;=~</b><a href="abs-guides.html#354">&nbsp;Regular Expression matching operator within a double brackets test expression. (Perl has a<br></a>similar operator.)<br>
#!/bin/bash<br>
variable=&quot;This is a fine mess.&quot;<br>
echo &quot;$variable&quot;<br>
# Regex matching with =~ operator within [[ double brackets ]].<br>
if [[ &quot;$variable&quot; =~ T.........fin*es* ]]<br>
# NOTE: As of version 3.2 of Bash, expression to match no longer quoted.<br>
then<br>
&nbsp; echo &quot;match found&quot;<br>
&nbsp; &nbsp; &nbsp; # match found<br>
fi<br>
Or, more usefully:<br>
#!/bin/bash<br>
input=$1<br>
if [[ &quot;$input&quot; =~ &quot;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&quot; ]]<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ NOTE: Quoting not necessary, as of version 3.2 of Bash.<br>
# NNN-NN-NNNN (where each N is a digit).<br>
then<br>
&nbsp; echo &quot;Social Security number.&quot;<br>
&nbsp; # Process SSN.<br>
else<br>
&nbsp; echo &quot;Not a Social Security number!&quot;<br>
&nbsp; # Or, ask for corrected input.<br>
fi<br>
For additional examples of using the<b>&nbsp;=~</b><a href="abs-guides.html#662">&nbsp;operator, see Example A-29, Example 19-14, Example A-35,<br></a><a href="abs-guides.html#618">and Example A-24.</a><br>
•&nbsp;<br>
The new&nbsp;set -o pipefail<a href="abs-guides.html#24">&nbsp;option is useful for debugging pipes. If this option is set, then the exit<br></a><a href="abs-guides.html#57">status of a pipe is the exit status of the last command in the pipe to</a><i>&nbsp;fail</i>&nbsp;(return a non-zero value),<br>rather than the actual final command in the pipe.<br>
<a href="abs-guides.html#288">See Example 16-43.</a><br>
Chapter 37. Bash, versions 2, 3, and 4<br>
541<br>
<hr>
<A name=548></a>Advanced Bash-Scripting Guide<br>
The update to version 3 of Bash breaks a few scripts that worked under earlier versions.<i>&nbsp;Test critical<br>legacy scripts to make sure they still work!</i><br>
As it happens, a couple of the scripts in the<i>&nbsp;Advanced Bash Scripting Guide</i>&nbsp;had to be fixed up (see<br><a href="abs-guides.html#102">Example 9-4, for instance).</a><br>
<b>37.2.1. Bash, version 3.1</b><br>
The version 3.1 update of Bash introduces a number of bugfixes and a few minor changes.<br>
The += operator is now permitted in in places where previously only the = assignment operator was<br>
•&nbsp;<br>
recognized.<br>
a=1<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 1<br>
a+=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Won't work under versions of Bash earlier than 3.1.<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 15<br>
a+=Hello<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 15Hello<br>
Here, += functions as a<i>&nbsp;string concatenation</i>&nbsp;operator. Note that its behavior in this particular context<br><a href="abs-guides.html#198">is different than within a let construct.</a><br>
a=1<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 1<br>
let a+=5 &nbsp; &nbsp; &nbsp; # Integer arithmetic, rather than string concatenation.<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 6<br>
let a+=Hello &nbsp; # Doesn't &quot;add&quot; anything to a.<br>
echo $a &nbsp; &nbsp; &nbsp; &nbsp;# 6<br>
Jeffrey Haemer points out that this concatenation operator can be quite useful. In this instance, we<br>append a directory to the&nbsp;$PATH.<br>
bash$&nbsp;<b>echo $PATH<br></b>/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin/:/usr/games<br>
bash$&nbsp;<b>PATH+=:/opt/bin</b><br>
bash$&nbsp;<b>echo $PATH<br></b>/usr/bin:/bin:/usr/local/bin:/usr/X11R6/bin/:/usr/games:/opt/bin<br>
<b>37.2.2. Bash, version 3.2</b><br>
This is pretty much a bugfix update.<br>
In&nbsp;<br>
•&nbsp;<br>
<a href="abs-guides.html#140"><i>global</i>&nbsp;parameter substitutions, the pattern no longer anchors at the start of the string.</a><br>
The&nbsp;<br>
•&nbsp;<br>
--wordexp<a href="abs-guides.html#394">&nbsp;option disables process substitution.</a><br>
The<br>
•&nbsp;<br>
<b>&nbsp;=~</b><a href="abs-guides.html#547">&nbsp;Regular Expression match operator no longer requires quoting of the</a><i>&nbsp;pattern</i><a href="abs-guides.html#65">&nbsp;within [[ ... ]].</a><br>
Chapter 37. Bash, versions 2, 3, and 4<br>
542<br>
<hr>
<A name=549></a><IMG src="abs-guide-549_1.png"><br>
Advanced Bash-Scripting Guide<br>
In fact, quoting in this context is<i>&nbsp;not</i>&nbsp;advisable as it may cause<i>&nbsp;regex</i>&nbsp;evaluation to fail.<br><a href="abs-guides.html#569">Chet Ramey states in the Bash FAQ that quoting explicitly disables regex evaluation.<br></a><a href="https://bugs.launchpad.net/ubuntu-website/+bug/109931">See also the &nbsp;Ubuntu Bug List and &nbsp;Wikinerds on Bash syntax.</a><br>
Setting<i>&nbsp;shopt -s compat31</i>&nbsp;in a script causes reversion to the original behavior.<br>
<b>37.3. Bash, version 4</b><br>
Chet Ramey announced Version 4 of Bash on the 20th of February, 2009. This release has a number of<br>significant new features, as well as some important bugfixes.<br>
Among the new goodies:<br>
Associative arrays.&nbsp;<br>
•&nbsp;<br>
[127]<br>
An<i>&nbsp;associative</i>&nbsp;array can be thought of as a set of two linked arrays -- one holding the<i>&nbsp;data</i>, and the<br>other the<i>&nbsp;keys</i>&nbsp;that index the individual elements of the<i>&nbsp;data</i>&nbsp;array.<br>
<b>Example 37-5. A simple address database</b><br>
#!/bin/bash4<br>
# fetch_address.sh<br>
declare -A address<br>
# &nbsp; &nbsp; &nbsp; -A option declares associative array.<br>
address[Charles]=&quot;414 W. 10th Ave., Baltimore, MD 21236&quot;<br>
address[John]=&quot;202 E. 3rd St., New York, NY 10009&quot;<br>
address[Wilma]=&quot;1854 Vermont Ave, Los Angeles, CA 90023&quot;<br>
echo &quot;Charles's address is ${address[Charles]}.&quot;<br>
# Charles's address is 414 W. 10th Ave., Baltimore, MD 21236.<br>
echo &quot;Wilma's address is ${address[Wilma]}.&quot;<br>
# Wilma's address is 1854 Vermont Ave, Los Angeles, CA 90023.<br>
echo &quot;John's address is ${address[John]}.&quot;<br>
# John's address is 202 E. 3rd St., New York, NY 10009.<br>
echo<br>
echo &quot;${!address[*]}&quot; &nbsp; # The array indices ...<br>
# Charles John Wilma<br>
<b>Example 37-6. A somewhat more elaborate address database</b><br>
#!/bin/bash4<br>
# fetch_address-2.sh<br>
# A more elaborate version of fetch_address.sh.<br>
SUCCESS=0<br>
E_DB=99 &nbsp; &nbsp;# Error code for missing entry.<br>
declare -A address<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
543<br>
<hr>
<A name=550></a><IMG src="abs-guide-550_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; -A option declares associative array.<br>
store_address ()<br>
{<br>
&nbsp; address[$1]=&quot;$2&quot;<br>
&nbsp; return $?<br>
}<br>
fetch_address ()<br>
{<br>
&nbsp; if [[ -z &quot;${address[$1]}&quot; ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$1's address is not in database.&quot;<br>
&nbsp; &nbsp; return $E_DB<br>
&nbsp; fi<br>
&nbsp; echo &quot;$1's address is ${address[$1]}.&quot;<br>
&nbsp; return $?<br>
}<br>
store_address &quot;Lucas Fayne&quot; &quot;414 W. 13th Ave., Baltimore, MD 21236&quot;<br>
store_address &quot;Arvid Boyce&quot; &quot;202 E. 3rd St., New York, NY 10009&quot;<br>
store_address &quot;Velma Winston&quot; &quot;1854 Vermont Ave, Los Angeles, CA 90023&quot;<br>
# &nbsp;Exercise:<br>
# &nbsp;Rewrite the above store_address calls to read data from a file,<br>
#+ then assign field 1 to name, field 2 to address in the array.<br>
# &nbsp;Each line in the file would have a format corresponding to the above.<br>
# &nbsp;Use a while-read loop to read from file, sed or awk to parse the fields.<br>
fetch_address &quot;Lucas Fayne&quot;<br>
# Lucas Fayne's address is 414 W. 13th Ave., Baltimore, MD 21236.<br>
fetch_address &quot;Velma Winston&quot;<br>
# Velma Winston's address is 1854 Vermont Ave, Los Angeles, CA 90023.<br>
fetch_address &quot;Arvid Boyce&quot;<br>
# Arvid Boyce's address is 202 E. 3rd St., New York, NY 10009.<br>
fetch_address &quot;Bozo Bozeman&quot;<br>
# Bozo Bozeman's address is not in database.<br>
exit $? &nbsp; # In this case, exit code = 99, since that is function return.<br>
<a href="abs-guides.html#751">See Example A-53 for an interesting usage of an</a><i>&nbsp;associative array</i>.<br>
Elements of the<i>&nbsp;index</i><a href="abs-guides.html#34">&nbsp;array may include embedded space characters, or even leading<br></a>and/or trailing space characters. However, index array elements containing<i>&nbsp;only<br>whitespace</i>&nbsp;are<i>&nbsp;not</i>&nbsp;permitted.<br>
address[ &nbsp; ]=&quot;Blank&quot; &nbsp; # Error!<br>
<a href="abs-guides.html#162">Enhancements to the case construct: the&nbsp;</a><br>
•&nbsp;<br>
<i>;;&amp;</i>&nbsp;and&nbsp;<i>;&amp;</i>&nbsp;terminators.<br>
<b>Example 37-7. Testing characters</b><br>
#!/bin/bash4<br>
test_char ()<br>
{<br>
&nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; [[:print:]] ) &nbsp;echo &quot;$1 is a printable character.&quot;;;&amp; &nbsp; &nbsp; &nbsp; # |<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
544<br>
<hr>
<A name=551></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; # The ;;&amp; terminator continues to the next pattern test. &nbsp; &nbsp; &nbsp;|<br>
&nbsp; &nbsp; [[:alnum:]] ) &nbsp;echo &quot;$1 is an alpha/numeric character.&quot;;;&amp; &nbsp;# v<br>
&nbsp; &nbsp; [[:alpha:]] ) &nbsp;echo &quot;$1 is an alphabetic character.&quot;;;&amp; &nbsp; &nbsp; # v<br>
&nbsp; &nbsp; [[:lower:]] ) &nbsp;echo &quot;$1 is a lowercase alphabetic character.&quot;;;&amp;<br>
&nbsp; &nbsp; [[:digit:]] ) &nbsp;echo &quot;$1 is an numeric character.&quot;;&amp; &nbsp; &nbsp; &nbsp; &nbsp; # |<br>
&nbsp; &nbsp; # The ;&amp; terminator executes the next statement ... &nbsp; &nbsp; &nbsp; &nbsp; # |<br>
&nbsp; &nbsp; %%%@@@@@ &nbsp; &nbsp;) &nbsp;echo &quot;********************************&quot;;; &nbsp; &nbsp;# v<br>
# &nbsp; ^^^^^^^^ &nbsp;... even with a dummy pattern.<br>
&nbsp; esac<br>
}<br>
echo<br>
test_char 3<br>
# 3 is a printable character.<br>
# 3 is an alpha/numeric character.<br>
# 3 is an numeric character.<br>
# ********************************<br>
echo<br>
test_char m<br>
# m is a printable character.<br>
# m is an alpha/numeric character.<br>
# m is an alphabetic character.<br>
# m is a lowercase alphabetic character.<br>
echo<br>
test_char /<br>
# / is a printable character.<br>
echo<br>
# The ;;&amp; terminator can save complex if/then conditions.<br>
# The ;&amp; is somewhat less useful.<br>
The new<br>
•&nbsp;<br>
<b>&nbsp;coproc</b><a href="abs-guides.html#882">&nbsp;builtin enables two parallel processes to communicate and interact. As Chet Ramey</a><br>
<a href="abs-guides.html#569">states in the Bash FAQ&nbsp;</a>[128] , ver. 4.01:&nbsp;<br>
&nbsp; &nbsp; There is a new 'coproc' reserved word that specifies a coprocess:<br>
&nbsp; &nbsp; an asynchronous command run with two pipes connected to the creating<br>
&nbsp; &nbsp; shell. Coprocs can be named. The input and output file descriptors<br>
&nbsp; &nbsp; and the PID of the coprocess are available to the calling shell in<br>
&nbsp; &nbsp; variables with coproc-specific names.<br>
&nbsp; &nbsp; George Dimitriu explains,<br>
&nbsp; &nbsp; &quot;... coproc ... is a feature used in Bash process substitution,<br>
&nbsp; &nbsp; which now is made publicly available.&quot;<br>
&nbsp; &nbsp; This means it can be explicitly invoked in a script, rather than<br>
&nbsp; &nbsp; just being a behind-the-scenes mechanism used by Bash.<br>
&nbsp; &nbsp; See http://linux010.blogspot.com/2008/12/bash-process-substitution.html.<br>
Coprocesses use<i>&nbsp;file descriptors</i><a href="abs-guides.html#376">. File descriptors enable processes and pipes to communicate.</a><br>
#!/bin/bash4<br>
# A coprocess communicates with a while-read loop.<br>
coproc { cat mx_data.txt; sleep 2; }<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
545<br>
<hr>
<A name=552></a><IMG src="abs-guide-552_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^<br>
# Try running this without &quot;sleep 2&quot; and see what happens.<br>
while read -u ${COPROC[0]} line &nbsp; &nbsp;# &nbsp;${COPROC[0]} is the<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ file descriptor of the coprocess.<br>
&nbsp; echo &quot;$line&quot; | sed -e 's/line/NOT-ORIGINAL-TEXT/'<br>
done<br>
kill $COPROC_PID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;No longer need the coprocess,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ so kill its PID.<br>
But, be careful!<br>
#!/bin/bash4<br>
echo; echo<br>
a=aaa<br>
b=bbb<br>
c=ccc<br>
coproc echo &quot;one two three&quot;<br>
while read -u ${COPROC[0]} a b c; &nbsp;# &nbsp;Note that this loop<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ runs in a subshell.<br>
&nbsp; echo &quot;Inside while-read loop: &quot;;<br>
&nbsp; echo &quot;a = $a&quot;; echo &quot;b = $b&quot;; echo &quot;c = $c&quot;<br>
&nbsp; echo &quot;coproc file descriptor: ${COPROC[0]}&quot;<br>
done&nbsp;<br>
# a = one<br>
# b = two<br>
# c = three<br>
# So far, so good, but ...<br>
echo &quot;-----------------&quot;<br>
echo &quot;Outside while-read loop: &quot;<br>
echo &quot;a = $a&quot; &nbsp;# a =<br>
echo &quot;b = $b&quot; &nbsp;# b =<br>
echo &quot;c = $c&quot; &nbsp;# c =<br>
echo &quot;coproc file descriptor: ${COPROC[0]}&quot;<br>
echo<br>
# &nbsp;The coproc is still running, but ...<br>
#+ it still doesn't enable the parent process<br>
#+ to &quot;inherit&quot; variables from the child process, the while-read loop.<br>
# &nbsp;Compare this to the &quot;badread.sh&quot; script.<br>
The coprocess is<i>&nbsp;asynchronous</i>, and this might cause a problem. It may terminate<br>before another process has finished communicating with it.<br>
#!/bin/bash4<br>
coproc cpname { for i in {0..10}; do echo &quot;index = $i&quot;; done; }<br>
# &nbsp; &nbsp; &nbsp;^^^^^^ This is a *named* coprocess.<br>
read -u ${cpname[0]}<br>
echo $REPLY &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;index = 0<br>
echo ${COPROC[0]} &nbsp; #+ No output ... the coprocess timed out<br>
# &nbsp;after the first loop iteration.<br>
# However, George Dimitriu has a partial fix.<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
546<br>
<hr>
<A name=553></a>Advanced Bash-Scripting Guide<br>
coproc cpname { for i in {0..10}; do echo &quot;index = $i&quot;; done; sleep 1;<br>
echo hi &gt; myo; cat - &gt;&gt; myo; }<br>
# &nbsp; &nbsp; &nbsp; ^^^^^ This is a *named* coprocess.<br>
echo &quot;I am main&quot;$'\04' &gt;&amp;${cpname[1]}<br>
myfd=${cpname[0]}<br>
echo myfd=$myfd<br>
### while read -u $myfd<br>
### do<br>
### &nbsp; echo $REPLY;<br>
### done<br>
echo $cpname_PID<br>
# &nbsp;Run this with and without the commented-out while-loop, and it is<br>
#+ apparent that each process, the executing shell and the coprocess,<br>
#+ waits for the other to finish writing in its own write-enabled pipe.<br>
The new<br>
•&nbsp;<br>
<b>&nbsp;mapfile</b>&nbsp;builtin makes it possible to load an array with the contents of a text file without<br>
<a href="abs-guides.html#437">using a loop or command substitution.</a><br>
#!/bin/bash4<br>
mapfile Arr1 &lt; $0<br>
# Same result as &nbsp; &nbsp; Arr1=( $(cat $0) )<br>
echo &quot;${Arr1[@]}&quot; &nbsp;# Copies this entire script out to stdout.<br>
echo &quot;--&quot;; echo<br>
# But, not the same as &nbsp; read -a &nbsp; !!!<br>
read -a Arr2 &lt; $0<br>
echo &quot;${Arr2[@]}&quot; &nbsp;# Reads only first line of script into the array.<br>
exit<br>
<a href="abs-guides.html#190">The read builtin got a minor facelift. The&nbsp;</a><br>
•&nbsp;<br>
-t<a href="abs-guides.html#194">&nbsp;timeout option now accepts (decimal) fractional values</a><br>
[129] and the&nbsp;-i&nbsp;option permits preloading the edit buffer.&nbsp;[130] Unfortunately, these enhancements<br>are still a work in progress and not (yet) usable in scripts.<br><a href="abs-guides.html#133">Parameter substitution gets</a><br>
<a href="abs-guides.html#133">•&nbsp;</a><br>
<i>&nbsp;case-modification</i>&nbsp;operators.<br>
#!/bin/bash4<br>
var=veryMixedUpVariable<br>
echo ${var} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# veryMixedUpVariable<br>
echo ${var^} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # VeryMixedUpVariable<br>
# &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;First char --&gt; uppercase.<br>
echo ${var^^} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# VERYMIXEDUPVARIABLE<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; All chars &nbsp;--&gt; uppercase.<br>
echo ${var,} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # veryMixedUpVariable<br>
# &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;First char --&gt; lowercase.<br>
echo ${var,,} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# verymixedupvariable<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; All chars &nbsp;--&gt; lowercase.<br>
•&nbsp;<br>
<a href="abs-guides.html#110">The declare builtin now accepts the&nbsp;</a>-l<i>&nbsp;lowercase</i>&nbsp;and&nbsp;-c<i>&nbsp;capitalize</i>&nbsp;options.<br>
#!/bin/bash4<br>
declare -l var1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Will change to lowercase<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
547<br>
<hr>
<A name=554></a>Advanced Bash-Scripting Guide<br>
var1=MixedCaseVARIABLE<br>
echo &quot;$var1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # mixedcasevariable<br>
# Same effect as &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $var1 | tr A-Z a-z<br>
declare -c var2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Changes only initial char to uppercase.<br>
var2=originally_lowercase<br>
echo &quot;$var2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Originally_lowercase<br>
# NOT the same effect as &nbsp; &nbsp; echo $var2 | tr a-z A-Z<br>
<a href="abs-guides.html#20">Brace expansion has more options.</a><br>
•&nbsp;<br>
<i>Increment/decrement</i>, specified in the final term within braces.<br>
#!/bin/bash4<br>
echo {40..60..2}<br>
# 40 42 44 46 48 50 52 54 56 58 60<br>
# All the even numbers, between 40 and 60.<br>
echo {60..40..2}<br>
# 60 58 56 54 52 50 48 46 44 42 40<br>
# All the even numbers, between 40 and 60, counting backwards.<br>
# In effect, a decrement.<br>
echo {60..40..-2}<br>
# The same output. The minus sign is not necessary.<br>
# But, what about letters and symbols?<br>
echo {X..d}<br>
# X Y Z [ &nbsp;] ^ _ ` a b c d<br>
# Does not echo the \ which escapes a space.<br>
<i>Zero-padding</i>, specified in the first term within braces, prefixes each term in the output with the<i>&nbsp;same<br>number</i>&nbsp;of zeroes.<br>
bash4$&nbsp;<b>echo {010..15}<br></b>010 011 012 013 014 015<br>
bash4$&nbsp;<b>echo {000..10}<br></b>000 001 002 003 004 005 006 007 008 009 010<br>
•&nbsp;<br>
<a href="abs-guides.html#554"><i>Substring extraction</i>&nbsp;on<i>&nbsp;positional parameters</i>&nbsp;now starts with $0 as the</a><i>&nbsp;zero-index</i>. (This corrects an<br>inconsistency in the treatment of positional parameters.)<br>
#!/bin/bash<br>
# show-params.bash<br>
# Requires version 4+ of Bash.<br>
# Invoke this scripts with at least one positional parameter.<br>
E_BADPARAMS=99<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage $0 param1 ...&quot;<br>
&nbsp; exit $E_BADPARAMS<br>
fi<br>
echo ${@:0}<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
548<br>
<hr>
<A name=555></a>Advanced Bash-Scripting Guide<br>
# bash3 show-params.bash4 one two three<br>
# one two three<br>
# bash4 show-params.bash4 one two three<br>
# show-params.bash4 one two three<br>
# $0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$1 &nbsp;$2 &nbsp;$3<br>
<a href="abs-guides.html#358">The new ** globbing operator matches filenames and directories recursively.</a><br>
•&nbsp;<br>
#!/bin/bash4<br>
# filelist.bash4<br>
shopt -s globstar &nbsp;# Must enable globstar, otherwise ** doesn't work.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The globstar shell option is new to version 4 of Bash.<br>
echo &quot;Using *&quot;; echo<br>
for filename in *<br>
do<br>
&nbsp; echo &quot;$filename&quot;<br>
done &nbsp; # Lists only files in current directory ($PWD).<br>
echo; echo &quot;--------------&quot;; echo<br>
echo &quot;Using **&quot;<br>
for filename in **<br>
do<br>
&nbsp; echo &quot;$filename&quot;<br>
done &nbsp; # Lists complete file tree, recursively.<br>
exit<br>
Using *<br>
allmyfiles<br>
filelist.bash4<br>
--------------<br>
Using **<br>
allmyfiles<br>
allmyfiles/file.index.txt<br>
allmyfiles/my_music<br>
allmyfiles/my_music/me-singing-60s-folksongs.ogg<br>
allmyfiles/my_music/me-singing-opera.ogg<br>
allmyfiles/my_music/piano-lesson.1.ogg<br>
allmyfiles/my_pictures<br>
allmyfiles/my_pictures/at-beach-with-Jade.png<br>
allmyfiles/my_pictures/picnic-with-Melissa.png<br>
filelist.bash4<br>
<a href="abs-guides.html#91">The new $BASHPID internal variable.</a><br>
•&nbsp;<br>•&nbsp;<br>
<a href="abs-guides.html#186">There is a new builtin error-handling function named</a><b>&nbsp;command_not_found_handle</b>.<br>
#!/bin/bash4<br>
command_not_found_handle ()<br>
{ # Accepts implicit parameters.<br>
&nbsp; echo &quot;The following command is not valid: \&quot;&quot;$1\&quot;&quot;&quot;<br>
&nbsp; echo &quot;With the following argument(s): \&quot;&quot;$2\&quot;&quot; \&quot;&quot;$3\&quot;&quot;&quot; &nbsp; # $4, $5 ...<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
549<br>
<hr>
<A name=556></a>Advanced Bash-Scripting Guide<br>
} # $1, $2, etc. are not explicitly passed to the function.<br>
bad_command arg1 arg2<br>
# The following command is not valid: &quot;bad_command&quot;<br>
# With the following argument(s): &quot;arg1&quot; &quot;arg2&quot;<br>
<i>Editorial comment</i><br>
Associative arrays? Coprocesses? Whatever happened to the lean and mean Bash we have come to know<br>and love? Could it be suffering from (horrors!) &quot;feature creep&quot;? Or perhaps even Korn shell envy?<br>
<i>Note to Chet Ramey:</i>&nbsp;Please add only<i>&nbsp;essential</i>&nbsp;features in future Bash releases -- perhaps<i>&nbsp;for-each</i>&nbsp;loops and<br>support for multi-dimensional arrays.&nbsp;[131] Most Bash users won't need, won't use, and likely won't greatly<br>appreciate complex &quot;features&quot; like built-in debuggers, Perl interfaces, and bolt-on rocket boosters.<br>
<b>37.3.1. Bash, version 4.1</b><br>
Version 4.1 of Bash, released in May, 2010, was primarily a bugfix update.<br>
<a href="abs-guides.html#188">The printf command now accepts a&nbsp;</a><br>
•&nbsp;<br>
-v<a href="abs-guides.html#427">&nbsp;option for setting array indices.</a><br>
<a href="abs-guides.html#65">Within double brackets, the</a><br>
•&nbsp;<br>
<b>&nbsp;&gt;</b>&nbsp;and<b>&nbsp;&lt;</b><a href="abs-guides.html#799">&nbsp;string comparison operators now conform to the locale. Since the</a><br>
locale setting may affect the sorting order of string expressions, this has side-effects on comparison<br>tests within<i>&nbsp;[[ ... ]]</i>&nbsp;expressions.<br><a href="abs-guides.html#190">The read builtin now takes a&nbsp;</a><br>
•&nbsp;<br>
-N&nbsp;option (<i>read -N chars</i>), which causes the<i>&nbsp;read</i>&nbsp;to terminate after<br>
<i>chars</i>&nbsp;characters.<br>
<b>Example 37-8. Reading N characters</b><br>
#!/bin/bash<br>
# Requires Bash version -ge 4.1 ...<br>
num_chars=61<br>
read -N $num_chars var &lt; $0 &nbsp; # Read first 61 characters of script!<br>
echo &quot;$var&quot;<br>
exit<br>
####### Output of Script #######<br>
#!/bin/bash<br>
# Requires Bash version -ge 4.1 ...<br>
num_chars=61<br>
<a href="abs-guides.html#360">Here documents embedded in &nbsp;</a><br>
<a href="abs-guides.html#360">•&nbsp;</a><br>
<a href="abs-guides.html#40"><b>$( ... )</b>&nbsp;command substitution constructs may terminate with a</a><br>
simple<b>&nbsp;)</b>.<br>
<b>Example 37-9. Using a<i>&nbsp;here document</i></b><b>&nbsp;to set a variable</b><br>
#!/bin/bash<br>
# here-commsub.sh<br>
# Requires Bash version -ge 4.1 ...<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
550<br>
<hr>
<A name=557></a>Advanced Bash-Scripting Guide<br>
multi_line_var=$( cat &lt;&lt;ENDxxx<br>
------------------------------<br>
This is line 1 of the variable<br>
This is line 2 of the variable<br>
This is line 3 of the variable<br>
------------------------------<br>
ENDxxx)<br>
# &nbsp;Rather than what Bash 4.0 requires:<br>
#+ that the terminating limit string and<br>
#+ the terminating close-parenthesis be on separate lines.<br>
# ENDxxx<br>
# )<br>
echo &quot;$multi_line_var&quot;<br>
# &nbsp;Bash still emits a warning, though.<br>
# &nbsp;warning: here-document at line 10 delimited<br>
#+ by end-of-file (wanted `ENDxxx')<br>
<b>37.3.2. Bash, version 4.2</b><br>
Version 4.2 of Bash, released in February, 2011, contains a number of new features and enhancements, in<br>addition to bugfixes.<br>
Bash now supports the the&nbsp;<br>
•&nbsp;<br>
<i>\u</i>&nbsp;and&nbsp;<i>\U&nbsp;Unicode</i>&nbsp;escape.<br>
Unicode is a cross-platform standard for encoding into numerical values letters and graphic<br>symbols. This permits representing and displaying characters in foreign alphabets and unusual fonts.<br>
echo -e '\u2630' &nbsp; # Horizontal triple bar character.<br>
# Equivalent to the more roundabout:<br>
echo -e &quot;\xE2\x98\xB0&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Recognized by earlier Bash versions.<br>
echo -e '\u220F' &nbsp; # PI (Greek letter and mathematical symbol)<br>
echo -e '\u0416' &nbsp; # Capital &quot;ZHE&quot; (Cyrillic letter)<br>
echo -e '\u2708' &nbsp; # Airplane (Dingbat font) symbol<br>
echo -e &quot;The amplifier circuit requires a 100 \u2126 pull-up resistor.&quot;<br>
unicode_var='\u2640'<br>
echo -e $unicode_var &nbsp; &nbsp; &nbsp;# Female symbol<br>
printf &quot;$unicode_var \n&quot; &nbsp;# Female symbol, with newline<br>
# &nbsp;And for something a bit more elaborate . . .<br>
# &nbsp;We can store Unicode symbols in an associative array,<br>
#+ then retrieve them by name.<br>
# &nbsp;Run this in a gnome-terminal or a terminal with a large, bold font<br>
#+ for better legibility.<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
551<br>
<hr>
<A name=558></a><IMG src="abs-guide-558_1.png"><br>
Advanced Bash-Scripting Guide<br>
declare -A symbol &nbsp;# Associative array.<br>
symbol[script_E]='\u2130'<br>
symbol[script_F]='\u2131'<br>
symbol[script_J]='\u2110'<br>
symbol[script_M]='\u2133'<br>
symbol[Rx]='\u211E'<br>
symbol[TEL]='\u2121'<br>
symbol[FAX]='\u213B'<br>
symbol[care_of]='\u2105'<br>
symbol[account]='\u2100'<br>
symbol[trademark]='\u2122'<br>
echo -ne &quot;${symbol[script_E]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[script_F]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[script_J]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[script_M]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[Rx]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[TEL]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[FAX]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[care_of]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[account]} &nbsp; &quot;<br>
echo -ne &quot;${symbol[trademark]} &nbsp; &quot;<br>
echo<br>
<a href="abs-guides.html#50">The above example uses the&nbsp;<b>$' ... '</b><i>&nbsp;string-expansion</i></a>&nbsp;construct.<br>
•&nbsp;<br>
When the&nbsp;<i>lastpipe</i><a href="abs-guides.html#24">&nbsp;shell option is set, the last command in a pipe</a><i>&nbsp;doesn't run in a subshell</i>.<br>
<a href="abs-guides.html#190"><b>Example 37-10. Piping input to a read</b></a><br>
#!/bin/bash<br>
# lastpipe-option.sh<br>
line='' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Null value.<br>
echo &quot;\$line = &quot;$line&quot;&quot; &nbsp; # $line =<br>
echo<br>
shopt -s lastpipe &nbsp; &nbsp; &nbsp; &nbsp; # Error on Bash version -lt 4.2.<br>
echo &quot;Exit status of attempting to set \&quot;lastpipe\&quot; option is $?&quot;<br>
# &nbsp; &nbsp; 1 if Bash version -lt 4.2, 0 otherwise.<br>
echo<br>
head -1 $0 | read line &nbsp; &nbsp;# Pipe the first line of the script to read.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^^^ &nbsp; &nbsp; &nbsp;Not in a subshell!!!<br>
echo &quot;\$line = &quot;$line&quot;&quot;<br>
# Older Bash releases &nbsp; &nbsp; &nbsp; $line =<br>
# Bash version 4.2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$line = #!/bin/bash<br>
<a href="abs-guides.html#495">This option offers possible &quot;fixups&quot; for these example scripts: Example 34-3 and Example 15-8.<br></a><a href="abs-guides.html#427">Negative array indices permit counting backwards from the end of an array.</a><br>
•&nbsp;<br>
<b>Example 37-11. Negative array indices</b><br>
Chapter 37. Bash, versions 2, 3, and 4<br>
552<br>
<hr>
<A name=559></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# neg-array.sh<br>
# Requires Bash, version -ge 4.2.<br>
array=( zero one two three four five ) &nbsp; # Six-element array.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp;1 &nbsp; 2 &nbsp; &nbsp;3 &nbsp; &nbsp;4 &nbsp; &nbsp;5<br>
# &nbsp; &nbsp; &nbsp; &nbsp;-6 &nbsp; -5 &nbsp;-4 &nbsp; -3 &nbsp; -2 &nbsp; -1<br>
# Negative array indices now permitted.<br>
echo ${array[-1]} &nbsp; # five<br>
echo ${array[-2]} &nbsp; # four<br>
# ...<br>
echo ${array[-6]} &nbsp; # zero<br>
# Negative array indices count backward from the last element+1.<br>
# But, you cannot index past the beginning of the array.<br>
echo ${array[-7]} &nbsp; # array: bad array subscript<br>
# So, what is this new feature good for?<br>
echo &quot;The last element in the array is &quot;${array[-1]}&quot;&quot;<br>
# Which is quite a bit more straightforward than:<br>
echo &quot;The last element in the array is &quot;${array[${#array[*]}-1]}&quot;&quot;<br>
echo<br>
# And ...<br>
index=0<br>
let &quot;neg_element_count = 0 - ${#array[*]}&quot;<br>
# Number of elements, converted to a negative number.<br>
while [ $index -gt $neg_element_count ]; do<br>
&nbsp; ((index--)); echo -n &quot;${array[index]} &quot;<br>
done &nbsp;# Lists the elements in the array, backwards.<br>
&nbsp; &nbsp; &nbsp; # We have just simulated the &quot;tac&quot; command on this array.<br>
echo<br>
# See also neg-offset.sh.<br>
<a href="abs-guides.html#126">Substring extraction uses a negative</a><br>
•&nbsp;<br>
<i>&nbsp;length</i>&nbsp;parameter to specify an offset from the<i>&nbsp;end</i>&nbsp;of the target<br>
string.<br>
<b>Example 37-12. Negative parameter in string-extraction construct</b><br>
#!/bin/bash<br>
# Bash, version -ge 4.2<br>
# Negative length-index in substring extraction.<br>
# Important: It changes the interpretation of this construct!<br>
stringZ=abcABC123ABCabc<br>
echo ${stringZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# abcABC123ABCabc<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Position within string: &nbsp; &nbsp;0123456789.....<br>
echo ${stringZ:2:3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp; cAB<br>
# &nbsp;Count 2 chars forward from string beginning, and extract 3 chars.<br>
# &nbsp;${string:position:length}<br>
# &nbsp;So far, nothing new, but now ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# abcABC123ABCabc<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
553<br>
<hr>
<A name=560></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Position within string: &nbsp; &nbsp;0123....6543210<br>
echo ${stringZ:3:-6} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp;ABC123<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^<br>
# &nbsp;Index 3 chars forward from beginning and 6 chars backward from end,<br>
#+ and extract everything in between.<br>
# &nbsp;${string:offset-from-front:offset-from-end}<br>
# &nbsp;When the &quot;length&quot; parameter is negative,&nbsp;<br>
#+ it serves as an offset-from-end parameter.<br>
# &nbsp;See also neg-array.sh.<br>
Chapter 37. Bash, versions 2, 3, and 4<br>
554<br>
<hr>
<A name=561></a><b>Chapter 38. Endnotes</b><br>
<b>38.1. Author's Note</b><br>
<i>doce ut discas</i><br>
<i>(Teach, that you yourself may learn.)</i><br>
How did I come to write a scripting book? It's a strange tale. It seems that a few years back I needed to learn<br>shell scripting -- and what better way to do that than to read a good book on the subject? I was looking to buy<br>a tutorial and reference covering all aspects of the subject. I was looking for a book that would take difficult<br>concepts, turn them inside out, and explain them in excruciating detail, with well-commented examples.&nbsp;[132]<br>In fact, I was looking for<i>&nbsp;this very book</i><a href="abs-guides.html#565">, or something very much like it. Unfortunately, it didn't exist, and if I<br></a>wanted it, I'd have to write it. And so, here we are, folks.<br>
That reminds me of the apocryphal story about a mad professor. Crazy as a loon, the fellow was. At the sight<br>of a book, any book -- at the library, at a bookstore, anywhere -- he would become totally obsessed with the<br>idea that he could have written it, should have written it -- and done a better job of it to boot. He would<br>thereupon rush home and proceed to do just that, write a book with the very same title. When he died some<br>years later, he allegedly had several thousand books to his credit, probably putting even Asimov to shame.<br>The books might not have been any good, who knows, but does that really matter? Here's a fellow who lived<br>his dream, even if he was obsessed by it, driven by it . . . and somehow I can't help admiring the old coot.<br>
<b>38.2. About the Author</b><br>
Who is this guy anyhow?<br>
The author claims no credentials or special qualifications,&nbsp;[133] other than a compulsion to write.&nbsp;[134] This<br><a href="http://bash.webofcrafts.net/hmw60.zip">book is somewhat of a departure from his other major work, &nbsp;HOW-2 Meet Women: The Shy Man's Guide to<br>Relationships. He has also written the Software-Building HOWTO. Of late, he has been trying his (heavy)<br></a>hand at short fiction.<br>
A Linux user since 1995 (Slackware 2.2, kernel 1.2.1), the author has emitted a few software truffles,<br><a href="http://ibiblio.org/pub/Linux/utils/file/cruft-0.2.tar.gz">including the cruft one-time pad encryption utility, the mcalc mortgage calculator, the judge Scrabble®<br></a><a href="http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz">adjudicator, the yawl word gaming list package, and the Quacky anagramming gaming package. He got off to<br></a>a rather shaky start in the computer game -- programming FORTRAN IV on a CDC 3800 (on paper coding<br>pads, no less) -- and is not the least bit nostalgic for those days.<br>
Living in a secluded community with wife and orange tabby, he cherishes human frailty, especially his own.<br>[135]<br>
<b>38.3. Where to Go For Help</b><br>
<a href="mailto:thegrendel.abs@gmail.com">The author will infrequently, if not too busy (and in a good mood), answer general scripting questions.&nbsp;</a>[136]<br>If you have a problem getting a particular script to work, you would be well advised to post to the<br><a href="">comp.os.unix.shell Usenet newsgroup.</a><br>
Chapter 38. Endnotes<br>
555<br>
<hr>
<A name=562></a>Advanced Bash-Scripting Guide<br>
If you need assistance with a schoolwork assignment, read the pertinent sections of this and other reference<br>works. Do your best to solve the problem using your own wits and resources. Please do not waste the<br>author's time. You will get neither help nor sympathy.&nbsp;[137]<br>
Likewise, kindly refrain from annoying the author with solicitations, offers of employment, or &quot;business<br>opportunities.&quot; He is doing just fine, and requires neither help nor sympathy, thank you.<br>
<i>... sophisticated in mechanism but possibly agile<br>operating under noises being extremely<br>suppressed ...</i><br>
<i>--CI-300 printer manual</i><br>
<b>38.4. Tools Used to Produce This Book</b><br>
<b>38.4.1. Hardware</b><br>
A used IBM Thinkpad, model 760XL laptop (P166, 104 meg RAM) running Red Hat 7.1/7.3. Sure, it's slow<br>and has a funky keyboard, but it beats the heck out of a No. 2 pencil and a Big Chief tablet.<br>
<i>Update:</i>&nbsp;upgraded to a 770Z Thinkpad (P2-366, 192 meg RAM) running FC3. Anyone feel like donating a<br>later-model laptop to a starving writer &lt;g&gt;?<br>
<i>Update:</i>&nbsp;upgraded to a T60 Thinkpad running Mandriva 2010. No longer starving &lt;g&gt;.<br>
<b>38.4.2. Software and Printware</b><br>
<a href="http://www.vim.org">Bram Moolenaar's powerful SGML-aware vim text editor.</a><br>
i.&nbsp;<br>
<a href="http://www.netfolder.com/DSSSL/">OpenJade, a DSSSL rendering engine for converting SGML documents into other formats.</a><br>
ii.&nbsp;<br>
<a href="http://nwalsh.com/docbook/dsssl/">Norman Walsh's DSSSL stylesheets.</a><br>
iii.&nbsp;<br>
<i>DocBook, The Definitive Guide</i><br>
iv.&nbsp;<br>
, by Norman Walsh and Leonard Muellner (O'Reilly, ISBN<br>
1-56592-580-7). This is still the standard reference for anyone attempting to write a document in<br>Docbook SGML format.<br>
<b>38.5. Credits</b><br>
<i>Community participation made this project possible.</i>&nbsp;The author gratefully acknowledges that writing this<br>book would have been unthinkable without help and feedback from all you people out there.<br>
<a href="mailto:feloy@free.fr">Philippe Martin translated the first version (0.1) of this document into DocBook/SGML. While not on the job<br></a>at a small French company as a software developer, he enjoys working on GNU/Linux documentation and<br>software, reading literature, playing music, and, for his peace of mind, making merry with friends. You may<br><a href="mailto:feloy@free.fr">run across him somewhere in France or in the Basque Country, or you can email him at feloy@free.fr.</a><br>
Philippe Martin also pointed out that positional parameters past $9 are possible using {bracket} notation. (See<br><a href="abs-guides.html#42">Example 4-5).</a><br>
<a href="mailto:stephane_chazelas@yahoo.fr">Stéphane Chazelas sent a long list of corrections, additions, and example scripts. More than a contributor, he<br></a>had, in effect, for a while taken on the role of<i>&nbsp;co-editor</i>&nbsp;for this document.<i>&nbsp;Merci beaucoup!</i><br>
Chapter 38. Endnotes<br>
556<br>
<hr>
<A name=563></a>Advanced Bash-Scripting Guide<br>
Paulo Marcel Coelho Aragao offered many corrections, both major and minor, and contributed quite a number<br>of helpful suggestions.<br>
I would like to especially thank<i>&nbsp;Patrick Callahan</i>,<i>&nbsp;Mike Novak</i>, and<i>&nbsp;Pal Domokos</i>&nbsp;for catching bugs, pointing<br>out ambiguities, and for suggesting clarifications and changes in the preliminary version (0.1) of this<br>document. Their lively discussion of shell scripting and general documentation issues inspired me to try to<br>make this document more readable.<br>
I'm grateful to Jim Van Zandt for pointing out errors and omissions in version 0.2 of this document. He also<br><a href="abs-guides.html#591">contributed an instructive example script.</a><br>
<a href="mailto:mikaku@fiwix.org">Many thanks to Jordi Sanfeliu for giving permission to use his fine tree script (Example A-16), and to Rick<br></a>Boivie for revising it.<br>
<a href="mailto:charpov@cs.unh.edu">Likewise, thanks to Michel Charpentier for permission to use his dc factoring script (Example 16-52).</a><br>
<a href="mailto:friedman@prep.ai.mit.edu">Kudos to Noah Friedman for permission to use his string function script (Example A-18).</a><br>
<a href="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel Rouat suggested corrections and additions on command substitution and aliases. He also<br></a>contributed a very nice sample&nbsp;.bashrc<a href="abs-guides.html#804">&nbsp;file (Appendix L).</a><br>
<a href="mailto:heiner.steven@odn.de">Heiner Steven kindly gave permission to use his base conversion script, Example 16-48. He also made a<br></a>number of corrections and many helpful suggestions. Special thanks.<br>
Rick Boivie contributed the delightfully recursive<i>&nbsp;pb.sh</i><a href="abs-guides.html#509">&nbsp;script (Example 36-9), revised the</a><i>&nbsp;tree.sh</i>&nbsp;script<br><a href="abs-guides.html#593">(Example A-16), and suggested performance improvements for the</a><i>&nbsp;monthlypmt.sh</i><a href="abs-guides.html#297">&nbsp;script (Example 16-47).</a><br>
<a href="abs-guides.html#74">Florian Wisser enlightened me on some of the fine points of testing strings (see Example 7-6), and on other<br></a>matters.<br>
<a href="abs-guides.html#242">Oleg Philon sent suggestions concerning cut and pidof.</a><br>
<a href="abs-guides.html#434">Michael Zick extended the empty array example to demonstrate some surprising array properties. He also<br></a>contributed the<i>&nbsp;isspammer</i><a href="abs-guides.html#282">&nbsp;scripts (Example 16-41 and Example A-28).</a><br>
Marc-Jano Knopp sent corrections and clarifications on DOS batch files.<br>
Hyun Jin Cha found several typos in the document in the process of doing a Korean translation. Thanks for<br>pointing these out.<br>
Andreas Abraham sent in a long list of typographical errors and other corrections. Special thanks!<br>
Others contributing scripts, making helpful suggestions, and pointing out errors were Gabor Kiss, Leopold<br>Toetsch, Peter Tillier, Marcus Berglof, Tony Richardson, Nick Drage (script ideas!), Rich Bartell, Jess<br>Thrysoee, Adam Lazur, Bram Moolenaar, Baris Cicek, Greg Keraunen, Keith Matthews, Sandro Magi, Albert<br>Reiner, Dim Segebart, Rory Winston, Lee Bigelow, Wayne Pollock, &quot;jipe,&quot; &quot;bojster,&quot; &quot;nyal,&quot; &quot;Hobbit,&quot;<br>&quot;Ender,&quot; &quot;Little Monster&quot; (Alexis), &quot;Mark,&quot; &quot;Patsie,&quot; &quot;vladz,&quot; Peggy Russell, Emilio Conti, Ian. D. Allen,<br>Hans-Joerg Diers, Arun Giridhar, Dennis Leeuw, Dan Jacobson, Aurelio Marinho Jargas, Edward Scholtz,<br>Jean Helou, Chris Martin, Lee Maschmeyer, Bruno Haible, Wilbert Berendsen, Sebastien Godard, Bjön<br>Eriksson, John MacDonald, John Lange, Joshua Tschida, Troy Engel, Manfred Schwarb, Amit Singh, Bill<br>Gradwohl, E. Choroba, David Lombard, Jason Parker, Steve Parker, Bruce W. Clare, William Park, Vernia<br>
Chapter 38. Endnotes<br>
557<br>
<hr>
<A name=564></a>Advanced Bash-Scripting Guide<br>
Damiano, Mihai Maties, Mark Alexander, Jeremy Impson, Ken Fuchs, Jared Martin, Frank Wang, Sylvain<br>Fourmanoit, Matthew Sage, Matthew Walker, Kenny Stauffer, Filip Moritz, Andrzej Stefanski, Daniel Albers,<br>Jeffrey Haemer, Stefano Palmeri, Nils Radtke, Sigurd Solaas, Serghey Rodin, Jeroen Domburg, Alfredo<br>Pironti, Phil Braham, Bruno de Oliveira Schneider, Stefano Falsetto, Chris Morgan, Walter Dnes, Linc<br>Fessenden, Michael Iatrou, Pharis Monalo, Jesse Gough, Fabian Kreutz, Mark Norman, Harald Koenig, Dan<br>Stromberg, Peter Knowles, Francisco Lobo, Mariusz Gniazdowski, Sebastian Arming, Chetankumar<br>Phulpagare, Benno Schulenberg, Tedman Eng, Jochen DeSmet, Juan Nicolas Ruiz, Oliver Beckstein, Achmed<br>Darwish, Dotan Barak, Richard Neill, Albert Siersema, Omair Eshkenazi, Geoff Lee, Graham Ewart, JuanJo<br>Ciarlante, Cliff Bamford, Nathan Coulter, Ramses Rodriguez Martinez, Evgeniy Ivanov, Craig Barnes,<br>George Dimitriu, Kevin LeBlanc, Antonio Macchi, Tomas Pospisek, Andreas Kühne, Pádraig Brady, and<br>David Lawyer (himself an author of four HOWTOs).<br>
<a href="mailto:chet@po.cwru.edu">My gratitude to Chet Ramey and Brian Fox for writing</a><i>&nbsp;Bash</i>, and building into it elegant and powerful<br>scripting capabilities rivaling those of<i>&nbsp;ksh</i>.<br>
<a href="http://www.tldp.org">Very special thanks to the hard-working volunteers at the Linux Documentation Project. The LDP hosts a<br></a>repository of Linux knowledge and lore, and has, to a great extent, enabled the publication of this book.<br>
<a href="http://www.fsf.org">Thanks and appreciation to IBM, Red Hat, Google, the Free Software Foundation, and all the good people<br></a>fighting the good fight to keep Open Source software free and open.<br>
Belated thanks to my fourth grade teacher, Miss Spencer, for emotional support and for convincing me that<br>maybe, just maybe I wasn't a total loss.<br>
Thanks most of all to my wife, Anita, for her encouragement, inspiration, and emotional support.<br>
<b>38.6. Disclaimer</b><br>
<a href="http://www.tldp.org">(This is a variant of the standard LDP disclaimer.)</a><br>
No liability for the contents of this document can be accepted. Use the concepts, examples and information at<br>your own risk. There may be errors, omissions, and inaccuracies that could cause you to lose data, harm your<br>system, or induce involuntary electrocution, so<i>&nbsp;proceed with appropriate caution</i>. The author takes no<br>responsibility for any damages, incidental or otherwise.<br>
As it happens, it is highly unlikely that either you or your system will suffer ill effects, aside from<br>uncontrollable hiccups. In fact, the<i>&nbsp;raison d'etre</i>&nbsp;of this book is to enable its readers to analyze shell scripts<br><a href="abs-guides.html#490">and determine whether they have unanticipated consequences.</a><br>
Chapter 38. Endnotes<br>
558<br>
<hr>
<A name=565></a><b>Bibliography</b><br>
<i>Those who do not understand UNIX are<br>condemned to reinvent it, poorly.</i><br>
<i>--Henry Spencer</i><br>
Edited by Peter Denning,<i>&nbsp;Computers Under Attack: Intruders, Worms, and Viruses</i>, ACM Press, 1990,<br>0-201-53067-8.<br>
This compendium contains a couple of articles on shell script viruses.<br>
*<br>
Ken Burtch,<a href="http://www.samspublishing.com/title/0672326426"><i>&nbsp;Linux Shell Scripting with Bash</i>, 1st edition, Sams Publishing (Pearson), 2004, 0672326426.</a><br>
Covers much of the same material as the<i>&nbsp;ABS Guide</i>, though in a different style.<br>
*<br>
Dale Dougherty and Arnold Robbins,<i>&nbsp;Sed and Awk</i>, 2nd edition, O'Reilly and Associates, 1997,<br>1-156592-225-5.<br>
Unfolding the full power of shell scripting requires at least a passing familiarity with&nbsp;<a href="abs-guides.html#781"><i>sed</i>&nbsp;and<i>&nbsp;awk</i>. This is the<br></a>standard tutorial. It includes an excellent introduction to<i>&nbsp;Regular Expressions</i>. Recommended.<br>
*<br>
Jeffrey Friedl,<i>&nbsp;Mastering Regular Expressions</i>, O'Reilly and Associates, 2002, 0-596-00289-0.<br>
<a href="abs-guides.html#354">Still the best all-around reference on Regular Expressions.</a><br>
*<br>
Aeleen Frisch,<i>&nbsp;Essential System Administration</i>, 3rd edition, O'Reilly and Associates, 2002, 0-596-00343-9.<br>
This excellent manual provides a decent introduction to shell scripting from a sys admin point of view. It<br>includes comprehensive explanations of the startup and initialization scripts in a UNIX system.<br>
*<br>
Stephen Kochan and Patrick Wood,<i>&nbsp;Unix Shell Programming</i>, Hayden, 1990, 067248448X.<br>
Bibliography<br>
559<br>
<hr>
<A name=566></a>Advanced Bash-Scripting Guide<br>
Still considered a standard reference, though somewhat dated, and a bit &quot;wooden&quot; stylistically speaking.&nbsp;[138]<br>In fact, this book was the<i>&nbsp;ABS Guide</i>&nbsp;author's first exposure to UNIX shell scripting, lo these many years ago.<br>
<a href="http://www.kochan-wood.com/">For more information, see the Kochan-Wood website.</a><br>
*<br>
Neil Matthew and Richard Stones,<i>&nbsp;Beginning Linux Programming</i>, Wrox Press, 1996, 1874416680.<br>
Surprisingly good in-depth coverage of various programming languages available for Linux, including a fairly<br>strong chapter on shell scripting.<br>
*<br>
Herbert Mayer,<i>&nbsp;Advanced C Programming on the IBM PC</i>, Windcrest Books, 1989, 0830693637.<br>
Excellent coverage of algorithms and general programming practices. Highly recommended, but unfortunately<br>out of print.<br>
*<br>
David Medinets,<i>&nbsp;Unix Shell Programming Tools</i>, McGraw-Hill, 1999, 0070397333.<br>
Pretty good treatment of shell scripting, with examples, and a short intro to Tcl and Perl.<br>
*<br>
Cameron Newham and Bill Rosenblatt,<i>&nbsp;Learning the Bash Shell</i>, 2nd edition, O'Reilly and Associates, 1998,<br>1-56592-347-2.<br>
This is a valiant effort at a decent shell primer, but sadly deficient in its coverage of writing scripts and<br>lacking sufficient examples.<br>
*<br>
Anatole Olczak,<i>&nbsp;Bourne Shell Quick Reference Guide</i>, ASP, Inc., 1991, 093573922X.<br>
A very handy pocket reference, despite lacking coverage of Bash-specific features.<br>
*<br>
Jerry Peek, Tim O'Reilly, and Mike Loukides,<i>&nbsp;Unix Power Tools</i>, 3rd edition, O'Reilly and Associates,<br>Random House, 2002, 0-596-00330-7.<br>
Bibliography<br>
560<br>
<hr>
<A name=567></a>Advanced Bash-Scripting Guide<br>
Contains a couple of sections of very informative in-depth articles on shell programming, but falls short of<br><a href="abs-guides.html#354">being a self-teaching manual. It reproduces much of the Regular Expressions tutorial from the Dougherty and<br></a>Robbins book, above. The comprehensive coverage of UNIX commands makes this book worthy of a place<br>on your bookshelf.<br>
*<br>
Clifford Pickover,<i>&nbsp;Computers, Pattern, Chaos, and Beauty</i>, St. Martin's Press, 1990, 0-312-04123-3.<br>
A treasure trove of ideas and recipes for computer-based exploration of mathematical oddities.<br>
*<br>
George Polya,<i>&nbsp;How To Solve It</i>, Princeton University Press, 1973, 0-691-02356-5.<br>
The classic tutorial on problem-solving methods (i.e., algorithms), with special emphasis on how to teach<br>them.<br>
*<br>
Chet Ramey and Brian Fox,<a href="http://www.network-theory.co.uk/bash/manual/"><i>&nbsp;The GNU Bash Reference Manual</i>, Network Theory Ltd, 2003, 0-9541617-7-7.</a><br>
This manual is the definitive reference for GNU Bash. The authors of this manual, Chet Ramey and Brian<br>Fox, are the original developers of GNU Bash. For each copy sold, the publisher donates $1 to the Free<br>Software Foundation.<br>
*<br>
Arnold Robbins,<i>&nbsp;Bash Reference Card</i>, SSC, 1998, 1-58731-010-5.<br>
Excellent Bash pocket reference (don't leave home without it, especially if you're a sysadmin). A bargain at<br>$4.95, but unfortunately no longer available for free download.<br>
*<br>
Arnold Robbins,<i>&nbsp;Effective Awk Programming</i>, Free Software Foundation / O'Reilly and Associates, 2000,<br>1-882114-26-4.<br>
<a href="abs-guides.html#784">The absolute best awk tutorial and reference. The free electronic version of this book is part of the</a><i>&nbsp;awk<br></i>documentation, and printed copies of the latest version are available from O'Reilly and Associates.<br>
This book has served as an inspiration for the author of the<i>&nbsp;ABS Guide</i>.<br>
*<br>
Bibliography<br>
561<br>
<hr>
<A name=568></a>Advanced Bash-Scripting Guide<br>
Bill Rosenblatt,<i>&nbsp;Learning the Korn Shell</i>, O'Reilly and Associates, 1993, 1-56592-054-6.<br>
This well-written book contains some excellent pointers on shell scripting in general.<br>
*<br>
Paul Sheer,<i>&nbsp;LINUX: Rute User's Tutorial and Exposition</i>, 1st edition, , 2002, 0-13-033351-4.<br>
Very detailed and readable introduction to Linux system administration.<br>
<a href="http://burks.brighton.ac.uk/burks/linux/rute/rute.htm">The book is available in print, or on-line.</a><br>
*<br>
Ellen Siever and the staff of O'Reilly and Associates,<i>&nbsp;Linux in a Nutshell</i>, 2nd edition, O'Reilly and<br>Associates, 1999, 1-56592-585-8.<br>
The all-around best Linux command reference. It even has a Bash section.<br>
*<br>
Dave Taylor,<i>&nbsp;Wicked Cool Shell Scripts: 101 Scripts for Linux, Mac OS X, and Unix Systems</i>, 1st edition, No<br>Starch Press, 2004, 1-59327-012-7.<br>
Just what the title promises . . .<br>
*<br>
<i>The UNIX CD Bookshelf</i>, 3rd edition, O'Reilly and Associates, 2003, 0-596-00392-7.<br>
An array of seven UNIX books on CD ROM, including<i>&nbsp;UNIX Power Tools</i>,<i>&nbsp;Sed and Awk</i>, and<i>&nbsp;Learning the<br>Korn Shell</i>. A complete set of all the UNIX references and tutorials you would ever need at about $130. Buy<br>this one, even if it means going into debt and not paying the rent.<br>
Update: Seems to have somehow fallen out of print. Ah, well. You can still buy the dead-tree editions of these<br>books.<br>
*<br>
The O'Reilly books on Perl. (Actually,<i>&nbsp;any</i>&nbsp;O'Reilly books.)<br>
* * *<br>
<b>Other Resources</b><br>
Bibliography<br>
562<br>
<hr>
<A name=569></a>Advanced Bash-Scripting Guide<br>
<a href="">Fioretti, Marco, &quot;Scripting for X Productivity,&quot;&nbsp;<i>Linux Journal</i></a>, Issue 113, September, 2003, pp. 86-9.<br>
Ben Okopnik's well-written<i>&nbsp;introductory Bash scripting</i><a href="http://www.linuxgazette.net">&nbsp;articles in issues 53, 54, 55, 57, and 59 of the&nbsp;<i>Linux<br>Gazette</i>, and his explanation of &quot;The Deep, Dark Secrets of Bash&quot; in issue 56.</a><br>
Chet Ramey's<i>&nbsp;Bash - The GNU Shell</i><a href="http://www.linuxjournal.com">, a two-part series published in issues 3 and 4 of the&nbsp;<i>Linux Journal</i></a>,<br>July-August 1994.<br>
<a href="http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">Mike G's Bash-Programming-Intro HOWTO.</a><br>
<a href="http://www.injunea.demon.co.uk/index.htm">Richard's Unix Scripting Universe.</a><br>
<a href="http://tiswww.case.edu/php/chet/bash/FAQ">Chet Ramey's Bash FAQ.</a><br>
<a href="http://wooledge.org:8000/BashFAQ">Greg's WIKI: Bash FAQ.</a><br>
<a href="http://alge.anart.no/linux/scripts/">Example shell scripts at Lucc's Shell Scripts .</a><br>
<a href="http://www.shelldorado.com">Example shell scripts at SHELLdorado .</a><br>
<a href="http://www.splode.com/~friedman/software/scripts/src/">Example shell scripts at Noah Friedman's script site.</a><br>
<a href="http://bashcookbook.com/bashinfo/">Examples from the</a><i>&nbsp;The Bash Scripting Cookbook</i>, by Albing, Vossen, and Newham.<br>
<a href="http://www.zazzybob.com">Example shell scripts at zazzybob.</a><br>
<a href="http://steve-parker.org/sh/sh.shtml">Steve Parker's Shell Programming Stuff. In fact, all of his shell scripting books are highly recommended. See<br></a><a href="http://nixshell.wordpress.com/2011/07/13/arcade-games-written-in-a-shell-script/">also Steve's Arcade Games written in a shell script.</a><br>
<a href="http://www.bash-hackers.org/wiki.doku.php">An excellent collection of Bash scripting tips, tricks, and resources at the Bash Hackers Wiki.</a><br>
<a href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/">Giles Orr's Bash-Prompt HOWTO.</a><br>
The&nbsp;<a href="http://www.pixelbeat.org/cmdline.html"><i>Pixelbeat</i>&nbsp;command-line reference.</a><br>
Bibliography<br>
563<br>
<hr>
<A name=570></a>Advanced Bash-Scripting Guide<br>
Very nice<b>&nbsp;sed</b>,<b>&nbsp;awk</b><a href="http://www.grymoire.com/Unix/index.html">, and regular expression tutorials at The UNIX Grymoire.</a><br>
<a href="http://www.gnu.org/software/sed/manual/">The GNU sed and &nbsp;gawk manuals. As you recall, gawk is the enhanced GNU version of</a><b>&nbsp;awk</b>.<br>
<a href="http://sed.sourceforge.net/grabbag/">Many interesting sed scripts at the &nbsp;seder's grab bag.</a><br>
<a href="http://linuxreviews.org">Tips and tricks at &nbsp;Linux Reviews.</a><br>
<a href="http://www.cs.pdx.edu/~trent/gnu/groff/groff.html">Trent Fisher's groff tutorial.</a><br>
<a href="http://www.shellscriptgames.com">&quot;Shelltris&quot; and &quot;shellitaire&quot; at Shell Script Games.</a><br>
<a href="http://www.tldp.org/HOWTO/Printing-Usage-HOWTO.html">Mark Komarinski's Printing-Usage HOWTO.</a><br>
<a href="http://www.linux-usb.org/USB-guide/book1.html">The Linux USB subsystem (helpful in writing scripts affecting USB peripherals).</a><br>
<a href="abs-guides.html#374">There is some nice material on I/O redirection in &nbsp;chapter 10 of the textutils documentation at the &nbsp;University<br></a><a href="http://sunsite.ualberta.ca/Documentation">of Alberta site.</a><br>
<a href="mailto:humbubba@smarty.smart.net">Rick Hohensee has written the</a><i>&nbsp;osimpa</i>&nbsp;i386 assembler entirely as Bash scripts.<br>
<i>dgatwood</i><a href="http://www.shellscriptgames.com/">&nbsp;has a very nice &nbsp;shell script games site, featuring a Tetris® clone and solitaire.</a><br>
<a href="http://txt2regex.sf.net">Aurelio Marinho Jargas has written a Regular expression wizard. He has also written an informative book on<br></a>Regular Expressions, in Portuguese.<br>
<a href="mailto:brtompkins@comcast.net">Ben Tomkins has created the &nbsp;Bash Navigator directory management tool.</a><br>
<a href="mailto:opengeometry@yahoo.ca">William Park has been working on a project to incorporate certain</a><i>&nbsp;Awk</i>&nbsp;and<i>&nbsp;Python</i>&nbsp;features into Bash. Among<br>these is a<i>&nbsp;gdbm</i>&nbsp;interface. He has released<i>&nbsp;bashdiff</i><a href="http://freshmeat.net">&nbsp;on Freshmeat.net. He has an article in the November, 2004<br></a>issue of the&nbsp;<a href="http://www.linuxgazette.net"><i>Linux Gazette</i></a><a href="http://linuxgazette.net/109/park.html">&nbsp;on adding string functions to Bash, with a followup article in the December issue,<br></a><a href="http://linuxgazette.net/110/park.htm">and yet another in the January, 2005 issue.</a><br>
<a href="http://booklistgensh.peterknowles.com/">Peter Knowles has written an elaborate Bash script that generates a book list on the Sony Librie e-book<br></a>reader. This useful tool facilitates loading non-DRM user content on the<i>&nbsp;Librie</i>&nbsp;(and the newer<i>&nbsp;PRS-xxx-series<br></i>devices).<br>
Bibliography<br>
564<br>
<hr>
<A name=571></a>Advanced Bash-Scripting Guide<br>
<a href="http://cyberelk.net/tim/xmlto/">Tim Waugh's xmlto is an elaborate Bash script for converting Docbook XML documents to other formats.</a><br>
<a href="http://www.gossiplabs.org">Philip Patterson's logforbash logging/debugging script.</a><br>
Of historical interest are Colin Needham's<i>&nbsp;original International Movie Database (IMDB) reader polling<br>scripts</i><a href="abs-guides.html#784">, which nicely illustrate the use of awk for string parsing. Unfortunately, the URL link is broken.</a><br>
---<br>
<a href="http://vim.sourceforge.net/scripts/script.php?script_id=365">Fritz Mehner has written a bash-support plugin for the</a><i>&nbsp;vim</i>&nbsp;text editor. He has also also come up with his own<br><a href="http://lug.fh-swf.de/vim/vim-bash/StyleGuideShell.en.pdf">stylesheet for Bash. Compare it with the ABS Guide Unofficial Stylesheet.</a><br>
---<br>
<i>Penguin Pete</i><a href="http://www.penguinpetes.com">&nbsp;has quite a number of shell scripting tips and hints on his superb site. Highly recommended.</a><br>
The excellent<i>&nbsp;Bash Reference Manual</i>, by Chet Ramey and Brian Fox, distributed as part of the<i>&nbsp;bash-2-doc<br></i><a href="abs-guides.html#263">package (available as an rpm). See especially the instructive example scripts in this package.</a><br>
<a href="http://www.lemis.com/grog/Documentation/Lions/index.html">John Lion's classic,&nbsp;<i>&nbsp;A Commentary on the Sixth Edition UNIX Operating System</i>.</a><br>
<a href="">The comp.os.unix.shell newsgroup.</a><br>
The&nbsp;<a href="http://www.linuxquestions.org/questions/showthread.php?t=362506"><i>dd</i>&nbsp;thread on Linux Questions.</a><br>
<a href="http://www.newsville.com/cgi-bin/getfaq?file=comp.unix.shell/comp.unix.shell_FAQ_-_Answers_to_Frequently_Asked_Questions">The comp.os.unix.shell FAQ.</a><br>
<a href="http://www.faqs.org/faqs/by-newsgroup/comp/comp.unix.shell.html">Assorted comp.os.unix &nbsp;FAQs.</a><br>
The&nbsp;<a href="http://en.wikipedia.org/wiki/Dc_(Unix)"><i>Wikipedia</i>&nbsp;article covering dc.</a><br>
<a href="abs-guides.html#225">The manpages for</a><b>&nbsp;bash</b>&nbsp;and<b>&nbsp;bash2</b>,<b>&nbsp;date</b>,<b>&nbsp;expect</b>,<b>&nbsp;expr</b>,<b>&nbsp;find</b>,<b>&nbsp;grep</b>,<b>&nbsp;gzip</b>,<b>&nbsp;ln</b>,<b>&nbsp;patch</b>,<b>&nbsp;tar</b>,<b>&nbsp;tr</b>,<b>&nbsp;bc</b>,<b>&nbsp;xargs</b>. The<br><i>texinfo</i>&nbsp;documentation on<b>&nbsp;bash</b>,<b>&nbsp;dd</b>,<b>&nbsp;m4</b>,<b>&nbsp;gawk</b>, and<b>&nbsp;sed</b>.<br>
Bibliography<br>
565<br>
<hr>
<A name=572></a><b>Appendix A. Contributed Scripts</b><br>
These scripts, while not fitting into the text of this document, do illustrate some interesting shell programming<br>techniques. They are useful, too. Have fun analyzing and running them.<br>
<b>Example A-1.<i>&nbsp;mailformat</i></b><b>: Formatting an e-mail message</b><br>
#!/bin/bash<br>
# mail-format.sh (ver. 1.1): Format e-mail messages.<br>
# Gets rid of carets, tabs, and also folds excessively long lines.<br>
# =================================================================<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Standard Check for Script Argument(s)<br>
ARGS=1<br>
E_BADARGS=65<br>
E_NOFILE=66<br>
if [ $# -ne $ARGS ] &nbsp;# Correct number of arguments passed to script?<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [ -f &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; # Check if file exists.<br>
then<br>
&nbsp; &nbsp; file_name=$1<br>
else<br>
&nbsp; &nbsp; echo &quot;File \&quot;$1\&quot; does not exist.&quot;<br>
&nbsp; &nbsp; exit $E_NOFILE<br>
fi<br>
# =================================================================<br>
MAXWIDTH=70 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Width to fold excessively long lines to.<br>
# ---------------------------------<br>
# A variable can hold a sed script.<br>
sedscript='s/^&gt;//<br>
s/^ &nbsp;*&gt;//<br>
s/^ &nbsp;*//<br>
s/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*//'<br>
# ---------------------------------<br>
# &nbsp;Delete carets and tabs at beginning of lines,<br>
#+ then fold lines to $MAXWIDTH characters.<br>
sed &quot;$sedscript&quot; $1 | fold -s --width=$MAXWIDTH<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;-s option to &quot;fold&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ breaks lines at whitespace, if possible.<br>
# &nbsp;This script was inspired by an article in a well-known trade journal<br>
#+ extolling a 164K MS Windows utility with similar functionality.<br>
#<br>
# &nbsp;An nice set of text processing utilities and an efficient<br>
#+ scripting language provide an alternative to bloated executables.<br>
exit<br>
Appendix A. Contributed Scripts<br>
566<br>
<hr>
<A name=573></a>Advanced Bash-Scripting Guide<br>
<b>Example A-2.<i>&nbsp;rn</i></b><b>: A simple-minded file renaming utility</b><br>
<a href="abs-guides.html#256">This script is a modification of Example 16-22.</a><br>
#! /bin/bash<br>
# rn.sh<br>
# Very simpleminded filename &quot;rename&quot; utility (based on &quot;lowercase.sh&quot;).<br>
#<br>
# &nbsp;The &quot;ren&quot; utility, by Vladimir Lanin (lanin@csd2.nyu.edu),<br>
#+ does a much better job of this.<br>
ARGS=2<br>
E_BADARGS=85<br>
ONE=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # For getting singular/plural right (see below).<br>
if [ $# -ne &quot;$ARGS&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` old-pattern new-pattern&quot;<br>
&nbsp; # As in &quot;rn gif jpg&quot;, which renames all gif files in working directory to jpg.<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
number=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Keeps track of how many files actually renamed.<br>
for filename in *$1* &nbsp; &nbsp; &nbsp;#Traverse all matching files in directory.<br>
do<br>
&nbsp; &nbsp;if [ -f &quot;$filename&quot; ] &nbsp;# If finds match...<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;fname=`basename $filename` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Strip off path.<br>
&nbsp; &nbsp; &nbsp;n=`echo $fname | sed -e &quot;s/$1/$2/&quot;` &nbsp; # Substitute new for old in filename.<br>
&nbsp; &nbsp; &nbsp;mv $fname $n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Rename.<br>
&nbsp; &nbsp; &nbsp;let &quot;number += 1&quot;<br>
&nbsp; &nbsp;fi<br>
done &nbsp;&nbsp;<br>
if [ &quot;$number&quot; -eq &quot;$ONE&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# For correct grammar.<br>
then<br>
&nbsp;echo &quot;$number file renamed.&quot;<br>
else&nbsp;<br>
&nbsp;echo &quot;$number files renamed.&quot;<br>
fi&nbsp;<br>
exit $?<br>
# Exercises:<br>
# ---------<br>
# What types of files will this not work on?<br>
# How can this be fixed?<br>
<b>Example A-3.<i>&nbsp;blank-rename</i></b><b>: Renames filenames containing blanks</b><br>
This is an even simpler-minded version of previous script.<br>
#! /bin/bash<br>
# blank-rename.sh<br>
#<br>
Appendix A. Contributed Scripts<br>
567<br>
<hr>
<A name=574></a>Advanced Bash-Scripting Guide<br>
# Substitutes underscores for blanks in all the filenames in a directory.<br>
ONE=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # For getting singular/plural right (see below).<br>
number=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Keeps track of how many files actually renamed.<br>
FOUND=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Successful return value.<br>
for filename in * &nbsp; &nbsp; &nbsp; &nbsp; #Traverse all files in directory.<br>
do<br>
&nbsp; &nbsp; &nbsp;echo &quot;$filename&quot; | grep -q &quot; &quot; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Check whether filename<br>
&nbsp; &nbsp; &nbsp;if [ $? -eq $FOUND ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ contains space(s).<br>
&nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp;fname=$filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Yes, this filename needs work.<br>
&nbsp; &nbsp; &nbsp; &nbsp;n=`echo $fname | sed -e &quot;s/ /_/g&quot;` &nbsp; # Substitute underscore for blank.<br>
&nbsp; &nbsp; &nbsp; &nbsp;mv &quot;$fname&quot; &quot;$n&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Do the actual renaming.<br>
&nbsp; &nbsp; &nbsp; &nbsp;let &quot;number += 1&quot;<br>
&nbsp; &nbsp; &nbsp;fi<br>
done &nbsp;&nbsp;<br>
if [ &quot;$number&quot; -eq &quot;$ONE&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # For correct grammar.<br>
then<br>
&nbsp;echo &quot;$number file renamed.&quot;<br>
else&nbsp;<br>
&nbsp;echo &quot;$number files renamed.&quot;<br>
fi&nbsp;<br>
exit 0<br>
<b>Example A-4.<i>&nbsp;encryptedpw</i></b><b>: Uploading to an ftp site, using a locally encrypted password</b><br>
#!/bin/bash<br>
# Example &quot;ex72.sh&quot; modified to use encrypted password.<br>
# &nbsp;Note that this is still rather insecure,<br>
#+ since the decrypted password is sent in the clear.<br>
# &nbsp;Use something like &quot;ssh&quot; if this is a concern.<br>
E_BADARGS=85<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` filename&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
Username=bozo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Change to suit.<br>
pword=/home/bozo/secret/password_encrypted.file<br>
# File containing encrypted password.<br>
Filename=`basename $1` &nbsp;# Strips pathname out of file name.<br>
Server=&quot;XXX&quot;<br>
Directory=&quot;YYY&quot; &nbsp; &nbsp; &nbsp; &nbsp; # Change above to actual server name &amp; directory.<br>
Password=`cruft &lt;$pword` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Decrypt password.<br>
# &nbsp;Uses the author's own &quot;cruft&quot; file encryption package,<br>
#+ based on the classic &quot;onetime pad&quot; algorithm,<br>
#+ and obtainable from:<br>
#+ Primary-site: &nbsp; ftp://ibiblio.org/pub/Linux/utils/file<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cruft-0.2.tar.gz [16k]<br>
Appendix A. Contributed Scripts<br>
568<br>
<hr>
<A name=575></a>Advanced Bash-Scripting Guide<br>
ftp -n $Server &lt;&lt;End-Of-Session<br>
user $Username $Password<br>
binary<br>
bell<br>
cd $Directory<br>
put $Filename<br>
bye<br>
End-Of-Session<br>
# -n option to &quot;ftp&quot; disables auto-logon.<br>
# Note that &quot;bell&quot; rings 'bell' after each file transfer.<br>
exit 0<br>
<b>Example A-5.<i>&nbsp;copy-cd</i></b><b>: Copying a data CD</b><br>
#!/bin/bash<br>
# copy-cd.sh: copying a data CD<br>
CDROM=/dev/cdrom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # CD ROM device<br>
OF=/home/bozo/projects/cdimage.iso &nbsp; &nbsp; &nbsp; &nbsp; # output file<br>
# &nbsp; &nbsp; &nbsp; /xxxx/xxxxxxxx/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Change to suit your system.<br>
BLOCKSIZE=2048<br>
# SPEED=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If unspecified, uses max spd.<br>
# DEVICE=/dev/cdrom &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;older version.<br>
DEVICE=&quot;1,0,0&quot;<br>
echo; echo &quot;Insert source CD, but do *not* mount it.&quot;<br>
echo &quot;Press ENTER when ready. &quot;<br>
read ready &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Wait for input, $ready not used.<br>
echo; echo &quot;Copying the source CD to $OF.&quot;<br>
echo &quot;This may take a while. Please be patient.&quot;<br>
dd if=$CDROM of=$OF bs=$BLOCKSIZE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Raw device copy.<br>
echo; echo &quot;Remove data CD.&quot;<br>
echo &quot;Insert blank CDR.&quot;<br>
echo &quot;Press ENTER when ready. &quot;<br>
read ready &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Wait for input, $ready not used.<br>
echo &quot;Copying $OF to CDR.&quot;<br>
# cdrecord -v -isosize speed=$SPEED dev=$DEVICE $OF &nbsp; # Old version.<br>
wodim -v -isosize dev=$DEVICE $OF<br>
# Uses Joerg Schilling's &quot;cdrecord&quot; package (see its docs).<br>
# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html<br>
# Newer Linux distros may use &quot;wodim&quot; rather than &quot;cdrecord&quot; ...<br>
echo; echo &quot;Done copying $OF to CDR on device $CDROM.&quot;<br>
echo &quot;Do you want to erase the image file (y/n)? &quot; &nbsp;# Probably a huge file.<br>
read answer<br>
case &quot;$answer&quot; in<br>
[yY]) rm -f $OF<br>
&nbsp; &nbsp; &nbsp; echo &quot;$OF erased.&quot;<br>
&nbsp; &nbsp; &nbsp; ;;<br>
Appendix A. Contributed Scripts<br>
569<br>
<hr>
<A name=576></a>Advanced Bash-Scripting Guide<br>
*) &nbsp; &nbsp;echo &quot;$OF not erased.&quot;;;<br>
esac<br>
echo<br>
# Exercise:<br>
# Change the above &quot;case&quot; statement to also accept &quot;yes&quot; and &quot;Yes&quot; as input.<br>
exit 0<br>
<b>Example A-6. Collatz series</b><br>
#!/bin/bash<br>
# collatz.sh<br>
# &nbsp;The notorious &quot;hailstone&quot; or Collatz series.<br>
# &nbsp;-------------------------------------------<br>
# &nbsp;1) Get the integer &quot;seed&quot; from the command-line.<br>
# &nbsp;2) NUMBER &lt;-- seed<br>
# &nbsp;3) Print NUMBER.<br>
# &nbsp;4) &nbsp;If NUMBER is even, divide by 2, or<br>
# &nbsp;5)+ if odd, multiply by 3 and add 1.<br>
# &nbsp;6) NUMBER &lt;-- result&nbsp;<br>
# &nbsp;7) Loop back to step 3 (for specified number of iterations).<br>
#<br>
# &nbsp;The theory is that every such sequence,<br>
#+ no matter how large the initial value,<br>
#+ eventually settles down to repeating &quot;4,2,1...&quot; cycles,<br>
#+ even after fluctuating through a wide range of values.<br>
#<br>
# &nbsp;This is an instance of an &quot;iterate,&quot;<br>
#+ an operation that feeds its output back into its input.<br>
# &nbsp;Sometimes the result is a &quot;chaotic&quot; series.<br>
MAX_ITERATIONS=200<br>
# For large seed numbers (&gt;32000), try increasing MAX_ITERATIONS.<br>
h=${1:-$$} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Seed.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Use $PID as seed,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ if not specified as command-line arg.<br>
echo<br>
echo &quot;C($h) -*- $MAX_ITERATIONS Iterations&quot;<br>
echo<br>
for ((i=1; i&lt;=MAX_ITERATIONS; i++))<br>
do<br>
# echo -n &quot;$h &nbsp; &quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^&nbsp;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tab<br>
# printf does it better ...<br>
COLWIDTH=%7d<br>
printf $COLWIDTH $h<br>
&nbsp; let &quot;remainder = h % 2&quot;<br>
&nbsp; if [ &quot;$remainder&quot; -eq 0 ] &nbsp; # Even?<br>
&nbsp; then<br>
&nbsp; &nbsp; let &quot;h /= 2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Divide by 2.<br>
&nbsp; else<br>
Appendix A. Contributed Scripts<br>
570<br>
<hr>
<A name=577></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; let &quot;h = h*3 + 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; # Multiply by 3 and add 1.<br>
&nbsp; fi<br>
COLUMNS=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Output 10 values per line.<br>
let &quot;line_break = i % $COLUMNS&quot;<br>
if [ &quot;$line_break&quot; -eq 0 ]<br>
then<br>
&nbsp; echo<br>
fi &nbsp;<br>
done<br>
echo<br>
# &nbsp;For more information on this strange mathematical function,<br>
#+ see _Computers, Pattern, Chaos, and Beauty_, by Pickover, p. 185 ff.,<br>
#+ as listed in the bibliography.<br>
exit 0<br>
<b>Example A-7.<i>&nbsp;days-between</i></b><b>: Days between two dates</b><br>
#!/bin/bash<br>
# days-between.sh: &nbsp; &nbsp;Number of days between two dates.<br>
# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY<br>
#<br>
# Note: Script modified to account for changes in Bash, v. 2.05b +,<br>
#+ &nbsp; &nbsp; &nbsp;that closed the loophole permitting large negative<br>
#+ &nbsp; &nbsp; &nbsp;integer return values.<br>
ARGS=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Two command-line parameters expected.<br>
E_PARAM_ERR=85 &nbsp; &nbsp; &nbsp; &nbsp;# Param error.<br>
REFYR=1600 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Reference year.<br>
CENTURY=100<br>
DIY=365<br>
ADJ_DIY=367 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Adjusted for leap year + fraction.<br>
MIY=12<br>
DIM=31<br>
LEAPCYCLE=4<br>
MAXRETVAL=255 &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Largest permissible<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ positive return value from a function.<br>
diff= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Declare global variable for date difference.<br>
value= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Declare global variable for absolute value.<br>
day= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Declare globals for day, month, year.<br>
month=<br>
year=<br>
Param_Error () &nbsp; &nbsp; &nbsp; &nbsp;# Command-line parameters wrong.<br>
{<br>
&nbsp; echo &quot;Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY&quot;<br>
&nbsp; echo &quot; &nbsp; &nbsp; &nbsp; (date must be after 1/3/1600)&quot;<br>
&nbsp; exit $E_PARAM_ERR<br>
} &nbsp;<br>
Appendix A. Contributed Scripts<br>
571<br>
<hr>
<A name=578></a>Advanced Bash-Scripting Guide<br>
Parse_Date () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Parse date from command-line params.<br>
{<br>
&nbsp; month=${1%%/**}<br>
&nbsp; dm=${1%/**} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Day and month.<br>
&nbsp; day=${dm#*/}<br>
&nbsp; let &quot;year = `basename $1`&quot; &nbsp;# Not a filename, but works just the same.<br>
} &nbsp;<br>
check_date () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Checks for invalid date(s) passed.<br>
{<br>
&nbsp; [ &quot;$day&quot; -gt &quot;$DIM&quot; ] || [ &quot;$month&quot; -gt &quot;$MIY&quot; ] ||<br>
&nbsp; [ &quot;$year&quot; -lt &quot;$REFYR&quot; ] &amp;&amp; Param_Error<br>
&nbsp; # Exit script on bad value(s).<br>
&nbsp; # Uses or-list / and-list.<br>
&nbsp; #<br>
&nbsp; # Exercise: Implement more rigorous date checking.<br>
}<br>
strip_leading_zero () # &nbsp;Better to strip possible leading zero(s)<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ from day and/or month<br>
&nbsp; return ${1#0} &nbsp; &nbsp; &nbsp; #+ since otherwise Bash will interpret them<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ as octal values (POSIX.2, sect 2.9.2.1).<br>
day_index () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Gauss' Formula:<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Days from March 1, 1600 to date passed as param.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^<br>
&nbsp; day=$1<br>
&nbsp; month=$2<br>
&nbsp; year=$3<br>
&nbsp; let &quot;month = $month - 2&quot;<br>
&nbsp; if [ &quot;$month&quot; -le 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; let &quot;month += 12&quot;<br>
&nbsp; &nbsp; let &quot;year -= 1&quot;<br>
&nbsp; fi &nbsp;<br>
&nbsp; let &quot;year -= $REFYR&quot;<br>
&nbsp; let &quot;indexyr = $year / $CENTURY&quot;<br>
&nbsp; let &quot;Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM&quot;<br>
&nbsp; # &nbsp;For an in-depth explanation of this algorithm, see<br>
&nbsp; #+ &nbsp; http://weblogs.asp.net/pgreborio/archive/2005/01/06/347968.aspx<br>
&nbsp; echo $Days<br>
} &nbsp;<br>
calculate_difference () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Difference between two day indices.<br>
{<br>
&nbsp; let &quot;diff = $1 - $2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Global variable.<br>
} &nbsp;<br>
abs () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Absolute value<br>
Appendix A. Contributed Scripts<br>
572<br>
<hr>
<A name=579></a>Advanced Bash-Scripting Guide<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Uses global &quot;value&quot; variable.<br>
&nbsp; if [ &quot;$1&quot; -lt 0 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;If negative<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ then<br>
&nbsp; &nbsp; let &quot;value = 0 - $1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ change sign,<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ else<br>
&nbsp; &nbsp; let &quot;value = $1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ leave it alone.<br>
&nbsp; fi<br>
}<br>
if [ $# -ne &quot;$ARGS&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Require two command-line params.<br>
then<br>
&nbsp; Param_Error<br>
fi &nbsp;<br>
Parse_Date $1<br>
check_date $day $month $year &nbsp; &nbsp; &nbsp; # &nbsp;See if valid date.<br>
strip_leading_zero $day &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Remove any leading zeroes<br>
day=$? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ on day and/or month.<br>
strip_leading_zero $month<br>
month=$?<br>
let &quot;date1 = `day_index $day $month $year`&quot;<br>
Parse_Date $2<br>
check_date $day $month $year<br>
strip_leading_zero $day<br>
day=$?<br>
strip_leading_zero $month<br>
month=$?<br>
date2=$(day_index $day $month $year) # Command substitution.<br>
calculate_difference $date1 $date2<br>
abs $diff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Make sure it's positive.<br>
diff=$value<br>
echo $diff<br>
exit 0<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;If given only one command-line parameter, have the script<br>
#+ use today's date as the second.<br>
# &nbsp;Compare this script with<br>
#+ the implementation of Gauss' Formula in a C program at<br>
#+ &nbsp; &nbsp;http://buschencrew.hypermart.net/software/datedif<br>
<b>Example A-8. Making a<i>&nbsp;dictionary</i></b><br>
#!/bin/bash<br>
# makedict.sh &nbsp;[make dictionary]<br>
Appendix A. Contributed Scripts<br>
573<br>
<hr>
<A name=580></a>Advanced Bash-Scripting Guide<br>
# Modification of /usr/sbin/mkdict (/usr/sbin/cracklib-forman) script.<br>
# Original script copyright 1993, by Alec Muffett.<br>
#<br>
# &nbsp;This modified script included in this document in a manner<br>
#+ consistent with the &quot;LICENSE&quot; document of the &quot;Crack&quot; package<br>
#+ that the original script is a part of.<br>
# &nbsp;This script processes text files to produce a sorted list<br>
#+ of words found in the files.<br>
# &nbsp;This may be useful for compiling dictionaries<br>
#+ and for other lexicographic purposes.<br>
E_BADARGS=65<br>
if [ ! -r &quot;$1&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Need at least one<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ valid file argument.<br>
&nbsp; echo &quot;Usage: $0 files-to-process&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi &nbsp;<br>
# SORT=&quot;sort&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;No longer necessary to define<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ options to sort. Changed from<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ original script.<br>
cat $* | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Contents of specified files to stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; tr A-Z a-z | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Convert to lowercase.<br>
&nbsp; &nbsp; &nbsp; &nbsp; tr ' ' '\012' | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # New: change spaces to newlines.<br>
# &nbsp; &nbsp; &nbsp; tr -cd '\012[a-z][0-9]' | &nbsp; # &nbsp;Get rid of everything<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ non-alphanumeric (in orig. script).<br>
&nbsp; &nbsp; &nbsp; &nbsp; tr -c '\012a-z' &nbsp;'\012' | &nbsp; # &nbsp;Rather than deleting non-alpha<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ chars, change them to newlines.<br>
&nbsp; &nbsp; &nbsp; &nbsp; sort | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $SORT options unnecessary now.<br>
&nbsp; &nbsp; &nbsp; &nbsp; uniq | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Remove duplicates.<br>
&nbsp; &nbsp; &nbsp; &nbsp; grep -v '^#' | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Delete lines starting with hashmark.<br>
&nbsp; &nbsp; &nbsp; &nbsp; grep -v '^$' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Delete blank lines.<br>
exit 0<br>
<b>Example A-9. Soundex conversion</b><br>
#!/bin/bash<br>
# soundex.sh: Calculate &quot;soundex&quot; code for names<br>
# =======================================================<br>
# &nbsp; &nbsp; &nbsp; &nbsp;Soundex script<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by<br>
# &nbsp; &nbsp; &nbsp; &nbsp; Mendel Cooper<br>
# &nbsp; &nbsp; thegrendel.abs@gmail.com<br>
# &nbsp; &nbsp; reldate: 23 January, 2002<br>
#<br>
# &nbsp; Placed in the Public Domain.<br>
#<br>
# A slightly different version of this script appeared in<br>
#+ Ed Schaefer's July, 2002 &quot;Shell Corner&quot; column<br>
#+ in &quot;Unix Review&quot; on-line,<br>
#+ http://www.unixreview.com/documents/uni1026336632258/<br>
# =======================================================<br>
Appendix A. Contributed Scripts<br>
574<br>
<hr>
<A name=581></a>Advanced Bash-Scripting Guide<br>
ARGCOUNT=1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Need name as argument.<br>
E_WRONGARGS=90<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` name&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi &nbsp;<br>
assign_value () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Assigns numerical value<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ to letters of name.<br>
&nbsp; val1=bfpv &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 'b,f,p,v' = 1<br>
&nbsp; val2=cgjkqsxz &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 'c,g,j,k,q,s,x,z' = 2<br>
&nbsp; val3=dt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;etc.<br>
&nbsp; val4=l<br>
&nbsp; val5=mn<br>
&nbsp; val6=r<br>
# Exceptionally clever use of 'tr' follows.<br>
# Try to figure out what is going on here.<br>
value=$( echo &quot;$1&quot; \<br>
| tr -d wh \<br>
| tr $val1 1 | tr $val2 2 | tr $val3 3 \<br>
| tr $val4 4 | tr $val5 5 | tr $val6 6 \<br>
| tr -s 123456 \<br>
| tr -d aeiouy )<br>
# Assign letter values.<br>
# Remove duplicate numbers, except when separated by vowels.<br>
# Ignore vowels, except as separators, so delete them last.<br>
# Ignore 'w' and 'h', even as separators, so delete them first.<br>
#<br>
# The above command substitution lays more pipe than a plumber &lt;g&gt;.<br>
} &nbsp;<br>
input_name=&quot;$1&quot;<br>
echo<br>
echo &quot;Name = $input_name&quot;<br>
# Change all characters of name input to lowercase.<br>
# ------------------------------------------------<br>
name=$( echo $input_name | tr A-Z a-z )<br>
# ------------------------------------------------<br>
# Just in case argument to script is mixed case.<br>
# Prefix of soundex code: first letter of name.<br>
# --------------------------------------------<br>
char_pos=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Initialize character position.&nbsp;<br>
prefix0=${name:$char_pos:1}<br>
prefix=`echo $prefix0 | tr a-z A-Z`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Uppercase 1st letter of soundex.<br>
Appendix A. Contributed Scripts<br>
575<br>
<hr>
<A name=582></a>Advanced Bash-Scripting Guide<br>
let &quot;char_pos += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Bump character position to 2nd letter of name.<br>
name1=${name:$char_pos}<br>
# ++++++++++++++++++++++++++ Exception Patch ++++++++++++++++++++++++++++++<br>
# &nbsp;Now, we run both the input name and the name shifted one char<br>
#+ to the right through the value-assigning function.<br>
# &nbsp;If we get the same value out, that means that the first two characters<br>
#+ of the name have the same value assigned, and that one should cancel.<br>
# &nbsp;However, we also need to test whether the first letter of the name<br>
#+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.<br>
char1=`echo $prefix | tr A-Z a-z` &nbsp; &nbsp;# First letter of name, lowercased.<br>
assign_value $name<br>
s1=$value<br>
assign_value $name1<br>
s2=$value<br>
assign_value $char1<br>
s3=$value<br>
s3=9$s3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;If first letter of name is a vowel<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ or 'w' or 'h',<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then its &quot;value&quot; will be null (unset).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ Therefore, set it to 9, an otherwise<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ unused value, which can be tested for.<br>
if [[ &quot;$s1&quot; -ne &quot;$s2&quot; || &quot;$s3&quot; -eq 9 ]]<br>
then<br>
&nbsp; suffix=$s2<br>
else &nbsp;<br>
&nbsp; suffix=${s2:$char_pos}<br>
fi &nbsp;<br>
# ++++++++++++++++++++++ end Exception Patch ++++++++++++++++++++++++++++++<br>
padding=000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Use at most 3 zeroes to pad.<br>
soun=$prefix$suffix$padding &nbsp; &nbsp;# Pad with zeroes.<br>
MAXLEN=4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Truncate to maximum of 4 chars.<br>
soundex=${soun:0:$MAXLEN}<br>
echo &quot;Soundex = $soundex&quot;<br>
echo<br>
# &nbsp;The soundex code is a method of indexing and classifying names<br>
#+ by grouping together the ones that sound alike.<br>
# &nbsp;The soundex code for a given name is the first letter of the name,<br>
#+ followed by a calculated three-number code.<br>
# &nbsp;Similar sounding names should have almost the same soundex codes.<br>
# &nbsp; Examples:<br>
# &nbsp; Smith and Smythe both have a &quot;S-530&quot; soundex.<br>
# &nbsp; Harrison = H-625<br>
# &nbsp; Hargison = H-622<br>
# &nbsp; Harriman = H-655<br>
# &nbsp;This works out fairly well in practice, but there are numerous anomalies.<br>
Appendix A. Contributed Scripts<br>
576<br>
<hr>
<A name=583></a>Advanced Bash-Scripting Guide<br>
#<br>
#<br>
# &nbsp;The U.S. Census and certain other governmental agencies use soundex,<br>
# &nbsp;as do genealogical researchers.<br>
#<br>
# &nbsp;For more information,<br>
#+ see the &quot;National Archives and Records Administration home page&quot;,<br>
#+ http://www.nara.gov/genealogy/soundex/soundex.html<br>
# Exercise:<br>
# --------<br>
# Simplify the &quot;Exception Patch&quot; section of this script.<br>
exit 0<br>
<b>Example A-10.<i>&nbsp;Game of Life</i></b><br>
#!/bin/bash<br>
# life.sh: &quot;Life in the Slow Lane&quot;<br>
# Author: Mendel Cooper<br>
# License: GPL3<br>
# Version 0.2: &nbsp; Patched by Daniel Albers<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to allow non-square grids as input.<br>
# Version 0.2.1: Added 2-second delay between generations.<br>
# ##################################################################### #<br>
# This is the Bash script version of John Conway's &quot;Game of Life&quot;. &nbsp; &nbsp; &nbsp;#<br>
# &quot;Life&quot; is a simple implementation of cellular automata. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# --------------------------------------------------------------------- #<br>
# On a rectangular grid, let each &quot;cell&quot; be either &quot;living&quot; or &quot;dead.&quot; &nbsp;#<br>
# Designate a living cell with a dot, and a dead one with a blank space.#<br>
# &nbsp; &nbsp; &nbsp;Begin with an arbitrarily drawn dot-and-blank grid, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
#+ &nbsp; &nbsp; and let this be the starting generation: generation 0. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# Determine each successive generation by the following rules: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; 1) Each cell has 8 neighbors, the adjoining cells &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
#+ &nbsp; &nbsp; left, right, top, bottom, and the 4 diagonals. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 123 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4*5 &nbsp; &nbsp; The * is the cell under consideration. &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 678 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# 2) A living cell with either 2 or 3 living neighbors remains alive. &nbsp; #<br>
SURVIVE=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# 3) A dead cell with 3 living neighbors comes alive, a &quot;birth.&quot; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
BIRTH=3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# 4) All other cases result in a dead cell for the next generation. &nbsp; &nbsp; #<br>
# ##################################################################### #<br>
startfile=gen0 &nbsp; # Read the starting generation from the file &quot;gen0&quot; ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default, if no other file specified when invoking script.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
if [ -n &quot;$1&quot; ] &nbsp; # Specify another &quot;generation 0&quot; file.<br>
then<br>
&nbsp; &nbsp; startfile=&quot;$1&quot;<br>
fi &nbsp;<br>
Appendix A. Contributed Scripts<br>
577<br>
<hr>
<A name=584></a>Advanced Bash-Scripting Guide<br>
############################################<br>
# &nbsp;Abort script if &quot;startfile&quot; not specified<br>
#+ and<br>
#+ default file &quot;gen0&quot; not present.<br>
E_NOSTARTFILE=86<br>
if [ ! -e &quot;$startfile&quot; ]<br>
then<br>
&nbsp; echo &quot;Startfile \&quot;&quot;$startfile&quot;\&quot; missing!&quot;<br>
&nbsp; exit $E_NOSTARTFILE<br>
fi<br>
############################################<br>
ALIVE1=.<br>
DEAD1=_<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Represent living and dead cells in the start-up file.<br>
# &nbsp;-----------------------------------------------------#<br>
# &nbsp;This script uses a 10 x 10 grid (may be increased,<br>
#+ but a large grid will slow down execution).<br>
ROWS=10<br>
COLS=10<br>
# &nbsp;Change above two variables to match desired grid size.<br>
# &nbsp;-----------------------------------------------------#<br>
GENERATIONS=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;How many generations to cycle through.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Adjust this upwards<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ if you have time on your hands.<br>
NONE_ALIVE=85 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Exit status on premature bailout,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ if no cells left alive.<br>
DELAY=2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Pause between generations.<br>
TRUE=0<br>
FALSE=1<br>
ALIVE=0<br>
DEAD=1<br>
avar= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Global; holds current generation.<br>
generation=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Initialize generation count.<br>
# =================================================================<br>
let &quot;cells = $ROWS * $COLS&quot; &nbsp; # How many cells.<br>
# Arrays containing &quot;cells.&quot;<br>
declare -a initial<br>
declare -a current<br>
display ()<br>
{<br>
alive=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # How many cells alive at any given time.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Initially zero.<br>
declare -a arr<br>
arr=( `echo &quot;$1&quot;` ) &nbsp; &nbsp; # Convert passed arg to array.<br>
element_count=${#arr[*]}<br>
local i<br>
Appendix A. Contributed Scripts<br>
578<br>
<hr>
<A name=585></a>Advanced Bash-Scripting Guide<br>
local rowcheck<br>
for ((i=0; i&lt;$element_count; i++))<br>
do<br>
&nbsp; # Insert newline at end of each row.<br>
&nbsp; let &quot;rowcheck = $i % COLS&quot;<br>
&nbsp; if [ &quot;$rowcheck&quot; -eq 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Newline.<br>
&nbsp; &nbsp; echo -n &quot; &nbsp; &nbsp; &nbsp;&quot; &nbsp; &nbsp;# Indent.<br>
&nbsp; fi &nbsp;<br>
&nbsp; cell=${arr[i]}<br>
&nbsp; if [ &quot;$cell&quot; = . ]<br>
&nbsp; then<br>
&nbsp; &nbsp; let &quot;alive += 1&quot;<br>
&nbsp; fi &nbsp;<br>
&nbsp; echo -n &quot;$cell&quot; | sed -e 's/_/ /g'<br>
&nbsp; # Print out array, changing underscores to spaces.<br>
done &nbsp;<br>
return<br>
}<br>
IsValid () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Test if cell coordinate valid.<br>
{<br>
&nbsp; if [ -z &quot;$1&quot; &nbsp;-o -z &quot;$2&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Mandatory arguments missing?<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FALSE<br>
&nbsp; fi<br>
local row<br>
local lower_limit=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Disallow negative coordinate.<br>
local upper_limit<br>
local left<br>
local right<br>
let &quot;upper_limit = $ROWS * $COLS - 1&quot; # Total number of cells.<br>
if [ &quot;$1&quot; -lt &quot;$lower_limit&quot; -o &quot;$1&quot; -gt &quot;$upper_limit&quot; ]<br>
then<br>
&nbsp; return $FALSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Out of array bounds.<br>
fi &nbsp;<br>
row=$2<br>
let &quot;left = $row * $COLS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Left limit.<br>
let &quot;right = $left + $COLS - 1&quot; &nbsp; &nbsp; &nbsp; # Right limit.<br>
if [ &quot;$1&quot; -lt &quot;$left&quot; -o &quot;$1&quot; -gt &quot;$right&quot; ]<br>
then<br>
&nbsp; return $FALSE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Beyond row boundary.<br>
fi &nbsp;<br>
return $TRUE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Valid coordinate.<br>
} &nbsp;<br>
Appendix A. Contributed Scripts<br>
579<br>
<hr>
<A name=586></a>Advanced Bash-Scripting Guide<br>
IsAlive () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Test whether cell is alive.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Takes array, cell number, and<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ state of cell as arguments.<br>
&nbsp; GetCount &quot;$1&quot; $2 &nbsp; &nbsp; &nbsp;# &nbsp;Get alive cell count in neighborhood.<br>
&nbsp; local nhbd=$?<br>
&nbsp; if [ &quot;$nhbd&quot; -eq &quot;$BIRTH&quot; ] &nbsp;# Alive in any case.<br>
&nbsp; then<br>
&nbsp; &nbsp; return $ALIVE<br>
&nbsp; fi<br>
&nbsp; if [ &quot;$3&quot; = &quot;.&quot; -a &quot;$nhbd&quot; -eq &quot;$SURVIVE&quot; ]<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Alive only if previously alive.<br>
&nbsp; &nbsp; return $ALIVE<br>
&nbsp; fi &nbsp;<br>
&nbsp; return $DEAD &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Defaults to dead.<br>
} &nbsp;<br>
GetCount () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Count live cells in passed cell's neighborhood.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Two arguments needed:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $1) variable holding array<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $2) cell number<br>
{<br>
&nbsp; local cell_number=$2<br>
&nbsp; local array<br>
&nbsp; local top<br>
&nbsp; local center<br>
&nbsp; local bottom<br>
&nbsp; local r<br>
&nbsp; local row<br>
&nbsp; local i<br>
&nbsp; local t_top<br>
&nbsp; local t_cen<br>
&nbsp; local t_bot<br>
&nbsp; local count=0<br>
&nbsp; local ROW_NHBD=3<br>
&nbsp; array=( `echo &quot;$1&quot;` )<br>
&nbsp; let &quot;top = $cell_number - $COLS - 1&quot; &nbsp; &nbsp;# Set up cell neighborhood.<br>
&nbsp; let &quot;center = $cell_number - 1&quot;<br>
&nbsp; let &quot;bottom = $cell_number + $COLS - 1&quot;<br>
&nbsp; let &quot;r = $cell_number / $COLS&quot;<br>
&nbsp; for ((i=0; i&lt;$ROW_NHBD; i++)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Traverse from left to right.&nbsp;<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;t_top = $top + $i&quot;<br>
&nbsp; &nbsp; let &quot;t_cen = $center + $i&quot;<br>
&nbsp; &nbsp; let &quot;t_bot = $bottom + $i&quot;<br>
&nbsp; &nbsp; let &quot;row = $r&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Count center row.<br>
&nbsp; &nbsp; IsValid $t_cen $row &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Valid cell position?<br>
&nbsp; &nbsp; if [ $? -eq &quot;$TRUE&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; if [ ${array[$t_cen]} = &quot;$ALIVE1&quot; ] # Is it alive?<br>
&nbsp; &nbsp; &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If yes, then ...<br>
Appendix A. Contributed Scripts<br>
580<br>
<hr>
<A name=587></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;count += 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Increment count.<br>
&nbsp; &nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; &nbsp; let &quot;row = $r - 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Count top row. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; IsValid $t_top $row<br>
&nbsp; &nbsp; if [ $? -eq &quot;$TRUE&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; if [ ${array[$t_top]} = &quot;$ALIVE1&quot; ] # Redundancy here.<br>
&nbsp; &nbsp; &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Can it be optimized?<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;count += 1&quot;<br>
&nbsp; &nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; &nbsp; let &quot;row = $r + 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Count bottom row.<br>
&nbsp; &nbsp; IsValid $t_bot $row<br>
&nbsp; &nbsp; if [ $? -eq &quot;$TRUE&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; if [ ${array[$t_bot]} = &quot;$ALIVE1&quot; ]&nbsp;<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;count += 1&quot;<br>
&nbsp; &nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; fi &nbsp;<br>
&nbsp; done &nbsp;<br>
&nbsp; if [ ${array[$cell_number]} = &quot;$ALIVE1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; let &quot;count -= 1&quot; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Make sure value of tested cell itself<br>
&nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ is not counted.<br>
&nbsp; return $count<br>
}<br>
next_gen () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Update generation array.<br>
{<br>
local array<br>
local i=0<br>
array=( `echo &quot;$1&quot;` ) &nbsp; &nbsp; # Convert passed arg to array.<br>
while [ &quot;$i&quot; -lt &quot;$cells&quot; ]<br>
do<br>
&nbsp; IsAlive &quot;$1&quot; $i ${array[$i]} &nbsp; # Is the cell alive?<br>
&nbsp; if [ $? -eq &quot;$ALIVE&quot; ]<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;If alive, then<br>
&nbsp; &nbsp; array[$i]=. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ represent the cell as a period.<br>
&nbsp; else &nbsp;<br>
&nbsp; &nbsp; array[$i]=&quot;_&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Otherwise underscore<br>
&nbsp; &nbsp;fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ (will later be converted to space).<br>
&nbsp; let &quot;i += 1&quot;&nbsp;<br>
done &nbsp;&nbsp;<br>
# &nbsp; &nbsp;let &quot;generation += 1&quot; &nbsp; &nbsp; &nbsp; # Increment generation count.<br>
### &nbsp;Why was the above line commented out?<br>
Appendix A. Contributed Scripts<br>
581<br>
<hr>
<A name=588></a>Advanced Bash-Scripting Guide<br>
# Set variable to pass as parameter to &quot;display&quot; function.<br>
avar=`echo ${array[@]}` &nbsp; # Convert array back to string variable.<br>
display &quot;$avar&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Display it.<br>
echo; echo<br>
echo &quot;Generation $generation &nbsp;- &nbsp;$alive alive&quot;<br>
if [ &quot;$alive&quot; -eq 0 ]<br>
then<br>
&nbsp; echo<br>
&nbsp; echo &quot;Premature exit: no more cells alive!&quot;<br>
&nbsp; exit $NONE_ALIVE &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;No point in continuing<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ if no live cells.<br>
}<br>
# =========================================================<br>
# main ()<br>
# {<br>
# Load initial array with contents of startup file.<br>
initial=( `cat &quot;$startfile&quot; | sed -e '/#/d' | tr -d '\n' |\<br>
# Delete lines containing '#' comment character.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sed -e 's/\./\. /g' -e 's/_/_ /g'` )<br>
# Remove linefeeds and insert space between elements.<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Clear screen.<br>
echo # &nbsp; &nbsp; &nbsp; &nbsp; Title<br>
setterm -reverse on<br>
echo &quot;=======================&quot;<br>
setterm -reverse off<br>
echo &quot; &nbsp; &nbsp;$GENERATIONS generations&quot;<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of&quot;<br>
echo &quot;\&quot;Life in the Slow Lane\&quot;&quot;<br>
setterm -reverse on<br>
echo &quot;=======================&quot;<br>
setterm -reverse off<br>
sleep $DELAY &nbsp; # Display &quot;splash screen&quot; for 2 seconds.<br>
# -------- Display first generation. --------<br>
Gen0=`echo ${initial[@]}`<br>
display &quot;$Gen0&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Display only.<br>
echo; echo<br>
echo &quot;Generation $generation &nbsp;- &nbsp;$alive alive&quot;<br>
sleep $DELAY<br>
# -------------------------------------------<br>
let &quot;generation += 1&quot; &nbsp; &nbsp; # Bump generation count.<br>
echo<br>
# ------- Display second generation. -------<br>
Cur=`echo ${initial[@]}`<br>
next_gen &quot;$Cur&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Update &amp; display.<br>
sleep $DELAY<br>
# ------------------------------------------<br>
let &quot;generation += 1&quot; &nbsp; &nbsp; # Increment generation count.<br>
Appendix A. Contributed Scripts<br>
582<br>
<hr>
<A name=589></a>Advanced Bash-Scripting Guide<br>
# ------ Main loop for displaying subsequent generations ------<br>
while [ &quot;$generation&quot; -le &quot;$GENERATIONS&quot; ]<br>
do<br>
&nbsp; Cur=&quot;$avar&quot;<br>
&nbsp; next_gen &quot;$Cur&quot;<br>
&nbsp; let &quot;generation += 1&quot;<br>
&nbsp; sleep $DELAY<br>
done<br>
# ==============================================================<br>
echo<br>
# }<br>
exit 0 &nbsp; # CEOF:EOF<br>
# The grid in this script has a &quot;boundary problem.&quot;<br>
# The the top, bottom, and sides border on a void of dead cells.<br>
# Exercise: Change the script to have the grid wrap around,<br>
# + &nbsp; &nbsp; &nbsp; &nbsp; so that the left and right sides will &quot;touch,&quot; &nbsp; &nbsp; &nbsp;<br>
# + &nbsp; &nbsp; &nbsp; &nbsp; as will the top and bottom.<br>
#<br>
# Exercise: Create a new &quot;gen0&quot; file to seed this script.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use a 12 x 16 grid, instead of the original 10 x 10 one.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Make the necessary changes to the script,<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;so it will run with the altered file.<br>
#<br>
# Exercise: Modify this script so that it can determine the grid size<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from the &quot;gen0&quot; file, and set any variables necessary<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for the script to run.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This would make unnecessary any changes to variables<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in the script for an altered grid size.<br>
#<br>
# Exercise: Optimize this script.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; It has redundant code.<br>
<b>Example A-11. Data file for<i>&nbsp;Game of Life</i></b><br>
# gen0<br>
#<br>
# This is an example &quot;generation 0&quot; start-up file for &quot;life.sh&quot;.<br>
# --------------------------------------------------------------<br>
# &nbsp;The &quot;gen0&quot; file is a 10 x 10 grid using a period (.) for live cells,<br>
#+ and an underscore (_) for dead ones. We cannot simply use spaces<br>
#+ for dead cells in this file because of a peculiarity in Bash arrays.<br>
# &nbsp;[Exercise for the reader: explain this.]<br>
#<br>
# Lines beginning with a '#' are comments, and the script ignores them.<br>
__.__..___<br>
___._.____<br>
____.___..<br>
_._______.<br>
____._____<br>
..__...___<br>
____._____<br>
___...____<br>
__.._..___<br>
_..___..__<br>
+++<br>
Appendix A. Contributed Scripts<br>
583<br>
<hr>
<A name=590></a>Advanced Bash-Scripting Guide<br>
The following script is by Mark Moraes of the University of Toronto. See the file&nbsp;Moraes-COPYRIGHT&nbsp;for<br><a href="abs-guides.html#838">permissions and restrictions. This file is included in the combined HTML/source tarball of the</a><i>&nbsp;ABS Guide</i>.<br>
<b>Example A-12.<i>&nbsp;behead</i></b><b>: Removing mail and news message headers</b><br>
#! /bin/sh<br>
# Strips off the header from a mail/News message i.e. till the first<br>
# empty line.<br>
# Author: Mark Moraes, University of Toronto<br>
# ==&gt; These comments added by author of this document.<br>
if [ $# -eq 0 ]; then<br>
# ==&gt; If no command-line args present, then works on file redirected to stdin.<br>
&nbsp; &nbsp; &nbsp; &nbsp; sed -e '1,/^$/d' -e '/^[ &nbsp; &nbsp; &nbsp; &nbsp;]*$/d'<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; Delete empty lines and all lines until&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # --&gt; first one beginning with white space.<br>
else<br>
# ==&gt; If command-line args present, then work on files named.<br>
&nbsp; &nbsp; &nbsp; &nbsp; for i do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed -e '1,/^$/d' -e '/^[ &nbsp; &nbsp; &nbsp; &nbsp;]*$/d' $i<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # --&gt; Ditto, as above.<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
fi<br>
exit<br>
# ==&gt; Exercise: Add error checking and other options.<br>
# ==&gt;<br>
# ==&gt; Note that the small sed script repeats, except for the arg passed.<br>
# ==&gt; Does it make sense to embed it in a function? Why or why not?<br>
/*<br>
&nbsp;* Copyright University of Toronto 1988, 1989.<br>
&nbsp;* Written by Mark Moraes<br>
&nbsp;*<br>
&nbsp;* Permission is granted to anyone to use this software for any purpose on<br>
&nbsp;* any computer system, and to alter it and redistribute it freely, subject<br>
&nbsp;* to the following restrictions:<br>
&nbsp;*<br>
&nbsp;* 1. The author and the University of Toronto are not responsible&nbsp;<br>
&nbsp;* &nbsp; &nbsp;for the consequences of use of this software, no matter how awful,&nbsp;<br>
&nbsp;* &nbsp; &nbsp;even if they arise from flaws in it.<br>
&nbsp;*<br>
&nbsp;* 2. The origin of this software must not be misrepresented, either by<br>
&nbsp;* &nbsp; &nbsp;explicit claim or by omission. &nbsp;Since few users ever read sources,<br>
&nbsp;* &nbsp; &nbsp;credits must appear in the documentation.<br>
&nbsp;*<br>
&nbsp;* 3. Altered versions must be plainly marked as such, and must not be<br>
&nbsp;* &nbsp; &nbsp;misrepresented as being the original software. &nbsp;Since few users<br>
&nbsp;* &nbsp; &nbsp;ever read sources, credits must appear in the documentation.<br>
&nbsp;*<br>
&nbsp;* 4. This notice may not be removed or altered.<br>
&nbsp;*/<br>
+<br>
Antek Sawicki contributed the following script, which makes very clever use of the parameter substitution<br><a href="abs-guides.html#133">operators discussed in Section 10.2.</a><br>
Appendix A. Contributed Scripts<br>
584<br>
<hr>
<A name=591></a>Advanced Bash-Scripting Guide<br>
<b>Example A-13.<i>&nbsp;password</i></b><b>: Generating random 8-character passwords</b><br>
#!/bin/bash<br>
# May need to be invoked with &nbsp;#!/bin/bash2 &nbsp;on older machines.<br>
#<br>
# &nbsp;Random password generator for Bash 2.x +<br>
#+ by Antek Sawicki &lt;tenox@tenox.tc&gt;,<br>
#+ who generously gave usage permission to the ABS Guide author.<br>
#<br>
# ==&gt; Comments added by document author ==&gt;<br>
MATRIX=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;<br>
# ==&gt; Password will consist of alphanumeric characters.<br>
LENGTH=&quot;8&quot;<br>
# ==&gt; May change 'LENGTH' for longer password.<br>
while [ &quot;${n:=1}&quot; -le &quot;$LENGTH&quot; ]<br>
# ==&gt; Recall that := is &quot;default substitution&quot; operator.<br>
# ==&gt; So, if 'n' has not been initialized, set it to 1.<br>
do<br>
&nbsp; &nbsp; &nbsp; &nbsp; PASS=&quot;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Very clever, but tricky.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Starting from the innermost nesting...<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; ${#MATRIX} returns length of array MATRIX.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; $RANDOM%${#MATRIX} returns random number between 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; and [length of MATRIX] - 1.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; ${MATRIX:$(($RANDOM%${#MATRIX})):1}<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; returns expansion of MATRIX at random position, by length 1.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; See {var:pos:len} parameter substitution in Chapter 9.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; and the associated examples.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; PASS=... simply pastes this result onto previous PASS (concatenation).<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; To visualize this more clearly, uncomment the following line<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$PASS&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; to see PASS being built up,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; one character at a time, each iteration of the loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp; let n+=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Increment 'n' for next pass.<br>
done<br>
echo &quot;$PASS&quot; &nbsp; &nbsp; &nbsp;# ==&gt; Or, redirect to a file, as desired.<br>
exit 0<br>
+<br>
James R. Van Zandt contributed this script which uses named pipes and, in his words, &quot;really exercises<br>quoting and escaping.&quot;<br>
<b>Example A-14.<i>&nbsp;fifo</i></b><b>: Making daily backups, using named pipes</b><br>
#!/bin/bash<br>
# ==&gt; Script by James R. Van Zandt, and used here with his permission.<br>
Appendix A. Contributed Scripts<br>
585<br>
<hr>
<A name=592></a>Advanced Bash-Scripting Guide<br>
# ==&gt; Comments added by author of this document.<br>
&nbsp; HERE=`uname -n` &nbsp; &nbsp;# ==&gt; hostname<br>
&nbsp; THERE=bilbo<br>
&nbsp; echo &quot;starting remote backup to $THERE at `date +%r`&quot;<br>
&nbsp; # ==&gt; `date +%r` returns time in 12-hour format, i.e. &quot;08:08:34 PM&quot;.<br>
&nbsp; # make sure /pipe really is a pipe and not a plain file<br>
&nbsp; rm -rf /pipe<br>
&nbsp; mkfifo /pipe &nbsp; &nbsp; &nbsp; # ==&gt; Create a &quot;named pipe&quot;, named &quot;/pipe&quot; ...<br>
&nbsp; # ==&gt; 'su xyz' runs commands as user &quot;xyz&quot;.<br>
&nbsp; # ==&gt; 'ssh' invokes secure shell (remote login client).<br>
&nbsp; su xyz -c &quot;ssh $THERE \&quot;cat &gt; /home/xyz/backup/${HERE}-daily.tar.gz\&quot; &lt; /pipe&quot;&amp;<br>
&nbsp; cd /<br>
&nbsp; tar -czf - bin boot dev etc home info lib man root sbin share usr var &gt; /pipe<br>
&nbsp; # ==&gt; Uses named pipe, /pipe, to communicate between processes:<br>
&nbsp; # ==&gt; 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.<br>
&nbsp; # ==&gt; The end result is this backs up the main directories, from / on down.<br>
&nbsp; # ==&gt; &nbsp;What are the advantages of a &quot;named pipe&quot; in this situation,<br>
&nbsp; # ==&gt;+ as opposed to an &quot;anonymous pipe&quot;, with |?<br>
&nbsp; # ==&gt; &nbsp;Will an anonymous pipe even work here?<br>
&nbsp; # ==&gt; &nbsp;Is it necessary to delete the pipe before exiting the script?<br>
&nbsp; # ==&gt; &nbsp;How could that be done?<br>
&nbsp; exit 0<br>
+<br>
Stéphane Chazelas used the following script to demonstrate generating prime numbers without arrays.<br>
<b>Example A-15. Generating prime numbers using the modulo operator</b><br>
#!/bin/bash<br>
# primes.sh: Generate prime numbers, without using arrays.<br>
# Script contributed by Stephane Chazelas.<br>
# &nbsp;This does *not* use the classic &quot;Sieve of Eratosthenes&quot; algorithm,<br>
#+ but instead the more intuitive method of testing each candidate number<br>
#+ for factors (divisors), using the &quot;%&quot; modulo operator.<br>
LIMIT=1000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Primes, 2 ... 1000.<br>
Primes()<br>
{<br>
&nbsp;(( n = $1 + 1 )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bump to next integer.<br>
&nbsp;shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Next parameter in list.<br>
# &nbsp;echo &quot;_n=$n i=$i_&quot;<br>
&nbsp;if (( n == LIMIT ))<br>
&nbsp;then echo $*<br>
Appendix A. Contributed Scripts<br>
586<br>
<hr>
<A name=593></a>Advanced Bash-Scripting Guide<br>
&nbsp;return<br>
&nbsp;fi<br>
&nbsp;for i; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &quot;i&quot; set to &quot;@&quot;, previous values of $n.<br>
# &nbsp; echo &quot;-n=$n i=$i-&quot;<br>
&nbsp; &nbsp;(( i * i &gt; n )) &amp;&amp; break &nbsp; # Optimization.<br>
&nbsp; &nbsp;(( n % i )) &amp;&amp; continue &nbsp; &nbsp;# Sift out non-primes using modulo operator.<br>
&nbsp; &nbsp;Primes $n $@ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Recursion inside loop.<br>
&nbsp; &nbsp;return<br>
&nbsp; &nbsp;done<br>
&nbsp; &nbsp;Primes $n $@ $n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Recursion outside loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Successively accumulate<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ positional parameters.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;&quot;$@&quot; is the accumulating list of primes.<br>
}<br>
Primes 1<br>
exit $?<br>
# Pipe output of the script to 'fmt' for prettier printing.<br>
# &nbsp;Uncomment lines 16 and 24 to help figure out what is going on.<br>
# &nbsp;Compare the speed of this algorithm for generating primes<br>
#+ with the Sieve of Eratosthenes (ex68.sh).<br>
# &nbsp;Exercise: Rewrite this script without recursion.<br>
+<br>
Rick Boivie's revision of Jordi Sanfeliu's<i>&nbsp;tree</i>&nbsp;script.<br>
<b>Example A-16.<i>&nbsp;tree</i></b><b>: Displaying a directory tree</b><br>
#!/bin/bash<br>
# tree.sh<br>
# &nbsp;Written by Rick Boivie.<br>
# &nbsp;Used with permission.<br>
# &nbsp;This is a revised and simplified version of a script<br>
#+ by Jordi Sanfeliu (the original author), and patched by Ian Kjos.<br>
# &nbsp;This script replaces the earlier version used in<br>
#+ previous releases of the Advanced Bash Scripting Guide.<br>
# &nbsp;Copyright (c) 2002, by Jordi Sanfeliu, Rick Boivie, and Ian Kjos.<br>
# ==&gt; Comments added by the author of this document.<br>
search () {<br>
for dir in `echo *`<br>
# &nbsp;==&gt; `echo *` lists all the files in current working directory,<br>
#+ ==&gt; without line breaks.<br>
# &nbsp;==&gt; Similar effect to for dir in *<br>
# &nbsp;==&gt; but &quot;dir in `echo *`&quot; will not handle filenames with blanks.<br>
do<br>
&nbsp; if [ -d &quot;$dir&quot; ] ; then # ==&gt; If it is a directory (-d)...<br>
&nbsp; zz=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ==&gt; Temp variable, keeping track of<br>
Appendix A. Contributed Scripts<br>
587<br>
<hr>
<A name=594></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; directory level.<br>
&nbsp; while [ $zz != $1 ] &nbsp; &nbsp; # Keep track of inner nested loop.<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;| &quot; &nbsp; &nbsp; &nbsp; &nbsp;# ==&gt; Display vertical connector symbol,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; with 2 spaces &amp; no line feed<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; in order to indent.<br>
&nbsp; &nbsp; &nbsp; zz=`expr $zz + 1` &nbsp; # ==&gt; Increment zz.<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; if [ -L &quot;$dir&quot; ] ; then # ==&gt; If directory is a symbolic link...<br>
&nbsp; &nbsp; &nbsp; echo &quot;+---$dir&quot; `ls -l $dir | sed 's/^.*'$dir' //'`<br>
&nbsp; &nbsp; &nbsp; # ==&gt; Display horiz. connector and list directory name, but...<br>
&nbsp; &nbsp; &nbsp; # ==&gt; delete date/time part of long listing.<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; echo &quot;+---$dir&quot; &nbsp; &nbsp; &nbsp; # ==&gt; Display horizontal connector symbol...<br>
&nbsp; &nbsp; &nbsp; # ==&gt; and print directory name.<br>
&nbsp; &nbsp; &nbsp; numdirs=`expr $numdirs + 1` # ==&gt; Increment directory count.<br>
&nbsp; &nbsp; &nbsp; if cd &quot;$dir&quot; ; then &nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; If can move to subdirectory...<br>
&nbsp; &nbsp; &nbsp; &nbsp; search `expr $1 + 1` &nbsp; &nbsp; &nbsp;# with recursion ;-)<br>
&nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; Function calls itself.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd ..<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; fi<br>
done<br>
}<br>
if [ $# != 0 ] ; then<br>
&nbsp; cd $1 &nbsp; # Move to indicated directory.<br>
&nbsp; #else &nbsp; # stay in current directory<br>
fi<br>
echo &quot;Initial directory = `pwd`&quot;<br>
numdirs=0<br>
search 0<br>
echo &quot;Total directories = $numdirs&quot;<br>
exit 0<br>
Patsie's version of a directory<i>&nbsp;tree</i>&nbsp;script.<br>
<b>Example A-17.<i>&nbsp;tree2</i></b><b>: Alternate directory tree script</b><br>
#!/bin/bash<br>
# tree2.sh<br>
# Lightly modified/reformatted by ABS Guide author.<br>
# Included in ABS Guide with permission of script author (thanks!).<br>
## Recursive file/dirsize checking script, by Patsie<br>
##<br>
## This script builds a list of files/directories and their size (du -akx)<br>
## and processes this list to a human readable tree shape<br>
## The 'du -akx' is only as good as the permissions the owner has.<br>
## So preferably run as root* to get the best results, or use only on<br>
## directories for which you have read permissions. Anything you can't<br>
## read is not in the list.<br>
#* ABS Guide author advises caution when running scripts as root!<br>
Appendix A. Contributed Scripts<br>
588<br>
<hr>
<A name=595></a>Advanced Bash-Scripting Guide<br>
########## &nbsp;THIS IS CONFIGURABLE &nbsp;##########<br>
TOP=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Top 5 biggest (sub)directories.<br>
MAXRECURS=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Max 5 subdirectories/recursions deep.<br>
E_BL=80 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Blank line already returned.<br>
E_DIR=81 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Directory not specified.<br>
########## &nbsp;DON'T CHANGE ANYTHING BELOW THIS LINE &nbsp;##########<br>
PID=$$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Our own process ID.<br>
SELF=`basename $0` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Our own program name.<br>
TMP=&quot;/tmp/${SELF}.${PID}.tmp&quot; &nbsp; &nbsp; # Temporary 'du' result.<br>
# Convert number to dotted thousand.<br>
function dot { echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$*&quot; |<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' |<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tail -c 12; }<br>
# Usage: tree &lt;recursion&gt; &lt;indent prefix&gt; &lt;min size&gt; &lt;directory&gt;<br>
function tree {<br>
&nbsp; recurs=&quot;$1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # How deep nested are we?<br>
&nbsp; prefix=&quot;$2&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # What do we display before file/dirname?<br>
&nbsp; minsize=&quot;$3&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# What is the minumum file/dirsize?<br>
&nbsp; dirname=&quot;$4&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Which directory are we checking?<br>
# Get ($TOP) biggest subdirs/subfiles from TMP file.<br>
&nbsp; LIST=`egrep &quot;[[:space:]]${dirname}/[^/]*$&quot; &quot;$TMP&quot; |<br>
&nbsp; &nbsp; &nbsp; &nbsp; awk '{if($1&gt;'$minsize') print;}' | sort -nr | head -$TOP`<br>
&nbsp; [ -z &quot;$LIST&quot; ] &amp;&amp; return &nbsp; &nbsp; &nbsp; &nbsp;# Empty list, then go back.<br>
&nbsp; cnt=0<br>
&nbsp; num=`echo &quot;$LIST&quot; | wc -l` &nbsp; &nbsp; &nbsp;# How many entries in the list.<br>
&nbsp; ## Main loop<br>
&nbsp; echo &quot;$LIST&quot; | while read size name; do<br>
&nbsp; &nbsp; ((cnt+=1)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Count entry number.<br>
&nbsp; &nbsp; bname=`basename &quot;$name&quot;` &nbsp; &nbsp; &nbsp;# We only need a basename of the entry.<br>
&nbsp; &nbsp; [ -d &quot;$name&quot; ] &amp;&amp; bname=&quot;$bname/&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If it's a directory, append a slash.<br>
&nbsp; &nbsp; echo &quot;`dot $size`$prefix +-$bname&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Display the result.<br>
&nbsp; &nbsp; # &nbsp;Call ourself recursively if it's a directory<br>
&nbsp; &nbsp; #+ and we're not nested too deep ($MAXRECURS).<br>
&nbsp; &nbsp; # &nbsp;The recursion goes up: $((recurs+1))<br>
&nbsp; &nbsp; # &nbsp;The prefix gets a space if it's the last entry,<br>
&nbsp; &nbsp; #+ or a pipe if there are more entries.<br>
&nbsp; &nbsp; # &nbsp;The minimum file/dirsize becomes<br>
&nbsp; &nbsp; #+ a tenth of his parent: $((size/10)).<br>
&nbsp; &nbsp; # Last argument is the full directory name to check.<br>
&nbsp; &nbsp; if [ -d &quot;$name&quot; -a $recurs -lt $MAXRECURS ]; then<br>
&nbsp; &nbsp; &nbsp; [ $cnt -lt $num ] \<br>
&nbsp; &nbsp; &nbsp; &nbsp; || (tree $((recurs+1)) &quot;$prefix &nbsp;&quot; $((size/10)) &quot;$name&quot;) \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (tree $((recurs+1)) &quot;$prefix |&quot; $((size/10)) &quot;$name&quot;)<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; [ $? -eq 0 ] &amp;&amp; echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $prefix&quot;<br>
&nbsp; # Every time we jump back add a 'blank' line.<br>
&nbsp; return $E_BL<br>
&nbsp; # We return 80 to tell we added a blank line already.<br>
Appendix A. Contributed Scripts<br>
589<br>
<hr>
<A name=596></a>Advanced Bash-Scripting Guide<br>
}<br>
### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;###<br>
### &nbsp;main program &nbsp;###<br>
### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;###<br>
rootdir=&quot;$@&quot;<br>
[ -d &quot;$rootdir&quot; ] ||<br>
&nbsp; { echo &quot;$SELF: Usage: $SELF &lt;directory&gt;&quot; &gt;&amp;2; exit $E_DIR; }<br>
&nbsp; # We should be called with a directory name.<br>
echo &quot;Building inventory list, please wait ...&quot;<br>
&nbsp; &nbsp; &nbsp;# Show &quot;please wait&quot; message.<br>
du -akx &quot;$rootdir&quot; 1&gt;&quot;$TMP&quot; 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp;# Build a temporary list of all files/dirs and their size.<br>
size=`tail -1 &quot;$TMP&quot; | awk '{print $1}'`<br>
&nbsp; &nbsp; &nbsp;# What is our rootdirectory's size?<br>
echo &quot;`dot $size` $rootdir&quot;<br>
&nbsp; &nbsp; &nbsp;# Display rootdirectory's entry.<br>
tree 0 &quot;&quot; 0 &quot;$rootdir&quot;<br>
&nbsp; &nbsp; &nbsp;# Display the tree below our rootdirectory.<br>
rm &quot;$TMP&quot; 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp;# Clean up TMP file.<br>
exit $?<br>
Noah Friedman permitted use of his<i>&nbsp;string function</i>&nbsp;script. It essentially reproduces some of the<i>&nbsp;C</i>-library<br>string manipulation functions.<br>
<b>Example A-18.<i>&nbsp;string functions</i></b><b>: C-style string functions</b><br>
#!/bin/bash<br>
# string.bash --- bash emulation of string(3) library routines<br>
# Author: Noah Friedman &lt;friedman@prep.ai.mit.edu&gt;<br>
# ==&gt; &nbsp; &nbsp; Used with his kind permission in this document.<br>
# Created: 1992-07-01<br>
# Last modified: 1993-09-29<br>
# Public domain<br>
# Conversion to bash v2 syntax done by Chet Ramey<br>
# Commentary:<br>
# Code:<br>
#:docstring strcat:<br>
# Usage: strcat s1 s2<br>
#<br>
# Strcat appends the value of variable s2 to variable s1.&nbsp;<br>
#<br>
# Example:<br>
# &nbsp; &nbsp;a=&quot;foo&quot;<br>
# &nbsp; &nbsp;b=&quot;bar&quot;<br>
# &nbsp; &nbsp;strcat a b<br>
# &nbsp; &nbsp;echo $a<br>
# &nbsp; &nbsp;=&gt; foobar<br>
#<br>
#:end docstring:<br>
Appendix A. Contributed Scripts<br>
590<br>
<hr>
<A name=597></a>Advanced Bash-Scripting Guide<br>
###;;;autoload &nbsp; ==&gt; Autoloading of function commented out.<br>
function strcat ()<br>
{<br>
&nbsp; &nbsp; local s1_val s2_val<br>
&nbsp; &nbsp; s1_val=${!1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# indirect variable expansion<br>
&nbsp; &nbsp; s2_val=${!2}<br>
&nbsp; &nbsp; eval &quot;$1&quot;=\'&quot;${s1_val}${s2_val}&quot;\'<br>
&nbsp; &nbsp; # ==&gt; eval $1='${s1_val}${s2_val}' avoids problems,<br>
&nbsp; &nbsp; # ==&gt; if one of the variables contains a single quote.<br>
}<br>
#:docstring strncat:<br>
# Usage: strncat s1 s2 $n<br>
#&nbsp;<br>
# Line strcat, but strncat appends a maximum of n characters from the value<br>
# of variable s2. &nbsp;It copies fewer if the value of variabl s2 is shorter<br>
# than n characters. &nbsp;Echoes result on stdout.<br>
#<br>
# Example:<br>
# &nbsp; &nbsp;a=foo<br>
# &nbsp; &nbsp;b=barbaz<br>
# &nbsp; &nbsp;strncat a b 3<br>
# &nbsp; &nbsp;echo $a<br>
# &nbsp; &nbsp;=&gt; foobar<br>
#<br>
#:end docstring:<br>
###;;;autoload<br>
function strncat ()<br>
{<br>
&nbsp; &nbsp; local s1=&quot;$1&quot;<br>
&nbsp; &nbsp; local s2=&quot;$2&quot;<br>
&nbsp; &nbsp; local -i n=&quot;$3&quot;<br>
&nbsp; &nbsp; local s1_val s2_val<br>
&nbsp; &nbsp; s1_val=${!s1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ==&gt; indirect variable expansion<br>
&nbsp; &nbsp; s2_val=${!s2}<br>
&nbsp; &nbsp; if [ ${#s2_val} -gt ${n} ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;s2_val=${s2_val:0:$n} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ==&gt; substring extraction<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; eval &quot;$s1&quot;=\'&quot;${s1_val}${s2_val}&quot;\'<br>
&nbsp; &nbsp; # ==&gt; eval $1='${s1_val}${s2_val}' avoids problems,<br>
&nbsp; &nbsp; # ==&gt; if one of the variables contains a single quote.<br>
}<br>
#:docstring strcmp:<br>
# Usage: strcmp $s1 $s2<br>
#<br>
# Strcmp compares its arguments and returns an integer less than, equal to,<br>
# or greater than zero, depending on whether string s1 is lexicographically<br>
# less than, equal to, or greater than string s2.<br>
#:end docstring:<br>
###;;;autoload<br>
function strcmp ()<br>
{<br>
&nbsp; &nbsp; [ &quot;$1&quot; = &quot;$2&quot; ] &amp;&amp; return 0<br>
&nbsp; &nbsp; [ &quot;${1}&quot; '&lt;' &quot;${2}&quot; ] &gt; /dev/null &amp;&amp; return -1<br>
Appendix A. Contributed Scripts<br>
591<br>
<hr>
<A name=598></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; return 1<br>
}<br>
#:docstring strncmp:<br>
# Usage: strncmp $s1 $s2 $n<br>
#&nbsp;<br>
# Like strcmp, but makes the comparison by examining a maximum of n<br>
# characters (n less than or equal to zero yields equality).<br>
#:end docstring:<br>
###;;;autoload<br>
function strncmp ()<br>
{<br>
&nbsp; &nbsp; if [ -z &quot;${3}&quot; -o &quot;${3}&quot; -le &quot;0&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;return 0<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;strcmp &quot;$1&quot; &quot;$2&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;return $?<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp;s1=${1:0:$3}<br>
&nbsp; &nbsp; &nbsp; &nbsp;s2=${2:0:$3}<br>
&nbsp; &nbsp; &nbsp; &nbsp;strcmp $s1 $s2<br>
&nbsp; &nbsp; &nbsp; &nbsp;return $?<br>
&nbsp; &nbsp; fi<br>
}<br>
#:docstring strlen:<br>
# Usage: strlen s<br>
#<br>
# Strlen returns the number of characters in string literal s.<br>
#:end docstring:<br>
###;;;autoload<br>
function strlen ()<br>
{<br>
&nbsp; &nbsp; eval echo &quot;\${#${1}}&quot;<br>
&nbsp; &nbsp; # ==&gt; Returns the length of the value of the variable<br>
&nbsp; &nbsp; # ==&gt; whose name is passed as an argument.<br>
}<br>
#:docstring strspn:<br>
# Usage: strspn $s1 $s2<br>
#&nbsp;<br>
# Strspn returns the length of the maximum initial segment of string s1,<br>
# which consists entirely of characters from string s2.<br>
#:end docstring:<br>
###;;;autoload<br>
function strspn ()<br>
{<br>
&nbsp; &nbsp; # Unsetting IFS allows whitespace to be handled as normal chars.&nbsp;<br>
&nbsp; &nbsp; local IFS=<br>
&nbsp; &nbsp; local result=&quot;${1%%[!${2}]*}&quot;<br>
&nbsp; &nbsp; echo ${#result}<br>
}<br>
#:docstring strcspn:<br>
# Usage: strcspn $s1 $s2<br>
Appendix A. Contributed Scripts<br>
592<br>
<hr>
<A name=599></a>Advanced Bash-Scripting Guide<br>
#<br>
# Strcspn returns the length of the maximum initial segment of string s1,<br>
# which consists entirely of characters not from string s2.<br>
#:end docstring:<br>
###;;;autoload<br>
function strcspn ()<br>
{<br>
&nbsp; &nbsp; # Unsetting IFS allows whitspace to be handled as normal chars.&nbsp;<br>
&nbsp; &nbsp; local IFS=<br>
&nbsp; &nbsp; local result=&quot;${1%%[${2}]*}&quot;<br>
&nbsp; &nbsp; echo ${#result}<br>
}<br>
#:docstring strstr:<br>
# Usage: strstr s1 s2<br>
#&nbsp;<br>
# Strstr echoes a substring starting at the first occurrence of string s2 in<br>
# string s1, or nothing if s2 does not occur in the string. &nbsp;If s2 points to<br>
# a string of zero length, strstr echoes s1.<br>
#:end docstring:<br>
###;;;autoload<br>
function strstr ()<br>
{<br>
&nbsp; &nbsp; # if s2 points to a string of zero length, strstr echoes s1<br>
&nbsp; &nbsp; [ ${#2} -eq 0 ] &amp;&amp; { echo &quot;$1&quot; ; return 0; }<br>
&nbsp; &nbsp; # strstr echoes nothing if s2 does not occur in s1<br>
&nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; *$2*) ;;<br>
&nbsp; &nbsp; *) return 1;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; # use the pattern matching code to strip off the match and everything<br>
&nbsp; &nbsp; # following it<br>
&nbsp; &nbsp; first=${1/$2*/}<br>
&nbsp; &nbsp; # then strip off the first unmatched portion of the string<br>
&nbsp; &nbsp; echo &quot;${1##$first}&quot;<br>
}<br>
#:docstring strtok:<br>
# Usage: strtok s1 s2<br>
#<br>
# Strtok considers the string s1 to consist of a sequence of zero or more<br>
# text tokens separated by spans of one or more characters from the<br>
# separator string s2. &nbsp;The first call (with a non-empty string s1<br>
# specified) echoes a string consisting of the first token on stdout. The<br>
# function keeps track of its position in the string s1 between separate<br>
# calls, so that subsequent calls made with the first argument an empty<br>
# string will work through the string immediately following that token. &nbsp;In<br>
# this way subsequent calls will work through the string s1 until no tokens<br>
# remain. &nbsp;The separator string s2 may be different from call to call.<br>
# When no token remains in s1, an empty value is echoed on stdout.<br>
#:end docstring:<br>
###;;;autoload<br>
function strtok ()<br>
{<br>
&nbsp;:<br>
Appendix A. Contributed Scripts<br>
593<br>
<hr>
<A name=600></a>Advanced Bash-Scripting Guide<br>
}<br>
#:docstring strtrunc:<br>
# Usage: strtrunc $n $s1 {$s2} {$...}<br>
#<br>
# Used by many functions like strncmp to truncate arguments for comparison.<br>
# Echoes the first n characters of each string s1 s2 ... on stdout.&nbsp;<br>
#:end docstring:<br>
###;;;autoload<br>
function strtrunc ()<br>
{<br>
&nbsp; &nbsp; n=$1 ; shift<br>
&nbsp; &nbsp; for z; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;${z:0:$n}&quot;<br>
&nbsp; &nbsp; done<br>
}<br>
# provide string<br>
# string.bash ends here<br>
# ========================================================================== #<br>
# ==&gt; Everything below here added by the document author.<br>
# ==&gt; Suggested use of this script is to delete everything below here,<br>
# ==&gt; and &quot;source&quot; this file into your own scripts.<br>
# strcat<br>
string0=one<br>
string1=two<br>
echo<br>
echo &quot;Testing \&quot;strcat\&quot; function:&quot;<br>
echo &quot;Original \&quot;string0\&quot; = $string0&quot;<br>
echo &quot;\&quot;string1\&quot; = $string1&quot;<br>
strcat string0 string1<br>
echo &quot;New \&quot;string0\&quot; = $string0&quot;<br>
echo<br>
# strlen<br>
echo<br>
echo &quot;Testing \&quot;strlen\&quot; function:&quot;<br>
str=123456789<br>
echo &quot;\&quot;str\&quot; = $str&quot;<br>
echo -n &quot;Length of \&quot;str\&quot; = &quot;<br>
strlen str<br>
echo<br>
# Exercise:<br>
# --------<br>
# Add code to test all the other string functions above.<br>
exit 0<br>
<a href="abs-guides.html#275">Michael Zick's complex array example uses the md5sum check sum command to encode directory<br></a>information.<br>
Appendix A. Contributed Scripts<br>
594<br>
<hr>
<A name=601></a>Advanced Bash-Scripting Guide<br>
<b>Example A-19. Directory information</b><br>
#! /bin/bash<br>
# directory-info.sh<br>
# Parses and lists directory information.<br>
# NOTE: Change lines 273 and 353 per &quot;README&quot; file.<br>
# Michael Zick is the author of this script.<br>
# Used here with his permission.<br>
# Controls<br>
# If overridden by command arguments, they must be in the order:<br>
# &nbsp; Arg1: &quot;Descriptor Directory&quot;<br>
# &nbsp; Arg2: &quot;Exclude Paths&quot;<br>
# &nbsp; Arg3: &quot;Exclude Directories&quot;<br>
#<br>
# Environment Settings override Defaults.<br>
# Command arguments override Environment Settings.<br>
# Default location for content addressed file descriptors.<br>
MD5UCFS=${1:-${MD5UCFS:-'/tmpfs/ucfs'}}<br>
# Directory paths never to list or enter<br>
declare -a \<br>
&nbsp; EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-'(/proc /dev /devfs /tmpfs)'}}<br>
# Directories never to list or enter<br>
declare -a \<br>
&nbsp; EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-'(ucfs lost+found tmp wtmp)'}}<br>
# Files never to list or enter<br>
declare -a \<br>
&nbsp; EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-'(core &quot;Name with Spaces&quot;)'}}<br>
# Here document used as a comment block.<br>
: &lt;&lt;LSfieldsDoc<br>
# # # # # List Filesystem Directory Information # # # # #<br>
#<br>
# &nbsp; &nbsp; &nbsp; ListDirectory &quot;FileGlob&quot; &quot;Field-Array-Name&quot;<br>
# or<br>
# &nbsp; &nbsp; &nbsp; ListDirectory -of &quot;FileGlob&quot; &quot;Field-Array-Filename&quot;<br>
# &nbsp; &nbsp; &nbsp; '-of' meaning 'output to filename'<br>
# # # # #<br>
String format description based on: ls (GNU fileutils) version 4.0.36<br>
Produces a line (or more) formatted:<br>
inode permissions hard-links owner group ...<br>
32736 -rw------- &nbsp; &nbsp;1 mszick &nbsp; mszick<br>
size &nbsp; &nbsp;day month date hh:mm:ss year path<br>
2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core<br>
Unless it is formatted:<br>
inode permissions hard-links owner group ...<br>
266705 crw-rw---- &nbsp; &nbsp;1 &nbsp; &nbsp;root &nbsp;uucp<br>
major minor day month date hh:mm:ss year path<br>
4, &nbsp;68 Sun Apr 20 09:27:33 2003 /dev/ttyS4<br>
NOTE: that pesky comma after the major number<br>
Appendix A. Contributed Scripts<br>
595<br>
<hr>
<A name=602></a>Advanced Bash-Scripting Guide<br>
NOTE: the 'path' may be multiple fields:<br>
/home/mszick/core<br>
/proc/982/fd/0 -&gt; /dev/null<br>
/proc/982/fd/1 -&gt; /home/mszick/.xsession-errors<br>
/proc/982/fd/13 -&gt; /tmp/tmpfZVVOCs (deleted)<br>
/proc/982/fd/7 -&gt; /tmp/kde-mszick/ksycoca<br>
/proc/982/fd/8 -&gt; socket:[11586]<br>
/proc/982/fd/9 -&gt; pipe:[11588]<br>
If that isn't enough to keep your parser guessing,<br>
either or both of the path components may be relative:<br>
../Built-Shared -&gt; Built-Static<br>
../linux-2.4.20.tar.bz2 -&gt; ../../../SRCS/linux-2.4.20.tar.bz2<br>
The first character of the 11 (10?) character permissions field:<br>
's' Socket<br>
'd' Directory<br>
'b' Block device<br>
'c' Character device<br>
'l' Symbolic link<br>
NOTE: Hard links not marked - test for identical inode numbers<br>
on identical filesystems.<br>
All information about hard linked files are shared, except<br>
for the names and the name's location in the directory system.<br>
NOTE: A &quot;Hard link&quot; is known as a &quot;File Alias&quot; on some systems.<br>
'-' An undistingushed file<br>
Followed by three groups of letters for: User, Group, Others<br>
Character 1: '-' Not readable; 'r' Readable<br>
Character 2: '-' Not writable; 'w' Writable<br>
Character 3, User and Group: Combined execute and special<br>
'-' Not Executable, Not Special<br>
'x' Executable, Not Special<br>
's' Executable, Special<br>
'S' Not Executable, Special<br>
Character 3, Others: Combined execute and sticky (tacky?)<br>
'-' Not Executable, Not Tacky<br>
'x' Executable, Not Tacky<br>
't' Executable, Tacky<br>
'T' Not Executable, Tacky<br>
Followed by an access indicator<br>
Haven't tested this one, it may be the eleventh character<br>
or it may generate another field<br>
' ' No alternate access<br>
'+' Alternate access<br>
LSfieldsDoc<br>
ListDirectory()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a T<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i of=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Default return in variable<br>
# &nbsp; &nbsp; &nbsp; OLD_IFS=$IFS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Using BASH default ' \t\n'<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$#&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 3) &nbsp; &nbsp; &nbsp;case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -of) &nbsp; &nbsp;of=1 ; shift ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ) &nbsp; &nbsp;return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2) &nbsp; &nbsp; &nbsp;: ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Poor man's &quot;continue&quot;<br>
Appendix A. Contributed Scripts<br>
596<br>
<hr>
<A name=603></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; # NOTE: the (ls) command is NOT quoted (&quot;)<br>
&nbsp; &nbsp; &nbsp; &nbsp; T=( $(ls --inode --ignore-backups --almost-all --directory \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --full-time --color=none --time=status --sort=none \<br>
&nbsp; &nbsp; &nbsp; &nbsp; --format=long $1) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; case $of in<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Assign T back to the array whose name was passed as $2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0) eval $2=\( \&quot;\$\{T\[@\]\}\&quot; \) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Write T into filename passed as $2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) echo &quot;${T[@]}&quot; &gt; &quot;$2&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp;}<br>
# # # # # Is that string a legal number? # # # # #<br>
#<br>
# &nbsp; &nbsp; &nbsp; IsNumber &quot;Var&quot;<br>
# # # # # There has to be a better way, sigh...<br>
IsNumber()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i int<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ $# -eq 0 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let int=$1) &nbsp;2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return $? &nbsp; &nbsp; &nbsp; # Exit status of the let thread<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
}<br>
# # # # # Index Filesystem Directory Information # # # # #<br>
#<br>
# &nbsp; &nbsp; &nbsp; IndexList &quot;Field-Array-Name&quot; &quot;Index-Array-Name&quot;<br>
# or<br>
# &nbsp; &nbsp; &nbsp; IndexList -if Field-Array-Filename Index-Array-Name<br>
# &nbsp; &nbsp; &nbsp; IndexList -of Field-Array-Name Index-Array-Filename<br>
# &nbsp; &nbsp; &nbsp; IndexList -if -of Field-Array-Filename Index-Array-Filename<br>
# # # # #<br>
: &lt;&lt;IndexListDoc<br>
Walk an array of directory fields produced by ListDirectory<br>
Having suppressed the line breaks in an otherwise line oriented<br>
report, build an index to the array element which starts each line.<br>
Each line gets two index entries, the first element of each line<br>
(inode) and the element that holds the pathname of the file.<br>
The first index entry pair (Line-Number==0) are informational:<br>
Index-Array-Name[0] : Number of &quot;Lines&quot; indexed<br>
Index-Array-Name[1] : &quot;Current Line&quot; pointer into Index-Array-Name<br>
The following index pairs (if any) hold element indexes into<br>
the Field-Array-Name per:<br>
Index-Array-Name[Line-Number * 2] : The &quot;inode&quot; field element.<br>
NOTE: This distance may be either +11 or +12 elements.<br>
Index-Array-Name[(Line-Number * 2) + 1] : The &quot;pathname&quot; element.<br>
NOTE: This distance may be a variable number of elements.<br>
Appendix A. Contributed Scripts<br>
597<br>
<hr>
<A name=604></a>Advanced Bash-Scripting Guide<br>
Next line index pair for Line-Number+1.<br>
IndexListDoc<br>
IndexList()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a LIST &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Local of listname passed<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a -i INDEX=( 0 0 ) &nbsp; &nbsp; &nbsp; # Local of index to return<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i Lidx Lcnt<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i if=0 of=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default to variable names<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$#&quot; in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Simplistic option testing<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2) : ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Poor man's continue<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3) case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -if) if=1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -of) of=1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;esac ; shift ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4) if=1 ; of=1 ; shift ; shift ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) return 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Make local copy of list<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$if&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0) eval LIST=\( \&quot;\$\{$1\[@\]\}\&quot; \) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) LIST=( $(cat $1) ) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Grok (grope?) the array<br>
&nbsp; &nbsp; &nbsp; &nbsp; Lcnt=${#LIST[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; Lidx=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; until (( Lidx &gt;= Lcnt ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; if IsNumber ${LIST[$Lidx]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local -i inode name<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local ft<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode=Lidx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local m=${LIST[$Lidx+2]} &nbsp; &nbsp; &nbsp; &nbsp;# Hard Links field<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ft=${LIST[$Lidx+1]:0:1} &nbsp; &nbsp; &nbsp; &nbsp; # Fast-Stat<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case $ft in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b) &nbsp; &nbsp; &nbsp;((Lidx+=12)) ;; &nbsp; &nbsp; &nbsp; &nbsp; # Block device<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c) &nbsp; &nbsp; &nbsp;((Lidx+=12)) ;; &nbsp; &nbsp; &nbsp; &nbsp; # Character device<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;((Lidx+=11)) ;; &nbsp; &nbsp; &nbsp; &nbsp; # Anything else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name=Lidx<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case $ft in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -) &nbsp; &nbsp; &nbsp;((Lidx+=1)) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The easy one<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b) &nbsp; &nbsp; &nbsp;((Lidx+=1)) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Block device<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c) &nbsp; &nbsp; &nbsp;((Lidx+=1)) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Character device<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d) &nbsp; &nbsp; &nbsp;((Lidx+=1)) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The other easy one<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l) &nbsp; &nbsp; &nbsp;((Lidx+=3)) ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# At LEAST two more fields<br>
# &nbsp;A little more elegance here would handle pipes,<br>
#+ sockets, deleted files - later.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;until IsNumber ${LIST[$Lidx]} || ((Lidx &gt;= Lcnt))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Lidx+=1))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Not required<br>
Appendix A. Contributed Scripts<br>
598<br>
<hr>
<A name=605></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX[${#INDEX[*]}]=$inode<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX[${#INDEX[*]}]=$name<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX[0]=${INDEX[0]}+1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# One more &quot;line&quot; found<br>
# echo &quot;Line: ${INDEX[0]} Type: $ft Links: $m Inode: \<br>
# ${LIST[$inode]} Name: ${LIST[$name]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Lidx+=1))<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$of&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0) eval $2=\( \&quot;\$\{INDEX\[@\]\}\&quot; \) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) echo &quot;${INDEX[@]}&quot; &gt; &quot;$2&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# What could go wrong?<br>
}<br>
# # # # # Content Identify File # # # # #<br>
#<br>
# &nbsp; &nbsp; &nbsp; DigestFile Input-Array-Name Digest-Array-Name<br>
# or<br>
# &nbsp; &nbsp; &nbsp; DigestFile -if Input-FileName Digest-Array-Name<br>
# # # # #<br>
# Here document used as a comment block.<br>
: &lt;&lt;DigestFilesDoc<br>
The key (no pun intended) to a Unified Content File System (UCFS)<br>
is to distinguish the files in the system based on their content.<br>
Distinguishing files by their name is just so 20th Century.<br>
The content is distinguished by computing a checksum of that content.<br>
This version uses the md5sum program to generate a 128 bit checksum<br>
representative of the file's contents.<br>
There is a chance that two files having different content might<br>
generate the same checksum using md5sum (or any checksum). &nbsp;Should<br>
that become a problem, then the use of md5sum can be replace by a<br>
cyrptographic signature. &nbsp;But until then...<br>
The md5sum program is documented as outputting three fields (and it<br>
does), but when read it appears as two fields (array elements). &nbsp;This<br>
is caused by the lack of whitespace between the second and third field.<br>
So this function gropes the md5sum output and returns:<br>
&nbsp; &nbsp; &nbsp; &nbsp; [0] &nbsp; &nbsp; 32 character checksum in hexidecimal (UCFS filename)<br>
&nbsp; &nbsp; &nbsp; &nbsp; [1] &nbsp; &nbsp; Single character: ' ' text file, '*' binary file<br>
&nbsp; &nbsp; &nbsp; &nbsp; [2] &nbsp; &nbsp; Filesystem (20th Century Style) name<br>
&nbsp; &nbsp; &nbsp; &nbsp; Note: That name may be the character '-' indicating STDIN read.<br>
DigestFilesDoc<br>
DigestFile()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local if=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default, variable name<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a T1 T2<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$#&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 3) &nbsp; &nbsp; &nbsp;case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -if) &nbsp; &nbsp;if=1 ; shift ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ) &nbsp; &nbsp;return 1 ;;<br>
Appendix A. Contributed Scripts<br>
599<br>
<hr>
<A name=606></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2) &nbsp; &nbsp; &nbsp;: ;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Poor man's &quot;continue&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; case $if in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0) eval T1=\( \&quot;\$\{$1\[@\]\}\&quot; \)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T2=( $(echo ${T1[@]} | md5sum -) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1) T2=( $(md5sum $1) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; case ${#T2[@]} in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2) case ${T2[1]:0:1} in &nbsp; &nbsp; &nbsp; &nbsp; # SanScrit-2.0.5<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\*) T2[${#T2[@]}]=${T2[1]:1}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T2[1]=\*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) T2[${#T2[@]}]=${T2[1]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T2[1]=&quot; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 3) : ;; # Assume it worked<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i len=${#T2[0]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ $len -ne 32 ] ; then return 1 ; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \&quot;\$\{T2\[@\]\}\&quot; \)<br>
}<br>
# # # # # Locate File # # # # #<br>
#<br>
# &nbsp; &nbsp; &nbsp; LocateFile [-l] FileName Location-Array-Name<br>
# or<br>
# &nbsp; &nbsp; &nbsp; LocateFile [-l] -of FileName Location-Array-FileName<br>
# # # # #<br>
# A file location is Filesystem-id and inode-number<br>
# Here document used as a comment block.<br>
: &lt;&lt;StatFieldsDoc<br>
&nbsp; &nbsp; &nbsp; &nbsp; Based on stat, version 2.2<br>
&nbsp; &nbsp; &nbsp; &nbsp; stat -t and stat -lt fields<br>
&nbsp; &nbsp; &nbsp; &nbsp; [0] &nbsp; &nbsp; name<br>
&nbsp; &nbsp; &nbsp; &nbsp; [1] &nbsp; &nbsp; Total size<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; File - number of bytes<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Symbolic link - string length of pathname<br>
&nbsp; &nbsp; &nbsp; &nbsp; [2] &nbsp; &nbsp; Number of (512 byte) blocks allocated<br>
&nbsp; &nbsp; &nbsp; &nbsp; [3] &nbsp; &nbsp; File type and Access rights (hex)<br>
&nbsp; &nbsp; &nbsp; &nbsp; [4] &nbsp; &nbsp; User ID of owner<br>
&nbsp; &nbsp; &nbsp; &nbsp; [5] &nbsp; &nbsp; Group ID of owner<br>
&nbsp; &nbsp; &nbsp; &nbsp; [6] &nbsp; &nbsp; Device number<br>
&nbsp; &nbsp; &nbsp; &nbsp; [7] &nbsp; &nbsp; Inode number<br>
&nbsp; &nbsp; &nbsp; &nbsp; [8] &nbsp; &nbsp; Number of hard links<br>
&nbsp; &nbsp; &nbsp; &nbsp; [9] &nbsp; &nbsp; Device type (if inode device) Major<br>
&nbsp; &nbsp; &nbsp; &nbsp; [10] &nbsp; &nbsp;Device type (if inode device) Minor<br>
&nbsp; &nbsp; &nbsp; &nbsp; [11] &nbsp; &nbsp;Time of last access<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; May be disabled in 'mount' with noatime<br>
Appendix A. Contributed Scripts<br>
600<br>
<hr>
<A name=607></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atime of files changed by exec, read, pipe, utime, mknod (mmap?)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atime of directories changed by addition/deletion of files<br>
&nbsp; &nbsp; &nbsp; &nbsp; [12] &nbsp; &nbsp;Time of last modification<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtime of files changed by write, truncate, utime, mknod<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mtime of directories changed by addtition/deletion of files<br>
&nbsp; &nbsp; &nbsp; &nbsp; [13] &nbsp; &nbsp;Time of last change<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctime reflects time of changed inode information (owner, group<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; permissions, link count<br>
-*-*- Per:<br>
&nbsp; &nbsp; &nbsp; &nbsp; Return code: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Size of array: 14<br>
&nbsp; &nbsp; &nbsp; &nbsp; Contents of array<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 0: /home/mszick<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 1: 4096<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 2: 8<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 3: 41e8<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 4: 500<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 5: 500<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 6: 303<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 7: 32385<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 8: 22<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 9: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 10: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 11: 1051221030<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 12: 1051214068<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 13: 1051214068<br>
&nbsp; &nbsp; &nbsp; &nbsp; For a link in the form of linkname -&gt; realname<br>
&nbsp; &nbsp; &nbsp; &nbsp; stat -t &nbsp;linkname returns the linkname (link) information<br>
&nbsp; &nbsp; &nbsp; &nbsp; stat -lt linkname returns the realname information<br>
&nbsp; &nbsp; &nbsp; &nbsp; stat -tf and stat -ltf fields<br>
&nbsp; &nbsp; &nbsp; &nbsp; [0] &nbsp; &nbsp; name<br>
&nbsp; &nbsp; &nbsp; &nbsp; [1] &nbsp; &nbsp; ID-0? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Maybe someday, but Linux stat structure<br>
&nbsp; &nbsp; &nbsp; &nbsp; [2] &nbsp; &nbsp; ID-0? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # does not have either LABEL nor UUID<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # fields, currently information must come<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # from file-system specific utilities<br>
&nbsp; &nbsp; &nbsp; &nbsp; These will be munged into:<br>
&nbsp; &nbsp; &nbsp; &nbsp; [1] &nbsp; &nbsp; UUID if possible<br>
&nbsp; &nbsp; &nbsp; &nbsp; [2] &nbsp; &nbsp; Volume Label if possible<br>
&nbsp; &nbsp; &nbsp; &nbsp; Note: 'mount -l' does return the label and could return the UUID<br>
&nbsp; &nbsp; &nbsp; &nbsp; [3] &nbsp; &nbsp; Maximum length of filenames<br>
&nbsp; &nbsp; &nbsp; &nbsp; [4] &nbsp; &nbsp; Filesystem type<br>
&nbsp; &nbsp; &nbsp; &nbsp; [5] &nbsp; &nbsp; Total blocks in the filesystem<br>
&nbsp; &nbsp; &nbsp; &nbsp; [6] &nbsp; &nbsp; Free blocks<br>
&nbsp; &nbsp; &nbsp; &nbsp; [7] &nbsp; &nbsp; Free blocks for non-root user(s)<br>
&nbsp; &nbsp; &nbsp; &nbsp; [8] &nbsp; &nbsp; Block size of the filesystem<br>
&nbsp; &nbsp; &nbsp; &nbsp; [9] &nbsp; &nbsp; Total inodes<br>
&nbsp; &nbsp; &nbsp; &nbsp; [10] &nbsp; &nbsp;Free inodes<br>
-*-*- Per:<br>
&nbsp; &nbsp; &nbsp; &nbsp; Return code: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Size of array: 11<br>
&nbsp; &nbsp; &nbsp; &nbsp; Contents of array<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 0: /home/mszick<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 1: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 2: 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 3: 255<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 4: ef53<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 5: 2581445<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 6: 2277180<br>
Appendix A. Contributed Scripts<br>
601<br>
<hr>
<A name=608></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 7: 2146050<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 8: 4096<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 9: 1311552<br>
&nbsp; &nbsp; &nbsp; &nbsp; Element 10: 1276425<br>
StatFieldsDoc<br>
# &nbsp; &nbsp; &nbsp; LocateFile [-l] FileName Location-Array-Name<br>
# &nbsp; &nbsp; &nbsp; LocateFile [-l] -of FileName Location-Array-FileName<br>
LocateFile()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a LOC LOC1 LOC2<br>
&nbsp; &nbsp; &nbsp; &nbsp; local lk=&quot;&quot; of=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$#&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 0) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2) : ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) while (( &quot;$#&quot; &gt; 2 ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-l) lk=-1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -of) of=1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) return 1 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
# More Sanscrit-2.0.5<br>
&nbsp; &nbsp; &nbsp; # LOC1=( $(stat -t $lk $1) )<br>
&nbsp; &nbsp; &nbsp; # LOC2=( $(stat -tf $lk $1) )<br>
&nbsp; &nbsp; &nbsp; # Uncomment above two lines if system has &quot;stat&quot; command installed.<br>
&nbsp; &nbsp; &nbsp; &nbsp; LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${LOC2[@]:1:2} ${LOC2[@]:4:1} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$of&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0) eval $2=\( \&quot;\$\{LOC\[@\]\}\&quot; \) ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1) echo &quot;${LOC[@]}&quot; &gt; &quot;$2&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
# Which yields (if you are lucky, and have &quot;stat&quot; installed)<br>
# -*-*- Location Discriptor -*-*-<br>
# &nbsp; &nbsp; &nbsp; Return code: 0<br>
# &nbsp; &nbsp; &nbsp; Size of array: 15<br>
# &nbsp; &nbsp; &nbsp; Contents of array<br>
# &nbsp; &nbsp; &nbsp; Element 0: /home/mszick &nbsp; &nbsp; &nbsp; &nbsp; 20th Century name<br>
# &nbsp; &nbsp; &nbsp; Element 1: 41e8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Type and Permissions<br>
# &nbsp; &nbsp; &nbsp; Element 2: 500 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;User<br>
# &nbsp; &nbsp; &nbsp; Element 3: 500 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Group<br>
# &nbsp; &nbsp; &nbsp; Element 4: 303 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device<br>
# &nbsp; &nbsp; &nbsp; Element 5: 32385 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inode<br>
# &nbsp; &nbsp; &nbsp; Element 6: 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Link count<br>
# &nbsp; &nbsp; &nbsp; Element 7: 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device Major<br>
# &nbsp; &nbsp; &nbsp; Element 8: 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Device Minor<br>
# &nbsp; &nbsp; &nbsp; Element 9: 1051224608 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Last Access<br>
# &nbsp; &nbsp; &nbsp; Element 10: 1051214068 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Last Modify<br>
# &nbsp; &nbsp; &nbsp; Element 11: 1051214068 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Last Status<br>
# &nbsp; &nbsp; &nbsp; Element 12: 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UUID (to be)<br>
# &nbsp; &nbsp; &nbsp; Element 13: 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Volume Label (to be)<br>
Appendix A. Contributed Scripts<br>
602<br>
<hr>
<A name=609></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; Element 14: ef53 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Filesystem type<br>
}<br>
# And then there was some test code<br>
ListArray() # ListArray Name<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a Ta<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval Ta=\( \&quot;\$\{$1\[@\]\}\&quot; \)<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;-*-*- List of Array -*-*-&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Size of array $1: ${#Ta[*]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Contents of array $1:&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( i=0 ; i&lt;${#Ta[*]} ; i++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e &quot;\tElement $i: ${Ta[$i]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
}<br>
declare -a CUR_DIR<br>
# For small arrays<br>
ListDirectory &quot;${PWD}&quot; CUR_DIR<br>
ListArray CUR_DIR<br>
declare -a DIR_DIG<br>
DigestFile CUR_DIR DIR_DIG<br>
echo &quot;The new \&quot;name\&quot; (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}&quot;<br>
declare -a DIR_ENT<br>
# BIG_DIR # For really big arrays - use a temporary file in ramdisk<br>
# BIG-DIR # ListDirectory -of &quot;${CUR_DIR[11]}/*&quot; &quot;/tmpfs/junk2&quot;<br>
ListDirectory &quot;${CUR_DIR[11]}/*&quot; DIR_ENT<br>
declare -a DIR_IDX<br>
# BIG-DIR # IndexList -if &quot;/tmpfs/junk2&quot; DIR_IDX<br>
IndexList DIR_ENT DIR_IDX<br>
declare -a IDX_DIG<br>
# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )<br>
# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG<br>
DigestFile DIR_ENT IDX_DIG<br>
# Small (should) be able to parallize IndexList &amp; DigestFile<br>
# Large (should) be able to parallize IndexList &amp; DigestFile &amp; the assignment<br>
echo &quot;The \&quot;name\&quot; (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}&quot;<br>
declare -a FILE_LOC<br>
LocateFile ${PWD} FILE_LOC<br>
ListArray FILE_LOC<br>
exit 0<br>
Stéphane Chazelas demonstrates object-oriented programming in a Bash script.<br>
<a href="abs-guides.html#885">Mariusz Gniazdowski contributed a hash library for use in scripts.</a><br>
<b>Example A-20. Library of hash functions</b><br>
Appendix A. Contributed Scripts<br>
603<br>
<hr>
<A name=610></a>Advanced Bash-Scripting Guide<br>
# Hash:<br>
# Hash function library<br>
# Author: Mariusz Gniazdowski &lt;mariusz.gn-at-gmail.com&gt;<br>
# Date: 2005-04-07<br>
# Functions making emulating hashes in Bash a little less painful.<br>
# &nbsp; &nbsp;Limitations:<br>
# &nbsp;* Only global variables are supported.<br>
# &nbsp;* Each hash instance generates one global variable per value.<br>
# &nbsp;* Variable names collisions are possible<br>
#+ &nbsp; if you define variable like __hash__hashname_key<br>
# &nbsp;* Keys must use chars that can be part of a Bash variable name<br>
#+ &nbsp; (no dashes, periods, etc.).<br>
# &nbsp;* The hash is created as a variable:<br>
# &nbsp; &nbsp;... hashname_keyname<br>
# &nbsp; &nbsp;So if somone will create hashes like:<br>
# &nbsp; &nbsp; &nbsp;myhash_ + mykey = myhash__mykey<br>
# &nbsp; &nbsp; &nbsp;myhash + _mykey = myhash__mykey<br>
# &nbsp; &nbsp;Then there will be a collision.<br>
# &nbsp; &nbsp;(This should not pose a major problem.)<br>
Hash_config_varname_prefix=__hash__<br>
# Emulates: &nbsp;hash[key]=value<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# 3 - value<br>
function hash_set {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;${Hash_config_varname_prefix}${1}_${2}=\&quot;${3}\&quot;&quot;<br>
}<br>
# Emulates: &nbsp;value=hash[key]<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# 3 - value (name of global variable to set)<br>
function hash_get_into {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;$3=\&quot;\$${Hash_config_varname_prefix}${1}_${2}\&quot;&quot;<br>
}<br>
# Emulates: &nbsp;echo hash[key]<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# 3 - echo params (like -n, for example)<br>
function hash_echo {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;echo $3 \&quot;\$${Hash_config_varname_prefix}${1}_${2}\&quot;&quot;<br>
}<br>
# Emulates: &nbsp;hash1[key1]=hash2[key2]<br>
#<br>
Appendix A. Contributed Scripts<br>
604<br>
<hr>
<A name=611></a>Advanced Bash-Scripting Guide<br>
# Params:<br>
# 1 - hash1<br>
# 2 - key1<br>
# 3 - hash2<br>
# 4 - key2<br>
function hash_copy {<br>
eval &quot;${Hash_config_varname_prefix}${1}_${2}\<br>
=\&quot;\$${Hash_config_varname_prefix}${3}_${4}\&quot;&quot;<br>
}<br>
# Emulates: &nbsp;hash[keyN-1]=hash[key2]=...hash[key1]<br>
#<br>
# Copies first key to rest of keys.<br>
#<br>
# Params:<br>
# 1 - hash1<br>
# 2 - key1<br>
# 3 - key2<br>
# . . .<br>
# N - keyN<br>
function hash_dup {<br>
&nbsp; local hashName=&quot;$1&quot; keyName=&quot;$2&quot;<br>
&nbsp; shift 2<br>
&nbsp; until [ ${#} -le 0 ]; do<br>
&nbsp; &nbsp; eval &quot;${Hash_config_varname_prefix}${hashName}_${1}\<br>
=\&quot;\$${Hash_config_varname_prefix}${hashName}_${keyName}\&quot;&quot;<br>
&nbsp; shift;<br>
&nbsp; done;<br>
}<br>
# Emulates: &nbsp;unset hash[key]<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
function hash_unset {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;unset ${Hash_config_varname_prefix}${1}_${2}&quot;<br>
}<br>
# Emulates something similar to: &nbsp;ref=&amp;hash[key]<br>
#<br>
# The reference is name of the variable in which value is held.<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# 3 - ref - Name of global variable to set.<br>
function hash_get_ref_into {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;$3=\&quot;${Hash_config_varname_prefix}${1}_${2}\&quot;&quot;<br>
}<br>
# Emulates something similar to: &nbsp;echo &amp;hash[key]<br>
#<br>
# That reference is name of variable in which value is held.<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
Appendix A. Contributed Scripts<br>
605<br>
<hr>
<A name=612></a>Advanced Bash-Scripting Guide<br>
# 3 - echo params (like -n for example)<br>
function hash_echo_ref {<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;echo $3 \&quot;${Hash_config_varname_prefix}${1}_${2}\&quot;&quot;<br>
}<br>
# Emulates something similar to: &nbsp;$$hash[key](param1, param2, ...)<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# 3,4, ... - Function parameters<br>
function hash_call {<br>
&nbsp; local hash key<br>
&nbsp; hash=$1<br>
&nbsp; key=$2<br>
&nbsp; shift 2<br>
&nbsp; eval &quot;eval \&quot;\$${Hash_config_varname_prefix}${hash}_${key} \\\&quot;\\\$@\\\&quot;\&quot;&quot;<br>
}<br>
# Emulates something similar to: &nbsp;isset(hash[key]) or hash[key]==NULL<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - key<br>
# Returns:<br>
# 0 - there is such key<br>
# 1 - there is no such key<br>
function hash_is_set {<br>
&nbsp; eval &quot;if [[ \&quot;\${${Hash_config_varname_prefix}${1}_${2}-a}\&quot; = \&quot;a\&quot; &amp;&amp;&nbsp;<br>
&nbsp; \&quot;\${${Hash_config_varname_prefix}${1}_${2}-b}\&quot; = \&quot;b\&quot; ]]<br>
&nbsp; &nbsp; then return 1; else return 0; fi&quot;<br>
}<br>
# Emulates something similar to:<br>
# &nbsp; foreach($hash as $key =&gt; $value) { fun($key,$value); }<br>
#<br>
# It is possible to write different variations of this function.<br>
# Here we use a function call to make it as &quot;generic&quot; as possible.<br>
#<br>
# Params:<br>
# 1 - hash<br>
# 2 - function name<br>
function hash_foreach {<br>
&nbsp; local keyname oldIFS=&quot;$IFS&quot;<br>
&nbsp; IFS=' '<br>
&nbsp; for i in $(eval &quot;echo \${!${Hash_config_varname_prefix}${1}_*}&quot;); do<br>
&nbsp; &nbsp; keyname=$(eval &quot;echo \${i##${Hash_config_varname_prefix}${1}_}&quot;)<br>
&nbsp; &nbsp; eval &quot;$2 $keyname \&quot;\$$i\&quot;&quot;<br>
&nbsp; done<br>
IFS=&quot;$oldIFS&quot;<br>
}<br>
# &nbsp;NOTE: In lines 103 and 116, ampersand changed.<br>
# &nbsp;But, it doesn't matter, because these are comment lines anyhow.<br>
Here is an example script using the foregoing hash library.<br>
Appendix A. Contributed Scripts<br>
606<br>
<hr>
<A name=613></a>Advanced Bash-Scripting Guide<br>
<b>Example A-21. Colorizing text using hash functions</b><br>
#!/bin/bash<br>
# hash-example.sh: Colorizing text.<br>
# Author: Mariusz Gniazdowski &lt;mariusz.gn-at-gmail.com&gt;<br>
. Hash.lib &nbsp; &nbsp; &nbsp;# Load the library of functions.<br>
hash_set colors red &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\033[0;31m&quot;<br>
hash_set colors blue &nbsp; &nbsp; &nbsp; &nbsp; &quot;\033[0;34m&quot;<br>
hash_set colors light_blue &nbsp; &quot;\033[1;34m&quot;<br>
hash_set colors light_red &nbsp; &nbsp;&quot;\033[1;31m&quot;<br>
hash_set colors cyan &nbsp; &nbsp; &nbsp; &nbsp; &quot;\033[0;36m&quot;<br>
hash_set colors light_green &nbsp;&quot;\033[1;32m&quot;<br>
hash_set colors light_gray &nbsp; &quot;\033[0;37m&quot;<br>
hash_set colors green &nbsp; &nbsp; &nbsp; &nbsp;&quot;\033[0;32m&quot;<br>
hash_set colors yellow &nbsp; &nbsp; &nbsp; &quot;\033[1;33m&quot;<br>
hash_set colors light_purple &quot;\033[1;35m&quot;<br>
hash_set colors purple &nbsp; &nbsp; &nbsp; &quot;\033[0;35m&quot;<br>
hash_set colors reset_color &nbsp;&quot;\033[0;00m&quot;<br>
# $1 - keyname<br>
# $2 - value<br>
try_colors() {<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -en &quot;$2&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;This line is $1.&quot;<br>
}<br>
hash_foreach colors try_colors<br>
hash_echo colors reset_color -en<br>
echo -e '\nLet us overwrite some colors with yellow.\n'<br>
# It's hard to read yellow text on some terminals.<br>
hash_dup colors yellow &nbsp; red light_green blue green light_gray cyan<br>
hash_foreach colors try_colors<br>
hash_echo colors reset_color -en<br>
echo -e '\nLet us delete them and try colors once more . . .\n'<br>
for i in red light_green blue green light_gray cyan; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; hash_unset colors $i<br>
done<br>
hash_foreach colors try_colors<br>
hash_echo colors reset_color -en<br>
hash_set other txt &quot;Other examples . . .&quot;<br>
hash_echo other txt<br>
hash_get_into other txt text<br>
echo $text<br>
hash_set other my_fun try_colors<br>
hash_call other my_fun &nbsp; purple &quot;`hash_echo colors purple`&quot;<br>
hash_echo colors reset_color -en<br>
echo; echo &quot;Back to normal?&quot;; echo<br>
exit $?<br>
# &nbsp;On some terminals, the &quot;light&quot; colors print in bold,<br>
# &nbsp;and end up looking darker than the normal ones.<br>
# &nbsp;Why is this?<br>
Appendix A. Contributed Scripts<br>
607<br>
<hr>
<A name=614></a>Advanced Bash-Scripting Guide<br>
An example illustrating the mechanics of hashing, but from a different point of view.<br>
<b>Example A-22. More on hash functions</b><br>
#!/bin/bash<br>
# $Id: ha.sh,v 1.2 2005/04/21 23:24:26 oliver Exp $<br>
# Copyright 2005 Oliver Beckstein<br>
# Released under the GNU Public License<br>
# Author of script granted permission for inclusion in ABS Guide.<br>
# (Thank you!)<br>
#----------------------------------------------------------------<br>
# pseudo hash based on indirect parameter expansion<br>
# API: access through functions:<br>
#&nbsp;<br>
# create the hash:<br>
# &nbsp;<br>
# &nbsp; &nbsp; &nbsp;newhash Lovers<br>
#<br>
# add entries (note single quotes for spaces)<br>
# &nbsp; &nbsp;<br>
# &nbsp; &nbsp; &nbsp;addhash Lovers Tristan Isolde<br>
# &nbsp; &nbsp; &nbsp;addhash Lovers 'Romeo Montague' 'Juliet Capulet'<br>
#<br>
# access value by key<br>
#<br>
# &nbsp; &nbsp; &nbsp;gethash Lovers Tristan &nbsp; ----&gt; &nbsp;Isolde<br>
#<br>
# show all keys<br>
#<br>
# &nbsp; &nbsp; &nbsp;keyshash Lovers &nbsp; &nbsp; &nbsp; &nbsp; ----&gt; 'Tristan' &nbsp;'Romeo Montague'<br>
#<br>
#<br>
# Convention: instead of perls' foo{bar} = boing' syntax,<br>
# use<br>
# &nbsp; &nbsp; &nbsp; '_foo_bar=boing' (two underscores, no spaces)<br>
#<br>
# 1) store key &nbsp; in _NAME_keys[]<br>
# 2) store value in _NAME_values[] using the same integer index<br>
# The integer index for the last entry is _NAME_ptr<br>
#<br>
# NOTE: No error or sanity checks, just bare bones.<br>
function _inihash () {<br>
&nbsp; &nbsp; # private function<br>
&nbsp; &nbsp; # call at the beginning of each procedure<br>
&nbsp; &nbsp; # defines: _keys _values _ptr<br>
&nbsp; &nbsp; #<br>
&nbsp; &nbsp; # Usage: _inihash NAME<br>
&nbsp; &nbsp; local name=$1<br>
&nbsp; &nbsp; _keys=_${name}_keys<br>
&nbsp; &nbsp; _values=_${name}_values<br>
&nbsp; &nbsp; _ptr=_${name}_ptr<br>
}<br>
function newhash () {<br>
&nbsp; &nbsp; # Usage: newhash NAME<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp;NAME should not contain spaces or dots.<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp;Actually: it must be a legal name for a Bash variable.<br>
Appendix A. Contributed Scripts<br>
608<br>
<hr>
<A name=615></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; # We rely on Bash automatically recognising arrays.<br>
&nbsp; &nbsp; local name=$1&nbsp;<br>
&nbsp; &nbsp; local _keys _values _ptr<br>
&nbsp; &nbsp; _inihash ${name}<br>
&nbsp; &nbsp; eval ${_ptr}=0<br>
}<br>
function addhash () {<br>
&nbsp; &nbsp; # Usage: addhash NAME KEY 'VALUE with spaces'<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp;arguments with spaces need to be quoted with single quotes ''<br>
&nbsp; &nbsp; local name=$1 k=&quot;$2&quot; v=&quot;$3&quot;&nbsp;<br>
&nbsp; &nbsp; local _keys _values _ptr<br>
&nbsp; &nbsp; _inihash ${name}<br>
&nbsp; &nbsp; #echo &quot;DEBUG(addhash): ${_ptr}=${!_ptr}&quot;<br>
&nbsp; &nbsp; eval let ${_ptr}=${_ptr}+1<br>
&nbsp; &nbsp; eval &quot;$_keys[${!_ptr}]=\&quot;${k}\&quot;&quot;<br>
&nbsp; &nbsp; eval &quot;$_values[${!_ptr}]=\&quot;${v}\&quot;&quot;<br>
}<br>
function gethash () {<br>
&nbsp; &nbsp; # &nbsp;Usage: gethash NAME KEY<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; Returns boing<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; ERR=0 if entry found, 1 otherwise<br>
&nbsp; &nbsp; # &nbsp;That's not a proper hash --<br>
&nbsp; &nbsp; #+ we simply linearly search through the keys.<br>
&nbsp; &nbsp; local name=$1 key=&quot;$2&quot;&nbsp;<br>
&nbsp; &nbsp; local _keys _values _ptr&nbsp;<br>
&nbsp; &nbsp; local k v i found h<br>
&nbsp; &nbsp; _inihash ${name}<br>
&nbsp; &nbsp; # _ptr holds the highest index in the hash<br>
&nbsp; &nbsp; found=0<br>
&nbsp; &nbsp; for i in $(seq 1 ${!_ptr}); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; h=&quot;\${${_keys}[${i}]}&quot; &nbsp;# &nbsp;Safer to do it in two steps,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval k=${h} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ especially when quoting for spaces.<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;${k}&quot; = &quot;${key}&quot; ]; then found=1; break; fi<br>
&nbsp; &nbsp; done;<br>
&nbsp; &nbsp; [ ${found} = 0 ] &amp;&amp; return 1;<br>
&nbsp; &nbsp; # else: i is the index that matches the key<br>
&nbsp; &nbsp; h=&quot;\${${_values}[${i}]}&quot;<br>
&nbsp; &nbsp; eval echo &quot;${h}&quot;<br>
&nbsp; &nbsp; return 0; &nbsp;&nbsp;<br>
}<br>
function keyshash () {<br>
&nbsp; &nbsp; # Usage: keyshash NAME<br>
&nbsp; &nbsp; # Returns list of all keys defined for hash name.<br>
&nbsp; &nbsp; local name=$1 key=&quot;$2&quot;&nbsp;<br>
&nbsp; &nbsp; local _keys _values _ptr&nbsp;<br>
&nbsp; &nbsp; local k i h<br>
&nbsp; &nbsp; _inihash ${name}<br>
&nbsp; &nbsp; # _ptr holds the highest index in the hash<br>
&nbsp; &nbsp; for i in $(seq 1 ${!_ptr}); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; h=&quot;\${${_keys}[${i}]}&quot; &nbsp; # &nbsp;Safer to do it in two steps,<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval k=${h} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ especially when quoting for spaces.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot;'${k}' &quot;<br>
Appendix A. Contributed Scripts<br>
609<br>
<hr>
<A name=616></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; done;<br>
}<br>
# -----------------------------------------------------------------------<br>
# Now, let's test it.<br>
# (Per comments at the beginning of the script.)<br>
newhash Lovers<br>
addhash Lovers Tristan Isolde<br>
addhash Lovers 'Romeo Montague' 'Juliet Capulet'<br>
# Output results.<br>
echo<br>
gethash Lovers Tristan &nbsp; &nbsp; &nbsp;# Isolde<br>
echo<br>
keyshash Lovers &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 'Tristan' 'Romeo Montague'<br>
echo; echo<br>
exit 0<br>
# Exercise:<br>
# --------<br>
# Add error checks to the functions.<br>
Now for a script that installs and mounts those cute USB keychain solid-state &quot;hard drives.&quot;<br>
<b>Example A-23. Mounting USB keychain storage devices</b><br>
#!/bin/bash<br>
# ==&gt; usb.sh<br>
# ==&gt; Script for mounting and installing pen/keychain USB storage devices.<br>
# ==&gt; Runs as root at system startup (see below).<br>
# ==&gt;<br>
# ==&gt; Newer Linux distros (2004 or later) autodetect<br>
# ==&gt; and install USB pen drives, and therefore don't need this script.<br>
# ==&gt; But, it's still instructive.<br>
# &nbsp;This code is free software covered by GNU GPL license version 2 or above.<br>
# &nbsp;Please refer to http://www.gnu.org/ for the full license text.<br>
#<br>
# &nbsp;Some code lifted from usb-mount by Michael Hamilton's usb-mount (LGPL)<br>
#+ see http://users.actrix.co.nz/michael/usbmount.html<br>
#<br>
# &nbsp;INSTALL<br>
# &nbsp;-------<br>
# &nbsp;Put this in /etc/hotplug/usb/diskonkey.<br>
# &nbsp;Then look in /etc/hotplug/usb.distmap, and copy all usb-storage entries<br>
#+ into /etc/hotplug/usb.usermap, substituting &quot;usb-storage&quot; for &quot;diskonkey&quot;.<br>
# &nbsp;Otherwise this code is only run during the kernel module invocation/removal<br>
#+ (at least in my tests), which defeats the purpose.<br>
#<br>
# &nbsp;TODO<br>
# &nbsp;----<br>
# &nbsp;Handle more than one diskonkey device at one time (e.g. /dev/diskonkey1<br>
#+ and /mnt/diskonkey1), etc. The biggest problem here is the handling in<br>
#+ devlabel, which I haven't yet tried.<br>
#<br>
# &nbsp;AUTHOR and SUPPORT<br>
Appendix A. Contributed Scripts<br>
610<br>
<hr>
<A name=617></a>Advanced Bash-Scripting Guide<br>
# &nbsp;------------------<br>
# &nbsp;Konstantin Riabitsev, &lt;icon linux duke edu&gt;.<br>
# &nbsp;Send any problem reports to my email address at the moment.<br>
#<br>
# ==&gt; Comments added by ABS Guide author.<br>
SYMLINKDEV=/dev/diskonkey<br>
MOUNTPOINT=/mnt/diskonkey<br>
DEVLABEL=/sbin/devlabel<br>
DEVLABELCONFIG=/etc/sysconfig/devlabel<br>
IAM=$0<br>
##<br>
# Functions lifted near-verbatim from usb-mount code.<br>
#<br>
function allAttachedScsiUsb {<br>
&nbsp; find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f |<br>
&nbsp; xargs grep -l 'Attached: Yes'<br>
}<br>
function scsiDevFromScsiUsb {<br>
&nbsp; echo $1 | awk -F&quot;[-/]&quot; '{ n=$(NF-1);<br>
&nbsp; print &quot;/dev/sd&quot; substr(&quot;abcdefghijklmnopqrstuvwxyz&quot;, n+1, 1) }'<br>
}<br>
if [ &quot;${ACTION}&quot; = &quot;add&quot; ] &amp;&amp; [ -f &quot;${DEVICE}&quot; ]; then<br>
&nbsp; &nbsp; ##<br>
&nbsp; &nbsp; # lifted from usbcam code.<br>
&nbsp; &nbsp; #<br>
&nbsp; &nbsp; if [ -f /var/run/console.lock ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; CONSOLEOWNER=`cat /var/run/console.lock`<br>
&nbsp; &nbsp; elif [ -f /var/lock/console.lock ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; CONSOLEOWNER=`cat /var/lock/console.lock`<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; CONSOLEOWNER=<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; for procEntry in $(allAttachedScsiUsb); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; scsiDev=$(scsiDevFromScsiUsb $procEntry)<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Some bug with usb-storage?<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Partitions are not in /proc/partitions until they are accessed<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ somehow.<br>
&nbsp; &nbsp; &nbsp; &nbsp; /sbin/fdisk -l $scsiDev &gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Most devices have partitioning info, so the data would be on<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ /dev/sd?1. However, some stupider ones don't have any partitioning<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ and use the entire device for data storage. This tries to<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ guess semi-intelligently if we have a /dev/sd?1 and if not, then<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ it uses the entire device and hopes for the better.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; if grep -q `basename $scsiDev`1 /proc/partitions; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part=&quot;$scsiDev&quot;&quot;1&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part=$scsiDev<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Change ownership of the partition to the console user so they can<br>
&nbsp; &nbsp; &nbsp; &nbsp; #+ mount it.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ! -z &quot;$CONSOLEOWNER&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chown $CONSOLEOWNER:disk $part<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
Appendix A. Contributed Scripts<br>
611<br>
<hr>
<A name=618></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # This checks if we already have this UUID defined with devlabel.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # If not, it then adds the device to the list.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; prodid=`$DEVLABEL printid -d $part`<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ! grep -q $prodid $DEVLABELCONFIG; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # cross our fingers and hope it works<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $DEVLABEL add -d $part -s $SYMLINKDEV 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Check if the mount point exists and create if it doesn't.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ! -e $MOUNTPOINT ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mkdir -p $MOUNTPOINT<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Take care of /etc/fstab so mounting is easy.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ! grep -q &quot;^$SYMLINKDEV&quot; /etc/fstab; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Add an fstab entry<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;$SYMLINKDEV\t\t$MOUNTPOINT\t\tauto\tnoauto,owner,kudzu 0 0&quot; \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt; /etc/fstab<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; if [ ! -z &quot;$REMOVER&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; ##<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Make sure this script is triggered on device removal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; mkdir -p `dirname $REMOVER`<br>
&nbsp; &nbsp; &nbsp; &nbsp; ln -s $IAM $REMOVER<br>
&nbsp; &nbsp; fi<br>
elif [ &quot;${ACTION}&quot; = &quot;remove&quot; ]; then<br>
&nbsp; &nbsp; ##<br>
&nbsp; &nbsp; # If the device is mounted, unmount it cleanly.<br>
&nbsp; &nbsp; #<br>
&nbsp; &nbsp; if grep -q &quot;$MOUNTPOINT&quot; /etc/mtab; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # unmount cleanly<br>
&nbsp; &nbsp; &nbsp; &nbsp; umount -l $MOUNTPOINT<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; ##<br>
&nbsp; &nbsp; # Remove it from /etc/fstab if it's there.<br>
&nbsp; &nbsp; #<br>
&nbsp; &nbsp; if grep -q &quot;^$SYMLINKDEV&quot; /etc/fstab; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; grep -v &quot;^$SYMLINKDEV&quot; /etc/fstab &gt; /etc/.fstab.new<br>
&nbsp; &nbsp; &nbsp; &nbsp; mv -f /etc/.fstab.new /etc/fstab<br>
&nbsp; &nbsp; fi<br>
fi<br>
exit 0<br>
Converting a text file to HTML format.<br>
<b>Example A-24. Converting to HTML</b><br>
#!/bin/bash<br>
# tohtml.sh [v. 0.2, reldate: 06/26/08, still buggy]<br>
# Convert a text file to HTML format.<br>
# Author: Mendel Cooper<br>
# License: GPL3<br>
Appendix A. Contributed Scripts<br>
612<br>
<hr>
<A name=619></a>Advanced Bash-Scripting Guide<br>
# Usage: sh tohtml.sh &lt; textfile &gt; htmlfile<br>
# Script can easily be modified to accept source and target filenames.<br>
# &nbsp; &nbsp;Assumptions:<br>
# 1) Paragraphs in (target) text file are separated by a blank line.<br>
# 2) Jpeg images (*.jpg) are located in &quot;images&quot; subdirectory.<br>
# &nbsp; &nbsp;In the target file, the image names are enclosed in square brackets,<br>
# &nbsp; &nbsp;for example, [image01.jpg].<br>
# 3) Emphasized (italic) phrases begin with a space+underscore<br>
#+ &nbsp; or the first character on the line is an underscore,<br>
#+ &nbsp; and end with an underscore+space or underscore+end-of-line.<br>
# Settings<br>
FNTSIZE=2 &nbsp; &nbsp; &nbsp; &nbsp;# Small-medium font size<br>
IMGDIR=&quot;images&quot; &nbsp;# Image directory<br>
# Headers<br>
HDR01='&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;'<br>
HDR02='&lt;!-- Converted to HTML by ***tohtml.sh*** script --&gt;'<br>
HDR03='&lt;!-- script author: M. Leo Cooper &lt;thegrendel.abs@gmail.com&gt; --&gt;'<br>
HDR10='&lt;html&gt;'<br>
HDR11='&lt;head&gt;'<br>
HDR11a='&lt;/head&gt;'<br>
HDR12a='&lt;title&gt;'<br>
HDR12b='&lt;/title&gt;'<br>
HDR121='&lt;META NAME=&quot;GENERATOR&quot; CONTENT=&quot;tohtml.sh script&quot;&gt;'<br>
HDR13='&lt;body bgcolor=&quot;#dddddd&quot;&gt;' &nbsp; # Change background color to suit.<br>
HDR14a='&lt;font size='<br>
HDR14b='&gt;'<br>
# Footers<br>
FTR10='&lt;/body&gt;'<br>
FTR11='&lt;/html&gt;'<br>
# Tags<br>
BOLD=&quot;&lt;b&gt;&quot;<br>
CENTER=&quot;&lt;center&gt;&quot;<br>
END_CENTER=&quot;&lt;/center&gt;&quot;<br>
LF=&quot;&lt;br&gt;&quot;<br>
write_headers ()<br>
&nbsp; {<br>
&nbsp; echo &quot;$HDR01&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;$HDR02&quot;<br>
&nbsp; echo &quot;$HDR03&quot;<br>
&nbsp; echo<br>
&nbsp; echo<br>
&nbsp; echo &quot;$HDR10&quot;<br>
&nbsp; echo &quot;$HDR11&quot;<br>
&nbsp; echo &quot;$HDR121&quot;<br>
&nbsp; echo &quot;$HDR11a&quot;<br>
&nbsp; echo &quot;$HDR13&quot;<br>
&nbsp; echo<br>
&nbsp; echo -n &quot;$HDR14a&quot;<br>
&nbsp; echo -n &quot;$FNTSIZE&quot;<br>
&nbsp; echo &quot;$HDR14b&quot;<br>
&nbsp; echo<br>
&nbsp; echo &quot;$BOLD&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Everything in bold (more easily readable).<br>
&nbsp; }<br>
process_text ()<br>
Appendix A. Contributed Scripts<br>
613<br>
<hr>
<A name=620></a>Advanced Bash-Scripting Guide<br>
&nbsp; {<br>
&nbsp; while read line &nbsp; &nbsp; # Read one line at a time.<br>
&nbsp; do<br>
&nbsp; &nbsp; {<br>
&nbsp; &nbsp; if [ ! &quot;$line&quot; ] &nbsp;# Blank line?<br>
&nbsp; &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Then new paragraph must follow.<br>
&nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; echo &quot;$LF&quot; &nbsp; &nbsp; &nbsp;# Insert two &lt;br&gt; tags.<br>
&nbsp; &nbsp; &nbsp; echo &quot;$LF&quot;<br>
&nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; continue &nbsp; &nbsp; &nbsp; &nbsp;# Skip the underscore test.<br>
&nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Otherwise . . .<br>
&nbsp; &nbsp; &nbsp; if [[ &quot;$line&quot; =~ &quot;\[*jpg\]&quot; ]] &nbsp;# Is a graphic?<br>
&nbsp; &nbsp; &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Strip away brackets.<br>
&nbsp; &nbsp; &nbsp; &nbsp; temp=$( echo &quot;$line&quot; | sed -e 's/\[//' -e 's/\]//' )<br>
&nbsp; &nbsp; &nbsp; &nbsp; line=&quot;&quot;$CENTER&quot; &lt;img src=&quot;\&quot;$IMGDIR&quot;/$temp\&quot;&gt; &quot;$END_CENTER&quot; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Add image tag.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # And, center it.<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; echo &quot;$line&quot; | grep -q _<br>
&nbsp; &nbsp; if [ &quot;$?&quot; -eq 0 ] &nbsp; &nbsp;# If line contains underscore ...<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; # ===================================================<br>
&nbsp; &nbsp; &nbsp; # Convert underscored phrase to italics.<br>
&nbsp; &nbsp; &nbsp; temp=$( echo &quot;$line&quot; |<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed -e 's/ _/ &lt;i&gt;/' -e 's/_/&lt;\/i&gt; /' |<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sed -e 's/^_/&lt;i&gt;/' &nbsp;-e 's/_/&lt;\/i&gt;/' )<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Process only underscores prefixed by space,<br>
&nbsp; &nbsp; &nbsp; #+ or at beginning or end of line.<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Do not convert underscores embedded within a word!<br>
&nbsp; &nbsp; &nbsp; line=&quot;$temp&quot;<br>
&nbsp; &nbsp; &nbsp; # Slows script execution. Can be optimized?<br>
&nbsp; &nbsp; &nbsp; # ===================================================<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; echo &quot;$line&quot;<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; } # End while<br>
&nbsp; done<br>
&nbsp; } &nbsp; # End process_text ()<br>
write_footers () &nbsp;# Termination tags.<br>
&nbsp; {<br>
&nbsp; echo &quot;$FTR10&quot;<br>
&nbsp; echo &quot;$FTR11&quot;<br>
&nbsp; }<br>
# main () {<br>
# =========<br>
write_headers<br>
process_text<br>
write_footers<br>
Appendix A. Contributed Scripts<br>
614<br>
<hr>
<A name=621></a>Advanced Bash-Scripting Guide<br>
# =========<br>
# &nbsp; &nbsp; &nbsp; &nbsp; }<br>
exit $?<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;1) Fixup: Check for closing underscore before a comma or period.<br>
# &nbsp;2) Add a test for the presence of a closing underscore<br>
#+ &nbsp; &nbsp;in phrases to be italicized.<br>
Here is something to warm the hearts of webmasters and mistresses: a script that saves weblogs.<br>
<b>Example A-25. Preserving weblogs</b><br>
#!/bin/bash<br>
# archiveweblogs.sh v1.0<br>
# Troy Engel &lt;tengel@fluid.com&gt;<br>
# Slightly modified by document author.<br>
# Used with permission.<br>
#<br>
# &nbsp;This script will preserve the normally rotated and<br>
#+ thrown away weblogs from a default RedHat/Apache installation.<br>
# &nbsp;It will save the files with a date/time stamp in the filename,<br>
#+ bzipped, to a given directory.<br>
#<br>
# &nbsp;Run this from crontab nightly at an off hour,<br>
#+ as bzip2 can suck up some serious CPU on huge logs:<br>
# &nbsp;0 2 * * * /opt/sbin/archiveweblogs.sh<br>
PROBLEM=66<br>
# Set this to your backup dir.<br>
BKP_DIR=/opt/backups/weblogs<br>
# Default Apache/RedHat stuff<br>
LOG_DAYS=&quot;4 3 2 1&quot;<br>
LOG_DIR=/var/log/httpd<br>
LOG_FILES=&quot;access_log error_log&quot;<br>
# Default RedHat program locations<br>
LS=/bin/ls<br>
MV=/bin/mv<br>
ID=/usr/bin/id<br>
CUT=/bin/cut<br>
COL=/usr/bin/column<br>
BZ2=/usr/bin/bzip2<br>
# Are we root?<br>
USER=`$ID -u`<br>
if [ &quot;X$USER&quot; != &quot;X0&quot; ]; then<br>
&nbsp; echo &quot;PANIC: Only root can run this script!&quot;<br>
&nbsp; exit $PROBLEM<br>
fi<br>
# Backup dir exists/writable?<br>
if [ ! -x $BKP_DIR ]; then<br>
&nbsp; echo &quot;PANIC: $BKP_DIR doesn't exist or isn't writable!&quot;<br>
&nbsp; exit $PROBLEM<br>
Appendix A. Contributed Scripts<br>
615<br>
<hr>
<A name=622></a>Advanced Bash-Scripting Guide<br>
fi<br>
# Move, rename and bzip2 the logs<br>
for logday in $LOG_DAYS; do<br>
&nbsp; for logfile in $LOG_FILES; do<br>
&nbsp; &nbsp; MYFILE=&quot;$LOG_DIR/$logfile.$logday&quot;<br>
&nbsp; &nbsp; if [ -w $MYFILE ]; then<br>
&nbsp; &nbsp; &nbsp; DTS=`$LS -lgo --time-style=+%Y%m%d $MYFILE | $COL -t | $CUT -d ' ' -f7`<br>
&nbsp; &nbsp; &nbsp; $MV $MYFILE $BKP_DIR/$logfile.$DTS<br>
&nbsp; &nbsp; &nbsp; $BZ2 $BKP_DIR/$logfile.$DTS<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; # Only spew an error if the file exits (ergo non-writable).<br>
&nbsp; &nbsp; &nbsp; if [ -f $MYFILE ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;ERROR: $MYFILE not writable. Skipping.&quot;<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
done<br>
exit 0<br>
How to keep the shell from expanding and reinterpreting text strings.<br>
<b>Example A-26. Protecting literal strings</b><br>
#! /bin/bash<br>
# protect_literal.sh<br>
# set -vx<br>
:&lt;&lt;-'_Protect_Literal_String_Doc'<br>
&nbsp; &nbsp; Copyright (c) Michael S. Zick, 2003; All Rights Reserved<br>
&nbsp; &nbsp; License: Unrestricted reuse in any form, for any purpose.<br>
&nbsp; &nbsp; Warranty: None<br>
&nbsp; &nbsp; Revision: $ID$<br>
&nbsp; &nbsp; Documentation redirected to the Bash no-operation.<br>
&nbsp; &nbsp; Bash will '/dev/null' this block when the script is first read.<br>
&nbsp; &nbsp; (Uncomment the above set command to see this action.)<br>
&nbsp; &nbsp; Remove the first (Sha-Bang) line when sourcing this as a library<br>
&nbsp; &nbsp; procedure. &nbsp;Also comment out the example use code in the two<br>
&nbsp; &nbsp; places where shown.<br>
&nbsp; &nbsp; Usage:<br>
&nbsp; &nbsp; &nbsp; &nbsp; _protect_literal_str 'Whatever string meets your ${fancy}'<br>
&nbsp; &nbsp; &nbsp; &nbsp; Just echos the argument to standard out, hard quotes<br>
&nbsp; &nbsp; &nbsp; &nbsp; restored.<br>
&nbsp; &nbsp; &nbsp; &nbsp; $(_protect_literal_str 'Whatever string meets your ${fancy}')<br>
&nbsp; &nbsp; &nbsp; &nbsp; as the right-hand-side of an assignment statement.<br>
&nbsp; &nbsp; Does:<br>
&nbsp; &nbsp; &nbsp; &nbsp; As the right-hand-side of an assignment, preserves the<br>
&nbsp; &nbsp; &nbsp; &nbsp; hard quotes protecting the contents of the literal during<br>
&nbsp; &nbsp; &nbsp; &nbsp; assignment.<br>
&nbsp; &nbsp; Notes:<br>
&nbsp; &nbsp; &nbsp; &nbsp; The strange names (_*) are used to avoid trampling on<br>
Appendix A. Contributed Scripts<br>
616<br>
<hr>
<A name=623></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; the user's chosen names when this is sourced as a<br>
&nbsp; &nbsp; &nbsp; &nbsp; library.<br>
_Protect_Literal_String_Doc<br>
# The 'for illustration' function form<br>
_protect_literal_str() {<br>
# Pick an un-used, non-printing character as local IFS.<br>
# Not required, but shows that we are ignoring it.<br>
&nbsp; &nbsp; local IFS=$'\x1B' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # \ESC character<br>
# Enclose the All-Elements-Of in hard quotes during assignment.<br>
&nbsp; &nbsp; local tmp=$'\x27'$@$'\x27'<br>
# &nbsp; &nbsp;local tmp=$'\''$@$'\'' &nbsp; &nbsp; &nbsp; &nbsp; # Even uglier.<br>
&nbsp; &nbsp; local len=${#tmp} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Info only.<br>
&nbsp; &nbsp; echo $tmp is $len long. &nbsp; &nbsp; &nbsp; &nbsp; # Output AND information.<br>
}<br>
# This is the short-named version.<br>
_pls() {<br>
&nbsp; &nbsp; local IFS=$'x1B' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \ESC character (not required)<br>
&nbsp; &nbsp; echo $'\x27'$@$'\x27' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Hard quoted parameter glob<br>
}<br>
# :&lt;&lt;-'_Protect_Literal_String_Test'<br>
# # # Remove the above &quot;# &quot; to disable this code. # # #<br>
# See how that looks when printed.<br>
echo<br>
echo &quot;- - Test One - -&quot;<br>
_protect_literal_str 'Hello $user'<br>
_protect_literal_str 'Hello &quot;${username}&quot;'<br>
echo<br>
# Which yields:<br>
# - - Test One - -<br>
# 'Hello $user' is 13 long.<br>
# 'Hello &quot;${username}&quot;' is 21 long.<br>
# &nbsp;Looks as expected, but why all of the trouble?<br>
# &nbsp;The difference is hidden inside the Bash internal order<br>
#+ of operations.<br>
# &nbsp;Which shows when you use it on the RHS of an assignment.<br>
# Declare an array for test values.<br>
declare -a arrayZ<br>
# Assign elements with various types of quotes and escapes.<br>
arrayZ=( zero &quot;$(_pls 'Hello ${Me}')&quot; 'Hello ${You}' &quot;\'Pass: ${pw}\'&quot; )<br>
# Now list that array and see what is there.<br>
echo &quot;- - Test Two - -&quot;<br>
for (( i=0 ; i&lt;${#arrayZ[*]} ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &nbsp;Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.<br>
done<br>
echo<br>
# Which yields:<br>
Appendix A. Contributed Scripts<br>
617<br>
<hr>
<A name=624></a>Advanced Bash-Scripting Guide<br>
# - - Test Two - -<br>
# Element 0: zero is: 4 long. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Our marker element<br>
# Element 1: 'Hello ${Me}' is: 13 long. # Our &quot;$(_pls '...' )&quot;<br>
# Element 2: Hello ${You} is: 12 long. &nbsp;# Quotes are missing<br>
# Element 3: \'Pass: \' is: 10 long. &nbsp; &nbsp;# ${pw} expanded to nothing<br>
# Now make an assignment with that result.<br>
declare -a array2=( ${arrayZ[@]} )<br>
# And print what happened.<br>
echo &quot;- - Test Three - -&quot;<br>
for (( i=0 ; i&lt;${#array2[*]} ; i++ ))<br>
do<br>
&nbsp; &nbsp; echo &nbsp;Element $i: ${array2[$i]} is: ${#array2[$i]} long.<br>
done<br>
echo<br>
# Which yields:<br>
# - - Test Three - -<br>
# Element 0: zero is: 4 long. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Our marker element.<br>
# Element 1: Hello ${Me} is: 11 long. &nbsp; # Intended result.<br>
# Element 2: Hello is: 5 long. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ${You} expanded to nothing.<br>
# Element 3: 'Pass: is: 6 long. &nbsp; &nbsp; &nbsp; &nbsp; # Split on the whitespace.<br>
# Element 4: ' is: 1 long. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The end quote is here now.<br>
# &nbsp;Our Element 1 has had its leading and trailing hard quotes stripped.<br>
# &nbsp;Although not shown, leading and trailing whitespace is also stripped.<br>
# &nbsp;Now that the string contents are set, Bash will always, internally,<br>
#+ hard quote the contents as required during its operations.<br>
# &nbsp;Why?<br>
# &nbsp;Considering our &quot;$(_pls 'Hello ${Me}')&quot; construction:<br>
# &nbsp;&quot; ... &quot; -&gt; Expansion required, strip the quotes.<br>
# &nbsp;$( ... ) -&gt; Replace with the result of..., strip this.<br>
# &nbsp;_pls ' ... ' -&gt; called with literal arguments, strip the quotes.<br>
# &nbsp;The result returned includes hard quotes; BUT the above processing<br>
#+ has already been done, so they become part of the value assigned.<br>
#<br>
# &nbsp;Similarly, during further usage of the string variable, the ${Me}<br>
#+ is part of the contents (result) and survives any operations<br>
# &nbsp;(Until explicitly told to evaluate the string).<br>
# &nbsp;Hint: See what happens when the hard quotes ($'\x27') are replaced<br>
#+ with soft quotes ($'\x22') in the above procedures.<br>
# &nbsp;Interesting also is to remove the addition of any quoting.<br>
# _Protect_Literal_String_Test<br>
# # # Remove the above &quot;# &quot; to disable this code. # # #<br>
exit 0<br>
But, what if you<i>&nbsp;want</i>&nbsp;the shell to expand and reinterpret strings?<br>
<b>Example A-27. Unprotecting literal strings</b><br>
#! /bin/bash<br>
# unprotect_literal.sh<br>
# set -vx<br>
:&lt;&lt;-'_UnProtect_Literal_String_Doc'<br>
Appendix A. Contributed Scripts<br>
618<br>
<hr>
<A name=625></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; Copyright (c) Michael S. Zick, 2003; All Rights Reserved<br>
&nbsp; &nbsp; License: Unrestricted reuse in any form, for any purpose.<br>
&nbsp; &nbsp; Warranty: None<br>
&nbsp; &nbsp; Revision: $ID$<br>
&nbsp; &nbsp; Documentation redirected to the Bash no-operation. Bash will<br>
&nbsp; &nbsp; '/dev/null' this block when the script is first read.<br>
&nbsp; &nbsp; (Uncomment the above set command to see this action.)<br>
&nbsp; &nbsp; Remove the first (Sha-Bang) line when sourcing this as a library<br>
&nbsp; &nbsp; procedure. &nbsp;Also comment out the example use code in the two<br>
&nbsp; &nbsp; places where shown.<br>
&nbsp; &nbsp; Usage:<br>
&nbsp; &nbsp; &nbsp; &nbsp; Complement of the &quot;$(_pls 'Literal String')&quot; function.<br>
&nbsp; &nbsp; &nbsp; &nbsp; (See the protect_literal.sh example.)<br>
&nbsp; &nbsp; &nbsp; &nbsp; StringVar=$(_upls ProtectedSringVariable)<br>
&nbsp; &nbsp; Does:<br>
&nbsp; &nbsp; &nbsp; &nbsp; When used on the right-hand-side of an assignment statement;<br>
&nbsp; &nbsp; &nbsp; &nbsp; makes the substitions embedded in the protected string.<br>
&nbsp; &nbsp; Notes:<br>
&nbsp; &nbsp; &nbsp; &nbsp; The strange names (_*) are used to avoid trampling on<br>
&nbsp; &nbsp; &nbsp; &nbsp; the user's chosen names when this is sourced as a<br>
&nbsp; &nbsp; &nbsp; &nbsp; library.<br>
_UnProtect_Literal_String_Doc<br>
_upls() {<br>
&nbsp; &nbsp; local IFS=$'x1B' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \ESC character (not required)<br>
&nbsp; &nbsp; eval echo $@ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Substitution on the glob.<br>
}<br>
# :&lt;&lt;-'_UnProtect_Literal_String_Test'<br>
# # # Remove the above &quot;# &quot; to disable this code. # # #<br>
_pls() {<br>
&nbsp; &nbsp; local IFS=$'x1B' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# \ESC character (not required)<br>
&nbsp; &nbsp; echo $'\x27'$@$'\x27' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Hard quoted parameter glob<br>
}<br>
# Declare an array for test values.<br>
declare -a arrayZ<br>
# Assign elements with various types of quotes and escapes.<br>
arrayZ=( zero &quot;$(_pls 'Hello ${Me}')&quot; 'Hello ${You}' &quot;\'Pass: ${pw}\'&quot; )<br>
# Now make an assignment with that result.<br>
declare -a array2=( ${arrayZ[@]} )<br>
# Which yielded:<br>
# - - Test Three - -<br>
# Element 0: zero is: 4 long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Our marker element.<br>
# Element 1: Hello ${Me} is: 11 long &nbsp; &nbsp;# Intended result.<br>
# Element 2: Hello is: 5 long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ${You} expanded to nothing.<br>
# Element 3: 'Pass: is: 6 long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Split on the whitespace.<br>
Appendix A. Contributed Scripts<br>
619<br>
<hr>
<A name=626></a>Advanced Bash-Scripting Guide<br>
# Element 4: ' is: 1 long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The end quote is here now.<br>
# set -vx<br>
# &nbsp;Initialize 'Me' to something for the embedded ${Me} substitution.<br>
# &nbsp;This needs to be done ONLY just prior to evaluating the<br>
#+ protected string.<br>
# &nbsp;(This is why it was protected to begin with.)<br>
Me=&quot;to the array guy.&quot;<br>
# Set a string variable destination to the result.<br>
newVar=$(_upls ${array2[1]})<br>
# Show what the contents are.<br>
echo $newVar<br>
# Do we really need a function to do this?<br>
newerVar=$(eval echo ${array2[1]})<br>
echo $newerVar<br>
# &nbsp;I guess not, but the _upls function gives us a place to hang<br>
#+ the documentation on.<br>
# &nbsp;This helps when we forget what a # construction like:<br>
#+ $(eval echo ... ) means.<br>
# What if Me isn't set when the protected string is evaluated?<br>
unset Me<br>
newestVar=$(_upls ${array2[1]})<br>
echo $newestVar<br>
# Just gone, no hints, no runs, no errors.<br>
# &nbsp;Why in the world?<br>
# &nbsp;Setting the contents of a string variable containing character<br>
#+ sequences that have a meaning in Bash is a general problem in<br>
#+ script programming.<br>
#<br>
# &nbsp;This problem is now solved in eight lines of code<br>
#+ (and four pages of description).<br>
# &nbsp;Where is all this going?<br>
# &nbsp;Dynamic content Web pages as an array of Bash strings.<br>
# &nbsp;Content set per request by a Bash 'eval' command<br>
#+ on the stored page template.<br>
# &nbsp;Not intended to replace PHP, just an interesting thing to do.<br>
###<br>
# &nbsp;Don't have a webserver application?<br>
# &nbsp;No problem, check the example directory of the Bash source;<br>
#+ there is a Bash script for that also.<br>
# _UnProtect_Literal_String_Test<br>
# # # Remove the above &quot;# &quot; to disable this code. # # #<br>
exit 0<br>
This interesting script helps hunt down spammers.<br>
<b>Example A-28. Spammer Identification</b><br>
Appendix A. Contributed Scripts<br>
620<br>
<hr>
<A name=627></a>Advanced Bash-Scripting Guide<br>
#!/bin/bash<br>
# $Id: is_spammer.bash,v 1.12.2.11 2004/10/01 21:42:33 mszick Exp $<br>
# Above line is RCS info.<br>
# The latest version of this script is available from http://www.morethan.org.<br>
#<br>
# Spammer-identification<br>
# by Michael S. Zick<br>
# Used in the ABS Guide with permission.<br>
#######################################################<br>
# Documentation<br>
# See also &quot;Quickstart&quot; at end of script.<br>
#######################################################<br>
:&lt;&lt;-'__is_spammer_Doc_'<br>
&nbsp; &nbsp; Copyright (c) Michael S. Zick, 2004<br>
&nbsp; &nbsp; License: Unrestricted reuse in any form, for any purpose.<br>
&nbsp; &nbsp; Warranty: None -{Its a script; the user is on their own.}-<br>
Impatient?<br>
&nbsp; &nbsp; Application code: goto &quot;# # # Hunt the Spammer' program code # # #&quot;<br>
&nbsp; &nbsp; Example output: &quot;:&lt;&lt;-'_is_spammer_outputs_'&quot;<br>
&nbsp; &nbsp; How to use: Enter script name without arguments.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Or goto &quot;Quickstart&quot; at end of script.<br>
Provides<br>
&nbsp; &nbsp; Given a domain name or IP(v4) address as input:<br>
&nbsp; &nbsp; Does an exhaustive set of queries to find the associated<br>
&nbsp; &nbsp; network resources (short of recursing into TLDs).<br>
&nbsp; &nbsp; Checks the IP(v4) addresses found against Blacklist<br>
&nbsp; &nbsp; nameservers.<br>
&nbsp; &nbsp; If found to be a blacklisted IP(v4) address,<br>
&nbsp; &nbsp; reports the blacklist text records.<br>
&nbsp; &nbsp; (Usually hyper-links to the specific report.)<br>
Requires<br>
&nbsp; &nbsp; A working Internet connection.<br>
&nbsp; &nbsp; (Exercise: Add check and/or abort if not on-line when running script.)<br>
&nbsp; &nbsp; Bash with arrays (2.05b+).<br>
&nbsp; &nbsp; The external program 'dig' --<br>
&nbsp; &nbsp; a utility program provided with the 'bind' set of programs.<br>
&nbsp; &nbsp; Specifically, the version which is part of Bind series 9.x<br>
&nbsp; &nbsp; See: http://www.isc.org<br>
&nbsp; &nbsp; All usages of 'dig' are limited to wrapper functions,<br>
&nbsp; &nbsp; which may be rewritten as required.<br>
&nbsp; &nbsp; See: dig_wrappers.bash for details.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(&quot;Additional documentation&quot; -- below)<br>
Usage<br>
&nbsp; &nbsp; Script requires a single argument, which may be:<br>
&nbsp; &nbsp; 1) A domain name;<br>
&nbsp; &nbsp; 2) An IP(v4) address;<br>
Appendix A. Contributed Scripts<br>
621<br>
<hr>
<A name=628></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; 3) A filename, with one name or address per line.<br>
&nbsp; &nbsp; Script accepts an optional second argument, which may be:<br>
&nbsp; &nbsp; 1) A Blacklist server name;<br>
&nbsp; &nbsp; 2) A filename, with one Blacklist server name per line.<br>
&nbsp; &nbsp; If the second argument is not provided, the script uses<br>
&nbsp; &nbsp; a built-in set of (free) Blacklist servers.<br>
&nbsp; &nbsp; See also, the Quickstart at the end of this script (after 'exit').<br>
Return Codes<br>
&nbsp; &nbsp; 0 - All OK<br>
&nbsp; &nbsp; 1 - Script failure<br>
&nbsp; &nbsp; 2 - Something is Blacklisted<br>
Optional environment variables<br>
&nbsp; &nbsp; SPAMMER_TRACE<br>
&nbsp; &nbsp; &nbsp; &nbsp; If set to a writable file,<br>
&nbsp; &nbsp; &nbsp; &nbsp; script will log an execution flow trace.<br>
&nbsp; &nbsp; SPAMMER_DATA<br>
&nbsp; &nbsp; &nbsp; &nbsp; If set to a writable file, script will dump its<br>
&nbsp; &nbsp; &nbsp; &nbsp; discovered data in the form of GraphViz file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; See: http://www.research.att.com/sw/tools/graphviz<br>
&nbsp; &nbsp; SPAMMER_LIMIT<br>
&nbsp; &nbsp; &nbsp; &nbsp; Limits the depth of resource tracing.<br>
&nbsp; &nbsp; &nbsp; &nbsp; Default is 2 levels.<br>
&nbsp; &nbsp; &nbsp; &nbsp; A setting of 0 (zero) means 'unlimited' . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Caution: script might recurse the whole Internet!<br>
&nbsp; &nbsp; &nbsp; &nbsp; A limit of 1 or 2 is most useful when processing<br>
&nbsp; &nbsp; &nbsp; &nbsp; a file of domain names and addresses.<br>
&nbsp; &nbsp; &nbsp; &nbsp; A higher limit can be useful when hunting spam gangs.<br>
Additional documentation<br>
&nbsp; &nbsp; Download the archived set of scripts<br>
&nbsp; &nbsp; explaining and illustrating the function contained within this script.<br>
&nbsp; &nbsp; http://bash.webofcrafts.net/mszick_clf.tar.bz2<br>
Study notes<br>
&nbsp; &nbsp; This script uses a large number of functions.<br>
&nbsp; &nbsp; Nearly all general functions have their own example script.<br>
&nbsp; &nbsp; Each of the example scripts have tutorial level comments.<br>
Scripting project<br>
&nbsp; &nbsp; Add support for IP(v6) addresses.<br>
&nbsp; &nbsp; IP(v6) addresses are recognized but not processed.<br>
Advanced project<br>
&nbsp; &nbsp; Add the reverse lookup detail to the discovered information.<br>
&nbsp; &nbsp; Report the delegation chain and abuse contacts.<br>
&nbsp; &nbsp; Modify the GraphViz file output to include the<br>
&nbsp; &nbsp; newly discovered information.<br>
Appendix A. Contributed Scripts<br>
622<br>
<hr>
<A name=629></a>Advanced Bash-Scripting Guide<br>
__is_spammer_Doc_<br>
#######################################################<br>
#### Special IFS settings used for string parsing. ####<br>
# Whitespace == :Space:Tab:Line Feed:Carriage Return:<br>
WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'<br>
# No Whitespace == Line Feed:Carriage Return<br>
NO_WSP=$'\x0A'$'\x0D'<br>
# Field separator for dotted decimal IP addresses<br>
ADR_IFS=${NO_WSP}'.'<br>
# Array to dotted string conversions<br>
DOT_IFS='.'${WSP_IFS}<br>
# # # Pending operations stack machine # # #<br>
# This set of functions described in func_stack.bash.<br>
# (See &quot;Additional documentation&quot; above.)<br>
# # #<br>
# Global stack of pending operations.<br>
declare -f -a _pending_<br>
# Global sentinel for stack runners<br>
declare -i _p_ctrl_<br>
# Global holder for currently executing function<br>
declare -f _pend_current_<br>
# # # Debug version only - remove for regular use # # #<br>
#<br>
# The function stored in _pend_hook_ is called<br>
# immediately before each pending function is<br>
# evaluated. &nbsp;Stack clean, _pend_current_ set.<br>
#<br>
# This thingy demonstrated in pend_hook.bash.<br>
declare -f _pend_hook_<br>
# # #<br>
# The do nothing function<br>
pend_dummy() { : ; }<br>
# Clear and initialize the function stack.<br>
pend_init() {<br>
&nbsp; &nbsp; unset _pending_[@]<br>
&nbsp; &nbsp; pend_func pend_stop_mark<br>
&nbsp; &nbsp; _pend_hook_='pend_dummy' &nbsp;# Debug only.<br>
}<br>
# Discard the top function on the stack.<br>
pend_pop() {<br>
&nbsp; &nbsp; if [ ${#_pending_[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i _top_<br>
&nbsp; &nbsp; &nbsp; &nbsp; _top_=${#_pending_[@]}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; unset _pending_[$_top_]<br>
&nbsp; &nbsp; fi<br>
}<br>
Appendix A. Contributed Scripts<br>
623<br>
<hr>
<A name=630></a>Advanced Bash-Scripting Guide<br>
# pend_func function_name [$(printf '%q\n' arguments)]<br>
pend_func() {<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; _pending_[${#_pending_[@]}]=$@<br>
&nbsp; &nbsp; set +f<br>
}<br>
# The function which stops the release:<br>
pend_stop_mark() {<br>
&nbsp; &nbsp; _p_ctrl_=0<br>
}<br>
pend_mark() {<br>
&nbsp; &nbsp; pend_func pend_stop_mark<br>
}<br>
# Execute functions until 'pend_stop_mark' . . .<br>
pend_release() {<br>
&nbsp; &nbsp; local -i _top_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Declare _top_ as integer.<br>
&nbsp; &nbsp; _p_ctrl_=${#_pending_[@]}<br>
&nbsp; &nbsp; while [ ${_p_ctrl_} -gt 0 ]<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp;_top_=${#_pending_[@]}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp;_pend_current_=${_pending_[$_top_]}<br>
&nbsp; &nbsp; &nbsp; &nbsp;unset _pending_[$_top_]<br>
&nbsp; &nbsp; &nbsp; &nbsp;$_pend_hook_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Debug only.<br>
&nbsp; &nbsp; &nbsp; &nbsp;eval $_pend_current_<br>
&nbsp; &nbsp; done<br>
}<br>
# Drop functions until 'pend_stop_mark' . . .<br>
pend_drop() {<br>
&nbsp; &nbsp; local -i _top_<br>
&nbsp; &nbsp; local _pd_ctrl_=${#_pending_[@]}<br>
&nbsp; &nbsp; while [ ${_pd_ctrl_} -gt 0 ]<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp;_top_=$_pd_ctrl_-1<br>
&nbsp; &nbsp; &nbsp; &nbsp;if [ &quot;${_pending_[$_top_]}&quot; == 'pend_stop_mark' ]<br>
&nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unset _pending_[$_top_]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break<br>
&nbsp; &nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unset _pending_[$_top_]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_pd_ctrl_=$_top_<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; if [ ${#_pending_[@]} -eq 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; pend_func pend_stop_mark<br>
&nbsp; &nbsp; fi<br>
}<br>
#### Array editors ####<br>
# This function described in edit_exact.bash.<br>
# (See &quot;Additional documentation,&quot; above.)<br>
# edit_exact &lt;excludes_array_name&gt; &lt;target_array_name&gt;<br>
edit_exact() {<br>
&nbsp; &nbsp; [ $# -eq 2 ] ||<br>
&nbsp; &nbsp; [ $# -eq 3 ] || return 1<br>
Appendix A. Contributed Scripts<br>
624<br>
<hr>
<A name=631></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; local -a _ee_Excludes<br>
&nbsp; &nbsp; local -a _ee_Target<br>
&nbsp; &nbsp; local _ee_x<br>
&nbsp; &nbsp; local _ee_t<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; eval _ee_Excludes=\( \$\{$1\[@\]\} \)<br>
&nbsp; &nbsp; eval _ee_Target=\( \$\{$2\[@\]\} \)<br>
&nbsp; &nbsp; local _ee_len=${#_ee_Target[@]} &nbsp; &nbsp; # Original length.<br>
&nbsp; &nbsp; local _ee_cnt=${#_ee_Excludes[@]} &nbsp; # Exclude list length.<br>
&nbsp; &nbsp; [ ${_ee_len} -ne 0 ] || return 0 &nbsp; &nbsp;# Can't edit zero length.<br>
&nbsp; &nbsp; [ ${_ee_cnt} -ne 0 ] || return 0 &nbsp; &nbsp;# Can't edit zero length.<br>
&nbsp; &nbsp; for (( x = 0; x &lt; ${_ee_cnt} ; x++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _ee_x=${_ee_Excludes[$x]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( n = 0 ; n &lt; ${_ee_len} ; n++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ee_t=${_ee_Target[$n]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ x&quot;${_ee_t}&quot; == x&quot;${_ee_x}&quot; ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _ee_Target[$n] &nbsp; &nbsp; # Discard match.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ $# -eq 2 ] &amp;&amp; break &nbsp; &nbsp;# If 2 arguments, then done.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; eval $2=\( \$\{_ee_Target\[@\]\} \)<br>
&nbsp; &nbsp; set +f<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in edit_by_glob.bash.<br>
# edit_by_glob &lt;excludes_array_name&gt; &lt;target_array_name&gt;<br>
edit_by_glob() {<br>
&nbsp; &nbsp; [ $# -eq 2 ] ||<br>
&nbsp; &nbsp; [ $# -eq 3 ] || return 1<br>
&nbsp; &nbsp; local -a _ebg_Excludes<br>
&nbsp; &nbsp; local -a _ebg_Target<br>
&nbsp; &nbsp; local _ebg_x<br>
&nbsp; &nbsp; local _ebg_t<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; eval _ebg_Excludes=\( \$\{$1\[@\]\} \)<br>
&nbsp; &nbsp; eval _ebg_Target=\( \$\{$2\[@\]\} \)<br>
&nbsp; &nbsp; local _ebg_len=${#_ebg_Target[@]}<br>
&nbsp; &nbsp; local _ebg_cnt=${#_ebg_Excludes[@]}<br>
&nbsp; &nbsp; [ ${_ebg_len} -ne 0 ] || return 0<br>
&nbsp; &nbsp; [ ${_ebg_cnt} -ne 0 ] || return 0<br>
&nbsp; &nbsp; for (( x = 0; x &lt; ${_ebg_cnt} ; x++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _ebg_x=${_ebg_Excludes[$x]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( n = 0 ; n &lt; ${_ebg_len} ; n++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ $# -eq 3 ] &amp;&amp; _ebg_x=${_ebg_x}'*' &nbsp;# &nbsp;Do prefix edit<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ${_ebg_Target[$n]:=} ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ if defined &amp; set.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ebg_t=${_ebg_Target[$n]/#${_ebg_x}/}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ ${#_ebg_t} -eq 0 ] &amp;&amp; unset _ebg_Target[$n]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; eval $2=\( \$\{_ebg_Target\[@\]\} \)<br>
&nbsp; &nbsp; set +f<br>
Appendix A. Contributed Scripts<br>
625<br>
<hr>
<A name=632></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in unique_lines.bash.<br>
# unique_lines &lt;in_name&gt; &lt;out_name&gt;<br>
unique_lines() {<br>
&nbsp; &nbsp; [ $# -eq 2 ] || return 1<br>
&nbsp; &nbsp; local -a _ul_in<br>
&nbsp; &nbsp; local -a _ul_out<br>
&nbsp; &nbsp; local -i _ul_cnt<br>
&nbsp; &nbsp; local -i _ul_pos<br>
&nbsp; &nbsp; local _ul_tmp<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; eval _ul_in=\( \$\{$1\[@\]\} \)<br>
&nbsp; &nbsp; _ul_cnt=${#_ul_in[@]}<br>
&nbsp; &nbsp; for (( _ul_pos = 0 ; _ul_pos &lt; ${_ul_cnt} ; _ul_pos++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ${_ul_in[${_ul_pos}]:=} ] &nbsp; &nbsp; &nbsp;# If defined &amp; not empty<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ul_tmp=${_ul_in[${_ul_pos}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ul_out[${#_ul_out[@]}]=${_ul_tmp}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (( zap = _ul_pos ; zap &lt; ${_ul_cnt} ; zap++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ ${_ul_in[${zap}]:=} ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_ul_in[${zap}]} == 'x'${_ul_tmp} ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _ul_in[${zap}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; eval $2=\( \$\{_ul_out\[@\]\} \)<br>
&nbsp; &nbsp; set +f<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in char_convert.bash.<br>
# to_lower &lt;string&gt;<br>
to_lower() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1<br>
&nbsp; &nbsp; local _tl_out<br>
&nbsp; &nbsp; _tl_out=${1//A/a}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//B/b}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//C/c}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//D/d}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//E/e}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//F/f}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//G/g}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//H/h}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//I/i}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//J/j}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//K/k}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//L/l}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//M/m}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//N/n}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//O/o}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//P/p}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//Q/q}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//R/r}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//S/s}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//T/t}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//U/u}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//V/v}<br>
Appendix A. Contributed Scripts<br>
626<br>
<hr>
<A name=633></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; _tl_out=${_tl_out//W/w}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//X/x}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//Y/y}<br>
&nbsp; &nbsp; _tl_out=${_tl_out//Z/z}<br>
&nbsp; &nbsp; echo ${_tl_out}<br>
&nbsp; &nbsp; return 0<br>
}<br>
#### Application helper functions ####<br>
# Not everybody uses dots as separators (APNIC, for example).<br>
# This function described in to_dot.bash<br>
# to_dot &lt;string&gt;<br>
to_dot() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1<br>
&nbsp; &nbsp; echo ${1//[#|@|%]/.}<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in is_number.bash.<br>
# is_number &lt;input&gt;<br>
is_number() {<br>
&nbsp; &nbsp; [ &quot;$#&quot; -eq 1 ] &nbsp; &nbsp;|| return 1 &nbsp;# is blank?<br>
&nbsp; &nbsp; [ x&quot;$1&quot; == 'x0' ] &amp;&amp; return 0 &nbsp;# is zero?<br>
&nbsp; &nbsp; local -i tst<br>
&nbsp; &nbsp; let tst=$1 2&gt;/dev/null &nbsp; &nbsp; &nbsp; &nbsp; # else is numeric!<br>
&nbsp; &nbsp; return $?<br>
}<br>
# This function described in is_address.bash.<br>
# is_address &lt;input&gt;<br>
is_address() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1 &nbsp; &nbsp;# Blank ==&gt; false<br>
&nbsp; &nbsp; local -a _ia_input<br>
&nbsp; &nbsp; local IFS=${ADR_IFS}<br>
&nbsp; &nbsp; _ia_input=( $1 )<br>
&nbsp; &nbsp; if &nbsp;[ ${#_ia_input[@]} -eq 4 ] &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; is_number ${_ia_input[0]} &nbsp; &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; is_number ${_ia_input[1]} &nbsp; &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; is_number ${_ia_input[2]} &nbsp; &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; is_number ${_ia_input[3]} &nbsp; &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ${_ia_input[0]} -lt 256 ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ${_ia_input[1]} -lt 256 ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ${_ia_input[2]} -lt 256 ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ${_ia_input[3]} -lt 256 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 1<br>
&nbsp; &nbsp; fi<br>
}<br>
# &nbsp;This function described in split_ip.bash.<br>
# &nbsp;split_ip &lt;IP_address&gt;<br>
#+ &lt;array_name_norm&gt; [&lt;array_name_rev&gt;]<br>
split_ip() {<br>
&nbsp; &nbsp; [ $# -eq 3 ] || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Either three<br>
&nbsp; &nbsp; [ $# -eq 2 ] || return 1 &nbsp; &nbsp; #+ or two arguments<br>
&nbsp; &nbsp; local -a _si_input<br>
&nbsp; &nbsp; local IFS=${ADR_IFS}<br>
&nbsp; &nbsp; _si_input=( $1 )<br>
&nbsp; &nbsp; IFS=${WSP_IFS}<br>
Appendix A. Contributed Scripts<br>
627<br>
<hr>
<A name=634></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; eval $2=\(\ \$\{_si_input\[@\]\}\ \)<br>
&nbsp; &nbsp; if [ $# -eq 3 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Build query order array.<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -a _dns_ip<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dns_ip[0]=${_si_input[3]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dns_ip[1]=${_si_input[2]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dns_ip[2]=${_si_input[1]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dns_ip[3]=${_si_input[0]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $3=\(\ \$\{_dns_ip\[@\]\}\ \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in dot_array.bash.<br>
# dot_array &lt;array_name&gt;<br>
dot_array() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1 &nbsp; &nbsp; # Single argument required.<br>
&nbsp; &nbsp; local -a _da_input<br>
&nbsp; &nbsp; eval _da_input=\(\ \$\{$1\[@\]\}\ \)<br>
&nbsp; &nbsp; local IFS=${DOT_IFS}<br>
&nbsp; &nbsp; local _da_output=${_da_input[@]}<br>
&nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; echo ${_da_output}<br>
&nbsp; &nbsp; return 0<br>
}<br>
# This function described in file_to_array.bash<br>
# file_to_array &lt;file_name&gt; &lt;line_array_name&gt;<br>
file_to_array() {<br>
&nbsp; &nbsp; [ $# -eq 2 ] || return 1 &nbsp;# Two arguments required.<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; local -a _fta_tmp_<br>
&nbsp; &nbsp; _fta_tmp_=( $(cat $1) )<br>
&nbsp; &nbsp; eval $2=\( \$\{_fta_tmp_\[@\]\} \)<br>
&nbsp; &nbsp; return 0<br>
}<br>
# &nbsp;Columnized print of an array of multi-field strings.<br>
# &nbsp;col_print &lt;array_name&gt; &lt;min_space&gt; &lt;<br>
#+ tab_stop [tab_stops]&gt;<br>
col_print() {<br>
&nbsp; &nbsp; [ $# -gt 2 ] || return 0<br>
&nbsp; &nbsp; local -a _cp_inp<br>
&nbsp; &nbsp; local -a _cp_spc<br>
&nbsp; &nbsp; local -a _cp_line<br>
&nbsp; &nbsp; local _cp_min<br>
&nbsp; &nbsp; local _cp_mcnt<br>
&nbsp; &nbsp; local _cp_pos<br>
&nbsp; &nbsp; local _cp_cnt<br>
&nbsp; &nbsp; local _cp_tab<br>
&nbsp; &nbsp; local -i _cp<br>
&nbsp; &nbsp; local -i _cpf<br>
&nbsp; &nbsp; local _cp_fld<br>
&nbsp; &nbsp; # WARNING: FOLLOWING LINE NOT BLANK -- IT IS QUOTED SPACES.<br>
&nbsp; &nbsp; local _cp_max=' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; eval _cp_inp=\(\ \$\{$1\[@\]\}\ \)<br>
&nbsp; &nbsp; [ ${#_cp_inp[@]} -gt 0 ] || return 0 # Empty is easy.<br>
&nbsp; &nbsp; _cp_mcnt=$2<br>
&nbsp; &nbsp; _cp_min=${_cp_max:1:${_cp_mcnt}}<br>
Appendix A. Contributed Scripts<br>
628<br>
<hr>
<A name=635></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; shift<br>
&nbsp; &nbsp; shift<br>
&nbsp; &nbsp; _cp_cnt=$#<br>
&nbsp; &nbsp; for (( _cp = 0 ; _cp &lt; _cp_cnt ; _cp++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _cp_spc[${#_cp_spc[@]}]=&quot;${_cp_max:2:$1}&quot; #&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; _cp_cnt=${#_cp_inp[@]}<br>
&nbsp; &nbsp; for (( _cp = 0 ; _cp &lt; _cp_cnt ; _cp++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _cp_pos=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}$'\x20'<br>
&nbsp; &nbsp; &nbsp; &nbsp; _cp_line=( ${_cp_inp[${_cp}]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _cpf = 0 ; _cpf &lt; ${#_cp_line[@]} ; _cpf++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _cp_tab=${_cp_spc[${_cpf}]:${_cp_pos}}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ${#_cp_tab} -lt ${_cp_mcnt} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _cp_tab=&quot;${_cp_min}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot;${_cp_tab}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( _cp_pos = ${_cp_pos} + ${#_cp_tab} ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _cp_fld=&quot;${_cp_line[${_cpf}]}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -n ${_cp_fld}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (( _cp_pos = ${_cp_pos} + ${#_cp_fld} ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; set +f<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # # 'Hunt the Spammer' data flow # # # #<br>
# Application return code<br>
declare -i _hs_RC<br>
# Original input, from which IP addresses are removed<br>
# After which, domain names to check<br>
declare -a uc_name<br>
# Original input IP addresses are moved here<br>
# After which, IP addresses to check<br>
declare -a uc_address<br>
# Names against which address expansion run<br>
# Ready for name detail lookup<br>
declare -a chk_name<br>
# Addresses against which name expansion run<br>
# Ready for address detail lookup<br>
declare -a chk_address<br>
# &nbsp;Recursion is depth-first-by-name.<br>
# &nbsp;The expand_input_address maintains this list<br>
#+ to prohibit looking up addresses twice during<br>
#+ domain name recursion.<br>
declare -a been_there_addr<br>
been_there_addr=( '127.0.0.1' ) # Whitelist localhost<br>
Appendix A. Contributed Scripts<br>
629<br>
<hr>
<A name=636></a>Advanced Bash-Scripting Guide<br>
# Names which we have checked (or given up on)<br>
declare -a known_name<br>
# Addresses which we have checked (or given up on)<br>
declare -a known_address<br>
# &nbsp;List of zero or more Blacklist servers to check.<br>
# &nbsp;Each 'known_address' will be checked against each server,<br>
#+ with negative replies and failures suppressed.<br>
declare -a list_server<br>
# Indirection limit - set to zero == no limit<br>
indirect=${SPAMMER_LIMIT:=2}<br>
# # # # 'Hunt the Spammer' information output data # # # #<br>
# Any domain name may have multiple IP addresses.<br>
# Any IP address may have multiple domain names.<br>
# Therefore, track unique address-name pairs.<br>
declare -a known_pair<br>
declare -a reverse_pair<br>
# &nbsp;In addition to the data flow variables; known_address<br>
#+ known_name and list_server, the following are output to the<br>
#+ external graphics interface file.<br>
# Authority chain, parent -&gt; SOA fields.<br>
declare -a auth_chain<br>
# Reference chain, parent name -&gt; child name<br>
declare -a ref_chain<br>
# DNS chain - domain name -&gt; address<br>
declare -a name_address<br>
# Name and service pairs - domain name -&gt; service<br>
declare -a name_srvc<br>
# Name and resource pairs - domain name -&gt; Resource Record<br>
declare -a name_resource<br>
# Parent and Child pairs - parent name -&gt; child name<br>
# This MAY NOT be the same as the ref_chain followed!<br>
declare -a parent_child<br>
# Address and Blacklist hit pairs - address-&gt;server<br>
declare -a address_hits<br>
# Dump interface file data<br>
declare -f _dot_dump<br>
_dot_dump=pend_dummy &nbsp; # Initially a no-op<br>
# &nbsp;Data dump is enabled by setting the environment variable SPAMMER_DATA<br>
#+ to the name of a writable file.<br>
declare _dot_file<br>
# Helper function for the dump-to-dot-file function<br>
# dump_to_dot &lt;array_name&gt; &lt;prefix&gt;<br>
dump_to_dot() {<br>
&nbsp; &nbsp; local -a _dda_tmp<br>
&nbsp; &nbsp; local -i _dda_cnt<br>
&nbsp; &nbsp; local _dda_form=' &nbsp; &nbsp;'${2}'%04u %s\n'<br>
Appendix A. Contributed Scripts<br>
630<br>
<hr>
<A name=637></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; eval _dda_tmp=\(\ \$\{$1\[@\]\}\ \)<br>
&nbsp; &nbsp; _dda_cnt=${#_dda_tmp[@]}<br>
&nbsp; &nbsp; if [ ${_dda_cnt} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _dda = 0 ; _dda &lt; _dda_cnt ; _dda++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf &quot;${_dda_form}&quot; \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;${_dda}&quot; &quot;${_dda_tmp[${_dda}]}&quot; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
}<br>
# Which will also set _dot_dump to this function . . .<br>
dump_dot() {<br>
&nbsp; &nbsp; local -i _dd_cnt<br>
&nbsp; &nbsp; echo '# Data vintage: '$(date -R) &gt;${_dot_file}<br>
&nbsp; &nbsp; echo '# ABS Guide: is_spammer.bash; v2, 2004-msz' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo 'digraph G {' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; if [ ${#known_name[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known domain name nodes' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dd_cnt=${#known_name[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf ' &nbsp; &nbsp;N%04u [label=&quot;%s&quot;] ;\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;${_dd}&quot; &quot;${known_name[${_dd}]}&quot; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#known_address[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known address nodes' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dd_cnt=${#known_address[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf ' &nbsp; &nbsp;A%04u [label=&quot;%s&quot;] ;\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;${_dd}&quot; &quot;${known_address[${_dd}]}&quot; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo '/*' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' * Known relationships :: User conversion to' &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' * graphic form by hand or program required.' &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' *' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; if [ ${#auth_chain[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; echo '# Authority ref. edges followed &amp; field source.' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot auth_chain AC<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#ref_chain[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Name ref. edges followed and field source.' &gt;&gt;${_dot_file}<br>
Appendix A. Contributed Scripts<br>
631<br>
<hr>
<A name=638></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot ref_chain RC<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#name_address[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known name-&gt;address edges' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot name_address NA<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#name_srvc[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known name-&gt;service edges' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot name_srvc NS<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#name_resource[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known name-&gt;resource edges' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot name_resource NR<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#parent_child[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known parent-&gt;child edges' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; dump_to_dot parent_child PC<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#list_server[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# Known Blacklist nodes' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dd_cnt=${#list_server[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _dd = 0 ; _dd &lt; _dd_cnt ; _dd++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf ' &nbsp; &nbsp;LS%04u [label=&quot;%s&quot;] ;\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;${_dd}&quot; &quot;${list_server[${_dd}]}&quot; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines address_hits address_hits<br>
&nbsp; &nbsp; if [ ${#address_hits[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; echo '# Known address-&gt;Blacklist_hit edges' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; echo '# CAUTION: dig warnings can trigger false hits.' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp;dump_to_dot address_hits AH<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' *' &nbsp; &nbsp; &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' * That is a lot of relationships. Happy graphing.' &gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo ' */' &nbsp; &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; echo '}' &nbsp; &nbsp; &nbsp;&gt;&gt;${_dot_file}<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # # 'Hunt the Spammer' execution flow # # # #<br>
# &nbsp;Execution trace is enabled by setting the<br>
Appendix A. Contributed Scripts<br>
632<br>
<hr>
<A name=639></a>Advanced Bash-Scripting Guide<br>
#+ environment variable SPAMMER_TRACE to the name of a writable file.<br>
declare -a _trace_log<br>
declare _log_file<br>
# Function to fill the trace log<br>
trace_logger() {<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]=${_pend_current_}<br>
}<br>
# Dump trace log to file function variable.<br>
declare -f _log_dump<br>
_log_dump=pend_dummy &nbsp; # Initially a no-op.<br>
# Dump the trace log to a file.<br>
dump_log() {<br>
&nbsp; &nbsp; local -i _dl_cnt<br>
&nbsp; &nbsp; _dl_cnt=${#_trace_log[@]}<br>
&nbsp; &nbsp; for (( _dl = 0 ; _dl &lt; _dl_cnt ; _dl++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo ${_trace_log[${_dl}]} &gt;&gt; ${_log_file}<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; _dl_cnt=${#_pending_[@]}<br>
&nbsp; &nbsp; if [ ${_dl_cnt} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; _dl_cnt=${_dl_cnt}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo '# # # Operations stack not empty # # #' &gt;&gt; ${_log_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _dl = ${_dl_cnt} ; _dl &gt;= 0 ; _dl-- ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ${_pending_[${_dl}]} &gt;&gt; ${_log_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
}<br>
# # # Utility program 'dig' wrappers # # #<br>
#<br>
# &nbsp;These wrappers are derived from the<br>
#+ examples shown in dig_wrappers.bash.<br>
#<br>
# &nbsp;The major difference is these return<br>
#+ their results as a list in an array.<br>
#<br>
# &nbsp;See dig_wrappers.bash for details and<br>
#+ use that script to develop any changes.<br>
#<br>
# # #<br>
# Short form answer: 'dig' parses answer.<br>
# Forward lookup :: Name -&gt; Address<br>
# short_fwd &lt;domain_name&gt; &lt;array_name&gt;<br>
short_fwd() {<br>
&nbsp; &nbsp; local -a _sf_reply<br>
&nbsp; &nbsp; local -i _sf_rc<br>
&nbsp; &nbsp; local -i _sf_cnt<br>
&nbsp; &nbsp; IFS=${NO_WSP}<br>
echo -n '.'<br>
# echo 'sfwd: '${1}<br>
&nbsp; _sf_reply=( $(dig +short ${1} -c in -t a 2&gt;/dev/null) )<br>
&nbsp; _sf_rc=$?<br>
&nbsp; if [ ${_sf_rc} -ne 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]='## Lookup error '${_sf_rc}' on '${1}' ##'<br>
Appendix A. Contributed Scripts<br>
633<br>
<hr>
<A name=640></a>Advanced Bash-Scripting Guide<br>
# [ ${_sf_rc} -ne 9 ] &amp;&amp; pend_drop<br>
&nbsp; &nbsp; &nbsp; &nbsp; return ${_sf_rc}<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Some versions of 'dig' return warnings on stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; _sf_cnt=${#_sf_reply[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _sf = 0 ; _sf &lt; ${_sf_cnt} ; _sf++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_sf_reply[${_sf}]:0:2} == 'x;;' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _sf_reply[${_sf}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \$\{_sf_reply\[@\]\} \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# Reverse lookup :: Address -&gt; Name<br>
# short_rev &lt;ip_address&gt; &lt;array_name&gt;<br>
short_rev() {<br>
&nbsp; &nbsp; local -a _sr_reply<br>
&nbsp; &nbsp; local -i _sr_rc<br>
&nbsp; &nbsp; local -i _sr_cnt<br>
&nbsp; &nbsp; IFS=${NO_WSP}<br>
echo -n '.'<br>
# echo 'srev: '${1}<br>
&nbsp; _sr_reply=( $(dig +short -x ${1} 2&gt;/dev/null) )<br>
&nbsp; _sr_rc=$?<br>
&nbsp; if [ ${_sr_rc} -ne 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]='## Lookup error '${_sr_rc}' on '${1}' ##'<br>
# [ ${_sr_rc} -ne 9 ] &amp;&amp; pend_drop<br>
&nbsp; &nbsp; &nbsp; &nbsp; return ${_sr_rc}<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Some versions of 'dig' return warnings on stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; _sr_cnt=${#_sr_reply[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _sr = 0 ; _sr &lt; ${_sr_cnt} ; _sr++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_sr_reply[${_sr}]:0:2} == 'x;;' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _sr_reply[${_sr}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \$\{_sr_reply\[@\]\} \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# Special format lookup used to query blacklist servers.<br>
# short_text &lt;ip_address&gt; &lt;array_name&gt;<br>
short_text() {<br>
&nbsp; &nbsp; local -a _st_reply<br>
&nbsp; &nbsp; local -i _st_rc<br>
&nbsp; &nbsp; local -i _st_cnt<br>
&nbsp; &nbsp; IFS=${NO_WSP}<br>
# echo 'stxt: '${1}<br>
&nbsp; _st_reply=( $(dig +short ${1} -c in -t txt 2&gt;/dev/null) )<br>
&nbsp; _st_rc=$?<br>
&nbsp; if [ ${_st_rc} -ne 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]='##Text lookup error '${_st_rc}' on '${1}'##'<br>
# [ ${_st_rc} -ne 9 ] &amp;&amp; pend_drop<br>
&nbsp; &nbsp; &nbsp; &nbsp; return ${_st_rc}<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Some versions of 'dig' return warnings on stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; _st_cnt=${#_st_reply[@]}<br>
Appendix A. Contributed Scripts<br>
634<br>
<hr>
<A name=641></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _st = 0 ; _st &lt; ${#_st_cnt} ; _st++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_st_reply[${_st}]:0:2} == 'x;;' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _st_reply[${_st}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \$\{_st_reply\[@\]\} \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# The long forms, a.k.a., the parse it yourself versions<br>
# RFC 2782 &nbsp; Service lookups<br>
# dig +noall +nofail +answer _ldap._tcp.openldap.org -t srv<br>
# _&lt;service&gt;._&lt;protocol&gt;.&lt;domain_name&gt;<br>
# _ldap._tcp.openldap.org. 3600 &nbsp; IN &nbsp; &nbsp; SRV &nbsp; &nbsp;0 0 389 ldap.openldap.org.<br>
# domain TTL Class SRV Priority Weight Port Target<br>
# Forward lookup :: Name -&gt; poor man's zone transfer<br>
# long_fwd &lt;domain_name&gt; &lt;array_name&gt;<br>
long_fwd() {<br>
&nbsp; &nbsp; local -a _lf_reply<br>
&nbsp; &nbsp; local -i _lf_rc<br>
&nbsp; &nbsp; local -i _lf_cnt<br>
&nbsp; &nbsp; IFS=${NO_WSP}<br>
echo -n ':'<br>
# echo 'lfwd: '${1}<br>
&nbsp; _lf_reply=( $(<br>
&nbsp; &nbsp; &nbsp;dig +noall +nofail +answer +authority +additional \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;${1} -t soa ${1} -t mx ${1} -t any 2&gt;/dev/null) )<br>
&nbsp; _lf_rc=$?<br>
&nbsp; if [ ${_lf_rc} -ne 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]='# Zone lookup err '${_lf_rc}' on '${1}' #'<br>
# [ ${_lf_rc} -ne 9 ] &amp;&amp; pend_drop<br>
&nbsp; &nbsp; &nbsp; &nbsp; return ${_lf_rc}<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Some versions of 'dig' return warnings on stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; _lf_cnt=${#_lf_reply[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _lf = 0 ; _lf &lt; ${_lf_cnt} ; _lf++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_lf_reply[${_lf}]:0:2} == 'x;;' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _lf_reply[${_lf}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \$\{_lf_reply\[@\]\} \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# &nbsp;The reverse lookup domain name corresponding to the IPv6 address:<br>
# &nbsp; &nbsp; &nbsp;4321:0:1:2:3:4:567:89ab<br>
# &nbsp;would be (nibble, I.E: Hexdigit) reversed:<br>
# &nbsp;b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.<br>
# Reverse lookup :: Address -&gt; poor man's delegation chain<br>
# long_rev &lt;rev_ip_address&gt; &lt;array_name&gt;<br>
long_rev() {<br>
&nbsp; &nbsp; local -a _lr_reply<br>
&nbsp; &nbsp; local -i _lr_rc<br>
&nbsp; &nbsp; local -i _lr_cnt<br>
&nbsp; &nbsp; local _lr_dns<br>
&nbsp; &nbsp; _lr_dns=${1}'.in-addr.arpa.'<br>
&nbsp; &nbsp; IFS=${NO_WSP}<br>
Appendix A. Contributed Scripts<br>
635<br>
<hr>
<A name=642></a>Advanced Bash-Scripting Guide<br>
echo -n ':'<br>
# echo 'lrev: '${1}<br>
&nbsp; _lr_reply=( $(<br>
&nbsp; &nbsp; &nbsp; &nbsp;dig +noall +nofail +answer +authority +additional \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;${_lr_dns} -t soa ${_lr_dns} -t any 2&gt;/dev/null) )<br>
&nbsp; _lr_rc=$?<br>
&nbsp; if [ ${_lr_rc} -ne 0 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; _trace_log[${#_trace_log[@]}]='# Deleg lkp error '${_lr_rc}' on '${1}' #'<br>
# [ ${_lr_rc} -ne 9 ] &amp;&amp; pend_drop<br>
&nbsp; &nbsp; &nbsp; &nbsp; return ${_lr_rc}<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Some versions of 'dig' return warnings on stdout.<br>
&nbsp; &nbsp; &nbsp; &nbsp; _lr_cnt=${#_lr_reply[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _lr = 0 ; _lr &lt; ${_lr_cnt} ; _lr++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [ 'x'${_lr_reply[${_lr}]:0:2} == 'x;;' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset _lr_reply[${_lr}]<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval $2=\( \$\{_lr_reply\[@\]\} \)<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # Application specific functions # # #<br>
# Mung a possible name; suppresses root and TLDs.<br>
# name_fixup &lt;string&gt;<br>
name_fixup(){<br>
&nbsp; &nbsp; local -a _nf_tmp<br>
&nbsp; &nbsp; local -i _nf_end<br>
&nbsp; &nbsp; local _nf_str<br>
&nbsp; &nbsp; local IFS<br>
&nbsp; &nbsp; _nf_str=$(to_lower ${1})<br>
&nbsp; &nbsp; _nf_str=$(to_dot ${_nf_str})<br>
&nbsp; &nbsp; _nf_end=${#_nf_str}-1<br>
&nbsp; &nbsp; [ ${_nf_str:${_nf_end}} != '.' ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; _nf_str=${_nf_str}'.'<br>
&nbsp; &nbsp; IFS=${ADR_IFS}<br>
&nbsp; &nbsp; _nf_tmp=( ${_nf_str} )<br>
&nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; _nf_end=${#_nf_tmp[@]}<br>
&nbsp; &nbsp; case ${_nf_end} in<br>
&nbsp; &nbsp; 0) # No dots, only dots.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 1<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; 1) # Only a TLD.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 1<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; 2) # Maybe okay.<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo ${_nf_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp;return 0<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Needs a lookup table?<br>
&nbsp; &nbsp; &nbsp; &nbsp;if [ ${#_nf_tmp[1]} -eq 2 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp;then # Country coded TLD.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 1<br>
&nbsp; &nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo ${_nf_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0<br>
Appendix A. Contributed Scripts<br>
636<br>
<hr>
<A name=643></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; echo ${_nf_str}<br>
&nbsp; &nbsp; return 0<br>
}<br>
# Grope and mung original input(s).<br>
split_input() {<br>
&nbsp; &nbsp; [ ${#uc_name[@]} -gt 0 ] || return 0<br>
&nbsp; &nbsp; local -i _si_cnt<br>
&nbsp; &nbsp; local -i _si_len<br>
&nbsp; &nbsp; local _si_str<br>
&nbsp; &nbsp; unique_lines uc_name uc_name<br>
&nbsp; &nbsp; _si_cnt=${#uc_name[@]}<br>
&nbsp; &nbsp; for (( _si = 0 ; _si &lt; _si_cnt ; _si++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _si_str=${uc_name[$_si]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if is_address ${_si_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc_address[${#uc_address[@]}]=${_si_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset uc_name[$_si]<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! uc_name[$_si]=$(name_fixup ${_si_str})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unset ucname[$_si]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; uc_name=( ${uc_name[@]} )<br>
&nbsp; _si_cnt=${#uc_name[@]}<br>
&nbsp; _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd name input(s).#'<br>
&nbsp; _si_cnt=${#uc_address[@]}<br>
&nbsp; _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd addr input(s).#'<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # Discovery functions -- recursively interlocked by external data # # #<br>
# # # The leading 'if list is empty; return 0' in each is required. # # #<br>
# Recursion limiter<br>
# limit_chk() &lt;next_level&gt;<br>
limit_chk() {<br>
&nbsp; &nbsp; local -i _lc_lmt<br>
&nbsp; &nbsp; # Check indirection limit.<br>
&nbsp; &nbsp; if [ ${indirect} -eq 0 ] || [ $# -eq 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # The 'do-forever' choice<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Any value will do.<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # OK to continue.<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Limiting is in effect.<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ${indirect} -lt ${1} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ${1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Whatever.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Stop here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _lc_lmt=${1}+1 &nbsp; &nbsp; # Bump the given limit.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ${_lc_lmt} &nbsp; &nbsp;# Echo it.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # OK to continue.<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
Appendix A. Contributed Scripts<br>
637<br>
<hr>
<A name=644></a>Advanced Bash-Scripting Guide<br>
}<br>
# For each name in uc_name:<br>
# &nbsp; &nbsp; Move name to chk_name.<br>
# &nbsp; &nbsp; Add addresses to uc_address.<br>
# &nbsp; &nbsp; Pend expand_input_address.<br>
# &nbsp; &nbsp; Repeat until nothing new found.<br>
# expand_input_name &lt;indirection_limit&gt;<br>
expand_input_name() {<br>
&nbsp; &nbsp; [ ${#uc_name[@]} -gt 0 ] || return 0<br>
&nbsp; &nbsp; local -a _ein_addr<br>
&nbsp; &nbsp; local -a _ein_new<br>
&nbsp; &nbsp; local -i _ucn_cnt<br>
&nbsp; &nbsp; local -i _ein_cnt<br>
&nbsp; &nbsp; local _ein_tst<br>
&nbsp; &nbsp; _ucn_cnt=${#uc_name[@]}<br>
&nbsp; &nbsp; if &nbsp;! _ein_cnt=$(limit_chk ${1})<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; for (( _ein = 0 ; _ein &lt; _ucn_cnt ; _ein++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; if short_fwd ${uc_name[${_ein}]} _ein_new<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (( _ein_cnt = 0 ; _ein_cnt &lt; ${#_ein_new[@]}; _ein_cnt++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ein_tst=${_ein_new[${_ein_cnt}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if is_address ${_ein_tst}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ein_addr[${#_ein_addr[@]}]=${_ein_tst}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; unique_lines _ein_addr _ein_addr &nbsp; &nbsp; # Scrub duplicates.<br>
&nbsp; &nbsp; edit_exact chk_address _ein_addr &nbsp; &nbsp; # Scrub pending detail.<br>
&nbsp; &nbsp; edit_exact known_address _ein_addr &nbsp; # Scrub already detailed.<br>
&nbsp;if [ ${#_ein_addr[@]} -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp;# Anything new?<br>
&nbsp;then<br>
&nbsp; &nbsp;uc_address=( ${uc_address[@]} ${_ein_addr[@]} )<br>
&nbsp; &nbsp;pend_func expand_input_address ${1}<br>
&nbsp; &nbsp;_trace_log[${#_trace_log[@]}]='#Add '${#_ein_addr[@]}' unchkd addr inp.#'<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; edit_exact chk_name uc_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Scrub pending detail.<br>
&nbsp; &nbsp; edit_exact known_name uc_name &nbsp; &nbsp; &nbsp; &nbsp;# Scrub already detailed.<br>
&nbsp; &nbsp; if [ ${#uc_name[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; chk_name=( ${chk_name[@]} ${uc_name[@]} &nbsp;)<br>
&nbsp; &nbsp; &nbsp; &nbsp; pend_func detail_each_name ${1}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unset uc_name[@]<br>
&nbsp; &nbsp; return 0<br>
}<br>
# For each address in uc_address:<br>
# &nbsp; &nbsp; Move address to chk_address.<br>
# &nbsp; &nbsp; Add names to uc_name.<br>
# &nbsp; &nbsp; Pend expand_input_name.<br>
# &nbsp; &nbsp; Repeat until nothing new found.<br>
# expand_input_address &lt;indirection_limit&gt;<br>
Appendix A. Contributed Scripts<br>
638<br>
<hr>
<A name=645></a>Advanced Bash-Scripting Guide<br>
expand_input_address() {<br>
&nbsp; &nbsp; [ ${#uc_address[@]} -gt 0 ] || return 0<br>
&nbsp; &nbsp; local -a _eia_addr<br>
&nbsp; &nbsp; local -a _eia_name<br>
&nbsp; &nbsp; local -a _eia_new<br>
&nbsp; &nbsp; local -i _uca_cnt<br>
&nbsp; &nbsp; local -i _eia_cnt<br>
&nbsp; &nbsp; local _eia_tst<br>
&nbsp; &nbsp; unique_lines uc_address _eia_addr<br>
&nbsp; &nbsp; unset uc_address[@]<br>
&nbsp; &nbsp; edit_exact been_there_addr _eia_addr<br>
&nbsp; &nbsp; _uca_cnt=${#_eia_addr[@]}<br>
&nbsp; &nbsp; [ ${_uca_cnt} -gt 0 ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; been_there_addr=( ${been_there_addr[@]} ${_eia_addr[@]} )<br>
&nbsp; &nbsp; for (( _eia = 0 ; _eia &lt; _uca_cnt ; _eia++ ))<br>
&nbsp; &nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp;if short_rev ${_eia_addr[${_eia}]} _eia_new<br>
&nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (( _eia_cnt = 0 ; _eia_cnt &lt; ${#_eia_new[@]} ; _eia_cnt++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_eia_tst=${_eia_new[${_eia_cnt}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _eia_tst=$(name_fixup ${_eia_tst})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_eia_name[${#_eia_name[@]}]=${_eia_tst}<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; unique_lines _eia_name _eia_name &nbsp; &nbsp; # Scrub duplicates.<br>
&nbsp; &nbsp; edit_exact chk_name _eia_name &nbsp; &nbsp; &nbsp; &nbsp;# Scrub pending detail.<br>
&nbsp; &nbsp; edit_exact known_name _eia_name &nbsp; &nbsp; &nbsp;# Scrub already detailed.<br>
&nbsp;if [ ${#_eia_name[@]} -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp;# Anything new?<br>
&nbsp;then<br>
&nbsp; &nbsp;uc_name=( ${uc_name[@]} ${_eia_name[@]} )<br>
&nbsp; &nbsp;pend_func expand_input_name ${1}<br>
&nbsp; &nbsp;_trace_log[${#_trace_log[@]}]='#Add '${#_eia_name[@]}' unchkd name inp.#'<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; edit_exact chk_address _eia_addr &nbsp; &nbsp; # Scrub pending detail.<br>
&nbsp; &nbsp; edit_exact known_address _eia_addr &nbsp; # Scrub already detailed.<br>
&nbsp; &nbsp; if [ ${#_eia_addr[@]} -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp;# Anything new?<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; chk_address=( ${chk_address[@]} ${_eia_addr[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; pend_func detail_each_address ${1}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# The parse-it-yourself zone reply.<br>
# The input is the chk_name list.<br>
# detail_each_name &lt;indirection_limit&gt;<br>
detail_each_name() {<br>
&nbsp; &nbsp; [ ${#chk_name[@]} -gt 0 ] || return 0<br>
&nbsp; &nbsp; local -a _den_chk &nbsp; &nbsp; &nbsp; # Names to check<br>
&nbsp; &nbsp; local -a _den_name &nbsp; &nbsp; &nbsp;# Names found here<br>
&nbsp; &nbsp; local -a _den_address &nbsp; # Addresses found here<br>
&nbsp; &nbsp; local -a _den_pair &nbsp; &nbsp; &nbsp;# Pairs found here<br>
&nbsp; &nbsp; local -a _den_rev &nbsp; &nbsp; &nbsp; # Reverse pairs found here<br>
&nbsp; &nbsp; local -a _den_tmp &nbsp; &nbsp; &nbsp; # Line being parsed<br>
&nbsp; &nbsp; local -a _den_auth &nbsp; &nbsp; &nbsp;# SOA contact being parsed<br>
&nbsp; &nbsp; local -a _den_new &nbsp; &nbsp; &nbsp; # The zone reply<br>
&nbsp; &nbsp; local -a _den_pc &nbsp; &nbsp; &nbsp; &nbsp;# Parent-Child gets big fast<br>
Appendix A. Contributed Scripts<br>
639<br>
<hr>
<A name=646></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; local -a _den_ref &nbsp; &nbsp; &nbsp; # So does reference chain<br>
&nbsp; &nbsp; local -a _den_nr &nbsp; &nbsp; &nbsp; &nbsp;# Name-Resource can be big<br>
&nbsp; &nbsp; local -a _den_na &nbsp; &nbsp; &nbsp; &nbsp;# Name-Address<br>
&nbsp; &nbsp; local -a _den_ns &nbsp; &nbsp; &nbsp; &nbsp;# Name-Service<br>
&nbsp; &nbsp; local -a _den_achn &nbsp; &nbsp; &nbsp;# Chain of Authority<br>
&nbsp; &nbsp; local -i _den_cnt &nbsp; &nbsp; &nbsp; # Count of names to detail<br>
&nbsp; &nbsp; local -i _den_lmt &nbsp; &nbsp; &nbsp; # Indirection limit<br>
&nbsp; &nbsp; local _den_who &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Named being processed<br>
&nbsp; &nbsp; local _den_rec &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Record type being processed<br>
&nbsp; &nbsp; local _den_cont &nbsp; &nbsp; &nbsp; &nbsp; # Contact domain<br>
&nbsp; &nbsp; local _den_str &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Fixed up name string<br>
&nbsp; &nbsp; local _den_str2 &nbsp; &nbsp; &nbsp; &nbsp; # Fixed up reverse<br>
&nbsp; &nbsp; local IFS=${WSP_IFS}<br>
&nbsp; &nbsp; # Local, unique copy of names to check<br>
&nbsp; &nbsp; unique_lines chk_name _den_chk<br>
&nbsp; &nbsp; unset chk_name[@] &nbsp; &nbsp; &nbsp; # Done with globals.<br>
&nbsp; &nbsp; # Less any names already known<br>
&nbsp; &nbsp; edit_exact known_name _den_chk<br>
&nbsp; &nbsp; _den_cnt=${#_den_chk[@]}<br>
&nbsp; &nbsp; # If anything left, add to known_name.<br>
&nbsp; &nbsp; [ ${_den_cnt} -gt 0 ] &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; known_name=( ${known_name[@]} ${_den_chk[@]} )<br>
&nbsp; &nbsp; # for the list of (previously) unknown names . . .<br>
&nbsp; &nbsp; for (( _den = 0 ; _den &lt; _den_cnt ; _den++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_who=${_den_chk[${_den}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if long_fwd ${_den_who} _den_new<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unique_lines _den_new _den_new<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ${#_den_new[@]} -eq 0 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Parse each line in the reply.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (( _line = 0 ; _line &lt; ${#_den_new[@]} ; _line++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}$'\x09'$'\x20'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_tmp=( ${_den_new[${_line}]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If usable record and not a warning message . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ${#_den_tmp[@]} -gt 4 ] &amp;&amp; [ 'x'${_den_tmp[0]} != 'x;;' ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_rec=${_den_tmp[3]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_nr[${#_den_nr[@]}]=${_den_who}' '${_den_rec}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Begin at RFC1033 (+++)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ${_den_rec} in<br>
#&lt;name&gt; [&lt;ttl&gt;] &nbsp;[&lt;class&gt;] SOA &lt;origin&gt; &lt;person&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SOA) # Start Of Authority<br>
&nbsp; &nbsp; if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; _den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str}' SOA'<br>
&nbsp; &nbsp; &nbsp; # SOA origin -- domain name of master zone record<br>
&nbsp; &nbsp; &nbsp; if _den_str2=$(name_fixup ${_den_tmp[4]})<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_name[${#_den_name[@]}]=${_den_str2}<br>
Appendix A. Contributed Scripts<br>
640<br>
<hr>
<A name=647></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str2}' SOA.O'<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; # Responsible party e-mail address (possibly bogus).<br>
&nbsp; &nbsp; &nbsp; # Possibility of first.last@domain.name ignored.<br>
&nbsp; &nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; &nbsp; if _den_str2=$(name_fixup ${_den_tmp[5]})<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${ADR_IFS}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_auth=( ${_den_str2} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ${#_den_auth[@]} -gt 2 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_cont=${_den_auth[1]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (( _auth = 2 ; _auth &lt; ${#_den_auth[@]} ; _auth++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_cont=${_den_cont}'.'${_den_auth[${_auth}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_name[${#_den_name[@]}]=${_den_cont}'.'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_cont}'. SOA.C'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; set +f<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; A) # IP(v4) Address Record<br>
&nbsp; &nbsp; &nbsp; if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' A'<br>
&nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain A'<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; _den_address[${#_den_address[@]}]=${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NS) # Name Server Record<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Domain name being serviced (may be other than current)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' NS'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Domain name of service provider<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str2=$(name_fixup ${_den_tmp[4]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str2}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' NSH'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ns[${#_den_ns[@]}]=${_den_str2}' NS'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_str}' '${_den_str2}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MX) # Mail Server Record<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Domain name being serviced (wildcards not handled here)<br>
Appendix A. Contributed Scripts<br>
641<br>
<hr>
<A name=648></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MX'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Domain name of service provider<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[5]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MXH'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ns[${#_den_ns[@]}]=${_den_str}' MX'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PTR) # Reverse address record<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Special name<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' PTR'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Host name (not a CNAME)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str2=$(name_fixup ${_den_tmp[4]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_rev[${#_den_rev[@]}]=${_den_str}' '${_den_str2}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' PTRH'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AAAA) # IP(v6) Address Record<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' AAAA'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No processing for IPv6 addresses<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CNAME) # Alias name record<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Nickname<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[0]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CNAME'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Hostname<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if _den_str=$(name_fixup ${_den_tmp[4]})<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_name[${#_den_name[@]}]=${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CHOST'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
Appendix A. Contributed Scripts<br>
642<br>
<hr>
<A name=649></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TXT)<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; else # Lookup error == 'A' record 'unknown address'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; # Control dot array growth.<br>
&nbsp; &nbsp; unique_lines _den_achn _den_achn &nbsp; &nbsp; &nbsp;# Works best, all the same.<br>
&nbsp; &nbsp; edit_exact auth_chain _den_achn &nbsp; &nbsp; &nbsp; # Works best, unique items.<br>
&nbsp; &nbsp; if [ ${#_den_achn[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; auth_chain=( ${auth_chain[@]} ${_den_achn[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines _den_ref _den_ref &nbsp; &nbsp; &nbsp;# Works best, all the same.<br>
&nbsp; &nbsp; edit_exact ref_chain _den_ref &nbsp; &nbsp; &nbsp; # Works best, unique items.<br>
&nbsp; &nbsp; if [ ${#_den_ref[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; ref_chain=( ${ref_chain[@]} ${_den_ref[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines _den_na _den_na<br>
&nbsp; &nbsp; edit_exact name_address _den_na<br>
&nbsp; &nbsp; if [ ${#_den_na[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; name_address=( ${name_address[@]} ${_den_na[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines _den_ns _den_ns<br>
&nbsp; &nbsp; edit_exact name_srvc _den_ns<br>
&nbsp; &nbsp; if [ ${#_den_ns[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; name_srvc=( ${name_srvc[@]} ${_den_ns[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines _den_nr _den_nr<br>
&nbsp; &nbsp; edit_exact name_resource _den_nr<br>
&nbsp; &nbsp; if [ ${#_den_nr[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; name_resource=( ${name_resource[@]} ${_den_nr[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; unique_lines _den_pc _den_pc<br>
&nbsp; &nbsp; edit_exact parent_child _den_pc<br>
&nbsp; &nbsp; if [ ${#_den_pc[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; parent_child=( ${parent_child[@]} ${_den_pc[@]} )<br>
Appendix A. Contributed Scripts<br>
643<br>
<hr>
<A name=650></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; # Update list known_pair (Address and Name).<br>
&nbsp; &nbsp; unique_lines _den_pair _den_pair<br>
&nbsp; &nbsp; edit_exact known_pair _den_pair<br>
&nbsp; &nbsp; if [ ${#_den_pair[@]} -gt 0 ] &nbsp;# Anything new?<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; known_pair=( ${known_pair[@]} ${_den_pair[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; # Update list of reverse pairs.<br>
&nbsp; &nbsp; unique_lines _den_rev _den_rev<br>
&nbsp; &nbsp; edit_exact reverse_pair _den_rev<br>
&nbsp; &nbsp; if [ ${#_den_rev[@]} -gt 0 ] &nbsp; # Anything new?<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${NO_WSP}<br>
&nbsp; &nbsp; &nbsp; &nbsp; reverse_pair=( ${reverse_pair[@]} ${_den_rev[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; IFS=${WSP_IFS}<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; # Check indirection limit -- give up if reached.<br>
&nbsp; &nbsp; if ! _den_lmt=$(limit_chk ${1})<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; fi<br>
# Execution engine is LIFO. Order of pend operations is important.<br>
# Did we define any new addresses?<br>
unique_lines _den_address _den_address &nbsp; &nbsp;# Scrub duplicates.<br>
edit_exact known_address _den_address &nbsp; &nbsp; # Scrub already processed.<br>
edit_exact un_address _den_address &nbsp; &nbsp; &nbsp; &nbsp;# Scrub already waiting.<br>
if [ ${#_den_address[@]} -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Anything new?<br>
then<br>
&nbsp; uc_address=( ${uc_address[@]} ${_den_address[@]} )<br>
&nbsp; pend_func expand_input_address ${_den_lmt}<br>
&nbsp; _trace_log[${#_trace_log[@]}]='# Add '${#_den_address[@]}' unchkd addr. #'<br>
&nbsp; &nbsp; fi<br>
# Did we find any new names?<br>
unique_lines _den_name _den_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Scrub duplicates.<br>
edit_exact known_name _den_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Scrub already processed.<br>
edit_exact uc_name _den_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Scrub already waiting.<br>
if [ ${#_den_name[@]} -gt 0 ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Anything new?<br>
then<br>
&nbsp; uc_name=( ${uc_name[@]} ${_den_name[@]} )<br>
&nbsp; pend_func expand_input_name ${_den_lmt}<br>
&nbsp; _trace_log[${#_trace_log[@]}]='#Added '${#_den_name[@]}' unchkd name#'<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# The parse-it-yourself delegation reply<br>
# Input is the chk_address list.<br>
# detail_each_address &lt;indirection_limit&gt;<br>
detail_each_address() {<br>
&nbsp; &nbsp; [ ${#chk_address[@]} -gt 0 ] || return 0<br>
&nbsp; &nbsp; unique_lines chk_address chk_address<br>
&nbsp; &nbsp; edit_exact known_address chk_address<br>
&nbsp; &nbsp; if [ ${#chk_address[@]} -gt 0 ]<br>
Appendix A. Contributed Scripts<br>
644<br>
<hr>
<A name=651></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; known_address=( ${known_address[@]} ${chk_address[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; unset chk_address[@]<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # Application specific output functions # # #<br>
# Pretty print the known pairs.<br>
report_pairs() {<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; echo 'Known network pairs.'<br>
&nbsp; &nbsp; col_print known_pair 2 5 30<br>
&nbsp; &nbsp; if [ ${#auth_chain[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Known chain of authority.'<br>
&nbsp; &nbsp; &nbsp; &nbsp; col_print auth_chain 2 5 30 55<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ ${#reverse_pair[@]} -gt 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Known reverse pairs.'<br>
&nbsp; &nbsp; &nbsp; &nbsp; col_print reverse_pair 2 5 55<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# Check an address against the list of blacklist servers.<br>
# A good place to capture for GraphViz: address-&gt;status(server(reports))<br>
# check_lists &lt;ip_address&gt;<br>
check_lists() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1<br>
&nbsp; &nbsp; local -a _cl_fwd_addr<br>
&nbsp; &nbsp; local -a _cl_rev_addr<br>
&nbsp; &nbsp; local -a _cl_reply<br>
&nbsp; &nbsp; local -i _cl_rc<br>
&nbsp; &nbsp; local -i _ls_cnt<br>
&nbsp; &nbsp; local _cl_dns_addr<br>
&nbsp; &nbsp; local _cl_lkup<br>
&nbsp; &nbsp; split_ip ${1} _cl_fwd_addr _cl_rev_addr<br>
&nbsp; &nbsp; _cl_dns_addr=$(dot_array _cl_rev_addr)'.'<br>
&nbsp; &nbsp; _ls_cnt=${#list_server[@]}<br>
&nbsp; &nbsp; echo ' &nbsp; &nbsp;Checking address '${1}<br>
&nbsp; &nbsp; for (( _cl = 0 ; _cl &lt; _ls_cnt ; _cl++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; _cl_lkup=${_cl_dns_addr}${list_server[${_cl}]}<br>
&nbsp; &nbsp; &nbsp; if short_text ${_cl_lkup} _cl_reply<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ${#_cl_reply[@]} -gt 0 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ' &nbsp; &nbsp; &nbsp; &nbsp;Records from '${list_server[${_cl}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address_hits[${#address_hits[@]}]=${1}' '${list_server[${_cl}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _hs_RC=2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (( _clr = 0 ; _clr &lt; ${#_cl_reply[@]} ; _clr++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'${_cl_reply[${_clr}]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
Appendix A. Contributed Scripts<br>
645<br>
<hr>
<A name=652></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # The usual application glue # # #<br>
# Who did it?<br>
credits() {<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;echo 'Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz'<br>
}<br>
# How to use it?<br>
# (See also, &quot;Quickstart&quot; at end of script.)<br>
usage() {<br>
&nbsp; &nbsp; cat &lt;&lt;-'_usage_statement_'<br>
&nbsp; &nbsp; The script is_spammer.bash requires either one or two arguments.<br>
&nbsp; &nbsp; arg 1) May be one of:<br>
&nbsp; &nbsp; &nbsp; &nbsp; a) A domain name<br>
&nbsp; &nbsp; &nbsp; &nbsp; b) An IPv4 address<br>
&nbsp; &nbsp; &nbsp; &nbsp; c) The name of a file with any mix of names<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and addresses, one per line.<br>
&nbsp; &nbsp; arg 2) May be one of:<br>
&nbsp; &nbsp; &nbsp; &nbsp; a) A Blacklist server domain name<br>
&nbsp; &nbsp; &nbsp; &nbsp; b) The name of a file with Blacklist server<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;domain names, one per line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; c) If not present, a default list of (free)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Blacklist servers is used.<br>
&nbsp; &nbsp; &nbsp; &nbsp; d) If a filename of an empty, readable, file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is given,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Blacklist server lookup is disabled.<br>
&nbsp; &nbsp; All script output is written to stdout.<br>
&nbsp; &nbsp; Return codes: 0 -&gt; All OK, 1 -&gt; Script failure,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 -&gt; Something is Blacklisted.<br>
&nbsp; &nbsp; Requires the external program 'dig' from the 'bind-9'<br>
&nbsp; &nbsp; set of DNS programs. &nbsp;See: http://www.isc.org<br>
&nbsp; &nbsp; The domain name lookup depth limit defaults to 2 levels.<br>
&nbsp; &nbsp; Set the environment variable SPAMMER_LIMIT to change.<br>
&nbsp; &nbsp; SPAMMER_LIMIT=0 means 'unlimited'<br>
&nbsp; &nbsp; Limit may also be set on the command-line.<br>
&nbsp; &nbsp; If arg#1 is an integer, the limit is set to that value<br>
&nbsp; &nbsp; and then the above argument rules are applied.<br>
&nbsp; &nbsp; Setting the environment variable 'SPAMMER_DATA' to a filename<br>
&nbsp; &nbsp; will cause the script to write a GraphViz graphic file.<br>
&nbsp; &nbsp; For the development version;<br>
&nbsp; &nbsp; Setting the environment variable 'SPAMMER_TRACE' to a filename<br>
&nbsp; &nbsp; will cause the execution engine to log a function call trace.<br>
_usage_statement_<br>
}<br>
Appendix A. Contributed Scripts<br>
646<br>
<hr>
<A name=653></a>Advanced Bash-Scripting Guide<br>
# The default list of Blacklist servers:<br>
# Many choices, see: http://www.spews.org/lists.html<br>
declare -a default_servers<br>
# See: http://www.spamhaus.org (Conservative, well maintained)<br>
default_servers[0]='sbl-xbl.spamhaus.org'<br>
# See: http://ordb.org (Open mail relays)<br>
default_servers[1]='relays.ordb.org'<br>
# See: http://www.spamcop.net/ (You can report spammers here)<br>
default_servers[2]='bl.spamcop.net'<br>
# See: http://www.spews.org (An 'early detect' system)<br>
default_servers[3]='l2.spews.dnsbl.sorbs.net'<br>
# See: http://www.dnsbl.us.sorbs.net/using.shtml<br>
default_servers[4]='dnsbl.sorbs.net'<br>
# See: http://dsbl.org/usage (Various mail relay lists)<br>
default_servers[5]='list.dsbl.org'<br>
default_servers[6]='multihop.dsbl.org'<br>
default_servers[7]='unconfirmed.dsbl.org'<br>
# User input argument #1<br>
setup_input() {<br>
&nbsp; &nbsp; if [ -e ${1} ] &amp;&amp; [ -r ${1} ] &nbsp;# Name of readable file<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; file_to_array ${1} uc_name<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Using filename &gt;'${1}'&lt; as input.'<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; if is_address ${1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# IP address?<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc_address=( ${1} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo 'Starting with address &gt;'${1}'&lt;'<br>
&nbsp; &nbsp; &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Must be a name.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uc_name=( ${1} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo 'Starting with domain name &gt;'${1}'&lt;'<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# User input argument #2<br>
setup_servers() {<br>
&nbsp; &nbsp; if [ -e ${1} ] &amp;&amp; [ -r ${1} ] &nbsp;# Name of a readable file<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; file_to_array ${1} list_server<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Using filename &gt;'${1}'&lt; as blacklist server list.'<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; list_server=( ${1} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Using blacklist server &gt;'${1}'&lt;'<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# User environment variable SPAMMER_TRACE<br>
live_log_die() {<br>
&nbsp; &nbsp; if [ ${SPAMMER_TRACE:=} ] &nbsp; &nbsp;# Wants trace log?<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ! -e ${SPAMMER_TRACE} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! touch ${SPAMMER_TRACE} 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func echo $(printf '%q\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Unable to create log file &gt;'${SPAMMER_TRACE}'&lt;')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
Appendix A. Contributed Scripts<br>
647<br>
<hr>
<A name=654></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _log_file=${SPAMMER_TRACE}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _pend_hook_=trace_logger<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _log_dump=dump_log<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ! -w ${SPAMMER_TRACE} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func echo $(printf '%q\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Unable to write log file &gt;'${SPAMMER_TRACE}'&lt;')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _log_file=${SPAMMER_TRACE}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo '' &gt; ${_log_file}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _pend_hook_=trace_logger<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _log_dump=dump_log<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# User environment variable SPAMMER_DATA<br>
data_capture() {<br>
&nbsp; &nbsp; if [ ${SPAMMER_DATA:=} ] &nbsp; &nbsp;# Wants a data dump?<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ! -e ${SPAMMER_DATA} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! touch ${SPAMMER_DATA} 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func echo $(printf '%q]n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Unable to create data output file &gt;'${SPAMMER_DATA}'&lt;')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dot_file=${SPAMMER_DATA}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dot_dump=dump_dot<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ! -w ${SPAMMER_DATA} ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func echo $(printf '%q\n' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'Unable to write data output file &gt;'${SPAMMER_DATA}'&lt;')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dot_file=${SPAMMER_DATA}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dot_dump=dump_dot<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
# Grope user specified arguments.<br>
do_user_args() {<br>
&nbsp; &nbsp; if [ $# -gt 0 ] &amp;&amp; is_number $1<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; indirect=$1<br>
&nbsp; &nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; case $# in &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Did user treat us well?<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1)<br>
Appendix A. Contributed Scripts<br>
648<br>
<hr>
<A name=655></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! setup_input $1 &nbsp; &nbsp;# Needs error checking.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $_log_dump<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_server=( ${default_servers[@]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _list_cnt=${#list_server[@]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo 'Using default blacklist server list.'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo 'Search depth limit: '${indirect}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! setup_input $1 &nbsp; &nbsp;# Needs error checking.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $_log_dump<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! setup_servers $2 &nbsp;# Needs error checking.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $_log_dump<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo 'Search depth limit: '${indirect}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func usage<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_release<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $_log_dump<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; return 0<br>
}<br>
# A general purpose debug tool.<br>
# list_array &lt;array_name&gt;<br>
list_array() {<br>
&nbsp; &nbsp; [ $# -eq 1 ] || return 1 &nbsp;# One argument required.<br>
&nbsp; &nbsp; local -a _la_lines<br>
&nbsp; &nbsp; set -f<br>
&nbsp; &nbsp; local IFS=${NO_WSP}<br>
&nbsp; &nbsp; eval _la_lines=\(\ \$\{$1\[@\]\}\ \)<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; echo &quot;Element count &quot;${#_la_lines[@]}&quot; array &quot;${1}<br>
&nbsp; &nbsp; local _ln_cnt=${#_la_lines[@]}<br>
&nbsp; &nbsp; for (( _i = 0; _i &lt; ${_ln_cnt}; _i++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Element '$_i' &gt;'${_la_lines[$_i]}'&lt;'<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; set +f<br>
&nbsp; &nbsp; return 0<br>
}<br>
# # # 'Hunt the Spammer' program code # # #<br>
pend_init &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Ready stack engine.<br>
pend_func credits &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Last thing to print.<br>
# # # Deal with user # # #<br>
Appendix A. Contributed Scripts<br>
649<br>
<hr>
<A name=656></a>Advanced Bash-Scripting Guide<br>
live_log_die &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Setup debug trace log.<br>
data_capture &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Setup data capture file.<br>
echo<br>
do_user_args $@<br>
# # # Haven't exited yet - There is some hope # # #<br>
# Discovery group - Execution engine is LIFO - pend<br>
# in reverse order of execution.<br>
_hs_RC=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Hunt the Spammer return code<br>
pend_mark<br>
&nbsp; &nbsp; pend_func report_pairs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Report name-address pairs.<br>
&nbsp; &nbsp; # The two detail_* are mutually recursive functions.<br>
&nbsp; &nbsp; # They also pend expand_* functions as required.<br>
&nbsp; &nbsp; # These two (the last of ???) exit the recursion.<br>
&nbsp; &nbsp; pend_func detail_each_address &nbsp; &nbsp; &nbsp; # Get all resources of addresses.<br>
&nbsp; &nbsp; pend_func detail_each_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Get all resources of names.<br>
&nbsp; &nbsp; # &nbsp;The two expand_* are mutually recursive functions,<br>
&nbsp; &nbsp; #+ which pend additional detail_* functions as required.<br>
&nbsp; &nbsp; pend_func expand_input_address 1 &nbsp; &nbsp;# Expand input names by address.<br>
&nbsp; &nbsp; pend_func expand_input_name 1 &nbsp; &nbsp; &nbsp; # #xpand input addresses by name.<br>
&nbsp; &nbsp; # Start with a unique set of names and addresses.<br>
&nbsp; &nbsp; pend_func unique_lines uc_address uc_address<br>
&nbsp; &nbsp; pend_func unique_lines uc_name uc_name<br>
&nbsp; &nbsp; # Separate mixed input of names and addresses.<br>
&nbsp; &nbsp; pend_func split_input<br>
pend_release<br>
# # # Pairs reported -- Unique list of IP addresses found<br>
echo<br>
_ip_cnt=${#known_address[@]}<br>
if [ ${#list_server[@]} -eq 0 ]<br>
then<br>
&nbsp; &nbsp; echo 'Blacklist server list empty, none checked.'<br>
else<br>
&nbsp; &nbsp; if [ ${_ip_cnt} -eq 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Known address list empty, none checked.'<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; _ip_cnt=${_ip_cnt}-1 &nbsp; # Start at top.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo 'Checking Blacklist servers.'<br>
&nbsp; &nbsp; &nbsp; &nbsp; for (( _ip = _ip_cnt ; _ip &gt;= 0 ; _ip-- ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pend_func check_lists $( printf '%q\n' ${known_address[$_ip]} )<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; fi<br>
fi<br>
pend_release<br>
$_dot_dump &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Graphics file dump<br>
$_log_dump &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Execution trace<br>
echo<br>
##############################<br>
# Example output from script #<br>
##############################<br>
:&lt;&lt;-'_is_spammer_outputs_'<br>
./is_spammer.bash 0 web4.alojamentos7.com<br>
Appendix A. Contributed Scripts<br>
650<br>
<hr>
<A name=657></a>Advanced Bash-Scripting Guide<br>
Starting with domain name &gt;web4.alojamentos7.com&lt;<br>
Using default blacklist server list.<br>
Search depth limit: 0<br>
.:....::::...:::...:::.......::..::...:::.......::<br>
Known network pairs.<br>
&nbsp; &nbsp; 66.98.208.97 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; web4.alojamentos7.com.<br>
&nbsp; &nbsp; 66.98.208.97 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns1.alojamentos7.com.<br>
&nbsp; &nbsp; 69.56.202.147 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ns2.alojamentos.ws.<br>
&nbsp; &nbsp; 66.98.208.97 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alojamentos7.com.<br>
&nbsp; &nbsp; 66.98.208.97 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; web.alojamentos7.com.<br>
&nbsp; &nbsp; 69.56.202.146 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ns1.alojamentos.ws.<br>
&nbsp; &nbsp; 69.56.202.146 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alojamentos.ws.<br>
&nbsp; &nbsp; 66.235.180.113 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns1.alojamentos.org.<br>
&nbsp; &nbsp; 66.235.181.192 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns2.alojamentos.org.<br>
&nbsp; &nbsp; 66.235.180.113 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alojamentos.org.<br>
&nbsp; &nbsp; 66.235.180.113 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; web6.alojamentos.org.<br>
&nbsp; &nbsp; 216.234.234.30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ns1.theplanet.com.<br>
&nbsp; &nbsp; 12.96.160.115 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ns2.theplanet.com.<br>
&nbsp; &nbsp; 216.185.111.52 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mail1.theplanet.com.<br>
&nbsp; &nbsp; 69.56.141.4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spooling.theplanet.com.<br>
&nbsp; &nbsp; 216.185.111.40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; theplanet.com.<br>
&nbsp; &nbsp; 216.185.111.40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; www.theplanet.com.<br>
&nbsp; &nbsp; 216.185.111.52 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mail.theplanet.com.<br>
Checking Blacklist servers.<br>
&nbsp; Checking address 66.98.208.97<br>
&nbsp; &nbsp; &nbsp; Records from dnsbl.sorbs.net<br>
&nbsp; &quot;Spam Received See: http://www.dnsbl.sorbs.net/lookup.shtml?66.98.208.97&quot;<br>
&nbsp; &nbsp; Checking address 69.56.202.147<br>
&nbsp; &nbsp; Checking address 69.56.202.146<br>
&nbsp; &nbsp; Checking address 66.235.180.113<br>
&nbsp; &nbsp; Checking address 66.235.181.192<br>
&nbsp; &nbsp; Checking address 216.185.111.40<br>
&nbsp; &nbsp; Checking address 216.234.234.30<br>
&nbsp; &nbsp; Checking address 12.96.160.115<br>
&nbsp; &nbsp; Checking address 216.185.111.52<br>
&nbsp; &nbsp; Checking address 69.56.141.4<br>
Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz<br>
_is_spammer_outputs_<br>
exit ${_hs_RC}<br>
####################################################<br>
# &nbsp;The script ignores everything from here on down #<br>
#+ because of the 'exit' command, just above. &nbsp; &nbsp; &nbsp;#<br>
####################################################<br>
Quickstart<br>
==========<br>
&nbsp;Prerequisites<br>
&nbsp; Bash version 2.05b or 3.00 (bash --version)<br>
&nbsp; A version of Bash which supports arrays. Array&nbsp;<br>
&nbsp; support is included by default Bash configurations.<br>
&nbsp; 'dig,' version 9.x.x (dig $HOSTNAME, see first line of output)<br>
Appendix A. Contributed Scripts<br>
651<br>
<hr>
<A name=658></a>Advanced Bash-Scripting Guide<br>
&nbsp; A version of dig which supports the +short options.&nbsp;<br>
&nbsp; See: dig_wrappers.bash for details.<br>
&nbsp;Optional Prerequisites<br>
&nbsp; 'named,' a local DNS caching program. Any flavor will do.<br>
&nbsp; Do twice: dig $HOSTNAME&nbsp;<br>
&nbsp; Check near bottom of output for: SERVER: 127.0.0.1#53<br>
&nbsp; That means you have one running.<br>
&nbsp;Optional Graphics Support<br>
&nbsp; 'date,' a standard *nix thing. (date -R)<br>
&nbsp; dot Program to convert graphic description file to a&nbsp;<br>
&nbsp; diagram. (dot -V)<br>
&nbsp; A part of the Graph-Viz set of programs.<br>
&nbsp; See: [http://www.research.att.com/sw/tools/graphviz||GraphViz]<br>
&nbsp; 'dotty,' a visual editor for graphic description files.<br>
&nbsp; Also a part of the Graph-Viz set of programs.<br>
&nbsp;Quick Start<br>
In the same directory as the is_spammer.bash script;&nbsp;<br>
Do: ./is_spammer.bash<br>
&nbsp;Usage Details<br>
1. Blacklist server choices.<br>
&nbsp; (a) To use default, built-in list: Do nothing.<br>
&nbsp; (b) To use your own list:&nbsp;<br>
&nbsp; &nbsp; i. Create a file with a single Blacklist server&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;domain name per line.<br>
&nbsp; &nbsp; ii. Provide that filename as the last argument to&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; the script.<br>
&nbsp; (c) To use a single Blacklist server: Last argument&nbsp;<br>
&nbsp; &nbsp; &nbsp; to the script.<br>
&nbsp; (d) To disable Blacklist lookups:<br>
&nbsp; &nbsp; i. Create an empty file (touch spammer.nul)<br>
&nbsp; &nbsp; &nbsp; &nbsp;Your choice of filename.<br>
&nbsp; &nbsp; ii. Provide the filename of that empty file as the&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; last argument to the script.<br>
2. Search depth limit.<br>
&nbsp; (a) To use the default value of 2: Do nothing.<br>
&nbsp; (b) To set a different limit:&nbsp;<br>
Appendix A. Contributed Scripts<br>
652<br>
<hr>
<A name=659></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; A limit of 0 means: no limit.<br>
&nbsp; &nbsp; i. export SPAMMER_LIMIT=1<br>
&nbsp; &nbsp; &nbsp; &nbsp;or whatever limit you want.<br>
&nbsp; &nbsp; ii. OR provide the desired limit as the first&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;argument to the script.<br>
3. Optional execution trace log.<br>
&nbsp; (a) To use the default setting of no log output: Do nothing.<br>
&nbsp; (b) To write an execution trace log:<br>
&nbsp; &nbsp; &nbsp; export SPAMMER_TRACE=spammer.log<br>
&nbsp; &nbsp; &nbsp; or whatever filename you want.<br>
4. Optional graphic description file.<br>
&nbsp; (a) To use the default setting of no graphic file: Do nothing.<br>
&nbsp; (b) To write a Graph-Viz graphic description file:<br>
&nbsp; &nbsp; &nbsp; export SPAMMER_DATA=spammer.dot<br>
&nbsp; &nbsp; &nbsp; or whatever filename you want.<br>
5. Where to start the search.<br>
&nbsp; (a) Starting with a single domain name:<br>
&nbsp; &nbsp; i. Without a command-line search limit: First&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;argument to script.<br>
&nbsp; &nbsp; ii. With a command-line search limit: Second&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; argument to script.<br>
&nbsp; (b) Starting with a single IP address:<br>
&nbsp; &nbsp; i. Without a command-line search limit: First&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;argument to script.<br>
&nbsp; &nbsp; ii. With a command-line search limit: Second&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; argument to script.<br>
&nbsp; (c) Starting with (mixed) multiple name(s) and/or address(es):<br>
&nbsp; &nbsp; &nbsp; Create a file with one name or address per line.<br>
&nbsp; &nbsp; &nbsp; Your choice of filename.<br>
&nbsp; &nbsp; i. Without a command-line search limit: Filename as&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;first argument to script.<br>
&nbsp; &nbsp; ii. With a command-line search limit: Filename as&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; second argument to script.<br>
6. What to do with the display output.<br>
&nbsp; (a) To view display output on screen: Do nothing.<br>
&nbsp; (b) To save display output to a file: Redirect stdout to a filename.<br>
&nbsp; (c) To discard display output: Redirect stdout to /dev/null.<br>
7. Temporary end of decision making.&nbsp;<br>
&nbsp; &nbsp;press RETURN&nbsp;<br>
Appendix A. Contributed Scripts<br>
653<br>
<hr>
<A name=660></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;wait (optionally, watch the dots and colons).<br>
8. Optionally check the return code.<br>
&nbsp; (a) Return code 0: All OK<br>
&nbsp; (b) Return code 1: Script setup failure<br>
&nbsp; (c) Return code 2: Something was blacklisted.<br>
9. Where is my graph (diagram)?<br>
The script does not directly produce a graph (diagram).&nbsp;<br>
It only produces a graphic description file. You can&nbsp;<br>
process the graphic descriptor file that was output&nbsp;<br>
with the 'dot' program.<br>
Until you edit that descriptor file, to describe the&nbsp;<br>
relationships you want shown, all that you will get is&nbsp;<br>
a bunch of labeled name and address nodes.<br>
All of the script's discovered relationships are within&nbsp;<br>
a comment block in the graphic descriptor file, each&nbsp;<br>
with a descriptive heading.<br>
The editing required to draw a line between a pair of&nbsp;<br>
nodes from the information in the descriptor file may&nbsp;<br>
be done with a text editor.&nbsp;<br>
Given these lines somewhere in the descriptor file:<br>
# Known domain name nodes<br>
N0000 [label=&quot;guardproof.info.&quot;] ;<br>
N0002 [label=&quot;third.guardproof.info.&quot;] ;<br>
# Known address nodes<br>
A0000 [label=&quot;61.141.32.197&quot;] ;<br>
/*<br>
# Known name-&gt;address edges<br>
NA0000 third.guardproof.info. 61.141.32.197<br>
# Known parent-&gt;child edges<br>
PC0000 guardproof.info. third.guardproof.info.<br>
&nbsp;*/<br>
Turn that into the following lines by substituting node&nbsp;<br>
identifiers into the relationships:<br>
Appendix A. Contributed Scripts<br>
654<br>
<hr>
<A name=661></a>Advanced Bash-Scripting Guide<br>
# Known domain name nodes<br>
N0000 [label=&quot;guardproof.info.&quot;] ;<br>
N0002 [label=&quot;third.guardproof.info.&quot;] ;<br>
# Known address nodes<br>
A0000 [label=&quot;61.141.32.197&quot;] ;<br>
# PC0000 guardproof.info. third.guardproof.info.<br>
N0000-&gt;N0002 ;<br>
# NA0000 third.guardproof.info. 61.141.32.197<br>
N0002-&gt;A0000 ;<br>
/*<br>
# Known name-&gt;address edges<br>
NA0000 third.guardproof.info. 61.141.32.197<br>
# Known parent-&gt;child edges<br>
PC0000 guardproof.info. third.guardproof.info.<br>
&nbsp;*/<br>
Process that with the 'dot' program, and you have your&nbsp;<br>
first network diagram.<br>
In addition to the conventional graphic edges, the&nbsp;<br>
descriptor file includes similar format pair-data that&nbsp;<br>
describes services, zone records (sub-graphs?),&nbsp;<br>
blacklisted addresses, and other things which might be&nbsp;<br>
interesting to include in your graph. This additional&nbsp;<br>
information could be displayed as different node&nbsp;<br>
shapes, colors, line sizes, etc.<br>
The descriptor file can also be read and edited by a&nbsp;<br>
Bash script (of course). You should be able to find&nbsp;<br>
most of the functions required within the&nbsp;<br>
&quot;is_spammer.bash&quot; script.<br>
# End Quickstart.<br>
Additional Note<br>
========== ====<br>
Appendix A. Contributed Scripts<br>
655<br>
<hr>
<A name=662></a>Advanced Bash-Scripting Guide<br>
Michael Zick points out that there is a &quot;makeviz.bash&quot; interactive<br>
Web site at rediris.es. Can't give the full URL, since this is not<br>
a publically accessible site.<br>
Another anti-spam script.<br>
<b>Example A-29. Spammer Hunt</b><br>
#!/bin/bash<br>
# whx.sh: &quot;whois&quot; spammer lookup<br>
# Author: Walter Dnes<br>
# Slight revisions (first section) by ABS Guide author.<br>
# Used in ABS Guide with permission.<br>
# Needs version 3.x or greater of Bash to run (because of =~ operator).<br>
# Commented by script author and ABS Guide author.<br>
E_BADARGS=65 &nbsp; &nbsp; &nbsp; &nbsp;# Missing command-line arg.<br>
E_NOHOST=66 &nbsp; &nbsp; &nbsp; &nbsp; # Host not found.<br>
E_TIMEOUT=67 &nbsp; &nbsp; &nbsp; &nbsp;# Host lookup timed out.<br>
E_UNDEF=68 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Some other (undefined) error.<br>
HOSTWAIT=10 &nbsp; &nbsp; &nbsp; &nbsp; # Specify up to 10 seconds for host query reply.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The actual wait may be a bit longer.<br>
OUTFILE=whois.txt &nbsp; # Output file.<br>
PORT=4321<br>
if [ -z &quot;$1&quot; ] &nbsp; &nbsp; &nbsp;# Check for (required) command-line arg.<br>
then<br>
&nbsp; echo &quot;Usage: $0 domain name or IP address&quot;<br>
&nbsp; exit $E_BADARGS<br>
fi<br>
if [[ &quot;$1&quot; =~ &quot;[a-zA-Z][a-zA-Z]$&quot; ]] &nbsp;# Ends in two alpha chars?<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# It's a domain name &amp;&amp; must do host lookup.<br>
&nbsp; IPADDR=$(host -W $HOSTWAIT $1 | awk '{print $4}')<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Doing host lookup to get IP address.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Extract final field.<br>
else<br>
&nbsp; IPADDR=&quot;$1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Command-line arg was IP address.<br>
fi<br>
echo; echo &quot;IP Address is: &quot;$IPADDR&quot;&quot;; echo<br>
if [ -e &quot;$OUTFILE&quot; ]<br>
then<br>
&nbsp; rm -f &quot;$OUTFILE&quot;<br>
&nbsp; echo &quot;Stale output file \&quot;$OUTFILE\&quot; removed.&quot;; echo<br>
fi<br>
# &nbsp;Sanity checks.<br>
# &nbsp;(This section needs more work.)<br>
# &nbsp;===============================<br>
if [ -z &quot;$IPADDR&quot; ]<br>
Appendix A. Contributed Scripts<br>
656<br>
<hr>
<A name=663></a>Advanced Bash-Scripting Guide<br>
# No response.<br>
then<br>
&nbsp; echo &quot;Host not found!&quot;<br>
&nbsp; exit $E_NOHOST &nbsp; &nbsp;# Bail out.<br>
fi<br>
if [[ &quot;$IPADDR&quot; =~ &quot;^[;;]&quot; ]]<br>
# &nbsp;;; connection timed out; no servers could be reached<br>
then<br>
&nbsp; echo &quot;Host lookup timed out!&quot;<br>
&nbsp; exit $E_TIMEOUT &nbsp; # Bail out.<br>
fi<br>
if [[ &quot;$IPADDR&quot; =~ &quot;[(NXDOMAIN)]$&quot; ]]<br>
# &nbsp;Host xxxxxxxxx.xxx not found: 3(NXDOMAIN)<br>
then<br>
&nbsp; echo &quot;Host not found!&quot;<br>
&nbsp; exit $E_NOHOST &nbsp; &nbsp;# Bail out.<br>
fi<br>
if [[ &quot;$IPADDR&quot; =~ &quot;[(SERVFAIL)]$&quot; ]]<br>
# &nbsp;Host xxxxxxxxx.xxx not found: 2(SERVFAIL)<br>
then<br>
&nbsp; echo &quot;Host not found!&quot;<br>
&nbsp; exit $E_NOHOST &nbsp; &nbsp;# Bail out.<br>
fi<br>
# ======================== Main body of script ========================<br>
AFRINICquery() {<br>
# &nbsp;Define the function that queries AFRINIC. Echo a notification to the<br>
#+ screen, and then run the actual query, redirecting output to $OUTFILE.<br>
&nbsp; echo &quot;Searching for $IPADDR in whois.afrinic.net&quot;<br>
&nbsp; whois -h whois.afrinic.net &quot;$IPADDR&quot; &gt; $OUTFILE<br>
# &nbsp;Check for presence of reference to an rwhois.<br>
# &nbsp;Warn about non-functional rwhois.infosat.net server<br>
#+ and attempt rwhois query.<br>
&nbsp; if grep -e &quot;^remarks: .*rwhois\.[^ ]\+&quot; &quot;$OUTFILE&quot;<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot; &quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot;***&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot;***&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot;Warning: rwhois.infosat.net was not working as of 2005/02/02&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; when this script was written.&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot;***&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot;***&quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; echo &quot; &quot; &gt;&gt; $OUTFILE<br>
&nbsp; &nbsp; RWHOIS=`grep &quot;^remarks: .*rwhois\.[^ ]\+&quot; &quot;$OUTFILE&quot; | tail -n 1 |\<br>
&nbsp; &nbsp; sed &quot;s/\(^.*\)\(rwhois\..*\)\(:4.*\)/\2/&quot;`<br>
&nbsp; &nbsp; whois -h ${RWHOIS}:${PORT} &quot;$IPADDR&quot; &gt;&gt; $OUTFILE<br>
&nbsp; fi<br>
}<br>
APNICquery() {<br>
&nbsp; echo &quot;Searching for $IPADDR in whois.apnic.net&quot;<br>
&nbsp; whois -h whois.apnic.net &quot;$IPADDR&quot; &gt; $OUTFILE<br>
Appendix A. Contributed Scripts<br>
657<br>
<hr>
<A name=664></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Just &nbsp;about &nbsp;every &nbsp;country has its own internet registrar.<br>
# &nbsp;I don't normally bother consulting them, because the regional registry<br>
#+ usually supplies sufficient information.<br>
# &nbsp;There are a few exceptions, where the regional registry simply<br>
#+ refers to the national registry for direct data.<br>
# &nbsp;These are Japan and South Korea in APNIC, and Brasil in LACNIC.<br>
# &nbsp;The following if statement checks $OUTFILE (whois.txt) for the presence<br>
#+ of &quot;KR&quot; (South Korea) or &quot;JP&quot; (Japan) in the country field.<br>
# &nbsp;If either is found, the query is re-run against the appropriate<br>
#+ national registry.<br>
&nbsp; if grep -E &quot;^country:[ ]+KR$&quot; &quot;$OUTFILE&quot;<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Searching for $IPADDR in whois.krnic.net&quot;<br>
&nbsp; &nbsp; whois -h whois.krnic.net &quot;$IPADDR&quot; &gt;&gt; $OUTFILE<br>
&nbsp; elif grep -E &quot;^country:[ ]+JP$&quot; &quot;$OUTFILE&quot;<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Searching for $IPADDR in whois.nic.ad.jp&quot;<br>
&nbsp; &nbsp; whois -h whois.nic.ad.jp &quot;$IPADDR&quot;/e &gt;&gt; $OUTFILE<br>
&nbsp; fi<br>
}<br>
ARINquery() {<br>
&nbsp; echo &quot;Searching for $IPADDR in whois.arin.net&quot;<br>
&nbsp; whois -h whois.arin.net &quot;$IPADDR&quot; &gt; $OUTFILE<br>
# &nbsp;Several large internet providers listed by ARIN have their own<br>
#+ internal whois service, referred to as &quot;rwhois&quot;.<br>
# &nbsp;A large block of IP addresses is listed with the provider<br>
#+ under the ARIN registry.<br>
# &nbsp;To get the IP addresses of 2nd-level ISPs or other large customers,<br>
#+ one has to refer to the rwhois server on port 4321.<br>
# &nbsp;I originally started with a bunch of &quot;if&quot; statements checking for<br>
#+ the larger providers.<br>
# &nbsp;This approach is unwieldy, and there's always another rwhois server<br>
#+ that I didn't know about.<br>
# &nbsp;A more elegant approach is to check $OUTFILE for a reference<br>
#+ to a whois server, parse that server name out of the comment section,<br>
#+ and re-run the query against the appropriate rwhois server.<br>
# &nbsp;The parsing looks a bit ugly, with a long continued line inside<br>
#+ backticks.<br>
# &nbsp;But it only has to be done once, and will work as new servers are added.<br>
#@ &nbsp; ABS Guide author comment: it isn't all that ugly, and is, in fact,<br>
#@+ &nbsp;an instructive use of Regular Expressions.<br>
&nbsp; if grep -E &quot;^Comment: .*rwhois.[^ ]+&quot; &quot;$OUTFILE&quot;<br>
&nbsp; then<br>
&nbsp; &nbsp; RWHOIS=`grep -e &quot;^Comment:.*rwhois\.[^ ]\+&quot; &quot;$OUTFILE&quot; | tail -n 1 |\<br>
&nbsp; &nbsp; sed &quot;s/^\(.*\)\(rwhois\.[^ ]\+\)\(.*$\)/\2/&quot;`<br>
&nbsp; &nbsp; echo &quot;Searching for $IPADDR in ${RWHOIS}&quot;<br>
&nbsp; &nbsp; whois -h ${RWHOIS}:${PORT} &quot;$IPADDR&quot; &gt;&gt; $OUTFILE<br>
&nbsp; fi<br>
}<br>
LACNICquery() {<br>
&nbsp; echo &quot;Searching for $IPADDR in whois.lacnic.net&quot;<br>
&nbsp; whois -h whois.lacnic.net &quot;$IPADDR&quot; &gt; $OUTFILE<br>
# &nbsp;The &nbsp;following if statement checks $OUTFILE (whois.txt) for the presence of<br>
#+ &quot;BR&quot; (Brasil) in the country field.<br>
# &nbsp;If it is found, the query is re-run against whois.registro.br.<br>
Appendix A. Contributed Scripts<br>
658<br>
<hr>
<A name=665></a>Advanced Bash-Scripting Guide<br>
&nbsp; if grep -E &quot;^country:[ ]+BR$&quot; &quot;$OUTFILE&quot;<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Searching for $IPADDR in whois.registro.br&quot;<br>
&nbsp; &nbsp; whois -h whois.registro.br &quot;$IPADDR&quot; &gt;&gt; $OUTFILE<br>
&nbsp; fi<br>
}<br>
RIPEquery() {<br>
&nbsp; echo &quot;Searching for $IPADDR in whois.ripe.net&quot;<br>
&nbsp; whois -h whois.ripe.net &quot;$IPADDR&quot; &gt; $OUTFILE<br>
}<br>
# &nbsp;Initialize a few variables.<br>
# &nbsp;* slash8 is the most significant octet<br>
# &nbsp;* slash16 consists of the two most significant octets<br>
# &nbsp;* octet2 is the second most significant octet<br>
slash8=`echo $IPADDR | cut -d. -f 1`<br>
&nbsp; if [ -z &quot;$slash8&quot; ] &nbsp;# Yet another sanity check.<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Undefined error!&quot;<br>
&nbsp; &nbsp; exit $E_UNDEF<br>
&nbsp; fi<br>
slash16=`echo $IPADDR | cut -d. -f 1-2`<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ Period specified as 'cut&quot; delimiter.<br>
&nbsp; if [ -z &quot;$slash16&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Undefined error!&quot;<br>
&nbsp; &nbsp; exit $E_UNDEF<br>
&nbsp; fi<br>
octet2=`echo $slash16 | cut -d. -f 2`<br>
&nbsp; if [ -z &quot;$octet2&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Undefined error!&quot;<br>
&nbsp; &nbsp; exit $E_UNDEF<br>
&nbsp; fi<br>
# &nbsp;Check for various odds and ends of reserved space.<br>
# &nbsp;There is no point in querying for those addresses.<br>
if [ $slash8 == 0 ]; then<br>
&nbsp; echo $IPADDR is '&quot;This Network&quot;' space\; Not querying<br>
elif [ $slash8 == 10 ]; then<br>
&nbsp; echo $IPADDR is RFC1918 space\; Not querying<br>
elif [ $slash8 == 14 ]; then<br>
&nbsp; echo $IPADDR is '&quot;Public Data Network&quot;' space\; Not querying<br>
elif [ $slash8 == 127 ]; then<br>
&nbsp; echo $IPADDR is loopback space\; Not querying<br>
elif [ $slash16 == 169.254 ]; then<br>
&nbsp; echo $IPADDR is link-local space\; Not querying<br>
elif [ $slash8 == 172 ] &amp;&amp; [ $octet2 -ge 16 ] &amp;&amp; [ $octet2 -le 31 ];then<br>
&nbsp; echo $IPADDR is RFC1918 space\; Not querying<br>
elif [ $slash16 == 192.168 ]; then<br>
&nbsp; echo $IPADDR is RFC1918 space\; Not querying<br>
elif [ $slash8 -ge 224 ]; then<br>
&nbsp; echo $IPADDR is either Multicast or reserved space\; Not querying<br>
elif [ $slash8 -ge 200 ] &amp;&amp; [ $slash8 -le 201 ]; then LACNICquery &quot;$IPADDR&quot;<br>
elif [ $slash8 -ge 202 ] &amp;&amp; [ $slash8 -le 203 ]; then APNICquery &quot;$IPADDR&quot;<br>
Appendix A. Contributed Scripts<br>
659<br>
<hr>
<A name=666></a>Advanced Bash-Scripting Guide<br>
elif [ $slash8 -ge 210 ] &amp;&amp; [ $slash8 -le 211 ]; then APNICquery &quot;$IPADDR&quot;<br>
elif [ $slash8 -ge 218 ] &amp;&amp; [ $slash8 -le 223 ]; then APNICquery &quot;$IPADDR&quot;<br>
# &nbsp;If we got this far without making a decision, query ARIN.<br>
# &nbsp;If a reference is found in $OUTFILE to APNIC, AFRINIC, LACNIC, or RIPE,<br>
#+ query the appropriate whois server.<br>
else<br>
&nbsp; ARINquery &quot;$IPADDR&quot;<br>
&nbsp; if grep &quot;whois.afrinic.net&quot; &quot;$OUTFILE&quot;; then<br>
&nbsp; &nbsp; AFRINICquery &quot;$IPADDR&quot;<br>
&nbsp; elif grep -E &quot;^OrgID:[ ]+RIPE$&quot; &quot;$OUTFILE&quot;; then<br>
&nbsp; &nbsp; RIPEquery &quot;$IPADDR&quot;<br>
&nbsp; elif grep -E &quot;^OrgID:[ ]+APNIC$&quot; &quot;$OUTFILE&quot;; then<br>
&nbsp; &nbsp; APNICquery &quot;$IPADDR&quot;<br>
&nbsp; elif grep -E &quot;^OrgID:[ ]+LACNIC$&quot; &quot;$OUTFILE&quot;; then<br>
&nbsp; &nbsp; LACNICquery &quot;$IPADDR&quot;<br>
&nbsp; fi<br>
fi<br>
#@ &nbsp;---------------------------------------------------------------<br>
# &nbsp; Try also:<br>
# &nbsp; wget http://logi.cc/nw/whois.php3?ACTION=doQuery&amp;DOMAIN=$IPADDR<br>
#@ &nbsp;---------------------------------------------------------------<br>
# &nbsp;We've &nbsp;now &nbsp;finished &nbsp;the querying.<br>
# &nbsp;Echo a copy of the final result to the screen.<br>
cat $OUTFILE<br>
# Or &quot;less $OUTFILE&quot; . . .<br>
exit 0<br>
#@ &nbsp;ABS Guide author comments:<br>
#@ &nbsp;Nothing fancy here, but still a very useful tool for hunting spammers.<br>
#@ &nbsp;Sure, the script can be cleaned up some, and it's still a bit buggy,<br>
#@+ (exercise for reader), but all the same, it's a nice piece of coding<br>
#@+ by Walter Dnes.<br>
#@ &nbsp;Thank you!<br>
<a href="abs-guides.html#287">&quot;Little Monster's&quot; front end to wget.</a><br>
<b>Example A-30. Making<i>&nbsp;wget</i></b><b>&nbsp;easier to use</b><br>
#!/bin/bash<br>
# wgetter2.bash<br>
# Author: Little Monster [monster@monstruum.co.uk]<br>
# ==&gt; Used in ABS Guide with permission of script author.<br>
# ==&gt; This script still needs debugging and fixups (exercise for reader).<br>
# ==&gt; It could also use some additional editing in the comments.<br>
# &nbsp;This is wgetter2 --<br>
#+ a Bash script to make wget a bit more friendly, and save typing.<br>
# &nbsp;Carefully crafted by Little Monster.<br>
# &nbsp;More or less complete on 02/02/2005.<br>
# &nbsp;If you think this script can be improved,<br>
#+ email me at: monster@monstruum.co.uk<br>
Appendix A. Contributed Scripts<br>
660<br>
<hr>
<A name=667></a>Advanced Bash-Scripting Guide<br>
# ==&gt; and cc: to the author of the ABS Guide, please.<br>
# &nbsp;This script is licenced under the GPL.<br>
# &nbsp;You are free to copy, alter and re-use it,<br>
#+ but please don't try to claim you wrote it.<br>
# &nbsp;Log your changes here instead.<br>
# =======================================================================<br>
# changelog:<br>
# 07/02/2005. &nbsp;Fixups by Little Monster.<br>
# 02/02/2005. &nbsp;Minor additions by Little Monster.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(See after # +++++++++++ )<br>
# 29/01/2005. &nbsp;Minor stylistic edits and cleanups by author of ABS Guide.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Added exit error codes.<br>
# 22/11/2004. &nbsp;Finished initial version of second version of wgetter:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wgetter2 is born.<br>
# 01/12/2004. &nbsp;Changed 'runn' function so it can be run 2 ways --<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;either ask for a file name or have one input on the CL.<br>
# 01/12/2004. &nbsp;Made sensible handling of no URL's given.<br>
# 01/12/2004. &nbsp;Made loop of main options, so you don't<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;have to keep calling wgetter 2 all the time.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Runs as a session instead.<br>
# 01/12/2004. &nbsp;Added looping to 'runn' function.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Simplified and improved.<br>
# 01/12/2004. &nbsp;Added state to recursion setting.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enables re-use of previous value.<br>
# 05/12/2004. &nbsp;Modified the file detection routine in the 'runn' function<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;so it's not fooled by empty values, and is cleaner.<br>
# 01/02/2004. &nbsp;Added cookie finding routine from later version (which&nbsp;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isn't ready yet), so as not to have hard-coded paths.<br>
# =======================================================================<br>
# Error codes for abnormal exit.<br>
E_USAGE=67 &nbsp; &nbsp; &nbsp; &nbsp;# Usage message, then quit.<br>
E_NO_OPTS=68 &nbsp; &nbsp; &nbsp;# No command-line args entered.<br>
E_NO_URLS=69 &nbsp; &nbsp; &nbsp;# No URLs passed to script.<br>
E_NO_SAVEFILE=70 &nbsp;# No save filename passed to script.<br>
E_USER_EXIT=71 &nbsp; &nbsp;# User decides to quit.<br>
# &nbsp;Basic default wget command we want to use.<br>
# &nbsp;This is the place to change it, if required.<br>
# &nbsp;NB: if using a proxy, set http_proxy = yourproxy in .wgetrc.<br>
# &nbsp;Otherwise delete --proxy=on, below.<br>
# ====================================================================<br>
CommandA=&quot;wget -nc -c -t 5 --progress=bar --random-wait --proxy=on -r&quot;<br>
# ====================================================================<br>
# --------------------------------------------------------------------<br>
# Set some other variables and explain them.<br>
pattern=&quot; -A .jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.htm,.html,.shtml,.php&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # wget's option to only get certain types of file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # comment out if not using<br>
today=`date +%F` &nbsp; &nbsp;# Used for a filename.<br>
home=$HOME &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Set HOME to an internal variable.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # In case some other path is used, change it here.<br>
depthDefault=3 &nbsp; &nbsp; &nbsp;# Set a sensible default recursion.<br>
Depth=$depthDefault # Otherwise user feedback doesn't tie in properly.<br>
RefA=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set blank referring page.<br>
Appendix A. Contributed Scripts<br>
661<br>
<hr>
<A name=668></a>Advanced Bash-Scripting Guide<br>
Flag=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Default to not saving anything,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ or whatever else might be wanted in future.<br>
lister=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Used for passing a list of urls directly to wget.<br>
Woptions=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; # Used for passing wget some options for itself.<br>
inFile=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Used for the run function.<br>
newFile=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Used for the run function.<br>
savePath=&quot;$home/w-save&quot;<br>
Config=&quot;$home/.wgetter2rc&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This is where some variables can be stored,&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ if permanently changed from within the script.<br>
Cookie_List=&quot;$home/.cookielist&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # So we know where the cookies are kept . . .<br>
cFlag=&quot;&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Part of the cookie file selection routine.<br>
# Define the options available. Easy to change letters here if needed.<br>
# These are the optional options; you don't just wait to be asked.<br>
save=s &nbsp; # Save command instead of executing it.<br>
cook=c &nbsp; # Change cookie file for this session.<br>
help=h &nbsp; # Usage guide.<br>
list=l &nbsp; # Pass wget the -i option and URL list.<br>
runn=r &nbsp; # Run saved commands as an argument to the option.<br>
inpu=i &nbsp; # Run saved commands interactively.<br>
wopt=w &nbsp; # Allow to enter options to pass directly to wget.<br>
# --------------------------------------------------------------------<br>
if [ -z &quot;$1&quot; ]; then &nbsp; # Make sure we get something for wget to eat.<br>
&nbsp; &nbsp;echo &quot;You must at least enter a URL or option!&quot;<br>
&nbsp; &nbsp;echo &quot;-$help for usage.&quot;<br>
&nbsp; &nbsp;exit $E_NO_OPTS<br>
fi<br>
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>
# added added added added added added added added added added added added<br>
if [ ! -e &quot;$Config&quot; ]; then &nbsp; # See if configuration file exists.<br>
&nbsp; &nbsp;echo &quot;Creating configuration file, $Config&quot;<br>
&nbsp; &nbsp;echo &quot;# This is the configuration file for wgetter2&quot; &gt; &quot;$Config&quot;<br>
&nbsp; &nbsp;echo &quot;# Your customised settings will be saved in this file&quot; &gt;&gt; &quot;$Config&quot;<br>
else<br>
&nbsp; &nbsp;source $Config &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Import variables we set outside the script.<br>
fi<br>
if [ ! -e &quot;$Cookie_List&quot; ]; then<br>
&nbsp; &nbsp;# Set up a list of cookie files, if there isn't one.<br>
&nbsp; &nbsp;echo &quot;Hunting for cookies . . .&quot;<br>
&nbsp; &nbsp;find -name cookies.txt &gt;&gt; $Cookie_List # Create the list of cookie files.<br>
fi # &nbsp;Isolate this in its own 'if' statement,<br>
&nbsp; &nbsp;#+ in case we got interrupted while searching.<br>
if [ -z &quot;$cFlag&quot; ]; then # If we haven't already done this . . .<br>
&nbsp; &nbsp;echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Make a nice space after the command prompt.<br>
&nbsp; &nbsp;echo &quot;Looks like you haven't set up your source of cookies yet.&quot;<br>
&nbsp; &nbsp;n=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Make sure the counter<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ doesn't contain random values.<br>
&nbsp; &nbsp;while read; do<br>
&nbsp; &nbsp; &nbsp; Cookies[$n]=$REPLY # Put the cookie files we found into an array.<br>
&nbsp; &nbsp; &nbsp; echo &quot;$n) ${Cookies[$n]}&quot; &nbsp;# Create a menu.<br>
&nbsp; &nbsp; &nbsp; n=$(( n + 1 )) &nbsp; &nbsp; # Increment the counter.<br>
Appendix A. Contributed Scripts<br>
662<br>
<hr>
<A name=669></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;done &lt; $Cookie_List &nbsp; # Feed the read statement.<br>
&nbsp; &nbsp;echo &quot;Enter the number of the cookie file you want to use.&quot;<br>
&nbsp; &nbsp;echo &quot;If you won't be using cookies, just press RETURN.&quot;<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;echo &quot;I won't be asking this again. Edit $Config&quot;<br>
&nbsp; &nbsp;echo &quot;If you decide to change at a later date&quot;<br>
&nbsp; &nbsp;echo &quot;or use the -${cook} option for per session changes.&quot;<br>
&nbsp; &nbsp;read<br>
&nbsp; &nbsp;if [ ! -z $REPLY ]; then &nbsp; # User didn't just press return.<br>
&nbsp; &nbsp; &nbsp; Cookie=&quot; --load-cookies ${Cookies[$REPLY]}&quot;<br>
&nbsp; &nbsp; &nbsp; # Set the variable here as well as in the config file.<br>
&nbsp; &nbsp; &nbsp; echo &quot;Cookie=\&quot; --load-cookies ${Cookies[$REPLY]}\&quot;&quot; &gt;&gt; $Config<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;echo &quot;cFlag=1&quot; &gt;&gt; $Config &nbsp;# So we know not to ask again.<br>
fi<br>
# end added section end added section end added section end added section<br>
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>
# Another variable.<br>
# This one may or may not be subject to variation.<br>
# A bit like the small print.<br>
CookiesON=$Cookie<br>
# echo &quot;cookie file is $CookiesON&quot; # For debugging.<br>
# echo &quot;home is ${home}&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # For debugging.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Got caught with this one!<br>
wopts()<br>
{<br>
echo &quot;Enter options to pass to wget.&quot;<br>
echo &quot;It is assumed you know what you're doing.&quot;<br>
echo<br>
echo &quot;You can pass their arguments here too.&quot;<br>
# That is to say, everything passed here is passed to wget.<br>
read Wopts<br>
# Read in the options to be passed to wget.<br>
Woptions=&quot; $Wopts&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp;Why the leading space?<br>
# Assign to another variable.<br>
# Just for fun, or something . . .<br>
echo &quot;passing options ${Wopts} to wget&quot;<br>
# Mainly for debugging.<br>
# Is cute.<br>
return<br>
}<br>
save_func()<br>
{<br>
echo &quot;Settings will be saved.&quot;<br>
if [ ! -d $savePath ]; then &nbsp;# &nbsp;See if directory exists.<br>
&nbsp; &nbsp;mkdir $savePath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Create the directory to save things in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ if it isn't already there.<br>
fi<br>
Appendix A. Contributed Scripts<br>
663<br>
<hr>
<A name=670></a>Advanced Bash-Scripting Guide<br>
Flag=S<br>
# Tell the final bit of code what to do.<br>
# Set a flag since stuff is done in main.<br>
return<br>
}<br>
usage() # Tell them how it works.<br>
{<br>
&nbsp; &nbsp; echo &quot;Welcome to wgetter. &nbsp;This is a front end to wget.&quot;<br>
&nbsp; &nbsp; echo &quot;It will always run wget with these options:&quot;<br>
&nbsp; &nbsp; echo &quot;$CommandA&quot;<br>
&nbsp; &nbsp; echo &quot;and the pattern to match: $pattern \<br>
(which you can change at the top of this script).&quot;<br>
&nbsp; &nbsp; echo &quot;It will also ask you for recursion depth, \<br>
and if you want to use a referring page.&quot;<br>
&nbsp; &nbsp; echo &quot;Wgetter accepts the following options:&quot;<br>
&nbsp; &nbsp; echo &quot;&quot;<br>
&nbsp; &nbsp; echo &quot;-$help : Display this help.&quot;<br>
&nbsp; &nbsp; echo &quot;-$save : Save the command to a file $savePath/wget-($today) \<br>
instead of running it.&quot;<br>
&nbsp; &nbsp; echo &quot;-$runn : Run saved wget commands instead of starting a new one -&quot;<br>
&nbsp; &nbsp; echo &quot;Enter filename as argument to this option.&quot;<br>
&nbsp; &nbsp; echo &quot;-$inpu : Run saved wget commands interactively --&quot;<br>
&nbsp; &nbsp; echo &quot;The script will ask you for the filename.&quot;<br>
&nbsp; &nbsp; echo &quot;-$cook : Change the cookies file for this session.&quot;<br>
&nbsp; &nbsp; echo &quot;-$list : Tell wget to use URL's from a list instead of \<br>
from the command-line.&quot;<br>
&nbsp; &nbsp; echo &quot;-$wopt : Pass any other options direct to wget.&quot;<br>
&nbsp; &nbsp; echo &quot;&quot;<br>
&nbsp; &nbsp; echo &quot;See the wget man page for additional options \<br>
you can pass to wget.&quot;<br>
&nbsp; &nbsp; echo &quot;&quot;<br>
&nbsp; &nbsp; exit $E_USAGE &nbsp;# End here. Don't process anything else.<br>
}<br>
list_func() # &nbsp;Gives the user the option to use the -i option to wget,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and a list of URLs.<br>
{<br>
while [ 1 ]; do<br>
&nbsp; &nbsp;echo &quot;Enter the name of the file containing URL's (press q to change<br>
your mind).&quot;<br>
&nbsp; &nbsp;read urlfile<br>
&nbsp; &nbsp;if [ ! -e &quot;$urlfile&quot; ] &amp;&amp; [ &quot;$urlfile&quot; != q ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Look for a file, or the quit option.<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;That file does not exist!&quot;<br>
&nbsp; &nbsp;elif [ &quot;$urlfile&quot; = q ]; then # Check quit option.<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Not using a url list.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;return<br>
&nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; echo &quot;using $urlfile.&quot;<br>
&nbsp; &nbsp; &nbsp; echo &quot;If you gave url's on the command-line, I'll use those first.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Report wget standard behaviour to the user.<br>
&nbsp; &nbsp; &nbsp; lister=&quot; -i $urlfile&quot; # This is what we want to pass to wget.<br>
&nbsp; &nbsp; &nbsp; return<br>
&nbsp; &nbsp;fi<br>
done<br>
Appendix A. Contributed Scripts<br>
664<br>
<hr>
<A name=671></a>Advanced Bash-Scripting Guide<br>
}<br>
cookie_func() # Give the user the option to use a different cookie file.<br>
{<br>
while [ 1 ]; do<br>
&nbsp; &nbsp;echo &quot;Change the cookies file. Press return if you don't want to change&nbsp;<br>
it.&quot;<br>
&nbsp; &nbsp;read Cookies<br>
&nbsp; &nbsp;# NB: this is not the same as Cookie, earlier.<br>
&nbsp; &nbsp;# There is an 's' on the end.<br>
&nbsp; &nbsp;# Bit like chocolate chips.<br>
&nbsp; &nbsp;if [ -z &quot;$Cookies&quot; ]; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Escape clause for wusses.<br>
&nbsp; &nbsp; &nbsp; return<br>
&nbsp; &nbsp;elif [ ! -e &quot;$Cookies&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;File does not exist. &nbsp;Try again.&quot; # Keep em going . . .<br>
&nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp;CookiesON=&quot; --load-cookies $Cookies&quot; &nbsp; # File is good -- use it!<br>
&nbsp; &nbsp; &nbsp; &nbsp;return<br>
&nbsp; &nbsp;fi<br>
done<br>
}<br>
run_func()<br>
{<br>
if [ -z &quot;$OPTARG&quot; ]; then<br>
# Test to see if we used the in-line option or the query one.<br>
&nbsp; &nbsp;if [ ! -d &quot;$savePath&quot; ]; then &nbsp; &nbsp; &nbsp;# If directory doesn't exist . . .<br>
&nbsp; &nbsp; &nbsp; echo &quot;$savePath does not appear to exist.&quot;<br>
&nbsp; &nbsp; &nbsp; echo &quot;Please supply path and filename of saved wget commands:&quot;<br>
&nbsp; &nbsp; &nbsp; read newFile<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;until [ -f &quot;$newFile&quot; ]; do &nbsp;# Keep going till we get something.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Sorry, that file does not exist. &nbsp;Please try again.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Try really hard to get something.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read newFile<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done<br>
# -----------------------------------------------------------------------<br>
# &nbsp; &nbsp; &nbsp; if [ -z ( grep wget ${newfile} ) ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Assume they haven't got the right file and bail out.<br>
# &nbsp; &nbsp; &nbsp; echo &quot;Sorry, that file does not contain wget commands. &nbsp;Aborting.&quot;<br>
# &nbsp; &nbsp; &nbsp; exit<br>
# &nbsp; &nbsp; &nbsp; fi<br>
#<br>
# This is bogus code.<br>
# It doesn't actually work.<br>
# If anyone wants to fix it, feel free!<br>
# -----------------------------------------------------------------------<br>
&nbsp; &nbsp; &nbsp; filePath=&quot;${newFile}&quot;<br>
&nbsp; &nbsp;else<br>
&nbsp; &nbsp;echo &quot;Save path is $savePath&quot;<br>
&nbsp; &nbsp; &nbsp;echo &quot;Please enter name of the file which you want to use.&quot;<br>
&nbsp; &nbsp; &nbsp;echo &quot;You have a choice of:&quot;<br>
&nbsp; &nbsp; &nbsp;ls $savePath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Give them a choice.<br>
&nbsp; &nbsp; &nbsp;read inFile<br>
&nbsp; &nbsp; &nbsp; &nbsp;until [ -f &quot;$savePath/$inFile&quot; ]; do &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Keep going till<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ we get something.<br>
Appendix A. Contributed Scripts<br>
665<br>
<hr>
<A name=672></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ ! -f &quot;${savePath}/${inFile}&quot; ]; then # If file doesn't exist.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Sorry, that file does not exist. &nbsp;Please choose from:&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ls $savePath &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If a mistake is made.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;read inFile<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp; &nbsp; filePath=&quot;${savePath}/${inFile}&quot; &nbsp;# Make one variable . . .<br>
&nbsp; &nbsp;fi<br>
else filePath=&quot;${savePath}/${OPTARG}&quot; &nbsp; # Which can be many things . . .<br>
fi<br>
if [ ! -f &quot;$filePath&quot; ]; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If a bogus file got through.<br>
&nbsp; &nbsp;echo &quot;You did not specify a suitable file.&quot;<br>
&nbsp; &nbsp;echo &quot;Run this script with the -${save} option first.&quot;<br>
&nbsp; &nbsp;echo &quot;Aborting.&quot;<br>
&nbsp; &nbsp;exit $E_NO_SAVEFILE<br>
fi<br>
echo &quot;Using: $filePath&quot;<br>
while read; do<br>
&nbsp; &nbsp; eval $REPLY<br>
&nbsp; &nbsp; echo &quot;Completed: $REPLY&quot;<br>
done &lt; $filePath &nbsp;# Feed the actual file we are using into a 'while' loop.<br>
exit<br>
}<br>
# Fish out any options we are using for the script.<br>
# This is based on the demo in &quot;Learning The Bash Shell&quot; (O'Reilly).<br>
while getopts &quot;:$save$cook$help$list$runn:$inpu$wopt&quot; opt<br>
do<br>
&nbsp; case $opt in<br>
&nbsp; &nbsp; &nbsp;$save) save_func;; &nbsp; # &nbsp;Save some wgetter sessions for later.<br>
&nbsp; &nbsp; &nbsp;$cook) cookie_func;; # &nbsp;Change cookie file.<br>
&nbsp; &nbsp; &nbsp;$help) usage;; &nbsp; &nbsp; &nbsp; # &nbsp;Get help.<br>
&nbsp; &nbsp; &nbsp;$list) list_func;; &nbsp; # &nbsp;Allow wget to use a list of URLs.<br>
&nbsp; &nbsp; &nbsp;$runn) run_func;; &nbsp; &nbsp;# &nbsp;Useful if you are calling wgetter from,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ for example, a cron script.<br>
&nbsp; &nbsp; &nbsp;$inpu) run_func;; &nbsp; &nbsp;# &nbsp;When you don't know what your files are named.<br>
&nbsp; &nbsp; &nbsp;$wopt) wopts;; &nbsp; &nbsp; &nbsp; # &nbsp;Pass options directly to wget.<br>
&nbsp; &nbsp; &nbsp; &nbsp; \?) echo &quot;Not a valid option.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Use -${wopt} to pass options directly to wget,&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;or -${help} for help&quot;;; &nbsp; &nbsp; &nbsp;# Catch anything else.<br>
&nbsp; esac<br>
done<br>
shift $((OPTIND - 1)) &nbsp; &nbsp; # Do funky magic stuff with $#.<br>
if [ -z &quot;$1&quot; ] &amp;&amp; [ -z &quot;$lister&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;We should be left with at least one URL<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ on the command-line, unless a list is&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ being used -- catch empty CL's.<br>
&nbsp; &nbsp;echo &quot;No URL's given! You must enter them on the same line as wgetter2.&quot;<br>
&nbsp; &nbsp;echo &quot;E.g., &nbsp;wgetter2 http://somesite http://anothersite.&quot;<br>
&nbsp; &nbsp;echo &quot;Use $help option for more information.&quot;<br>
&nbsp; &nbsp;exit $E_NO_URLS &nbsp; &nbsp; &nbsp; &nbsp;# Bail out, with appropriate error code.<br>
fi<br>
URLS=&quot; $@&quot;<br>
# Use this so that URL list can be changed if we stay in the option loop.<br>
Appendix A. Contributed Scripts<br>
666<br>
<hr>
<A name=673></a>Advanced Bash-Scripting Guide<br>
while [ 1 ]; do<br>
&nbsp; &nbsp;# This is where we ask for the most used options.<br>
&nbsp; &nbsp;# (Mostly unchanged from version 1 of wgetter)<br>
&nbsp; &nbsp;if [ -z $curDepth ]; then<br>
&nbsp; &nbsp; &nbsp; Current=&quot;&quot;<br>
&nbsp; &nbsp;else Current=&quot; Current value is $curDepth&quot;<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;How deep should I go? \<br>
(integer: Default is $depthDefault.$Current)&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;read Depth &nbsp; # Recursion -- how far should we go?<br>
&nbsp; &nbsp; &nbsp; &nbsp;inputB=&quot;&quot; &nbsp; &nbsp;# Reset this to blank on each pass of the loop.<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Enter the name of the referring page (default is none).&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;read inputB &nbsp;# Need this for some sites.<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Do you want to have the output logged to the terminal&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;(y/n, default is yes)?&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;read noHide &nbsp;# Otherwise wget will just log it to a file.<br>
&nbsp; &nbsp; &nbsp; &nbsp;case $noHide in &nbsp; &nbsp;# Now you see me, now you don't.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y|Y ) hide=&quot;&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n|N ) hide=&quot; -b&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * ) hide=&quot;&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; &nbsp; &nbsp;if [ -z ${Depth} ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;User accepted either default or current depth,<br>
&nbsp; &nbsp; &nbsp; &nbsp;#+ in which case Depth is now empty.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if [ -z ${curDepth} ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;See if a depth was set on a previous iteration.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Depth=&quot;$depthDefault&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Set the default recursion depth if nothing<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ else to use.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else Depth=&quot;$curDepth&quot; # &nbsp;Otherwise, set the one we used before.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp;Recurse=&quot; -l $Depth&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Set how deep we want to go.<br>
&nbsp; &nbsp;curDepth=$Depth &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Remember setting for next time.<br>
&nbsp; &nbsp; &nbsp; &nbsp;if [ ! -z $inputB ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RefA=&quot; --referer=$inputB&quot; &nbsp; # Option to use referring page.<br>
&nbsp; &nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp;WGETTER=&quot;${CommandA}${pattern}${hide}${RefA}${Recurse}\<br>
${CookiesON}${lister}${Woptions}${URLS}&quot;<br>
&nbsp; &nbsp;# &nbsp;Just string the whole lot together . . .<br>
&nbsp; &nbsp;# &nbsp;NB: no embedded spaces.<br>
&nbsp; &nbsp;# &nbsp;They are in the individual elements so that if any are empty,<br>
&nbsp; &nbsp;#+ we don't get an extra space.<br>
&nbsp; &nbsp;if [ -z &quot;${CookiesON}&quot; ] &amp;&amp; [ &quot;$cFlag&quot; = &quot;1&quot; ] ; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Warning -- can't find cookie file&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This should be changed,<br>
&nbsp; &nbsp; &nbsp; &nbsp;#+ in case the user has opted to not use cookies.<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp;if [ &quot;$Flag&quot; = &quot;S&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;$WGETTER&quot; &gt;&gt; $savePath/wget-${today}<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Create a unique filename for today, or append to it if it exists.<br>
&nbsp; &nbsp; &nbsp; echo &quot;$inputB&quot; &gt;&gt; $savePath/site-list-${today}<br>
&nbsp; &nbsp; &nbsp; # &nbsp;Make a list, so it's easy to refer back to,<br>
&nbsp; &nbsp; &nbsp; #+ since the whole command is a bit confusing to look at.<br>
&nbsp; &nbsp; &nbsp; echo &quot;Command saved to the file $savePath/wget-${today}&quot;<br>
Appendix A. Contributed Scripts<br>
667<br>
<hr>
<A name=674></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Tell the user.<br>
&nbsp; &nbsp; &nbsp; echo &quot;Referring page URL saved to the file$ \<br>
savePath/site-list-${today}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Tell the user.<br>
&nbsp; &nbsp; &nbsp; Saver=&quot; with save option&quot;<br>
&nbsp; &nbsp; &nbsp; # Stick this somewhere, so it appears in the loop if set.<br>
&nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;*****************&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;*****Getting*****&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;*****************&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$WGETTER&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;*****************&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;eval &quot;$WGETTER&quot;<br>
&nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Starting over$Saver.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;If you want to stop, press q.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Otherwise, enter some URL's:&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Let them go again. Tell about save option being set.<br>
&nbsp; &nbsp; &nbsp; &nbsp;read<br>
&nbsp; &nbsp; &nbsp; &nbsp;case $REPLY in<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Need to change this to a 'trap' clause.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q|Q ) exit $E_USER_EXIT;; &nbsp;# Exercise for the reader?<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * ) URLS=&quot; $REPLY&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;&quot;<br>
done<br>
exit 0<br>
<b>Example A-31. A<i>&nbsp;podcasting</i></b><b>&nbsp;script</b><br>
#!/bin/bash<br>
# &nbsp;bashpodder.sh:<br>
# &nbsp;By Linc 10/1/2004<br>
# &nbsp;Find the latest script at<br>
#+ http://linc.homeunix.org:8080/scripts/bashpodder<br>
# &nbsp;Last revision 12/14/2004 - Many Contributors!<br>
# &nbsp;If you use this and have made improvements or have comments<br>
#+ drop me an email at linc dot fessenden at gmail dot com<br>
# &nbsp;I'd appreciate it!<br>
# ==&gt; &nbsp;ABS Guide extra comments.<br>
# ==&gt; &nbsp;Author of this script has kindly granted permission<br>
# ==&gt;+ for inclusion in ABS Guide.<br>
# ==&gt; ################################################################<br>
#&nbsp;<br>
# ==&gt; What is &quot;podcasting&quot;?<br>
# ==&gt; It's broadcasting &quot;radio shows&quot; over the Internet.<br>
# ==&gt; These shows can be played on iPods and other music file players.<br>
Appendix A. Contributed Scripts<br>
668<br>
<hr>
<A name=675></a>Advanced Bash-Scripting Guide<br>
# ==&gt; This script makes it possible.<br>
# ==&gt; See documentation at the script author's site, above.<br>
# ==&gt; ################################################################<br>
# Make script crontab friendly:<br>
cd $(dirname $0)<br>
# ==&gt; Change to directory where this script lives.<br>
# datadir is the directory you want podcasts saved to:<br>
datadir=$(date +%Y-%m-%d)<br>
# ==&gt; Will create a date-labeled directory, named: YYYY-MM-DD<br>
# Check for and create datadir if necessary:<br>
if test ! -d $datadir<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; mkdir $datadir<br>
fi<br>
# Delete any temp file:<br>
rm -f temp.log<br>
# &nbsp;Read the bp.conf file and wget any url not already<br>
#+ in the podcast.log file:<br>
while read podcast<br>
&nbsp; do # ==&gt; Main action follows.<br>
&nbsp; file=$(wget -q $podcast -O - | tr '\r' '\n' | tr \' \&quot; | \<br>
sed -n 's/.*url=&quot;\([^&quot;]*\)&quot;.*/\1/p')<br>
&nbsp; for url in $file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $url &gt;&gt; temp.log<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ! grep &quot;$url&quot; podcast.log &gt; /dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wget -q -P $datadir &quot;$url&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; done &lt; bp.conf<br>
# Move dynamically created log file to permanent log file:<br>
cat podcast.log &gt;&gt; temp.log<br>
sort temp.log | uniq &gt; podcast.log<br>
rm temp.log<br>
# Create an m3u playlist:<br>
ls $datadir | grep -v m3u &gt; $datadir/podcast.m3u<br>
exit 0<br>
#################################################<br>
For a different scripting approach to Podcasting,<br>
see Phil Salkie's article,&nbsp;<br>
&quot;Internet Radio to Podcast with Shell Tools&quot;<br>
in the September, 2005 issue of LINUX JOURNAL,<br>
http://www.linuxjournal.com/article/8171<br>
#################################################<br>
<b>Example A-32. Nightly backup to a firewire HD</b><br>
#!/bin/bash<br>
Appendix A. Contributed Scripts<br>
669<br>
<hr>
<A name=676></a>Advanced Bash-Scripting Guide<br>
# nightly-backup.sh<br>
# http://www.richardneill.org/source.php#nightly-backup-rsync<br>
# Copyright (c) 2005 Richard Neill &lt;backup@richardneill.org&gt;.<br>
# This is Free Software licensed under the GNU GPL.<br>
# ==&gt; Included in ABS Guide with script author's kind permission.<br>
# ==&gt; (Thanks!)<br>
# &nbsp;This does a backup from the host computer to a locally connected<br>
#+ firewire HDD using rsync and ssh.<br>
# &nbsp;(Script should work with USB-connected device (see lines 40-43).<br>
# &nbsp;It then rotates the backups.<br>
# &nbsp;Run it via cron every night at 5am.<br>
# &nbsp;This only backs up the home directory.<br>
# &nbsp;If ownerships (other than the user's) should be preserved,<br>
#+ then run the rsync process as root (and re-instate the -o).<br>
# &nbsp;We save every day for 7 days, then every week for 4 weeks,<br>
#+ then every month for 3 months.<br>
# &nbsp;See: http://www.mikerubel.org/computers/rsync_snapshots/<br>
#+ for more explanation of the theory.<br>
# &nbsp;Save as: $HOME/bin/nightly-backup_firewire-hdd.sh<br>
# &nbsp;Known bugs:<br>
# &nbsp;----------<br>
# &nbsp;i) &nbsp;Ideally, we want to exclude ~/.tmp and the browser caches.<br>
# &nbsp;ii) If the user is sitting at the computer at 5am,<br>
#+ &nbsp; &nbsp; and files are modified while the rsync is occurring,<br>
#+ &nbsp; &nbsp; then the BACKUP_JUSTINCASE branch gets triggered.<br>
# &nbsp; &nbsp; &nbsp;To some extent, this is a&nbsp;<br>
#+ &nbsp; &nbsp; feature, but it also causes a &quot;disk-space leak&quot;.<br>
##### BEGIN CONFIGURATION SECTION ############################################<br>
LOCAL_USER=rjn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# User whose home directory should be backed up.<br>
MOUNT_POINT=/backup &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Mountpoint of backup drive.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NO trailing slash!<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This must be unique (eg using a udev symlink)<br>
# MOUNT_POINT=/media/disk &nbsp; &nbsp; # For USB-connected device.<br>
SOURCE_DIR=/home/$LOCAL_USER &nbsp;# NO trailing slash - it DOES matter to rsync.<br>
BACKUP_DEST_DIR=$MOUNT_POINT/backup/`hostname -s`.${LOCAL_USER}.nightly_backup<br>
DRY_RUN=false &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #If true, invoke rsync with -n, to do a dry run.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Comment out or set to false for normal use.<br>
VERBOSE=false &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If true, make rsync verbose.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Comment out or set to false otherwise.<br>
COMPRESS=false &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If true, compress.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Good for internet, bad on LAN.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Comment out or set to false otherwise.<br>
### Exit Codes ###<br>
E_VARS_NOT_SET=64<br>
E_COMMANDLINE=65<br>
E_MOUNT_FAIL=70<br>
E_NOSOURCEDIR=71<br>
E_UNMOUNTED=72<br>
E_BACKUP=73<br>
##### END CONFIGURATION SECTION ##############################################<br>
Appendix A. Contributed Scripts<br>
670<br>
<hr>
<A name=677></a>Advanced Bash-Scripting Guide<br>
# Check that all the important variables have been set:<br>
if [ -z &quot;$LOCAL_USER&quot; ] ||<br>
&nbsp; &nbsp;[ -z &quot;$SOURCE_DIR&quot; ] ||<br>
&nbsp; &nbsp;[ -z &quot;$MOUNT_POINT&quot; ] &nbsp;||<br>
&nbsp; &nbsp;[ -z &quot;$BACKUP_DEST_DIR&quot; ]<br>
then<br>
&nbsp; &nbsp;echo 'One of the variables is not set! Edit the file: $0. BACKUP FAILED.'<br>
&nbsp; &nbsp;exit $E_VARS_NOT_SET<br>
fi<br>
if [ &quot;$#&quot; != 0 ] &nbsp;# If command-line param(s) . . .<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Here document(ation).<br>
&nbsp; cat &lt;&lt;-ENDOFTEXT<br>
&nbsp; &nbsp; Automatic Nightly backup run from cron.<br>
&nbsp; &nbsp; Read the source for more details: $0<br>
&nbsp; &nbsp; The backup directory is $BACKUP_DEST_DIR .<br>
&nbsp; &nbsp; It will be created if necessary; initialisation is no longer required.<br>
&nbsp; &nbsp; WARNING: Contents of $BACKUP_DEST_DIR are rotated.<br>
&nbsp; &nbsp; Directories named 'backup.\$i' will eventually be DELETED.<br>
&nbsp; &nbsp; We keep backups from every day for 7 days (1-8),<br>
&nbsp; &nbsp; then every week for 4 weeks (9-12),<br>
&nbsp; &nbsp; then every month for 3 months (13-15).<br>
&nbsp; &nbsp; You may wish to add this to your crontab using 'crontab -e'<br>
&nbsp; &nbsp; # &nbsp;Back up files: $SOURCE_DIR to $BACKUP_DEST_DIR<br>
&nbsp; &nbsp; #+ every night at 3:15 am<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;15 03 * * * /home/$LOCAL_USER/bin/nightly-backup_firewire-hdd.sh<br>
&nbsp; &nbsp; Don't forget to verify the backups are working,<br>
&nbsp; &nbsp; especially if you don't read cron's mail!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ENDOFTEXT<br>
&nbsp; &nbsp;exit $E_COMMANDLINE<br>
fi<br>
# Parse the options.<br>
# ==================<br>
if [ &quot;$DRY_RUN&quot; == &quot;true&quot; ]; then<br>
&nbsp; DRY_RUN=&quot;-n&quot;<br>
&nbsp; echo &quot;WARNING:&quot;<br>
&nbsp; echo &quot;THIS IS A 'DRY RUN'!&quot;<br>
&nbsp; echo &quot;No data will actually be transferred!&quot;<br>
else<br>
&nbsp; DRY_RUN=&quot;&quot;<br>
fi<br>
if [ &quot;$VERBOSE&quot; == &quot;true&quot; ]; then<br>
&nbsp; VERBOSE=&quot;-v&quot;<br>
else<br>
&nbsp; VERBOSE=&quot;&quot;<br>
fi<br>
if [ &quot;$COMPRESS&quot; == &quot;true&quot; ]; then<br>
&nbsp; COMPRESS=&quot;-z&quot;<br>
else<br>
&nbsp; COMPRESS=&quot;&quot;<br>
fi<br>
# &nbsp;Every week (actually of 8 days) and every month,<br>
Appendix A. Contributed Scripts<br>
671<br>
<hr>
<A name=678></a>Advanced Bash-Scripting Guide<br>
#+ extra backups are preserved.<br>
DAY_OF_MONTH=`date +%d` &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Day of month (01..31).<br>
if [ $DAY_OF_MONTH = 01 ]; then &nbsp; &nbsp;# First of month.<br>
&nbsp; MONTHSTART=true<br>
elif [ $DAY_OF_MONTH = 08 \<br>
&nbsp; &nbsp; -o $DAY_OF_MONTH = 16 \<br>
&nbsp; &nbsp; -o $DAY_OF_MONTH = 24 ]; then<br>
&nbsp; &nbsp; # Day 8,16,24 &nbsp;(use 8, not 7 to better handle 31-day months)<br>
&nbsp; &nbsp; &nbsp; WEEKSTART=true<br>
fi<br>
# &nbsp;Check that the HDD is mounted.<br>
# &nbsp;At least, check that *something* is mounted here!<br>
# &nbsp;We can use something unique to the device, rather than just guessing<br>
#+ the scsi-id by having an appropriate udev rule in<br>
#+ /etc/udev/rules.d/10-rules.local<br>
#+ and by putting a relevant entry in /etc/fstab.<br>
# &nbsp;Eg: this udev rule:<br>
# BUS=&quot;scsi&quot;, KERNEL=&quot;sd*&quot;, SYSFS{vendor}=&quot;WDC WD16&quot;,<br>
# SYSFS{model}=&quot;00JB-00GVA0 &nbsp; &nbsp; &quot;, NAME=&quot;%k&quot;, SYMLINK=&quot;lacie_1394d%n&quot;<br>
if mount | grep $MOUNT_POINT &gt;/dev/null; then<br>
&nbsp; echo &quot;Mount point $MOUNT_POINT is indeed mounted. OK&quot;<br>
else<br>
&nbsp; echo -n &quot;Attempting to mount $MOUNT_POINT...&quot;&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# If it isn't mounted, try to mount it.<br>
&nbsp; sudo mount $MOUNT_POINT 2&gt;/dev/null<br>
&nbsp; if mount | grep $MOUNT_POINT &gt;/dev/null; then<br>
&nbsp; &nbsp; UNMOUNT_LATER=TRUE<br>
&nbsp; &nbsp; echo &quot;OK&quot;<br>
&nbsp; &nbsp; # &nbsp;Note: Ensure that this is also unmounted<br>
&nbsp; &nbsp; #+ if we exit prematurely with failure.<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;FAILED&quot;<br>
&nbsp; &nbsp; echo -e &quot;Nothing is mounted at $MOUNT_POINT. BACKUP FAILED!&quot;<br>
&nbsp; &nbsp; exit $E_MOUNT_FAIL<br>
&nbsp; fi<br>
fi<br>
# Check that source dir exists and is readable.<br>
if [ ! -r &nbsp;$SOURCE_DIR ] ; then<br>
&nbsp; echo &quot;$SOURCE_DIR does not exist, or cannot be read. BACKUP FAILED.&quot;<br>
&nbsp; exit $E_NOSOURCEDIR<br>
fi<br>
# Check that the backup directory structure is as it should be.<br>
# If not, create it.<br>
# Create the subdirectories.<br>
# Note that backup.0 will be created as needed by rsync.<br>
for ((i=1;i&lt;=15;i++)); do<br>
&nbsp; if [ ! -d $BACKUP_DEST_DIR/backup.$i ]; then<br>
&nbsp; &nbsp; if /bin/mkdir -p $BACKUP_DEST_DIR/backup.$i ; then<br>
&nbsp; &nbsp; # &nbsp;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &nbsp;No [ ] test brackets. Why?<br>
&nbsp; &nbsp; &nbsp; echo &quot;Warning: directory $BACKUP_DEST_DIR/backup.$i is missing,&quot;<br>
&nbsp; &nbsp; &nbsp; echo &quot;or was not initialised. (Re-)creating it.&quot;<br>
&nbsp; &nbsp; else<br>
Appendix A. Contributed Scripts<br>
672<br>
<hr>
<A name=679></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; echo &quot;ERROR: directory $BACKUP_DEST_DIR/backup.$i&quot;<br>
&nbsp; &nbsp; &nbsp; echo &quot;is missing and could not be created.&quot;<br>
&nbsp; &nbsp; if &nbsp;[ &quot;$UNMOUNT_LATER&quot; == &quot;TRUE&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Before we exit, unmount the mount point if necessary.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd<br>
&nbsp; &nbsp; &nbsp; &nbsp; sudo umount $MOUNT_POINT &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Unmounted $MOUNT_POINT again. Giving up.&quot;<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; exit $E_UNMOUNTED<br>
&nbsp; fi<br>
fi<br>
done<br>
# &nbsp;Set the permission to 700 for security<br>
#+ on an otherwise permissive multi-user system.<br>
if ! /bin/chmod 700 $BACKUP_DEST_DIR ; then<br>
&nbsp; echo &quot;ERROR: Could not set permissions on $BACKUP_DEST_DIR to 700.&quot;<br>
&nbsp; if &nbsp;[ &quot;$UNMOUNT_LATER&quot; == &quot;TRUE&quot; ]; then<br>
&nbsp; # Before we exit, unmount the mount point if necessary.<br>
&nbsp; &nbsp; &nbsp;cd ; sudo umount $MOUNT_POINT \<br>
&nbsp; &nbsp; &nbsp;&amp;&amp; echo &quot;Unmounted $MOUNT_POINT again. Giving up.&quot;<br>
&nbsp; fi<br>
&nbsp; exit $E_UNMOUNTED<br>
fi<br>
# Create the symlink: current -&gt; backup.1 if required.<br>
# A failure here is not critical.<br>
cd $BACKUP_DEST_DIR<br>
if [ ! -h current ] ; then<br>
&nbsp; if ! /bin/ln -s backup.1 current ; then<br>
&nbsp; &nbsp; echo &quot;WARNING: could not create symlink current -&gt; backup.1&quot;<br>
&nbsp; fi<br>
fi<br>
# Now, do the rsync.<br>
echo &quot;Now doing backup with rsync...&quot;<br>
echo &quot;Source dir: $SOURCE_DIR&quot;<br>
echo -e &quot;Backup destination dir: $BACKUP_DEST_DIR\n&quot;<br>
/usr/bin/rsync $DRY_RUN $VERBOSE -a -S --delete --modify-window=60 \<br>
--link-dest=../backup.1 $SOURCE_DIR $BACKUP_DEST_DIR/backup.0/<br>
# &nbsp;Only warn, rather than exit if the rsync failed,<br>
#+ since it may only be a minor problem.<br>
# &nbsp;E.g., if one file is not readable, rsync will fail.<br>
# &nbsp;This shouldn't prevent the rotation.<br>
# &nbsp;Not using, e.g., `date +%a` &nbsp;since these directories<br>
#+ are just full of links and don't consume *that much* space.<br>
if [ $? != 0 ]; then<br>
&nbsp; BACKUP_JUSTINCASE=backup.`date +%F_%T`.justincase<br>
&nbsp; echo &quot;WARNING: the rsync process did not entirely succeed.&quot;<br>
&nbsp; echo &quot;Something might be wrong.&quot;<br>
&nbsp; echo &quot;Saving an extra copy at: $BACKUP_JUSTINCASE&quot;<br>
&nbsp; echo &quot;WARNING: if this occurs regularly, a LOT of space will be consumed,&quot;<br>
&nbsp; echo &quot;even though these are just hard-links!&quot;<br>
fi<br>
Appendix A. Contributed Scripts<br>
673<br>
<hr>
<A name=680></a>Advanced Bash-Scripting Guide<br>
# Save a readme in the backup parent directory.<br>
# Save another one in the recent subdirectory.<br>
echo &quot;Backup of $SOURCE_DIR on `hostname` was last run on \<br>
`date`&quot; &gt; $BACKUP_DEST_DIR/README.txt<br>
echo &quot;This backup of $SOURCE_DIR on `hostname` was created on \<br>
`date`&quot; &gt; $BACKUP_DEST_DIR/backup.0/README.txt<br>
# If we are not in a dry run, rotate the backups.<br>
[ -z &quot;$DRY_RUN&quot; ] &amp;&amp;<br>
&nbsp; # &nbsp;Check how full the backup disk is.<br>
&nbsp; # &nbsp;Warn if 90%. if 98% or more, we'll probably fail, so give up.<br>
&nbsp; # &nbsp;(Note: df can output to more than one line.)<br>
&nbsp; # &nbsp;We test this here, rather than before<br>
&nbsp; #+ so that rsync may possibly have a chance.<br>
&nbsp; DISK_FULL_PERCENT=`/bin/df $BACKUP_DEST_DIR |<br>
&nbsp; tr &quot;\n&quot; ' ' | awk '{print $12}' | grep -oE [0-9]+ `<br>
&nbsp; echo &quot;Disk space check on backup partition \<br>
&nbsp; $MOUNT_POINT $DISK_FULL_PERCENT% full.&quot;<br>
&nbsp; if [ $DISK_FULL_PERCENT -gt 90 ]; then<br>
&nbsp; &nbsp; echo &quot;Warning: Disk is greater than 90% full.&quot;<br>
&nbsp; fi<br>
&nbsp; if [ $DISK_FULL_PERCENT -gt 98 ]; then<br>
&nbsp; &nbsp; echo &quot;Error: Disk is full! Giving up.&quot;<br>
&nbsp; &nbsp; &nbsp; if &nbsp;[ &quot;$UNMOUNT_LATER&quot; == &quot;TRUE&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Before we exit, unmount the mount point if necessary.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd; sudo umount $MOUNT_POINT &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Unmounted $MOUNT_POINT again. Giving up.&quot;<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; exit $E_UNMOUNTED<br>
&nbsp; fi<br>
&nbsp;# Create an extra backup.<br>
&nbsp;# If this copy fails, give up.<br>
&nbsp;if [ -n &quot;$BACKUP_JUSTINCASE&quot; ]; then<br>
&nbsp; &nbsp;if ! /bin/cp -al $BACKUP_DEST_DIR/backup.0 \<br>
&nbsp; &nbsp; &nbsp; $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;echo &quot;ERROR: Failed to create extra copy \<br>
&nbsp; &nbsp; &nbsp;$BACKUP_DEST_DIR/$BACKUP_JUSTINCASE&quot;<br>
&nbsp; &nbsp; &nbsp;if &nbsp;[ &quot;$UNMOUNT_LATER&quot; == &quot;TRUE&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp;# Before we exit, unmount the mount point if necessary.<br>
&nbsp; &nbsp; &nbsp; &nbsp;cd ;sudo umount $MOUNT_POINT &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Unmounted $MOUNT_POINT again. Giving up.&quot;<br>
&nbsp; &nbsp; &nbsp;fi<br>
&nbsp; &nbsp; &nbsp;exit $E_UNMOUNTED<br>
&nbsp; &nbsp;fi<br>
&nbsp;fi<br>
&nbsp;# At start of month, rotate the oldest 8.<br>
&nbsp;if [ &quot;$MONTHSTART&quot; == &quot;true&quot; ]; then<br>
&nbsp; &nbsp;echo -e &quot;\nStart of month. \<br>
&nbsp; &nbsp;Removing oldest backup: $BACKUP_DEST_DIR/backup.15&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp;/bin/rm -rf &nbsp;$BACKUP_DEST_DIR/backup.15 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp;echo &quot;Rotating monthly,weekly backups: \<br>
&nbsp; &nbsp;$BACKUP_DEST_DIR/backup.[8-14] -&gt; $BACKUP_DEST_DIR/backup.[9-15]&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.14 $BACKUP_DEST_DIR/backup.15 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.13 $BACKUP_DEST_DIR/backup.14 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.12 $BACKUP_DEST_DIR/backup.13 &nbsp;&amp;&amp;<br>
Appendix A. Contributed Scripts<br>
674<br>
<hr>
<A name=681></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9<br>
&nbsp;# At start of week, rotate the second-oldest 4.<br>
&nbsp;elif [ &quot;$WEEKSTART&quot; == &quot;true&quot; ]; then<br>
&nbsp; &nbsp;echo -e &quot;\nStart of week. \<br>
&nbsp; &nbsp;Removing oldest weekly backup: $BACKUP_DEST_DIR/backup.12&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp;/bin/rm -rf &nbsp;$BACKUP_DEST_DIR/backup.12 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp;echo &quot;Rotating weekly backups: \<br>
&nbsp; &nbsp;$BACKUP_DEST_DIR/backup.[8-11] -&gt; $BACKUP_DEST_DIR/backup.[9-12]&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9<br>
&nbsp;else<br>
&nbsp; &nbsp;echo -e &quot;\nRemoving oldest daily backup: $BACKUP_DEST_DIR/backup.8&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/rm -rf &nbsp;$BACKUP_DEST_DIR/backup.8<br>
&nbsp;fi &nbsp;&amp;&amp;<br>
&nbsp;# Every day, rotate the newest 8.<br>
&nbsp;echo &quot;Rotating daily backups: \<br>
&nbsp;$BACKUP_DEST_DIR/backup.[1-7] -&gt; $BACKUP_DEST_DIR/backup.[2-8]&quot; &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.7 $BACKUP_DEST_DIR/backup.8 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.6 $BACKUP_DEST_DIR/backup.7 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.5 $BACKUP_DEST_DIR/backup.6 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.4 $BACKUP_DEST_DIR/backup.5 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.3 $BACKUP_DEST_DIR/backup.4 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.2 $BACKUP_DEST_DIR/backup.3 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.1 $BACKUP_DEST_DIR/backup.2 &nbsp;&amp;&amp;<br>
&nbsp; &nbsp; &nbsp;/bin/mv $BACKUP_DEST_DIR/backup.0 $BACKUP_DEST_DIR/backup.1 &nbsp;&amp;&amp;<br>
&nbsp;SUCCESS=true<br>
if &nbsp;[ &quot;$UNMOUNT_LATER&quot; == &quot;TRUE&quot; ]; then<br>
&nbsp; # Unmount the mount point if it wasn't mounted to begin with.<br>
&nbsp; cd ; sudo umount $MOUNT_POINT &amp;&amp; echo &quot;Unmounted $MOUNT_POINT again.&quot;<br>
fi<br>
if [ &quot;$SUCCESS&quot; == &quot;true&quot; ]; then<br>
&nbsp; echo 'SUCCESS!'<br>
&nbsp; exit 0<br>
fi<br>
# Should have already exited if backup worked.<br>
echo 'BACKUP FAILED! Is this just a dry run? Is the disk full?) '<br>
exit $E_BACKUP<br>
<b>Example A-33. An expanded<i>&nbsp;cd</i></b><b>&nbsp;command</b><br>
###########################################################################<br>
#<br>
# &nbsp; &nbsp; &nbsp; cdll<br>
# &nbsp; &nbsp; &nbsp; by Phil Braham<br>
#<br>
Appendix A. Contributed Scripts<br>
675<br>
<hr>
<A name=682></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; &nbsp; ############################################<br>
# &nbsp; &nbsp; &nbsp; Latest version of this script available from<br>
# &nbsp; &nbsp; &nbsp; http://freshmeat.net/projects/cd/<br>
# &nbsp; &nbsp; &nbsp; ############################################<br>
#<br>
# &nbsp; &nbsp; &nbsp; .cd_new<br>
#<br>
# &nbsp; &nbsp; &nbsp; An enhancement of the Unix cd command<br>
#<br>
# &nbsp; &nbsp; &nbsp; There are unlimited stack entries and special entries. The stack<br>
# &nbsp; &nbsp; &nbsp; entries keep the last cd_maxhistory<br>
# &nbsp; &nbsp; &nbsp; directories that have been used. The special entries can be<br>
# &nbsp; &nbsp; &nbsp; assigned to commonly used directories.<br>
#<br>
# &nbsp; &nbsp; &nbsp; The special entries may be pre-assigned by setting the environment<br>
# &nbsp; &nbsp; &nbsp; variables CDSn or by using the -u or -U command.<br>
#<br>
# &nbsp; &nbsp; &nbsp; The following is a suggestion for the .profile file:<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . cdll &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Set up the cd command<br>
# &nbsp; &nbsp; &nbsp; alias cd='cd_new' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Replace the cd command<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd -U &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Upload pre-assigned entries for<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ the stack and special entries<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd -D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Set non-default mode<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alias @=&quot;cd_new @&quot; &nbsp;# &nbsp;Allow @ to be used to get history<br>
#<br>
# &nbsp; &nbsp; &nbsp; For help type:<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd -h or<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd -H<br>
#<br>
#<br>
###########################################################################<br>
#<br>
# &nbsp; &nbsp; &nbsp; Version 1.2.1<br>
#<br>
# &nbsp; &nbsp; &nbsp; Written by Phil Braham - Realtime Software Pty Ltd<br>
# &nbsp; &nbsp; &nbsp; (realtime@mpx.com.au)<br>
# &nbsp; &nbsp; &nbsp; Please send any suggestions or enhancements to the author (also at<br>
# &nbsp; &nbsp; &nbsp; phil@braham.net)<br>
#<br>
############################################################################<br>
cd_hm ()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;%s&quot; &quot;cd [dir] [0-9] [@[s|h] [-g [&lt;dir&gt;]] [-d] \<br>
[-D] [-r&lt;n&gt;] [dir|0-9] [-R&lt;n&gt;] [&lt;dir&gt;|0-9]<br>
&nbsp; &nbsp;[-s&lt;n&gt;] [-S&lt;n&gt;] [-u] [-U] [-f] [-F] [-h] [-H] [-v]<br>
&nbsp; &nbsp; &lt;dir&gt; Go to directory<br>
&nbsp; &nbsp; 0-n &nbsp; &nbsp; &nbsp; &nbsp; Go to previous directory (0 is previous, 1 is last but 1 etc)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n is up to max history (default is 50)<br>
&nbsp; &nbsp; @ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List history and special entries<br>
&nbsp; &nbsp; @h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List history entries<br>
&nbsp; &nbsp; @s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List special entries<br>
&nbsp; &nbsp; -g [&lt;dir&gt;] &nbsp;Go to literal name (bypass special names)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is to allow access to dirs called '0','1','-h' etc<br>
&nbsp; &nbsp; -d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Change default action - verbose. (See note)<br>
&nbsp; &nbsp; -D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Change default action - silent. (See note)<br>
&nbsp; &nbsp; -s&lt;n&gt; Go to the special entry &lt;n&gt;*<br>
&nbsp; &nbsp; -S&lt;n&gt; Go to the special entry &lt;n&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and replace it with the current dir*<br>
&nbsp; &nbsp; -r&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;<br>
Appendix A. Contributed Scripts<br>
676<br>
<hr>
<A name=683></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and then put it on special entry &lt;n&gt;*<br>
&nbsp; &nbsp; -R&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and put current dir on special entry &lt;n&gt;*<br>
&nbsp; &nbsp; -a&lt;n&gt; &nbsp; &nbsp; &nbsp; Alternative suggested directory. See note below.<br>
&nbsp; &nbsp; -f [&lt;file&gt;] File entries to &lt;file&gt;.<br>
&nbsp; &nbsp; -u [&lt;file&gt;] Update entries from &lt;file&gt;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If no filename supplied then default file<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (${CDPath}${2:-&quot;$CDFile&quot;}) is used<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -F and -U are silent versions<br>
&nbsp; &nbsp; -v &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Print version number<br>
&nbsp; &nbsp; -h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Help<br>
&nbsp; &nbsp; -H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Detailed help<br>
&nbsp; &nbsp; *The special entries (0 - 9) are held until log off, replaced by another<br>
&nbsp; &nbsp; &nbsp;entry or updated with the -u command<br>
&nbsp; &nbsp; Alternative suggested directories:<br>
&nbsp; &nbsp; If a directory is not found then CD will suggest any<br>
&nbsp; &nbsp; possibilities. These are directories starting with the same letters<br>
&nbsp; &nbsp; and if any are found they are listed prefixed with -a&lt;n&gt;<br>
&nbsp; &nbsp; where &lt;n&gt; is a number.<br>
&nbsp; &nbsp; It's possible to go to the directory by entering cd -a&lt;n&gt;<br>
&nbsp; &nbsp; on the command line.<br>
&nbsp; &nbsp; The directory for -r&lt;n&gt; or -R&lt;n&gt; may be a number.<br>
&nbsp; &nbsp; For example:<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r3 4 &nbsp;Go to history entry 4 and put it on special entry 3<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -R3 4 &nbsp;Put current dir on the special entry 3<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and go to history entry 4<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -s3 &nbsp; &nbsp;Go to special entry 3<br>
&nbsp; &nbsp; Note that commands R,r,S and s may be used without a number<br>
&nbsp; &nbsp; and refer to 0:<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -s &nbsp; &nbsp; Go to special entry 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -S &nbsp; &nbsp; Go to special entry 0 and make special<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry 0 current dir<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r 1 &nbsp; Go to history entry 1 and put it on special entry 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r &nbsp; &nbsp; Go to history entry 0 and put it on special entry 0<br>
&nbsp; &nbsp; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;$CD_MODE&quot; = &quot;PREV&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;$cd_mnset&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;$cd_mset&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
}<br>
cd_Hm ()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_hm<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;%s&quot; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; The previous directories (0-$cd_maxhistory) are stored in the<br>
&nbsp; &nbsp; &nbsp; &nbsp; environment variables CD[0] - CD[$cd_maxhistory]<br>
&nbsp; &nbsp; &nbsp; &nbsp; Similarly the special directories S0 - $cd_maxspecial are in<br>
&nbsp; &nbsp; &nbsp; &nbsp; the environment variable CDS[0] - CDS[$cd_maxspecial]<br>
&nbsp; &nbsp; &nbsp; &nbsp; and may be accessed from the command line<br>
&nbsp; &nbsp; &nbsp; &nbsp; The default pathname for the -f and -u commands is $CDPath<br>
&nbsp; &nbsp; &nbsp; &nbsp; The default filename for the -f and -u commands is $CDFile<br>
&nbsp; &nbsp; &nbsp; &nbsp; Set the following environment variables:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPTLEN &nbsp;- Set to the length of prompt you require.<br>
Appendix A. Contributed Scripts<br>
677<br>
<hr>
<A name=684></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Prompt string is set to the right characters of the<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current directory.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If not set then prompt is left unchanged<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPT_PRE - Set to the string to prefix the prompt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non-root: &nbsp;\&quot;\\[\\e[01;34m\\]\&quot; &nbsp;(sets colour to blue).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root: &nbsp; &nbsp; &nbsp;\&quot;\\[\\e[01;31m\\]\&quot; &nbsp;(sets colour to red).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPT_POST &nbsp; &nbsp;- Set to the string to suffix the prompt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non-root: &nbsp;\&quot;\\[\\e[00m\\]$\&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resets colour and displays $).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root: &nbsp; &nbsp; &nbsp;\&quot;\\[\\e[00m\\]#\&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (resets colour and displays #).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDPath - Set the default path for the -f &amp; -u options.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Default is home directory<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDFile - Set the default filename for the -f &amp; -u options.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Default is cdfile<br>
&quot;<br>
&nbsp; &nbsp; cd_version<br>
}<br>
cd_version ()<br>
{<br>
&nbsp;printf &quot;Version: ${VERSION_MAJOR}.${VERSION_MINOR} Date: ${VERSION_DATE}\n&quot;<br>
}<br>
#<br>
# Truncate right.<br>
#<br>
# params:<br>
# &nbsp; p1 - string<br>
# &nbsp; p2 - length to truncate to<br>
#<br>
# returns string in tcd<br>
#<br>
cd_right_trunc ()<br>
{<br>
&nbsp; &nbsp; local tlen=${2}<br>
&nbsp; &nbsp; local plen=${#1}<br>
&nbsp; &nbsp; local str=&quot;${1}&quot;<br>
&nbsp; &nbsp; local diff<br>
&nbsp; &nbsp; local filler=&quot;&lt;--&quot;<br>
&nbsp; &nbsp; if ${TEST} ${plen} -le ${tlen}<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; tcd=&quot;${str}&quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; let diff=${plen}-${tlen}<br>
&nbsp; &nbsp; &nbsp; &nbsp; elen=3<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} ${diff} -le 2<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let elen=${diff}<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; tlen=-${tlen}<br>
&nbsp; &nbsp; &nbsp; &nbsp; let tlen=${tlen}+${elen}<br>
&nbsp; &nbsp; &nbsp; &nbsp; tcd=${filler:0:elen}${str:tlen}<br>
&nbsp; &nbsp; fi<br>
}<br>
#<br>
# Three versions of do history:<br>
Appendix A. Contributed Scripts<br>
678<br>
<hr>
<A name=685></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp;cd_dohistory &nbsp;- packs history and specials side by side<br>
# &nbsp; &nbsp;cd_dohistoryH - Shows only hstory<br>
# &nbsp; &nbsp;cd_dohistoryS - Shows only specials<br>
#<br>
cd_dohistory ()<br>
{<br>
&nbsp; &nbsp; cd_getrc<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;History:\n&quot;<br>
&nbsp; &nbsp; local -i count=${cd_histcount}<br>
&nbsp; &nbsp; while ${TEST} ${count} -ge 0<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_right_trunc &quot;${CD[count]}&quot; ${cd_lchar}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;%2d %-${cd_lchar}.${cd_lchar}s &quot; ${count} &quot;${tcd}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_right_trunc &quot;${CDS[count]}&quot; ${cd_rchar}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;S%d %-${cd_rchar}.${cd_rchar}s\n&quot; ${count} &quot;${tcd}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; count=${count}-1<br>
&nbsp; &nbsp; done<br>
}<br>
cd_dohistoryH ()<br>
{<br>
&nbsp; &nbsp; cd_getrc<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;History:\n&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i count=${cd_maxhistory}<br>
&nbsp; &nbsp; &nbsp; &nbsp; while ${TEST} ${count} -ge 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;${count} %-${cd_flchar}.${cd_flchar}s\n&quot; ${CD[$count]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=${count}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
}<br>
cd_dohistoryS ()<br>
{<br>
&nbsp; &nbsp; cd_getrc<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;Specials:\n&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i count=${cd_maxspecial}<br>
&nbsp; &nbsp; &nbsp; &nbsp; while ${TEST} ${count} -ge 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;S${count} %-${cd_flchar}.${cd_flchar}s\n&quot; ${CDS[$count]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=${count}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
}<br>
cd_getrc ()<br>
{<br>
&nbsp; &nbsp; cd_flchar=$(stty -a | awk -F \;<br>
&nbsp; &nbsp; '/rows/ { print $2 $3 }' | awk -F \ &nbsp;'{ print $4 }')<br>
&nbsp; &nbsp; if ${TEST} ${cd_flchar} -ne 0<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_lchar=${cd_flchar}/2-5<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_rchar=${cd_flchar}/2-5<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_flchar=${cd_flchar}-5<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_flchar=${FLCHAR:=75}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # cd_flchar is used for for the @s &amp; @h history<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_lchar=${LCHAR:=35}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_rchar=${RCHAR:=35}<br>
&nbsp; &nbsp; fi<br>
}<br>
cd_doselection ()<br>
Appendix A. Contributed Scripts<br>
679<br>
<hr>
<A name=686></a>Advanced Bash-Scripting Guide<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i nm=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_doflag=&quot;TRUE&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;${CD_MODE}&quot; = &quot;PREV&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} -z &quot;$cd_npwd&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_npwd=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; tm=$(echo &quot;${cd_npwd}&quot; | cut -b 1)<br>
&nbsp; &nbsp; if ${TEST} &quot;${tm}&quot; = &quot;-&quot;<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; pm=$(echo &quot;${cd_npwd}&quot; | cut -b 2)<br>
&nbsp; &nbsp; &nbsp; &nbsp; nm=$(echo &quot;${cd_npwd}&quot; | cut -d $pm -f2)<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;${pm}&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a) cd_npwd=${cd_sugg[$nm]} ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s) cd_npwd=&quot;${CDS[$nm]}&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S) cd_npwd=&quot;${CDS[$nm]}&quot; ; CDS[$nm]=`pwd` ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;r) cd_npwd=&quot;$2&quot; ; cd_specDir=$nm ; cd_doselection &quot;$1&quot; &quot;$2&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;R) cd_npwd=&quot;$2&quot; ; CDS[$nm]=`pwd` ; cd_doselection &quot;$1&quot; &quot;$2&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if ${TEST} &quot;${cd_npwd}&quot; != &quot;.&quot; -a &quot;${cd_npwd}&quot; \<br>
!= &quot;..&quot; -a &quot;${cd_npwd}&quot; -le ${cd_maxhistory} &gt;&gt;/dev/null 2&gt;&amp;1<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; cd_npwd=${CD[$cd_npwd]}<br>
&nbsp; &nbsp; &nbsp;else<br>
&nbsp; &nbsp; &nbsp; &nbsp;case &quot;$cd_npwd&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @) &nbsp;cd_dohistory ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;@h) cd_dohistoryH ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;@s) cd_dohistoryS ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-h) cd_hm ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-H) cd_Hm ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-f) cd_fsave &quot;SHOW&quot; $2 ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-u) cd_upload &quot;SHOW&quot; $2 ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-F) cd_fsave &quot;NOSHOW&quot; $2 ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-U) cd_upload &quot;NOSHOW&quot; $2 ; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-g) cd_npwd=&quot;$2&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-d) cd_chdefm 1; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-D) cd_chdefm 0; cd_doflag=&quot;FALSE&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-r) cd_npwd=&quot;$2&quot; ; cd_specDir=0 ; cd_doselection &quot;$1&quot; &quot;$2&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-R) cd_npwd=&quot;$2&quot; ; CDS[0]=`pwd` ; cd_doselection &quot;$1&quot; &quot;$2&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-s) cd_npwd=&quot;${CDS[0]}&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-S) cd_npwd=&quot;${CDS[0]}&quot; &nbsp;; CDS[0]=`pwd` ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-v) cd_version ; cd_doflag=&quot;FALSE&quot;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; fi<br>
}<br>
cd_chdefm ()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;${CD_MODE}&quot; = &quot;PREV&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CD_MODE=&quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} $1 -eq 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;${cd_mset}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CD_MODE=&quot;PREV&quot;<br>
Appendix A. Contributed Scripts<br>
680<br>
<hr>
<A name=687></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} $1 -eq 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;${cd_mnset}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
}<br>
cd_fsave ()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local sfile=${CDPath}${2:-&quot;$CDFile&quot;}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;$1&quot; = &quot;SHOW&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;Saved to %s\n&quot; $sfile<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${RM} -f ${sfile}<br>
&nbsp; &nbsp; &nbsp; &nbsp; local -i count=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; while ${TEST} ${count} -le ${cd_maxhistory}<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;CD[$count]=\&quot;${CD[$count]}\&quot;&quot; &gt;&gt; ${sfile}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=${count}+1<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; count=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; while ${TEST} ${count} -le ${cd_maxspecial}<br>
&nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;CDS[$count]=\&quot;${CDS[$count]}\&quot;&quot; &gt;&gt; ${sfile}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=${count}+1<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
}<br>
cd_upload ()<br>
{<br>
&nbsp; &nbsp; &nbsp; &nbsp; local sfile=${CDPath}${2:-&quot;$CDFile&quot;}<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;${1}&quot; = &quot;SHOW&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;Loading from %s\n&quot; ${sfile}<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; . ${sfile}<br>
}<br>
cd_new ()<br>
{<br>
&nbsp; &nbsp; local -i count<br>
&nbsp; &nbsp; local -i choose=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_npwd=&quot;${1}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_specDir=-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_doselection &quot;${1}&quot; &quot;${2}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} ${cd_doflag} = &quot;TRUE&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} &quot;${CD[0]}&quot; != &quot;`pwd`&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=$cd_maxhistory<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while ${TEST} $count -gt 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CD[$count]=${CD[$count-1]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count=${count}-1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CD[0]=`pwd`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command cd &quot;${cd_npwd}&quot; 2&gt;/dev/null<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} $? -eq 1<br>
Appendix A. Contributed Scripts<br>
681<br>
<hr>
<A name=688></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;Unknown dir: %s\n&quot; &quot;${cd_npwd}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local -i ftflag=0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for i in &quot;${cd_npwd}&quot;*<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} -d &quot;${i}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} ${ftflag} -eq 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;Suggest:\n&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftflag=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${PRINTF} &quot;\t-a${choose} %s\n&quot; &quot;$i&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_sugg[$choose]=&quot;${i}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; choose=${choose}+1<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} ${cd_specDir} -ne -1<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDS[${cd_specDir}]=`pwd`<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ${TEST} ! -z &quot;${CDL_PROMPTLEN}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_right_trunc &quot;${PWD}&quot; ${CDL_PROMPTLEN}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd_rp=${CDL_PROMPT_PRE}${tcd}${CDL_PROMPT_POST}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; export PS1=&quot;$(echo -ne ${cd_rp})&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
}<br>
#########################################################################<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Initialisation here &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
#########################################################################<br>
#<br>
VERSION_MAJOR=&quot;1&quot;<br>
VERSION_MINOR=&quot;2.1&quot;<br>
VERSION_DATE=&quot;24-MAY-2003&quot;<br>
#<br>
alias cd=cd_new<br>
#<br>
# Set up commands<br>
RM=/bin/rm<br>
TEST=test<br>
PRINTF=printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Use builtin printf<br>
#########################################################################<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# Change this to modify the default pre- and post prompt strings. &nbsp; &nbsp; &nbsp; #<br>
# These only come into effect if CDL_PROMPTLEN is set. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
#########################################################################<br>
if ${TEST} ${EUID} -eq 0<br>
then<br>
# &nbsp; CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=&quot;$HOSTNAME@&quot;}<br>
&nbsp; &nbsp; CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=&quot;\\[\\e[01;31m\\]&quot;} &nbsp;# Root is in red<br>
&nbsp; &nbsp; CDL_PROMPT_POST=${CDL_PROMPT_POST:=&quot;\\[\\e[00m\\]#&quot;}<br>
else<br>
&nbsp; &nbsp; CDL_PROMPT_PRE=${CDL_PROMPT_PRE:=&quot;\\[\\e[01;34m\\]&quot;} &nbsp;# Users in blue<br>
Appendix A. Contributed Scripts<br>
682<br>
<hr>
<A name=689></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; CDL_PROMPT_POST=${CDL_PROMPT_POST:=&quot;\\[\\e[00m\\]$&quot;}<br>
fi<br>
#########################################################################<br>
#<br>
# cd_maxhistory defines the max number of history entries allowed.<br>
typeset -i cd_maxhistory=50<br>
#########################################################################<br>
#<br>
# cd_maxspecial defines the number of special entries.<br>
typeset -i cd_maxspecial=9<br>
#<br>
#<br>
#########################################################################<br>
#<br>
# &nbsp;cd_histcount defines the number of entries displayed in<br>
#+ the history command.<br>
typeset -i cd_histcount=9<br>
#<br>
#########################################################################<br>
export CDPath=${HOME}/<br>
# &nbsp;Change these to use a different &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
#+ default path and filename &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
export CDFile=${CDFILE:=cdfile} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # for the -u and -f commands &nbsp;#<br>
#<br>
#########################################################################<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
typeset -i cd_lchar cd_rchar cd_flchar<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;This is the number of chars to allow for the #<br>
cd_flchar=${FLCHAR:=75} #+ cd_flchar is used for for the @s &amp; @h history#<br>
typeset -ax CD CDS<br>
#<br>
cd_mset=&quot;\n\tDefault mode is now set - entering cd with no parameters \<br>
has the default action\n\tUse cd -d or -D for cd to go to \<br>
previous directory with no parameters\n&quot;<br>
cd_mnset=&quot;\n\tNon-default mode is now set - entering cd with no \<br>
parameters is the same as entering cd 0\n\tUse cd -d or \<br>
-D to change default cd action\n&quot;<br>
# ==================================================================== #<br>
: &lt;&lt;DOCUMENTATION<br>
Written by Phil Braham. Realtime Software Pty Ltd.<br>
Released under GNU license. Free to use. Please pass any modifications<br>
or comments to the author Phil Braham:<br>
realtime@mpx.com.au<br>
=======================================================================<br>
cdll is a replacement for cd and incorporates similar functionality to<br>
the bash pushd and popd commands but is independent of them.<br>
This version of cdll has been tested on Linux using Bash. It will work<br>
on most Linux versions but will probably not work on other shells without<br>
modification.<br>
Introduction<br>
============<br>
Appendix A. Contributed Scripts<br>
683<br>
<hr>
<A name=690></a>Advanced Bash-Scripting Guide<br>
cdll allows easy moving about between directories. When changing to a new<br>
directory the current one is automatically put onto a stack. By default<br>
50 entries are kept, but this is configurable. Special directories can be<br>
kept for easy access - by default up to 10, but this is configurable. The<br>
most recent stack entries and the special entries can be easily viewed.<br>
The directory stack and special entries can be saved to, and loaded from,<br>
a file. This allows them to be set up on login, saved before logging out<br>
or changed when moving project to project.<br>
In addition, cdll provides a flexible command prompt facility that allows,<br>
for example, a directory name in colour that is truncated from the left<br>
if it gets too long.<br>
Setting up cdll<br>
===============<br>
Copy cdll to either your local home directory or a central directory<br>
such as /usr/bin (this will require root access).<br>
Copy the file cdfile to your home directory. It will require read and<br>
write access. This a default file that contains a directory stack and<br>
special entries.<br>
To replace the cd command you must add commands to your login script.<br>
The login script is one or more of:<br>
&nbsp; &nbsp; /etc/profile<br>
&nbsp; &nbsp; ~/.bash_profile<br>
&nbsp; &nbsp; ~/.bash_login<br>
&nbsp; &nbsp; ~/.profile<br>
&nbsp; &nbsp; ~/.bashrc<br>
&nbsp; &nbsp; /etc/bash.bashrc.local<br>
To setup your login, ~/.bashrc is recommended, for global (and root) setup<br>
add the commands to /etc/bash.bashrc.local<br>
To set up on login, add the command:<br>
&nbsp; &nbsp; . &lt;dir&gt;/cdll<br>
For example if cdll is in your local home directory:<br>
&nbsp; &nbsp; . ~/cdll<br>
If in /usr/bin then:<br>
&nbsp; &nbsp; . /usr/bin/cdll<br>
If you want to use this instead of the buitin cd command then add:<br>
&nbsp; &nbsp; alias cd='cd_new'<br>
We would also recommend the following commands:<br>
&nbsp; &nbsp; alias @='cd_new @'<br>
&nbsp; &nbsp; cd -U<br>
&nbsp; &nbsp; cd -D<br>
If you want to use cdll's prompt facilty then add the following:<br>
&nbsp; &nbsp; CDL_PROMPTLEN=nn<br>
Where nn is a number described below. Initially 99 would be suitable<br>
number.<br>
Thus the script looks something like this:<br>
&nbsp; &nbsp; ######################################################################<br>
&nbsp; &nbsp; # CD Setup<br>
Appendix A. Contributed Scripts<br>
684<br>
<hr>
<A name=691></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; ######################################################################<br>
&nbsp; &nbsp; CDL_PROMPTLEN=21 &nbsp; &nbsp; &nbsp; &nbsp;# Allow a prompt length of up to 21 characters<br>
&nbsp; &nbsp; . /usr/bin/cdll &nbsp; &nbsp; &nbsp; &nbsp; # Initialise cdll<br>
&nbsp; &nbsp; alias cd='cd_new' &nbsp; &nbsp; &nbsp; # Replace the built in cd command<br>
&nbsp; &nbsp; alias @='cd_new @' &nbsp; &nbsp; &nbsp;# Allow @ at the prompt to display history<br>
&nbsp; &nbsp; cd -U &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Upload directories<br>
&nbsp; &nbsp; cd -D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Set default action to non-posix<br>
&nbsp; &nbsp; ######################################################################<br>
The full meaning of these commands will become clear later.<br>
There are a couple of caveats. If another program changes the directory<br>
without calling cdll, then the directory won't be put on the stack and<br>
also if the prompt facility is used then this will not be updated. Two<br>
programs that can do this are pushd and popd. To update the prompt and<br>
stack simply enter:<br>
&nbsp; &nbsp; cd .<br>
Note that if the previous entry on the stack is the current directory<br>
then the stack is not updated.<br>
Usage<br>
===== &nbsp;<br>
cd [dir] [0-9] [@[s|h] [-g &lt;dir&gt;] [-d] [-D] [-r&lt;n&gt;]<br>
&nbsp; &nbsp;[dir|0-9] [-R&lt;n&gt;] [&lt;dir&gt;|0-9] [-s&lt;n&gt;] [-S&lt;n&gt;]<br>
&nbsp; &nbsp;[-u] [-U] [-f] [-F] [-h] [-H] [-v]<br>
&nbsp; &nbsp; &lt;dir&gt; &nbsp; &nbsp; &nbsp; Go to directory<br>
&nbsp; &nbsp; 0-n &nbsp; &nbsp; &nbsp; &nbsp; Goto previous directory (0 is previous,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 is last but 1, etc.)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n is up to max history (default is 50)<br>
&nbsp; &nbsp; @ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List history and special entries (Usually available as $ @)<br>
&nbsp; &nbsp; @h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List history entries<br>
&nbsp; &nbsp; @s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;List special entries<br>
&nbsp; &nbsp; -g [&lt;dir&gt;] &nbsp;Go to literal name (bypass special names)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is to allow access to dirs called '0','1','-h' etc<br>
&nbsp; &nbsp; -d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Change default action - verbose. (See note)<br>
&nbsp; &nbsp; -D &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Change default action - silent. (See note)<br>
&nbsp; &nbsp; -s&lt;n&gt; &nbsp; &nbsp; &nbsp; Go to the special entry &lt;n&gt;<br>
&nbsp; &nbsp; -S&lt;n&gt; &nbsp; &nbsp; &nbsp; Go to the special entry &lt;n&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and replace it with the current dir<br>
&nbsp; &nbsp; -r&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and then put it on special entry &lt;n&gt;<br>
&nbsp; &nbsp; -R&lt;n&gt; [&lt;dir&gt;] Go to directory &lt;dir&gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and put current dir on special entry &lt;n&gt;<br>
&nbsp; &nbsp; -a&lt;n&gt; &nbsp; &nbsp; &nbsp; Alternative suggested directory. See note below.<br>
&nbsp; &nbsp; -f [&lt;file&gt;] File entries to &lt;file&gt;.<br>
&nbsp; &nbsp; -u [&lt;file&gt;] Update entries from &lt;file&gt;.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If no filename supplied then default file (~/cdfile) is used<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -F and -U are silent versions<br>
&nbsp; &nbsp; -v &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Print version number<br>
&nbsp; &nbsp; -h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Help<br>
&nbsp; &nbsp; -H &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Detailed help<br>
Examples<br>
========<br>
These examples assume non-default mode is set (that is, cd with no<br>
parameters will go to the most recent stack directory), that aliases<br>
Appendix A. Contributed Scripts<br>
685<br>
<hr>
<A name=692></a>Advanced Bash-Scripting Guide<br>
have been set up for cd and @ as described above and that cd's prompt<br>
facility is active and the prompt length is 21 characters.<br>
&nbsp; &nbsp; /home/phil$ @<br>
&nbsp; &nbsp; # List the entries with the @<br>
&nbsp; &nbsp; History:<br>
&nbsp; &nbsp; # Output of the @ command<br>
&nbsp; &nbsp; .....<br>
&nbsp; &nbsp; # Skipped these entries for brevity<br>
&nbsp; &nbsp; 1 /home/phil/ummdev &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; S1 /home/phil/perl<br>
&nbsp; &nbsp; # Most recent two history entries<br>
&nbsp; &nbsp; 0 /home/phil/perl/eg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S0 /home/phil/umm/ummdev<br>
&nbsp; &nbsp; # and two special entries are shown<br>
&nbsp; &nbsp; /home/phil$ cd /home/phil/utils/Cdll<br>
&nbsp; &nbsp; # Now change directories<br>
&nbsp; &nbsp; /home/phil/utils/Cdll$ @<br>
&nbsp; &nbsp; # Prompt reflects the directory.<br>
&nbsp; &nbsp; History:<br>
&nbsp; &nbsp; # New history<br>
&nbsp; &nbsp; ..... &nbsp;&nbsp;<br>
&nbsp; &nbsp; 1 /home/phil/perl/eg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S1 /home/phil/perl<br>
&nbsp; &nbsp; # History entry 0 has moved to 1<br>
&nbsp; &nbsp; 0 /home/phil &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;S0 /home/phil/umm/ummdev<br>
&nbsp; &nbsp; # and the most recent has entered<br>
To go to a history entry:<br>
&nbsp; &nbsp; /home/phil/utils/Cdll$ cd 1<br>
&nbsp; &nbsp; # Go to history entry 1.<br>
&nbsp; &nbsp; /home/phil/perl/eg$<br>
&nbsp; &nbsp; # Current directory is now what was 1<br>
To go to a special entry:<br>
&nbsp; &nbsp; /home/phil/perl/eg$ cd -s1<br>
&nbsp; &nbsp; # Go to special entry 1<br>
&nbsp; &nbsp; /home/phil/umm/ummdev$<br>
&nbsp; &nbsp; # Current directory is S1<br>
To go to a directory called, for example, 1:<br>
&nbsp; &nbsp; /home/phil$ cd -g 1<br>
&nbsp; &nbsp; # -g ignores the special meaning of 1<br>
&nbsp; &nbsp; /home/phil/1$<br>
To put current directory on the special list as S1:<br>
&nbsp; &nbsp; cd -r1 . &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;OR<br>
&nbsp; &nbsp; cd -R1 . &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;These have the same effect if the directory is<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ . (the current directory)<br>
To go to a directory and add it as a special &nbsp;<br>
&nbsp; The directory for -r&lt;n&gt; or -R&lt;n&gt; may be a number.<br>
&nbsp; For example:<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r3 4 &nbsp;Go to history entry 4 and put it on special entry 3<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -R3 4 &nbsp;Put current dir on the special entry 3 and go to<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; history entry 4<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -s3 &nbsp; &nbsp;Go to special entry 3<br>
&nbsp; &nbsp; Note that commands R,r,S and s may be used without a number and<br>
&nbsp; &nbsp; refer to 0:<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -s &nbsp; &nbsp; Go to special entry 0<br>
Appendix A. Contributed Scripts<br>
686<br>
<hr>
<A name=693></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -S &nbsp; &nbsp; Go to special entry 0 and make special entry 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current dir<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r 1 &nbsp; Go to history entry 1 and put it on special entry 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; $ cd -r &nbsp; &nbsp; Go to history entry 0 and put it on special entry 0<br>
&nbsp; &nbsp; Alternative suggested directories:<br>
&nbsp; &nbsp; If a directory is not found, then CD will suggest any<br>
&nbsp; &nbsp; possibilities. These are directories starting with the same letters<br>
&nbsp; &nbsp; and if any are found they are listed prefixed with -a&lt;n&gt;<br>
&nbsp; &nbsp; where &lt;n&gt; is a number. It's possible to go to the directory<br>
&nbsp; &nbsp; by entering cd -a&lt;n&gt; on the command line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; Use cd -d or -D to change default cd action. cd -H will show<br>
&nbsp; &nbsp; &nbsp; &nbsp; current action.<br>
&nbsp; &nbsp; &nbsp; &nbsp; The history entries (0-n) are stored in the environment variables<br>
&nbsp; &nbsp; &nbsp; &nbsp; CD[0] - CD[n]<br>
&nbsp; &nbsp; &nbsp; &nbsp; Similarly the special directories S0 - 9 are in the environment<br>
&nbsp; &nbsp; &nbsp; &nbsp; variable CDS[0] - CDS[9]<br>
&nbsp; &nbsp; &nbsp; &nbsp; and may be accessed from the command line, for example:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ls -l ${CDS[3]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat ${CD[8]}/file.txt<br>
&nbsp; &nbsp; &nbsp; &nbsp; The default pathname for the -f and -u commands is ~<br>
&nbsp; &nbsp; &nbsp; &nbsp; The default filename for the -f and -u commands is cdfile<br>
Configuration<br>
=============<br>
&nbsp; &nbsp; The following environment variables can be set:<br>
&nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPTLEN &nbsp;- Set to the length of prompt you require.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Prompt string is set to the right characters of the current<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; directory. If not set, then prompt is left unchanged. Note<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that this is the number of characters that the directory is<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shortened to, not the total characters in the prompt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPT_PRE - Set to the string to prefix the prompt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non-root: &nbsp;&quot;\\[\\e[01;34m\\]&quot; &nbsp;(sets colour to blue).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root: &nbsp; &nbsp; &nbsp;&quot;\\[\\e[01;31m\\]&quot; &nbsp;(sets colour to red).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPT_POST &nbsp; &nbsp;- Set to the string to suffix the prompt.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non-root: &nbsp;&quot;\\[\\e[00m\\]$&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(resets colour and displays $).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root: &nbsp; &nbsp; &nbsp;&quot;\\[\\e[00m\\]#&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(resets colour and displays #).<br>
&nbsp; &nbsp; &nbsp; &nbsp; Note:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CDL_PROMPT_PRE &amp; _POST only t<br>
&nbsp; &nbsp; &nbsp; &nbsp; CDPath - Set the default path for the -f &amp; -u options.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Default is home directory<br>
&nbsp; &nbsp; &nbsp; &nbsp; CDFile - Set the default filename for the -f &amp; -u options.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Default is cdfile<br>
Appendix A. Contributed Scripts<br>
687<br>
<hr>
<A name=694></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; There are three variables defined in the file cdll which control the<br>
&nbsp; &nbsp; number of entries stored or displayed. They are in the section labeled<br>
&nbsp; &nbsp; 'Initialisation here' towards the end of the file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_maxhistory &nbsp; &nbsp; &nbsp; - The number of history entries stored.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is 50.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_maxspecial &nbsp; &nbsp; &nbsp; - The number of special entries allowed.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Default is 9.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cd_histcount &nbsp; &nbsp; &nbsp; &nbsp;- The number of history and special entries<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; displayed. Default is 9.<br>
&nbsp; &nbsp; Note that cd_maxspecial should be &gt;= cd_histcount to avoid displaying<br>
&nbsp; &nbsp; special entries that can't be set.<br>
Version: 1.2.1 Date: 24-MAY-2003<br>
DOCUMENTATION<br>
<b>Example A-34. A soundcard setup script</b><br>
#!/bin/bash<br>
# soundcard-on.sh<br>
# &nbsp;Script author: Mkarcher<br>
# &nbsp;http://www.thinkwiki.org/wiki &nbsp;...<br>
# &nbsp;/Script_for_configuring_the_CS4239_sound_chip_in_PnP_mode<br>
# &nbsp;ABS Guide author made minor changes and added comments.<br>
# &nbsp;Couldn't contact script author to ask for permission to use, but ...<br>
#+ the script was released under the FDL,<br>
#+ so its use here should be both legal and ethical.<br>
# &nbsp;Sound-via-pnp-script for Thinkpad 600E<br>
#+ and possibly other computers with onboard CS4239/CS4610<br>
#+ that do not work with the PCI driver<br>
#+ and are not recognized by the PnP code of snd-cs4236.<br>
# &nbsp;Also for some 770-series Thinkpads, such as the 770x.<br>
# &nbsp;Run as root user, of course.<br>
#<br>
# &nbsp;These are old and very obsolete laptop computers,<br>
#+ but this particular script is very instructive,<br>
#+ as it shows how to set up and hack device files.<br>
# &nbsp;Search for sound card pnp device:<br>
for dev in /sys/bus/pnp/devices/*<br>
do<br>
&nbsp; grep CSC0100 $dev/id &gt; /dev/null &amp;&amp; WSSDEV=$dev<br>
&nbsp; grep CSC0110 $dev/id &gt; /dev/null &amp;&amp; CTLDEV=$dev<br>
done<br>
# On 770x:<br>
# WSSDEV = /sys/bus/pnp/devices/00:07<br>
# CTLDEV = /sys/bus/pnp/devices/00:06<br>
# These are symbolic links to /sys/devices/pnp0/ ...<br>
# &nbsp;Activate devices:<br>
# &nbsp;Thinkpad boots with devices disabled unless &quot;fast boot&quot; is turned off<br>
#+ (in BIOS).<br>
Appendix A. Contributed Scripts<br>
688<br>
<hr>
<A name=695></a>Advanced Bash-Scripting Guide<br>
echo activate &gt; $WSSDEV/resources<br>
echo activate &gt; $CTLDEV/resources<br>
# Parse resource settings.<br>
{ read # Discard &quot;state = active&quot; (see below).<br>
&nbsp; read bla port1<br>
&nbsp; read bla port2<br>
&nbsp; read bla port3<br>
&nbsp; read bla irq<br>
&nbsp; read bla dma1<br>
&nbsp; read bla dma2<br>
&nbsp;# The &quot;bla's&quot; are labels in the first field: &quot;io,&quot; &quot;state,&quot; etc.<br>
&nbsp;# These are discarded.<br>
&nbsp;# &nbsp;Hack: with PnPBIOS: ports are: port1: WSS, port2:<br>
&nbsp;#+ OPL, port3: sb (unneeded)<br>
&nbsp;# &nbsp; &nbsp; &nbsp; with ACPI-PnP:ports are: port1: OPL, port2: sb, port3: WSS<br>
&nbsp;# &nbsp;(ACPI bios seems to be wrong here, the PnP-card-code in snd-cs4236.c<br>
&nbsp;#+ &nbsp;uses the PnPBIOS port order)<br>
&nbsp;# &nbsp;Detect port order using the fixed OPL port as reference.<br>
&nbsp; if [ ${port2%%-*} = 0x388 ]<br>
&nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^ &nbsp;Strip out everything following hyphen in port address.<br>
&nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;So, if port1 is 0x530-0x537<br>
&nbsp;#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; we're left with 0x530 -- the start address of the port.<br>
&nbsp;then<br>
&nbsp; &nbsp;# PnPBIOS: usual order<br>
&nbsp; &nbsp;port=${port1%%-*}<br>
&nbsp; &nbsp;oplport=${port2%%-*}<br>
&nbsp;else<br>
&nbsp; &nbsp;# ACPI: mixed-up order<br>
&nbsp; &nbsp;port=${port3%%-*}<br>
&nbsp; &nbsp;oplport=${port1%%-*}<br>
&nbsp;fi<br>
&nbsp;} &lt; $WSSDEV/resources<br>
# To see what's going on here:<br>
# ---------------------------<br>
# &nbsp; cat /sys/devices/pnp0/00:07/resources<br>
#<br>
# &nbsp; state = active<br>
# &nbsp; io 0x530-0x537<br>
# &nbsp; io 0x388-0x38b<br>
# &nbsp; io 0x220-0x233<br>
# &nbsp; irq 5<br>
# &nbsp; dma 1<br>
# &nbsp; dma 0<br>
# &nbsp; ^^^ &nbsp; &quot;bla&quot; labels in first field (discarded).&nbsp;<br>
{ read # Discard first line, as above.<br>
&nbsp; read bla port1<br>
&nbsp; cport=${port1%%-*}<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^<br>
&nbsp; # Just want _start_ address of port.<br>
} &lt; $CTLDEV/resources<br>
# Load the module:<br>
modprobe --ignore-install snd-cs4236 port=$port cport=$cport\<br>
Appendix A. Contributed Scripts<br>
689<br>
<hr>
<A name=696></a>Advanced Bash-Scripting Guide<br>
fm_port=$oplport irq=$irq dma1=$dma1 dma2=$dma2 isapnp=0 index=0<br>
# See the modprobe manpage.<br>
exit $?<br>
<b>Example A-35. Locating split paragraphs in a text file</b><br>
#!/bin/bash<br>
# find-splitpara.sh<br>
# &nbsp;Finds split paragraphs in a text file,<br>
#+ and tags the line numbers.<br>
ARGCOUNT=1 &nbsp; &nbsp; &nbsp; # Expect one arg.<br>
E_WRONGARGS=65<br>
file=&quot;$1&quot; &nbsp; &nbsp; &nbsp; &nbsp;# Target filename.<br>
lineno=1 &nbsp; &nbsp; &nbsp; &nbsp; # Line number. Start at 1.<br>
Flag=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Blank line flag.<br>
if [ $# -ne &quot;$ARGCOUNT&quot; ]<br>
then<br>
&nbsp; echo &quot;Usage: `basename $0` FILENAME&quot;<br>
&nbsp; exit $E_WRONGARGS<br>
fi &nbsp;<br>
file_read () &nbsp; &nbsp; # Scan file for pattern, then print line.<br>
{<br>
while read line<br>
do<br>
&nbsp; if [[ &quot;$line&quot; =~ ^[a-z] &amp;&amp; $Flag -eq 1 ]]<br>
&nbsp; &nbsp; &nbsp;then &nbsp;# Line begins with lc character, following blank line.<br>
&nbsp; &nbsp; &nbsp;echo -n &quot;$lineno:: &nbsp; &quot;<br>
&nbsp; &nbsp; &nbsp;echo &quot;$line&quot;<br>
&nbsp; fi<br>
&nbsp; if [[ &quot;$line&quot; =~ &quot;^$&quot; ]]<br>
&nbsp; &nbsp; &nbsp;then &nbsp; &nbsp; # &nbsp;If blank line,<br>
&nbsp; &nbsp; &nbsp;Flag=1 &nbsp; #+ set flag.<br>
&nbsp; else<br>
&nbsp; &nbsp; &nbsp;Flag=0<br>
&nbsp; fi<br>
&nbsp; ((lineno++))<br>
done<br>
} &lt; $file &nbsp;# Redirect file into function's stdin.<br>
file_read<br>
exit $?<br>
# ----------------------------------------------------------------<br>
This is line one of an example paragraph, bla, bla, bla.<br>
This is line two, and line three should follow on next line, but<br>
Appendix A. Contributed Scripts<br>
690<br>
<hr>
<A name=697></a>Advanced Bash-Scripting Guide<br>
there is a blank line separating the two parts of the paragraph.<br>
# ----------------------------------------------------------------<br>
Running this script on a file containing the above paragraph<br>
yields:<br>
4:: &nbsp; there is a blank line separating the two parts of the paragraph.<br>
There will be additional output for all the other split paragraphs<br>
in the target file.<br>
<b>Example A-36. Insertion sort</b><br>
#!/bin/bash<br>
# insertion-sort.bash: Insertion sort implementation in Bash<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heavy use of Bash array features:<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (string) slicing, merging, etc<br>
# URL: http://www.lugmen.org.ar/~jjo/jjotip/insertion-sort.bash.d<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/insertion-sort.bash.sh<br>
#<br>
# Author: JuanJo Ciarlante &lt;jjo@irrigacion.gov.ar&gt;<br>
# Lightly reformatted by ABS Guide author.<br>
# License: GPLv2<br>
# Used in ABS Guide with author's permission (thanks!).<br>
#<br>
# Test with: &nbsp; ./insertion-sort.bash -t<br>
# Or: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bash insertion-sort.bash -t<br>
# The following *doesn't* work:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sh insertion-sort.bash -t<br>
# &nbsp;Why not? Hint: which Bash-specific features are disabled<br>
#+ when running a script by 'sh script.sh'?<br>
#<br>
: ${DEBUG:=0} &nbsp;# Debug, override with: &nbsp;DEBUG=1 ./scriptname . . .<br>
# Parameter substitution -- set DEBUG to 0 if not previously set.<br>
# Global array: &quot;list&quot;<br>
typeset -a list<br>
# Load whitespace-separated numbers from stdin.<br>
if [ &quot;$1&quot; = &quot;-t&quot; ]; then<br>
DEBUG=1<br>
&nbsp; &nbsp; &nbsp; &nbsp; read -a list &lt; &lt;( od -Ad -w24 -t u2 /dev/urandom ) # Random list.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ ^ &nbsp;process substition<br>
else<br>
&nbsp; &nbsp; &nbsp; &nbsp; read -a list<br>
fi<br>
numelem=${#list[*]}<br>
# &nbsp;Shows the list, marking the element whose index is $1<br>
#+ by surrounding it with the two chars passed as $2.<br>
# &nbsp;Whole line prefixed with $3.<br>
showlist()<br>
&nbsp; {<br>
&nbsp; echo &quot;$3&quot;${list[@]:0:$1} ${2:0:1}${list[$1]}${2:1:1} ${list[@]:$1+1};<br>
&nbsp; }<br>
# Loop _pivot_ -- from second element to end of list.<br>
for(( i=1; i&lt;numelem; i++ )) do<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((DEBUG))&amp;&amp;showlist i &quot;[]&quot; &quot; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # From current _pivot_, back to first element.<br>
Appendix A. Contributed Scripts<br>
691<br>
<hr>
<A name=698></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; for(( j=i; j; j-- )) do<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Search for the 1st elem. less than current &quot;pivot&quot; . . .<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [[ &quot;${list[j-1]}&quot; -le &quot;${list[i]}&quot; ]] &amp;&amp; break<br>
&nbsp; &nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; (( i==j )) &amp;&amp; continue ## No insertion was needed for this element.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # . . . Move list[i] (pivot) to the left of list[j]:<br>
&nbsp; &nbsp; &nbsp; &nbsp; list=(${list[@]:0:j} ${list[i]} ${list[j]}\<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; {0,j-1} &nbsp; &nbsp; &nbsp; &nbsp;{i} &nbsp; &nbsp; &nbsp; {j}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ${list[@]:j+1:i-(j+1)} ${list[@]:i+1})<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; {j+1,i-1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{i+1,last}<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((DEBUG))&amp;&amp;showlist j &quot;&lt;&gt;&quot; &quot;*&quot;<br>
done<br>
echo<br>
echo &nbsp;&quot;------&quot;<br>
echo $'Result:\n'${list[@]}<br>
exit $?<br>
<b>Example A-37. Standard Deviation</b><br>
#!/bin/bash<br>
# sd.sh: Standard Deviation<br>
# &nbsp;The Standard Deviation indicates how consistent a set of data is.<br>
# &nbsp;It shows to what extent the individual data points deviate from the<br>
#+ arithmetic mean, i.e., how much they &quot;bounce around&quot; (or cluster).<br>
# &nbsp;It is essentially the average deviation-distance of the<br>
#+ data points from the mean.<br>
# =========================================================== #<br>
# &nbsp; &nbsp;To calculate the Standard Deviation:<br>
#<br>
# 1 &nbsp;Find the arithmetic mean (average) of all the data points.<br>
# 2 &nbsp;Subtract each data point from the arithmetic mean,<br>
# &nbsp; &nbsp;and square that difference.<br>
# 3 &nbsp;Add all of the individual difference-squares in # 2.<br>
# 4 &nbsp;Divide the sum in # 3 by the number of data points.<br>
# &nbsp; &nbsp;This is known as the &quot;variance.&quot;<br>
# 5 &nbsp;The square root of # 4 gives the Standard Deviation.<br>
# =========================================================== #<br>
count=0 &nbsp; &nbsp; &nbsp; &nbsp; # Number of data points; global.<br>
SC=9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Scale to be used by bc. Nine decimal places.<br>
E_DATAFILE=90 &nbsp; # Data file error.<br>
# ----------------- Set data file ---------------------<br>
if [ ! -z &quot;$1&quot; ] &nbsp;# Specify filename as cmd-line arg?<br>
then<br>
&nbsp; datafile=&quot;$1&quot; # &nbsp;ASCII text file,<br>
else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ one (numerical) data point per line!<br>
&nbsp; datafile=sample.dat<br>
fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;See example data file, below.<br>
if [ ! -e &quot;$datafile&quot; ]<br>
then<br>
&nbsp; echo &quot;\&quot;&quot;$datafile&quot;\&quot; does not exist!&quot;<br>
&nbsp; exit $E_DATAFILE<br>
fi<br>
# -----------------------------------------------------<br>
Appendix A. Contributed Scripts<br>
692<br>
<hr>
<A name=699></a>Advanced Bash-Scripting Guide<br>
arith_mean ()<br>
{<br>
&nbsp; local rt=0 &nbsp; &nbsp; &nbsp; &nbsp; # Running total.<br>
&nbsp; local am=0 &nbsp; &nbsp; &nbsp; &nbsp; # Arithmetic mean.<br>
&nbsp; local ct=0 &nbsp; &nbsp; &nbsp; &nbsp; # Number of data points.<br>
&nbsp; while read value &nbsp; # Read one data point at a time.<br>
&nbsp; do<br>
&nbsp; &nbsp; rt=$(echo &quot;scale=$SC; $rt + $value&quot; | bc)<br>
&nbsp; &nbsp; (( ct++ ))<br>
&nbsp; done<br>
&nbsp; am=$(echo &quot;scale=$SC; $rt / $ct&quot; | bc)<br>
&nbsp; echo $am; return $ct &nbsp; # This function &quot;returns&quot; TWO values!<br>
&nbsp; # &nbsp;Caution: This little trick will not work if $ct &gt; 255!<br>
&nbsp; # &nbsp;To handle a larger number of data points,<br>
&nbsp; #+ simply comment out the &quot;return $ct&quot; above.<br>
} &lt;&quot;$datafile&quot; &nbsp; # Feed in data file.<br>
sd ()<br>
{<br>
&nbsp; mean1=$1 &nbsp;# Arithmetic mean (passed to function).<br>
&nbsp; n=$2 &nbsp; &nbsp; &nbsp;# How many data points.<br>
&nbsp; sum2=0 &nbsp; &nbsp;# Sum of squared differences (&quot;variance&quot;).<br>
&nbsp; avg2=0 &nbsp; &nbsp;# Average of $sum2.<br>
&nbsp; sdev=0 &nbsp; &nbsp;# Standard Deviation.<br>
&nbsp; while read value &nbsp; # Read one line at a time.<br>
&nbsp; do<br>
&nbsp; &nbsp; diff=$(echo &quot;scale=$SC; $mean1 - $value&quot; | bc)<br>
&nbsp; &nbsp; # Difference between arith. mean and data point.<br>
&nbsp; &nbsp; dif2=$(echo &quot;scale=$SC; $diff * $diff&quot; | bc) # Squared.<br>
&nbsp; &nbsp; sum2=$(echo &quot;scale=$SC; $sum2 + $dif2&quot; | bc) # Sum of squares.<br>
&nbsp; done<br>
&nbsp; &nbsp; avg2=$(echo &quot;scale=$SC; $sum2 / $n&quot; | bc) &nbsp;# Avg. of sum of squares.<br>
&nbsp; &nbsp; sdev=$(echo &quot;scale=$SC; sqrt($avg2)&quot; | bc) # Square root =<br>
&nbsp; &nbsp; echo $sdev &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Standard Deviation.<br>
} &lt;&quot;$datafile&quot; &nbsp; # Rewinds data file.<br>
# ======================================================= #<br>
mean=$(arith_mean); count=$? &nbsp; # Two returns from function!<br>
std_dev=$(sd $mean $count)<br>
echo<br>
echo &quot;Number of data points in \&quot;&quot;$datafile&quot;\&quot; = $count&quot;<br>
echo &quot;Arithmetic mean (average) = $mean&quot;<br>
echo &quot;Standard Deviation = $std_dev&quot;<br>
echo<br>
# ======================================================= #<br>
exit<br>
# &nbsp;This script could stand some drastic streamlining,<br>
#+ but not at the cost of reduced legibility, please.<br>
Appendix A. Contributed Scripts<br>
693<br>
<hr>
<A name=700></a>Advanced Bash-Scripting Guide<br>
# ++++++++++++++++++++++++++++++++++++++++ #<br>
# A sample data file (sample1.dat):<br>
# 18.35<br>
# 19.0<br>
# 18.88<br>
# 18.91<br>
# 18.64<br>
# $ sh sd.sh sample1.dat<br>
# Number of data points in &quot;sample1.dat&quot; = 5<br>
# Arithmetic mean (average) = 18.756000000<br>
# Standard Deviation = .235338054<br>
# ++++++++++++++++++++++++++++++++++++++++ #<br>
<b>Example A-38. A<i>&nbsp;pad</i></b><b>&nbsp;file generator for shareware authors</b><br>
#!/bin/bash<br>
# pad.sh<br>
#######################################################<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAD (xml) file creator<br>
#+ Written by Mendel Cooper &lt;thegrendel.abs@gmail.com&gt;.<br>
#+ Released to the Public Domain.<br>
#<br>
# &nbsp;Generates a &quot;PAD&quot; descriptor file for shareware<br>
#+ packages, according to the specifications<br>
#+ of the ASP.<br>
# &nbsp;http://www.asp-shareware.org/pad<br>
#######################################################<br>
# Accepts (optional) save filename as a command-line argument.<br>
if [ -n &quot;$1&quot; ]<br>
then<br>
&nbsp; savefile=$1<br>
else<br>
&nbsp; savefile=save_file.xml &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Default save_file name.<br>
fi &nbsp;<br>
# ===== PAD file headers =====<br>
HDR1=&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;Windows-1252\&quot; ?&gt;&quot;<br>
HDR2=&quot;&lt;XML_DIZ_INFO&gt;&quot;<br>
HDR3=&quot;&lt;MASTER_PAD_VERSION_INFO&gt;&quot;<br>
HDR4=&quot;\t&lt;MASTER_PAD_VERSION&gt;1.15&lt;/MASTER_PAD_VERSION&gt;&quot;<br>
HDR5=&quot;\t&lt;MASTER_PAD_INFO&gt;Portable Application Description, or PAD<br>
for short, is a data set that is used by shareware authors to<br>
disseminate information to anyone interested in their software products.<br>
To find out more go to http://www.asp-shareware.org/pad&lt;/MASTER_PAD_INFO&gt;&quot;<br>
HDR6=&quot;&lt;/MASTER_PAD_VERSION_INFO&gt;&quot;<br>
# ============================<br>
fill_in ()<br>
{<br>
&nbsp; if [ -z &quot;$2&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo -n &quot;$1? &quot; &nbsp; &nbsp; # Get user input.<br>
Appendix A. Contributed Scripts<br>
694<br>
<hr>
<A name=701></a>Advanced Bash-Scripting Guide<br>
&nbsp; else<br>
&nbsp; &nbsp; echo -n &quot;$1 $2? &quot; &nbsp;# Additional query?<br>
&nbsp; fi &nbsp;<br>
&nbsp; read var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # May paste to fill in field.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# This shows how flexible &quot;read&quot; can be.<br>
&nbsp; if [ -z &quot;$var&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo -e &quot;\t\t&lt;$1 /&gt;&quot; &gt;&gt;$savefile &nbsp; &nbsp;# Indent with 2 tabs.<br>
&nbsp; &nbsp; return<br>
&nbsp; else<br>
&nbsp; &nbsp; echo -e &quot;\t\t&lt;$1&gt;$var&lt;/$1&gt;&quot; &gt;&gt;$savefile<br>
&nbsp; &nbsp; return ${#var} &nbsp; &nbsp; # Return length of input string.<br>
&nbsp; fi<br>
} &nbsp; &nbsp;<br>
check_field_length () &nbsp;# Check length of program description fields.<br>
{<br>
&nbsp; # $1 = maximum field length<br>
&nbsp; # $2 = actual field length<br>
&nbsp; if [ &quot;$2&quot; -gt &quot;$1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Warning: Maximum field length of $1 characters exceeded!&quot;<br>
&nbsp; fi<br>
} &nbsp;<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Clear screen.<br>
echo &quot;PAD File Creator&quot;<br>
echo &quot;--- ---- -------&quot;<br>
echo<br>
# Write File Headers to file.<br>
echo $HDR1 &gt;$savefile<br>
echo $HDR2 &gt;&gt;$savefile<br>
echo $HDR3 &gt;&gt;$savefile<br>
echo -e $HDR4 &gt;&gt;$savefile<br>
echo -e $HDR5 &gt;&gt;$savefile<br>
echo $HDR6 &gt;&gt;$savefile<br>
# Company_Info<br>
echo &quot;COMPANY INFO&quot;<br>
CO_HDR=&quot;Company_Info&quot;<br>
echo &quot;&lt;$CO_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Company_Name<br>
fill_in Address_1<br>
fill_in Address_2<br>
fill_in City_Town&nbsp;<br>
fill_in State_Province<br>
fill_in Zip_Postal_Code<br>
fill_in Country<br>
# If applicable:<br>
# fill_in ASP_Member &quot;[Y/N]&quot;<br>
# fill_in ASP_Member_Number<br>
# fill_in ESC_Member &quot;[Y/N]&quot;<br>
fill_in Company_WebSite_URL<br>
clear &nbsp; # Clear screen between sections.<br>
Appendix A. Contributed Scripts<br>
695<br>
<hr>
<A name=702></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;# Contact_Info<br>
echo &quot;CONTACT INFO&quot;<br>
CONTACT_HDR=&quot;Contact_Info&quot;<br>
echo &quot;&lt;$CONTACT_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Author_First_Name<br>
fill_in Author_Last_Name<br>
fill_in Author_Email<br>
fill_in Contact_First_Name<br>
fill_in Contact_Last_Name<br>
fill_in Contact_Email<br>
echo -e &quot;\t&lt;/$CONTACT_HDR&gt;&quot; &gt;&gt;$savefile<br>
&nbsp; &nbsp;# END Contact_Info<br>
clear<br>
&nbsp; &nbsp;# Support_Info<br>
echo &quot;SUPPORT INFO&quot;<br>
SUPPORT_HDR=&quot;Support_Info&quot;<br>
echo &quot;&lt;$SUPPORT_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Sales_Email<br>
fill_in Support_Email<br>
fill_in General_Email<br>
fill_in Sales_Phone<br>
fill_in Support_Phone<br>
fill_in General_Phone<br>
fill_in Fax_Phone<br>
echo -e &quot;\t&lt;/$SUPPORT_HDR&gt;&quot; &gt;&gt;$savefile<br>
&nbsp; &nbsp;# END Support_Info<br>
echo &quot;&lt;/$CO_HDR&gt;&quot; &gt;&gt;$savefile<br>
# END Company_Info<br>
clear<br>
# Program_Info&nbsp;<br>
echo &quot;PROGRAM INFO&quot;<br>
PROGRAM_HDR=&quot;Program_Info&quot;<br>
echo &quot;&lt;$PROGRAM_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Program_Name<br>
fill_in Program_Version<br>
fill_in Program_Release_Month<br>
fill_in Program_Release_Day<br>
fill_in Program_Release_Year<br>
fill_in Program_Cost_Dollars<br>
fill_in Program_Cost_Other<br>
fill_in Program_Type &quot;[Shareware/Freeware/GPL]&quot;<br>
fill_in Program_Release_Status &quot;[Beta, Major Upgrade, etc.]&quot;<br>
fill_in Program_Install_Support<br>
fill_in Program_OS_Support &quot;[Win9x/Win2k/Linux/etc.]&quot;<br>
fill_in Program_Language &quot;[English/Spanish/etc.]&quot;<br>
echo; echo<br>
&nbsp; # File_Info&nbsp;<br>
echo &quot;FILE INFO&quot;<br>
FILEINFO_HDR=&quot;File_Info&quot;<br>
echo &quot;&lt;$FILEINFO_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Filename_Versioned<br>
fill_in Filename_Previous<br>
fill_in Filename_Generic<br>
fill_in Filename_Long<br>
Appendix A. Contributed Scripts<br>
696<br>
<hr>
<A name=703></a>Advanced Bash-Scripting Guide<br>
fill_in File_Size_Bytes<br>
fill_in File_Size_K<br>
fill_in File_Size_MB<br>
echo -e &quot;\t&lt;/$FILEINFO_HDR&gt;&quot; &gt;&gt;$savefile<br>
&nbsp; # END File_Info&nbsp;<br>
clear<br>
&nbsp; # Expire_Info&nbsp;<br>
echo &quot;EXPIRE INFO&quot;<br>
EXPIRE_HDR=&quot;Expire_Info&quot;<br>
echo &quot;&lt;$EXPIRE_HDR&gt;&quot; &gt;&gt;$savefile<br>
fill_in Has_Expire_Info &quot;Y/N&quot;<br>
fill_in Expire_Count<br>
fill_in Expire_Based_On<br>
fill_in Expire_Other_Info<br>
fill_in Expire_Month<br>
fill_in Expire_Day<br>
fill_in Expire_Year<br>
echo -e &quot;\t&lt;/$EXPIRE_HDR&gt;&quot; &gt;&gt;$savefile<br>
&nbsp; # END Expire_Info&nbsp;<br>
clear<br>
&nbsp; # More Program_Info<br>
echo &quot;ADDITIONAL PROGRAM INFO&quot;<br>
fill_in Program_Change_Info<br>
fill_in Program_Specific_Category<br>
fill_in Program_Categories<br>
fill_in Includes_JAVA_VM &quot;[Y/N]&quot;<br>
fill_in Includes_VB_Runtime &quot;[Y/N]&quot;<br>
fill_in Includes_DirectX &quot;[Y/N]&quot;<br>
&nbsp; # END More Program_Info<br>
echo &quot;&lt;/$PROGRAM_HDR&gt;&quot; &gt;&gt;$savefile<br>
# END Program_Info&nbsp;<br>
clear<br>
# Program Description<br>
echo &quot;PROGRAM DESCRIPTIONS&quot;<br>
PROGDESC_HDR=&quot;Program_Descriptions&quot;<br>
echo &quot;&lt;$PROGDESC_HDR&gt;&quot; &gt;&gt;$savefile<br>
LANG=&quot;English&quot;<br>
echo &quot;&lt;$LANG&gt;&quot; &gt;&gt;$savefile<br>
fill_in Keywords &quot;[comma + space separated]&quot;<br>
echo<br>
echo &quot;45, 80, 250, 450, 2000 word program descriptions&quot;<br>
echo &quot;(may cut and paste into field)&quot;<br>
# &nbsp;It would be highly appropriate to compose the following<br>
#+ &quot;Char_Desc&quot; fields with a text editor,<br>
#+ then cut-and-paste the text into the answer fields.<br>
echo<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|---------------45 characters---------------|&quot;<br>
fill_in Char_Desc_45<br>
check_field_length 45 &quot;$?&quot;<br>
echo<br>
fill_in Char_Desc_80<br>
check_field_length 80 &quot;$?&quot;<br>
Appendix A. Contributed Scripts<br>
697<br>
<hr>
<A name=704></a>Advanced Bash-Scripting Guide<br>
fill_in Char_Desc_250<br>
check_field_length 250 &quot;$?&quot;<br>
fill_in Char_Desc_450<br>
fill_in Char_Desc_2000<br>
echo &quot;&lt;/$LANG&gt;&quot; &gt;&gt;$savefile<br>
echo &quot;&lt;/$PROGDESC_HDR&gt;&quot; &gt;&gt;$savefile<br>
# END Program Description<br>
clear<br>
echo &quot;Done.&quot;; echo; echo<br>
echo &quot;Save file is: &nbsp;\&quot;&quot;$savefile&quot;\&quot;&quot;<br>
exit 0<br>
<b>Example A-39. A<i>&nbsp;man page</i></b><b>&nbsp;editor</b><br>
#!/bin/bash<br>
# maned.sh<br>
# A rudimentary man page editor<br>
# Version: 0.1 (Alpha, probably buggy)<br>
# Author: Mendel Cooper &lt;thegrendel.abs@gmail.com&gt;<br>
# Reldate: 16 June 2008<br>
# License: GPL3<br>
savefile= &nbsp; &nbsp; &nbsp;# Global, used in multiple functions.<br>
E_NOINPUT=90 &nbsp; # User input missing (error). May or may not be critical.<br>
# =========== Markup Tags ============ #<br>
TopHeader=&quot;.TH&quot;<br>
NameHeader=&quot;.SH NAME&quot;<br>
SyntaxHeader=&quot;.SH SYNTAX&quot;<br>
SynopsisHeader=&quot;.SH SYNOPSIS&quot;<br>
InstallationHeader=&quot;.SH INSTALLATION&quot;<br>
DescHeader=&quot;.SH DESCRIPTION&quot;<br>
OptHeader=&quot;.SH OPTIONS&quot;<br>
FilesHeader=&quot;.SH FILES&quot;<br>
EnvHeader=&quot;.SH ENVIRONMENT&quot;<br>
AuthHeader=&quot;.SH AUTHOR&quot;<br>
BugsHeader=&quot;.SH BUGS&quot;<br>
SeeAlsoHeader=&quot;.SH SEE ALSO&quot;<br>
BOLD=&quot;.B&quot;<br>
# Add more tags, as needed.<br>
# See groff docs for markup meanings.<br>
# ==================================== #<br>
start ()<br>
{<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Clear screen.<br>
echo &quot;ManEd&quot;<br>
echo &quot;-----&quot;<br>
echo<br>
echo &quot;Simple man page creator&quot;<br>
echo &quot;Author: Mendel Cooper&quot;<br>
echo; echo; echo<br>
}<br>
progname ()<br>
Appendix A. Contributed Scripts<br>
698<br>
<hr>
<A name=705></a>Advanced Bash-Scripting Guide<br>
{<br>
&nbsp; echo -n &quot;Program name? &quot;<br>
&nbsp; read name<br>
&nbsp; echo -n &quot;Manpage section? [Hit RETURN for default (\&quot;1\&quot;) ] &nbsp;&quot;<br>
&nbsp; read section<br>
&nbsp; if [ -z &quot;$section&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; section=1 &nbsp; # Most man pages are in section 1.<br>
&nbsp; fi<br>
&nbsp; if [ -n &quot;$name&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; savefile=&quot;&quot;$name&quot;.&quot;$section&quot;&quot; &nbsp; &nbsp; &nbsp; # &nbsp;Filename suffix = section.<br>
&nbsp; &nbsp; echo -n &quot;$1 &quot; &gt;&gt;$savefile<br>
&nbsp; &nbsp; name1=$(echo &quot;$name&quot; | tr a-z A-Z) &nbsp;# &nbsp;Change to uppercase,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ per man page convention.<br>
&nbsp; &nbsp; echo -n &quot;$name1&quot; &gt;&gt;$savefile<br>
&nbsp; else<br>
&nbsp; &nbsp; echo &quot;Error! No input.&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Mandatory input.<br>
&nbsp; &nbsp; exit $E_NOINPUT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Critical!<br>
&nbsp; &nbsp; # &nbsp;Exercise: The script-abort if no filename input is a bit clumsy.<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rewrite this section so a default filename is used<br>
&nbsp; &nbsp; #+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if no input.<br>
&nbsp; fi<br>
&nbsp; echo -n &quot; &nbsp;\&quot;$section\&quot;&quot;&gt;&gt;$savefile &nbsp; # Append, always append.<br>
&nbsp; echo -n &quot;Version? &quot;<br>
&nbsp; read ver<br>
&nbsp; echo -n &quot; \&quot;Version $ver \&quot;&quot;&gt;&gt;$savefile<br>
&nbsp; echo &gt;&gt;$savefile<br>
&nbsp; echo -n &quot;Short description [0 - 5 words]? &quot;<br>
&nbsp; read sdesc<br>
&nbsp; echo &quot;$NameHeader&quot;&gt;&gt;$savefile<br>
&nbsp; echo &quot;&quot;$BOLD&quot; &quot;$name&quot;&quot;&gt;&gt;$savefile<br>
&nbsp; echo &quot;\- &quot;$sdesc&quot;&quot;&gt;&gt;$savefile<br>
}<br>
fill_in ()<br>
{ # This function more or less copied from &quot;pad.sh&quot; script.<br>
&nbsp; echo -n &quot;$2? &quot; &nbsp; &nbsp; &nbsp; # Get user input.<br>
&nbsp; read var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # May paste (a single line only!) to fill in field.<br>
&nbsp; if [ -n &quot;$var&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;$1 &quot; &gt;&gt;$savefile<br>
&nbsp; &nbsp; echo -n &quot;$var&quot; &gt;&gt;$savefile<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Don't append empty field to file.<br>
&nbsp; &nbsp; return $E_NOINPUT &nbsp;# Not critical here.<br>
&nbsp; fi<br>
&nbsp; echo &gt;&gt;$savefile<br>
} &nbsp; &nbsp;<br>
end ()<br>
{<br>
clear<br>
Appendix A. Contributed Scripts<br>
699<br>
<hr>
<A name=706></a>Advanced Bash-Scripting Guide<br>
echo -n &quot;Would you like to view the saved man page (y/n)? &quot;<br>
read ans<br>
if [ &quot;$ans&quot; = &quot;n&quot; -o &quot;$ans&quot; = &quot;N&quot; ]; then exit; fi<br>
exec less &quot;$savefile&quot; &nbsp;# &nbsp;Exit script and hand off control to &quot;less&quot; ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ ... which formats for viewing man page source.<br>
}<br>
# ---------------------------------------- #<br>
start<br>
progname &quot;$TopHeader&quot;<br>
fill_in &quot;$SynopsisHeader&quot; &quot;Synopsis&quot;<br>
fill_in &quot;$DescHeader&quot; &quot;Long description&quot;<br>
# May paste in *single line* of text.<br>
fill_in &quot;$OptHeader&quot; &quot;Options&quot;<br>
fill_in &quot;$FilesHeader&quot; &quot;Files&quot;<br>
fill_in &quot;$AuthHeader&quot; &quot;Author&quot;<br>
fill_in &quot;$BugsHeader&quot; &quot;Bugs&quot;<br>
fill_in &quot;$SeeAlsoHeader&quot; &quot;See also&quot;<br>
# fill_in &quot;$OtherHeader&quot; ... as necessary.<br>
end &nbsp; &nbsp;# ... exit not needed.<br>
# ---------------------------------------- #<br>
# &nbsp;Note that the generated man page will usually<br>
#+ require manual fine-tuning with a text editor.<br>
# &nbsp;However, it's a distinct improvement upon<br>
#+ writing man source from scratch<br>
#+ or even editing a blank man page template.<br>
# &nbsp;The main deficiency of the script is that it permits<br>
#+ pasting only a single text line into the input fields.<br>
# &nbsp;This may be a long, cobbled-together line, which groff<br>
# &nbsp;will automatically wrap and hyphenate.<br>
# &nbsp;However, if you want multiple (newline-separated) paragraphs,<br>
#+ these must be inserted by manual text editing on the<br>
#+ script-generated man page.<br>
# &nbsp;Exercise (difficult): Fix this!<br>
# &nbsp;This script is not nearly as elaborate as the<br>
#+ full-featured &quot;manedit&quot; package<br>
#+ http://freshmeat.net/projects/manedit/<br>
#+ but it's much easier to use.<br>
<b>Example A-40. Petals Around the Rose</b><br>
#!/bin/bash -i<br>
# petals.sh<br>
#########################################################################<br>
# Petals Around the Rose &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# Version 0.1 Created by Serghey Rodin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# Version 0.2 Modded by ABS Guide Author &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# License: GPL3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# Used in ABS Guide with permission. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# ##################################################################### #<br>
hits=0 &nbsp; &nbsp; &nbsp;# Correct guesses.<br>
WIN=6 &nbsp; &nbsp; &nbsp; # Mastered the game.<br>
ALMOST=5 &nbsp; &nbsp;# One short of mastery.<br>
Appendix A. Contributed Scripts<br>
700<br>
<hr>
<A name=707></a>Advanced Bash-Scripting Guide<br>
EXIT=exit &nbsp; # Give up early?<br>
RANDOM=$$ &nbsp; # Seeds the random number generator from PID of script.<br>
# Bones (ASCII graphics for dice)<br>
bone1[1]=&quot;| &nbsp; &nbsp; &nbsp; &nbsp; |&quot;<br>
bone1[2]=&quot;| &nbsp; &nbsp; &nbsp; o |&quot;<br>
bone1[3]=&quot;| &nbsp; &nbsp; &nbsp; o |&quot;<br>
bone1[4]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone1[5]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone1[6]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone2[1]=&quot;| &nbsp; &nbsp;o &nbsp; &nbsp;|&quot;<br>
bone2[2]=&quot;| &nbsp; &nbsp; &nbsp; &nbsp; |&quot;<br>
bone2[3]=&quot;| &nbsp; &nbsp;o &nbsp; &nbsp;|&quot;<br>
bone2[4]=&quot;| &nbsp; &nbsp; &nbsp; &nbsp; |&quot;<br>
bone2[5]=&quot;| &nbsp; &nbsp;o &nbsp; &nbsp;|&quot;<br>
bone2[6]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone3[1]=&quot;| &nbsp; &nbsp; &nbsp; &nbsp; |&quot;<br>
bone3[2]=&quot;| o &nbsp; &nbsp; &nbsp; |&quot;<br>
bone3[3]=&quot;| o &nbsp; &nbsp; &nbsp; |&quot;<br>
bone3[4]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone3[5]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone3[6]=&quot;| o &nbsp; &nbsp; o |&quot;<br>
bone=&quot;+---------+&quot;<br>
# Functions<br>
instructions () {<br>
&nbsp; clear<br>
&nbsp; echo -n &quot;Do you need instructions? (y/n) &quot;; read ans<br>
&nbsp; if [ &quot;$ans&quot; = &quot;y&quot; -o &quot;$ans&quot; = &quot;Y&quot; ]; then<br>
&nbsp; &nbsp; clear<br>
&nbsp; &nbsp; echo -e '\E[34;47m' &nbsp;# Blue type.<br>
# &nbsp;&quot;cat document&quot;<br>
&nbsp; &nbsp; cat &lt;&lt;INSTRUCTIONSZZZ<br>
The name of the game is Petals Around the Rose,<br>
and that name is significant.<br>
Five dice will roll and you must guess the &quot;answer&quot; for each roll.<br>
It will be zero or an even number.<br>
After your guess, you will be told the answer for the roll, but . . .<br>
that's ALL the information you will get.<br>
Six consecutive correct guesses admits you to the<br>
Fellowship of the Rose.<br>
INSTRUCTIONSZZZ<br>
&nbsp; &nbsp; echo -e &quot;\033[0m&quot; &nbsp; &nbsp;# Turn off blue.<br>
&nbsp; &nbsp; else clear<br>
&nbsp; fi<br>
}<br>
fortune ()<br>
{<br>
&nbsp; RANGE=7<br>
&nbsp; FLOOR=0<br>
Appendix A. Contributed Scripts<br>
701<br>
<hr>
<A name=708></a>Advanced Bash-Scripting Guide<br>
&nbsp; number=0<br>
&nbsp; while [ &quot;$number&quot; -le $FLOOR ]<br>
&nbsp; do<br>
&nbsp; &nbsp; number=$RANDOM<br>
&nbsp; &nbsp; let &quot;number %= $RANGE&quot; &nbsp; # 1 - 6.<br>
&nbsp; done<br>
&nbsp; return $number<br>
}<br>
throw () { # Calculate each individual die.<br>
&nbsp; fortune; B1=$?<br>
&nbsp; fortune; B2=$?<br>
&nbsp; fortune; B3=$?<br>
&nbsp; fortune; B4=$?<br>
&nbsp; fortune; B5=$?<br>
&nbsp; calc () { # Function embedded within a function!<br>
&nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; ) rose=2;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; ) rose=4;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;* &nbsp; ) rose=0;;<br>
&nbsp; &nbsp; esac &nbsp; &nbsp;# Simplified algorithm.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Doesn't really get to the heart of the matter.<br>
&nbsp; &nbsp; return $rose<br>
&nbsp; }<br>
&nbsp; answer=0<br>
&nbsp; calc &quot;$B1&quot;; answer=$(expr $answer + $(echo $?))<br>
&nbsp; calc &quot;$B2&quot;; answer=$(expr $answer + $(echo $?))<br>
&nbsp; calc &quot;$B3&quot;; answer=$(expr $answer + $(echo $?))<br>
&nbsp; calc &quot;$B4&quot;; answer=$(expr $answer + $(echo $?))<br>
&nbsp; calc &quot;$B5&quot;; answer=$(expr $answer + $(echo $?))<br>
}<br>
game ()<br>
{ # Generate graphic display of dice throw.<br>
&nbsp; throw<br>
&nbsp; &nbsp; echo -e &quot;\033[1m&quot; &nbsp; &nbsp;# Bold.<br>
&nbsp; echo -e &quot;\n&quot;<br>
&nbsp; echo -e &quot;$bone\t$bone\t$bone\t$bone\t$bone&quot;<br>
&nbsp; echo -e \<br>
&nbsp;&quot;${bone1[$B1]}\t${bone1[$B2]}\t${bone1[$B3]}\t${bone1[$B4]}\t${bone1[$B5]}&quot;<br>
&nbsp; echo -e \<br>
&nbsp;&quot;${bone2[$B1]}\t${bone2[$B2]}\t${bone2[$B3]}\t${bone2[$B4]}\t${bone2[$B5]}&quot;<br>
&nbsp; echo -e \<br>
&nbsp;&quot;${bone3[$B1]}\t${bone3[$B2]}\t${bone3[$B3]}\t${bone3[$B4]}\t${bone3[$B5]}&quot;<br>
&nbsp; echo -e &quot;$bone\t$bone\t$bone\t$bone\t$bone&quot;<br>
&nbsp; echo -e &quot;\n\n\t\t&quot;<br>
&nbsp; &nbsp; echo -e &quot;\033[0m&quot; &nbsp; &nbsp;# Turn off bold.<br>
&nbsp; echo -n &quot;There are how many petals around the rose? &quot;<br>
}<br>
# ============================================================== #<br>
instructions<br>
Appendix A. Contributed Scripts<br>
702<br>
<hr>
<A name=709></a>Advanced Bash-Scripting Guide<br>
while [ &quot;$petal&quot; != &quot;$EXIT&quot; ] &nbsp; &nbsp;# Main loop.<br>
do<br>
&nbsp; game<br>
&nbsp; read petal<br>
&nbsp; echo &quot;$petal&quot; | grep [0-9] &gt;/dev/null &nbsp;# Filter response for digit.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Otherwise just roll dice again.<br>
&nbsp; if [ &quot;$?&quot; -eq 0 ] &nbsp; # If-loop #1.<br>
&nbsp; then<br>
&nbsp; &nbsp; if [ &quot;$petal&quot; == &quot;$answer&quot; ]; then &nbsp; &nbsp;# If-loop #2.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -e &quot;\nCorrect. There are $petal petals around the rose.\n&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; (( hits++ ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;$hits&quot; -eq &quot;$WIN&quot; ]; then &nbsp; # If-loop #3.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e '\E[31;47m' &nbsp;# Red type.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e &quot;\033[1m&quot; &nbsp; &nbsp;# Bold.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;You have unraveled the mystery of the Rose Petals!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Welcome to the Fellowship of the Rose!!!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;(You are herewith sworn to secrecy.)&quot;; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e &quot;\033[0m&quot; &nbsp; &nbsp;# Turn off red &amp; bold.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Exit!<br>
&nbsp; &nbsp; &nbsp; &nbsp; else echo &quot;You have $hits correct so far.&quot;; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;$hits&quot; -eq &quot;$ALMOST&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Just one more gets you to the heart of the mystery!&quot;; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Close if-loop #3.<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; echo -e &quot;\nWrong. There are $answer petals around the rose.\n&quot;<br>
&nbsp; &nbsp; &nbsp; hits=0 &nbsp; # Reset number of correct guesses.<br>
&nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Close if-loop #2.<br>
&nbsp; &nbsp; echo -n &quot;Hit ENTER for the next roll, or type \&quot;exit\&quot; to end. &quot;<br>
&nbsp; &nbsp; read<br>
&nbsp; &nbsp; if [ &quot;$REPLY&quot; = &quot;$EXIT&quot; ]; then exit<br>
&nbsp; &nbsp; fi<br>
&nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Close if-loop #1.<br>
&nbsp; clear<br>
done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# End of main (while) loop.<br>
###<br>
exit $?<br>
# Resources:<br>
# ---------<br>
# 1) http://en.wikipedia.org/wiki/Petals_Around_the_Rose<br>
# &nbsp; &nbsp;(Wikipedia entry.)<br>
# 2) http://www.borrett.id.au/computing/petals-bg.htm<br>
# &nbsp; &nbsp;(How Bill Gates coped with the Petals Around the Rose challenge.)<br>
<b>Example A-41. Quacky: a Perquackey-type word game</b><br>
#!/bin/bash<br>
# qky.sh<br>
##############################################################<br>
Appendix A. Contributed Scripts<br>
703<br>
<hr>
<A name=710></a>Advanced Bash-Scripting Guide<br>
# QUACKEY: a somewhat simplified version of Perquackey [TM]. #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# Author: Mendel Cooper &nbsp;&lt;thegrendel.abs@gmail.com&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# version 0.1.02 &nbsp; &nbsp; &nbsp;03 May, 2008 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# License: GPL3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
##############################################################<br>
WLIST=/usr/share/dict/word.lst<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^ &nbsp;Word list file found here.<br>
# &nbsp;ASCII word list, one word per line, UNIX format.<br>
# &nbsp;A suggested list is the script author's &quot;yawl&quot; word list package.<br>
# &nbsp;http://bash.webofcrafts.net/yawl-0.3.2.tar.gz<br>
# &nbsp; &nbsp;or<br>
# &nbsp;http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz<br>
NONCONS=0 &nbsp; &nbsp; # Word not constructable from letter set.<br>
CONS=1 &nbsp; &nbsp; &nbsp; &nbsp;# Constructable.<br>
SUCCESS=0<br>
NG=1<br>
FAILURE=''<br>
NULL=0 &nbsp; &nbsp; &nbsp; &nbsp;# Zero out value of letter (if found).<br>
MINWLEN=3 &nbsp; &nbsp; # Minimum word length.<br>
MAXCAT=5 &nbsp; &nbsp; &nbsp;# Maximum number of words in a given category.<br>
PENALTY=200 &nbsp; # General-purpose penalty for unacceptable words.<br>
total=<br>
E_DUP=70 &nbsp; &nbsp; &nbsp;# Duplicate word error.<br>
TIMEOUT=10 &nbsp; &nbsp;# Time for word input.<br>
NVLET=10 &nbsp; &nbsp; &nbsp;# 10 letters for non-vulnerable.<br>
VULET=13 &nbsp; &nbsp; &nbsp;# 13 letters for vulnerable (not yet implemented).<br>
declare -a Words<br>
declare -a Status<br>
declare -a Score=( 0 0 0 0 0 0 0 0 0 0 0 )<br>
letters=( a n s r t m l k p r b c i d s i d z e w u e t f<br>
e y e r e f e g t g h h i t r s c i t i d i j a t a o l a<br>
m n a n o v n w o s e l n o s p a q e e r a b r s a o d s<br>
t g t i t l u e u v n e o x y m r k )<br>
# &nbsp;Letter distribution table shamelessly borrowed from &quot;Wordy&quot; game,<br>
#+ ca. 1992, written by a certain fine fellow named Mendel Cooper.<br>
declare -a LS<br>
numelements=${#letters[@]}<br>
randseed=&quot;$1&quot;<br>
instructions ()<br>
{<br>
&nbsp; clear<br>
&nbsp; echo &quot;Welcome to QUACKEY, the anagramming word construction game.&quot;; echo<br>
&nbsp; echo -n &quot;Do you need instructions? (y/n) &quot;; read ans<br>
&nbsp; &nbsp;if [ &quot;$ans&quot; = &quot;y&quot; -o &quot;$ans&quot; = &quot;Y&quot; ]; then<br>
&nbsp; &nbsp; &nbsp;clear<br>
&nbsp; &nbsp; &nbsp;echo -e '\E[31;47m' &nbsp;# Red foreground. '\E[34;47m' for blue.<br>
&nbsp; &nbsp; &nbsp;cat &lt;&lt;INSTRUCTION1<br>
QUACKEY is a variant of Perquackey [TM].<br>
The rules are the same, but the scoring is simplified<br>
Appendix A. Contributed Scripts<br>
704<br>
<hr>
<A name=711></a>Advanced Bash-Scripting Guide<br>
and plurals of previously played words are allowed.<br>
&quot;Vulnerable&quot; play is not yet implemented,<br>
but it is otherwise feature-complete.<br>
As the game begins, the player gets 10 letters.<br>
The object is to construct valid dictionary words<br>
of at least 3-letter-length from the letterset.<br>
Each word-length category<br>
-- 3-letter, 4-letter, 5-letter, ... --<br>
fills up with the fifth word entered,<br>
and no further words in that category are accepted.<br>
The penalty for too-short (two-letter), duplicate, unconstructable,<br>
and invalid (not in dictionary) words is -200. The same penalty applies<br>
to attempts to enter a word in a filled-up category.<br>
INSTRUCTION1<br>
&nbsp; echo -n &quot;Hit ENTER for next page of instructions. &quot;; read az1<br>
&nbsp; &nbsp; &nbsp;cat &lt;&lt;INSTRUCTION2<br>
The scoring mostly corresponds to classic Perquackey:<br>
The first 3-letter word scores &nbsp; &nbsp;60, plus &nbsp; 10 for each additional one.<br>
The first 4-letter word scores &nbsp; 120, plus &nbsp; 20 for each additional one.<br>
The first 5-letter word scores &nbsp; 200, plus &nbsp; 50 for each additional one.<br>
The first 6-letter word scores &nbsp; 300, plus &nbsp;100 for each additional one.<br>
The first 7-letter word scores &nbsp; 500, plus &nbsp;150 for each additional one.<br>
The first 8-letter word scores &nbsp; 750, plus &nbsp;250 for each additional one.<br>
The first 9-letter word scores &nbsp;1000, plus &nbsp;500 for each additional one.<br>
The first 10-letter word scores 2000, plus 2000 for each additional one.<br>
Category completion bonuses are:<br>
3-letter words &nbsp; 100<br>
4-letter words &nbsp; 200<br>
5-letter words &nbsp; 400<br>
6-letter words &nbsp; 800<br>
7-letter words &nbsp;2000<br>
8-letter words 10000<br>
This is a simplification of the absurdly complicated Perquackey bonus<br>
scoring system.<br>
INSTRUCTION2<br>
&nbsp; echo -n &quot;Hit ENTER for final page of instructions. &quot;; read az1<br>
&nbsp; &nbsp; &nbsp;cat &lt;&lt;INSTRUCTION3<br>
Hitting just ENTER for a word entry ends the game.<br>
Individual word entry is timed to a maximum of 10 seconds.<br>
*** Timing out on an entry ends the game. ***<br>
Other than that, the game is untimed.<br>
--------------------------------------------------<br>
Game statistics are automatically saved to a file.<br>
--------------------------------------------------<br>
For competitive (&quot;duplicate&quot;) play, a previous letterset<br>
may be duplicated by repeating the script's random seed,<br>
command-line parameter \$1.<br>
Appendix A. Contributed Scripts<br>
705<br>
<hr>
<A name=712></a>Advanced Bash-Scripting Guide<br>
For example, &quot;qky 7633&quot; specifies the letterset&nbsp;<br>
c a d i f r h u s k ...<br>
INSTRUCTION3<br>
&nbsp; echo; echo -n &quot;Hit ENTER to begin game. &quot;; read az1<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo -e &quot;\033[0m&quot; &nbsp; &nbsp;# Turn off red.<br>
&nbsp; &nbsp; &nbsp;else clear<br>
&nbsp; fi<br>
&nbsp; clear<br>
}<br>
seed_random ()<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Seed random number generator.<br>
&nbsp; if [ -n &quot;$randseed&quot; ] &nbsp; # &nbsp;Can specify random seed.<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ for play in competitive mode.<br>
# &nbsp; RANDOM=&quot;$randseed&quot;<br>
&nbsp; &nbsp; echo &quot;RANDOM seed set to &quot;$randseed&quot;&quot;<br>
&nbsp; else<br>
&nbsp; &nbsp; randseed=&quot;$$&quot; &nbsp; &nbsp; &nbsp; &nbsp; # Or get random seed from process ID.<br>
&nbsp; &nbsp; echo &quot;RANDOM seed not specified, set to Process ID of script ($$).&quot;<br>
&nbsp; fi<br>
&nbsp; RANDOM=&quot;$randseed&quot;<br>
&nbsp; echo<br>
}<br>
get_letset ()<br>
{<br>
&nbsp; element=0<br>
&nbsp; echo -n &quot;Letterset:&quot;<br>
&nbsp; for lset in $(seq $NVLET)<br>
&nbsp; do &nbsp;# Pick random letters to fill out letterset.<br>
&nbsp; &nbsp; LS[element]=&quot;${letters[$((RANDOM%numelements))]}&quot;<br>
&nbsp; &nbsp; ((element++))<br>
&nbsp; done<br>
&nbsp; echo<br>
&nbsp; echo &quot;${LS[@]}&quot;<br>
}<br>
add_word ()<br>
{<br>
&nbsp; wrd=&quot;$1&quot;<br>
&nbsp; local idx=0<br>
&nbsp; Status[0]=&quot;&quot;<br>
&nbsp; Status[3]=&quot;&quot;<br>
&nbsp; Status[4]=&quot;&quot;<br>
&nbsp; while [ &quot;${Words[idx]}&quot; != '' ]<br>
&nbsp; do<br>
&nbsp; &nbsp; if [ &quot;${Words[idx]}&quot; = &quot;$wrd&quot; ]<br>
Appendix A. Contributed Scripts<br>
706<br>
<hr>
<A name=713></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; Status[3]=&quot;Duplicate-word-PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;Score[0]= 0 - $PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;Score[1]-=$PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; return $E_DUP<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; ((idx++))<br>
&nbsp; done<br>
&nbsp; Words[idx]=&quot;$wrd&quot;<br>
&nbsp; get_score<br>
}<br>
get_score()<br>
{<br>
&nbsp; local wlen=0<br>
&nbsp; local score=0<br>
&nbsp; local bonus=0<br>
&nbsp; local first_word=0<br>
&nbsp; local add_word=0<br>
&nbsp; local numwords=0<br>
&nbsp; wlen=${#wrd}<br>
&nbsp; numwords=${Score[wlen]}<br>
&nbsp; Score[2]=0<br>
&nbsp; Status[4]=&quot;&quot; &nbsp; # Initialize &quot;bonus&quot; to 0.<br>
&nbsp; case &quot;$wlen&quot; in<br>
&nbsp; &nbsp; 3) first_word=60<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=10;;<br>
&nbsp; &nbsp; 4) first_word=120<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=20;;<br>
&nbsp; &nbsp; 5) first_word=200<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=50;;<br>
&nbsp; &nbsp; 6) first_word=300<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=100;;<br>
&nbsp; &nbsp; 7) first_word=500<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=150;;<br>
&nbsp; &nbsp; 8) first_word=750<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=250;;<br>
&nbsp; &nbsp; 9) first_word=1000<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=500;;<br>
&nbsp; &nbsp;10) first_word=2000<br>
&nbsp; &nbsp; &nbsp; &nbsp;add_word=2000;; &nbsp; # This category modified from original rules!<br>
&nbsp; &nbsp; &nbsp; esac<br>
&nbsp; ((Score[wlen]++))<br>
&nbsp; if [ ${Score[wlen]} -eq $MAXCAT ]<br>
&nbsp; then &nbsp; # Category completion bonus scoring simplified!<br>
&nbsp; &nbsp; case $wlen in<br>
&nbsp; &nbsp; &nbsp; 3 ) bonus=100;;<br>
&nbsp; &nbsp; &nbsp; 4 ) bonus=200;;<br>
&nbsp; &nbsp; &nbsp; 5 ) bonus=400;;<br>
&nbsp; &nbsp; &nbsp; 6 ) bonus=800;;<br>
&nbsp; &nbsp; &nbsp; 7 ) bonus=2000;;<br>
&nbsp; &nbsp; &nbsp; 8 ) bonus=10000;;<br>
&nbsp; &nbsp; esac &nbsp;# Needn't worry about 9's and 10's.<br>
&nbsp; &nbsp; Status[4]=&quot;Category-$wlen-completion***BONUS***&quot;<br>
&nbsp; &nbsp; Score[2]=$bonus<br>
&nbsp; else<br>
Appendix A. Contributed Scripts<br>
707<br>
<hr>
<A name=714></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; Status[4]=&quot;&quot; &nbsp; # Erase it.<br>
&nbsp; fi<br>
&nbsp; &nbsp; let &quot;score = &nbsp;$first_word + &nbsp; $add_word * $numwords&quot;<br>
&nbsp; &nbsp; if [ &quot;$numwords&quot; -eq 0 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; Score[0]=$score<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; Score[0]=$add_word<br>
&nbsp; &nbsp; fi &nbsp; # &nbsp;All this to distinguish last-word score<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ from total running score.<br>
&nbsp; let &quot;Score[1] += ${Score[0]}&quot;<br>
&nbsp; let &quot;Score[1] += ${Score[2]}&quot;<br>
}<br>
get_word ()<br>
{<br>
&nbsp; local wrd=''<br>
&nbsp; read -t $TIMEOUT wrd &nbsp; # Timed read.<br>
&nbsp; echo $wrd<br>
}<br>
is_constructable ()<br>
{ # This was the most complex and difficult-to-write function.<br>
&nbsp; local -a local_LS=( &quot;${LS[@]}&quot; ) &nbsp;# Local copy of letter set.<br>
&nbsp; local is_found=0<br>
&nbsp; local idx=0<br>
&nbsp; local pos<br>
&nbsp; local strlen<br>
&nbsp; local local_word=( &quot;$1&quot; )<br>
&nbsp; strlen=${#local_word}<br>
&nbsp; while [ &quot;$idx&quot; -lt &quot;$strlen&quot; ]<br>
&nbsp; do<br>
&nbsp; &nbsp; is_found=$(expr index &quot;${local_LS[*]}&quot; &quot;${local_word:idx:1}&quot;)<br>
&nbsp; &nbsp; if [ &quot;$is_found&quot; -eq &quot;$NONCONS&quot; ] # Not constructable!<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;$FAILURE&quot;; return<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((pos = ($is_found - 1) / 2)) &nbsp; # Compensate for spaces betw. letters!<br>
&nbsp; &nbsp; &nbsp; local_LS[pos]=$NULL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Zero out used letters.<br>
&nbsp; &nbsp; &nbsp; ((idx++)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Bump index.<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; echo &quot;$SUCCESS&quot;<br>
&nbsp; return<br>
}<br>
is_valid ()<br>
{ # Surprisingly easy to check if word in dictionary ...<br>
&nbsp; fgrep -qw &quot;$1&quot; &quot;$WLIST&quot; &nbsp; # ... thanks to 'grep' ...<br>
&nbsp; echo $?<br>
}<br>
check_word ()<br>
{<br>
&nbsp; if [ -z &quot;$1&quot; ]<br>
Appendix A. Contributed Scripts<br>
708<br>
<hr>
<A name=715></a>Advanced Bash-Scripting Guide<br>
&nbsp; then<br>
&nbsp; &nbsp; return<br>
&nbsp; fi<br>
&nbsp; Status[1]=&quot;&quot;<br>
&nbsp; Status[2]=&quot;&quot;<br>
&nbsp; Status[3]=&quot;&quot;<br>
&nbsp; Status[4]=&quot;&quot;<br>
&nbsp; iscons=$(is_constructable &quot;$1&quot;)<br>
&nbsp; if [ &quot;$iscons&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; Status[1]=&quot;constructable&quot;&nbsp;<br>
&nbsp; &nbsp; v=$(is_valid &quot;$1&quot;)<br>
&nbsp; &nbsp; if [ &quot;$v&quot; -eq &quot;$SUCCESS&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; Status[2]=&quot;valid&quot;&nbsp;<br>
&nbsp; &nbsp; &nbsp; strlen=${#1}<br>
&nbsp; &nbsp; &nbsp; if [ ${Score[strlen]} -eq &quot;$MAXCAT&quot; ] &nbsp; # Category full!<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; Status[3]=&quot;Category-$strlen-overflow-PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; return $NG<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; case &quot;$strlen&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1 | 2 )<br>
&nbsp; &nbsp; &nbsp; &nbsp; Status[3]=&quot;Two-letter-word-PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; return $NG;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; * )&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Status[3]=&quot;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; return $SUCCESS;;<br>
&nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; Status[3]=&quot;Not-valid-PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; return $NG<br>
&nbsp; &nbsp; fi<br>
&nbsp; else<br>
&nbsp; &nbsp; Status[3]=&quot;Not-constructable-PENALTY&quot;&nbsp;<br>
&nbsp; &nbsp; &nbsp; return $NG<br>
&nbsp; fi<br>
&nbsp; ### FIXME: Streamline the above code.<br>
}<br>
display_words ()<br>
{<br>
&nbsp; local idx=0<br>
&nbsp; local wlen0<br>
&nbsp; clear<br>
&nbsp; echo &quot;Letterset: &nbsp; ${LS[@]}&quot;<br>
&nbsp; echo &quot;Threes: &nbsp; &nbsp;Fours: &nbsp; &nbsp;Fives: &nbsp; &nbsp; Sixes: &nbsp; &nbsp;Sevens: &nbsp; &nbsp;Eights:&quot;<br>
&nbsp; echo &quot;------------------------------------------------------------&quot;<br>
&nbsp; while [ &quot;${Words[idx]}&quot; != '' ]<br>
&nbsp; do<br>
&nbsp; &nbsp;wlen0=${#Words[idx]}<br>
Appendix A. Contributed Scripts<br>
709<br>
<hr>
<A name=716></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp;case &quot;$wlen0&quot; in<br>
&nbsp; &nbsp; &nbsp;3) ;;<br>
&nbsp; &nbsp; &nbsp;4) echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot; ;;<br>
&nbsp; &nbsp; &nbsp;5) echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot; ;;<br>
&nbsp; &nbsp; &nbsp;6) echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot; ;;<br>
&nbsp; &nbsp; &nbsp;7) echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot; ;;<br>
&nbsp; &nbsp; &nbsp;8) echo -n &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot; ;;<br>
&nbsp; &nbsp;esac<br>
&nbsp; &nbsp;echo &quot;${Words[idx]}&quot;<br>
&nbsp; &nbsp;((idx++))<br>
&nbsp; done<br>
&nbsp; ### FIXME: The word display is pretty crude.<br>
}<br>
play ()<br>
{<br>
&nbsp; word=&quot;Start game&quot; &nbsp; # Dummy word, to start ...<br>
&nbsp; while [ &quot;$word&quot; ] &nbsp; # &nbsp;If player just hits return (blank word),<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ then game ends.<br>
&nbsp; &nbsp; echo &quot;$word: &quot;${Status[@]}&quot;&quot;<br>
&nbsp; &nbsp; echo -n &quot;Last score: [${Score[0]}] &nbsp; TOTAL score: [${Score[1]}]: &nbsp; &nbsp; Next word: &quot;<br>
&nbsp; &nbsp; total=${Score[1]}<br>
&nbsp; &nbsp; word=$(get_word)<br>
&nbsp; &nbsp; check_word &quot;$word&quot;<br>
&nbsp; &nbsp; if [ &quot;$?&quot; -eq &quot;$SUCCESS&quot; ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; add_word &quot;$word&quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; let &quot;Score[0]= 0 - $PENALTY&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;Score[1]-=$PENALTY&quot;<br>
&nbsp; &nbsp; fi<br>
&nbsp; display_words<br>
&nbsp; done &nbsp; # Exit game.<br>
&nbsp; ### FIXME: The play () function calls too many other functions.<br>
&nbsp; ### This is perilously close to &quot;spaghetti code&quot; ...<br>
}<br>
end_of_game ()<br>
{ # Save and display stats.<br>
&nbsp; #######################Autosave##########################<br>
&nbsp; savefile=qky.save.$$<br>
&nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ PID of script<br>
&nbsp; echo `date` &gt;&gt; $savefile<br>
&nbsp; echo &quot;Letterset # $randseed &nbsp;(random seed) &quot;&gt;&gt; $savefile<br>
&nbsp; echo -n &quot;Letterset: &quot; &gt;&gt; $savefile<br>
&nbsp; echo &quot;${LS[@]}&quot; &gt;&gt; $savefile<br>
&nbsp; echo &quot;---------&quot; &gt;&gt; $savefile<br>
&nbsp; echo &quot;Words constructed:&quot; &gt;&gt; $savefile<br>
&nbsp; echo &quot;${Words[@]}&quot; &gt;&gt; $savefile<br>
&nbsp; echo &gt;&gt; $savefile<br>
&nbsp; echo &quot;Score: $total&quot; &gt;&gt; $savefile<br>
&nbsp; echo &quot;Statistics for this round saved in \&quot;&quot;$savefile&quot;\&quot;&quot;<br>
&nbsp; #########################################################<br>
Appendix A. Contributed Scripts<br>
710<br>
<hr>
<A name=717></a>Advanced Bash-Scripting Guide<br>
&nbsp; echo &quot;Score for this round: $total&quot;<br>
&nbsp; echo &quot;Words: &nbsp;${Words[@]}&quot;<br>
}<br>
# ---------#<br>
instructions<br>
seed_random<br>
get_letset<br>
play<br>
end_of_game<br>
# ---------#<br>
exit $?<br>
# TODO:<br>
#<br>
# 1) Clean up code!<br>
# 2) Prettify the display_words () function (maybe with widgets?).<br>
# 3) Improve the time-out ... maybe change to untimed entry,<br>
#+ &nbsp; but with a time limit for the overall round. &nbsp;&nbsp;<br>
# 4) An on-screen countdown timer would be nice.<br>
# 5) Implement &quot;vulnerable&quot; mode of play.<br>
# 6) Improve save-to-file capability (and maybe make it optional).<br>
# 7) Fix bugs!!!<br>
# Reference for more info:<br>
# http://bash.webofcrafts.net/qky.README.html<br>
<b>Example A-42. Nim</b><br>
#!/bin/bash<br>
# nim.sh: Game of Nim<br>
# Author: Mendel Cooper<br>
# Reldate: 15 July 2008<br>
# License: GPL3<br>
ROWS=5 &nbsp; &nbsp; # Five rows of pegs (or matchsticks).<br>
WON=91 &nbsp; &nbsp; # Exit codes to keep track of wins/losses.<br>
LOST=92 &nbsp; &nbsp;# Possibly useful if running in batch mode. &nbsp;<br>
QUIT=99<br>
peg_msg= &nbsp; # Peg/Pegs?<br>
Rows=( 0 5 4 3 2 1 ) &nbsp; # Array holding play info.<br>
# ${Rows[0]} holds total number of pegs, updated after each turn.<br>
# Other array elements hold number of pegs in corresponding row.<br>
instructions ()<br>
{<br>
&nbsp; clear<br>
&nbsp; tput bold<br>
&nbsp; echo &quot;Welcome to the game of Nim.&quot;; echo<br>
&nbsp; echo -n &quot;Do you need instructions? (y/n) &quot;; read ans<br>
&nbsp; &nbsp;if [ &quot;$ans&quot; = &quot;y&quot; -o &quot;$ans&quot; = &quot;Y&quot; ]; then<br>
&nbsp; &nbsp; &nbsp;clear<br>
&nbsp; &nbsp; &nbsp;echo -e '\E[33;41m' &nbsp;# Yellow fg., over red bg.; bold.<br>
&nbsp; &nbsp; &nbsp;cat &lt;&lt;INSTRUCTIONS<br>
Nim is a game with roots in the distant past.<br>
This particular variant starts with five rows of pegs.<br>
Appendix A. Contributed Scripts<br>
711<br>
<hr>
<A name=718></a>Advanced Bash-Scripting Guide<br>
1: &nbsp; &nbsp;| | | | |&nbsp;<br>
2: &nbsp; &nbsp; | | | |&nbsp;<br>
3: &nbsp; &nbsp; &nbsp;| | |&nbsp;<br>
4: &nbsp; &nbsp; &nbsp; | |&nbsp;<br>
5: &nbsp; &nbsp; &nbsp; &nbsp;|&nbsp;<br>
The number at the left identifies the row.<br>
The human player moves first, and alternates turns with the bot.<br>
A turn consists of removing at least one peg from a single row.<br>
It is permissable to remove ALL the pegs from a row.<br>
For example, in row 2, above, the player can remove 1, 2, 3, or 4 pegs.<br>
The player who removes the last peg loses.<br>
The strategy consists of trying to be the one who removes<br>
the next-to-last peg(s), leaving the loser with the final peg.<br>
To exit the game early, hit ENTER during your turn.<br>
INSTRUCTIONS<br>
echo; echo -n &quot;Hit ENTER to begin game. &quot;; read azx<br>
&nbsp; &nbsp; &nbsp; echo -e &quot;\033[0m&quot; &nbsp; &nbsp;# Restore display.<br>
&nbsp; &nbsp; &nbsp; else tput sgr0; clear<br>
&nbsp; fi<br>
clear<br>
}<br>
tally_up ()<br>
{<br>
&nbsp; let &quot;Rows[0] = ${Rows[1]} + ${Rows[2]} + ${Rows[3]} + ${Rows[4]} + \<br>
&nbsp; ${Rows[5]}&quot; &nbsp; &nbsp;# Add up how many pegs remaining.<br>
}<br>
display ()<br>
{<br>
&nbsp; index=1 &nbsp; # Start with top row.<br>
&nbsp; echo<br>
&nbsp; while [ &quot;$index&quot; -le &quot;$ROWS&quot; ]<br>
&nbsp; do<br>
&nbsp; &nbsp; p=${Rows[index]}<br>
&nbsp; &nbsp; echo -n &quot;$index: &nbsp; &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Show row number.<br>
&nbsp; # ------------------------------------------------<br>
&nbsp; # Two concurrent inner loops.<br>
&nbsp; &nbsp; &nbsp; indent=$index<br>
&nbsp; &nbsp; &nbsp; while [ &quot;$indent&quot; -gt 0 ]<br>
&nbsp; &nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot; &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Staggered rows.<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((indent--)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Spacing between pegs.<br>
&nbsp; &nbsp; &nbsp; done<br>
&nbsp; &nbsp; while [ &quot;$p&quot; -gt 0 ]<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;| &quot;<br>
&nbsp; &nbsp; &nbsp; ((p--))<br>
Appendix A. Contributed Scripts<br>
712<br>
<hr>
<A name=719></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; done<br>
&nbsp; # -----------------------------------------------<br>
&nbsp; echo<br>
&nbsp; ((index++))<br>
&nbsp; done &nbsp;<br>
&nbsp; tally_up<br>
&nbsp; rp=${Rows[0]}<br>
&nbsp; if [ &quot;$rp&quot; -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; peg_msg=peg<br>
&nbsp; &nbsp; final_msg=&quot;Game over.&quot;<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Game not yet over . . .<br>
&nbsp; &nbsp; peg_msg=pegs<br>
&nbsp; &nbsp; final_msg=&quot;&quot; &nbsp; # . . . So &quot;final message&quot; is blank.<br>
&nbsp; fi<br>
&nbsp; echo &quot; &nbsp; &nbsp; &nbsp;$rp $peg_msg remaining.&quot;<br>
&nbsp; echo &quot; &nbsp; &nbsp; &nbsp;&quot;$final_msg&quot;&quot;<br>
&nbsp; echo<br>
}<br>
player_move ()<br>
{<br>
&nbsp; echo &quot;Your move:&quot;<br>
&nbsp; echo -n &quot;Which row? &quot;<br>
&nbsp; while read idx<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Validity check, etc.<br>
&nbsp; &nbsp; if [ -z &quot;$idx&quot; ] &nbsp; # Hitting return quits.<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Premature exit.&quot;; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; tput sgr0 &nbsp; &nbsp; &nbsp;# Restore display.<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit $QUIT<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ &quot;$idx&quot; -gt &quot;$ROWS&quot; -o &quot;$idx&quot; -lt 1 ] &nbsp; # Bounds check.<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;Invalid row number!&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;Which row? &quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; # TODO:<br>
&nbsp; &nbsp; # Add check for non-numeric input.<br>
&nbsp; &nbsp; # Also, script crashes on input outside of range of long double.<br>
&nbsp; &nbsp; # Fix this.<br>
&nbsp; done<br>
&nbsp; echo -n &quot;Remove how many? &quot;<br>
&nbsp; while read num<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Validity check.<br>
&nbsp; if [ -z &quot;$num&quot; ]<br>
Appendix A. Contributed Scripts<br>
713<br>
<hr>
<A name=720></a>Advanced Bash-Scripting Guide<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot;Premature exit.&quot;; echo<br>
&nbsp; &nbsp; tput sgr0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Restore display.<br>
&nbsp; &nbsp; exit $QUIT<br>
&nbsp; fi<br>
&nbsp; &nbsp; if [ &quot;$num&quot; -gt ${Rows[idx]} -o &quot;$num&quot; -lt 1 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; echo &quot;Cannot remove $num!&quot;<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;Remove how many? &quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; # TODO:<br>
&nbsp; # Add check for non-numeric input.<br>
&nbsp; # Also, script crashes on input outside of range of long double.<br>
&nbsp; # Fix this.<br>
&nbsp; let &quot;Rows[idx] -= $num&quot;<br>
&nbsp; display<br>
&nbsp; tally_up<br>
&nbsp; if [ ${Rows[0]} -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp;Human wins!&quot;<br>
&nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp;Congratulations!&quot;<br>
&nbsp; &nbsp;tput sgr0 &nbsp; # Restore display.<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;exit $WON<br>
&nbsp; fi<br>
&nbsp; if [ ${Rows[0]} -eq 0 ]<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Snatching defeat from the jaws of victory . . .<br>
&nbsp; &nbsp; echo &quot; &nbsp; &nbsp; &nbsp;Fool!&quot;<br>
&nbsp; &nbsp; echo &quot; &nbsp; &nbsp; &nbsp;You just removed the last peg!&quot;<br>
&nbsp; &nbsp; echo &quot; &nbsp; &nbsp; &nbsp;Bot wins!&quot;<br>
&nbsp; &nbsp; tput sgr0 &nbsp; # Restore display.<br>
&nbsp; &nbsp; echo<br>
&nbsp; &nbsp; exit $LOST<br>
&nbsp; fi<br>
}<br>
bot_move ()<br>
{<br>
&nbsp; row_b=0<br>
&nbsp; while [[ $row_b -eq 0 || ${Rows[row_b]} -eq 0 ]]<br>
&nbsp; do<br>
&nbsp; &nbsp; row_b=$RANDOM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Choose random row.<br>
&nbsp; &nbsp; let &quot;row_b %= $ROWS&quot;<br>
&nbsp; done<br>
&nbsp; num_b=0<br>
&nbsp; r0=${Rows[row_b]}<br>
&nbsp; if [ &quot;$r0&quot; -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; num_b=1<br>
Appendix A. Contributed Scripts<br>
714<br>
<hr>
<A name=721></a>Advanced Bash-Scripting Guide<br>
&nbsp; else<br>
&nbsp; &nbsp; let &quot;num_b = $r0 - 1&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Leave only a single peg in the row.<br>
&nbsp; fi &nbsp; &nbsp; # &nbsp;Not a very strong strategy,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ but probably a bit better than totally random.<br>
&nbsp; let &quot;Rows[row_b] -= $num_b&quot;<br>
&nbsp; echo -n &quot;Bot: &nbsp;&quot;<br>
&nbsp; echo &quot;Removing from row $row_b ... &quot;<br>
&nbsp; if [ &quot;$num_b&quot; -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp; peg_msg=peg<br>
&nbsp; else<br>
&nbsp; &nbsp; peg_msg=pegs<br>
&nbsp; fi<br>
&nbsp; echo &quot; &nbsp; &nbsp; &nbsp;$num_b $peg_msg.&quot;<br>
&nbsp; display<br>
&nbsp; tally_up<br>
&nbsp; if [ ${Rows[0]} -eq 1 ]<br>
&nbsp; then<br>
&nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp;Bot wins!&quot;<br>
&nbsp; &nbsp;tput sgr0 &nbsp; # Restore display.<br>
&nbsp; &nbsp;exit $WON<br>
&nbsp; fi<br>
}<br>
# ================================================== #<br>
instructions &nbsp; &nbsp; # If human player needs them . . .<br>
tput bold &nbsp; &nbsp; &nbsp; &nbsp;# Bold characters for easier viewing.<br>
display &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Show game board.<br>
while [ true ] &nbsp; # Main loop.<br>
do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Alternate human and bot turns.<br>
&nbsp; player_move<br>
&nbsp; bot_move<br>
done<br>
# ================================================== #<br>
# Exercise:<br>
# --------<br>
# Improve the bot's strategy.<br>
# There is, in fact, a Nim strategy that can force a win.<br>
# See the Wikipedia article on Nim: &nbsp;http://en.wikipedia.org/wiki/Nim<br>
# Recode the bot to use this strategy (rather difficult).<br>
# &nbsp;Curiosities:<br>
# &nbsp;-----------<br>
# &nbsp;Nim played a prominent role in Alain Resnais' 1961 New Wave film,<br>
#+ Last Year at Marienbad.<br>
#<br>
# &nbsp;In 1978, Leo Christopherson wrote an animated version of Nim,<br>
#+ Android Nim, for the TRS-80 Model I.<br>
<b>Example A-43. A command-line stopwatch</b><br>
Appendix A. Contributed Scripts<br>
715<br>
<hr>
<A name=722></a>Advanced Bash-Scripting Guide<br>
#!/bin/sh<br>
# sw.sh<br>
# A command-line Stopwatch<br>
# Author: Pádraig Brady<br>
# &nbsp; &nbsp;http://www.pixelbeat.org/scripts/sw<br>
# &nbsp; &nbsp;(Minor reformatting by ABS Guide author.)<br>
# &nbsp; &nbsp;Used in ABS Guide with script author's permission.<br>
# Notes:<br>
# &nbsp; &nbsp;This script starts a few processes per lap, in addition to<br>
# &nbsp; &nbsp;the shell loop processing, so the assumption is made that<br>
# &nbsp; &nbsp;this takes an insignificant amount of time compared to<br>
# &nbsp; &nbsp;the response time of humans (~.1s) (or the keyboard<br>
# &nbsp; &nbsp;interrupt rate (~.05s)).<br>
# &nbsp; &nbsp;'?' for splits must be entered twice if characters<br>
# &nbsp; &nbsp;(erroneously) entered before it (on the same line).<br>
# &nbsp; &nbsp;'?' since not generating a signal may be slightly delayed<br>
# &nbsp; &nbsp;on heavily loaded systems.<br>
# &nbsp; &nbsp;Lap timings on ubuntu may be slightly delayed due to:<br>
# &nbsp; &nbsp;https://bugs.launchpad.net/bugs/62511<br>
# Changes:<br>
# &nbsp; &nbsp;V1.0, 23 Aug 2005, Initial release<br>
# &nbsp; &nbsp;V1.1, 26 Jul 2007, Allow both splits and laps from single invocation.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Only start timer after a key is pressed.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Indicate lap number<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cache programs at startup so there is less error<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; due to startup delays.<br>
# &nbsp; &nbsp;V1.2, 01 Aug 2007, Work around `date` commands that don't have<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nanoseconds.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use stty to change interrupt keys to space for<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; laps etc.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ignore other input as it causes problems.<br>
# &nbsp; &nbsp;V1.3, 01 Aug 2007, Testing release.<br>
# &nbsp; &nbsp;V1.4, 02 Aug 2007, Various tweaks to get working under ubuntu<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and Mac OS X.<br>
# &nbsp; &nbsp;V1.5, 27 Jun 2008, set LANG=C as got vague bug report about it.<br>
export LANG=C<br>
ulimit -c 0 &nbsp; # No coredumps from SIGQUIT.<br>
trap '' TSTP &nbsp;# Ignore Ctrl-Z just in case.<br>
save_tty=`stty -g` &amp;&amp; trap &quot;stty $save_tty&quot; EXIT &nbsp;# Restore tty on exit.<br>
stty quit ' ' # Space for laps rather than Ctrl-\.<br>
stty eof &nbsp;'?' # ? for splits rather than Ctrl-D.<br>
stty -echo &nbsp; &nbsp;# Don't echo input.<br>
cache_progs() {<br>
&nbsp; &nbsp; stty &gt; /dev/null<br>
&nbsp; &nbsp; date &gt; /dev/null<br>
&nbsp; &nbsp; grep . &lt; /dev/null<br>
&nbsp; &nbsp; (echo &quot;import time&quot; | python) 2&gt; /dev/null<br>
&nbsp; &nbsp; bc &lt; /dev/null<br>
&nbsp; &nbsp; sed '' &lt; /dev/null<br>
&nbsp; &nbsp; printf '1' &gt; /dev/null<br>
&nbsp; &nbsp; /usr/bin/time false 2&gt; /dev/null<br>
&nbsp; &nbsp; cat &lt; /dev/null<br>
}<br>
cache_progs &nbsp; # To minimise startup delay.<br>
date +%s.%N | grep -qF 'N' &amp;&amp; use_python=1 # If `date` lacks nanoseconds.<br>
now() {<br>
&nbsp; &nbsp; if [ &quot;$use_python&quot; ]; then<br>
Appendix A. Contributed Scripts<br>
716<br>
<hr>
<A name=723></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;import time; print time.time()&quot; 2&gt;/dev/null | python<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;%.2f&quot; `date +%s.%N`<br>
&nbsp; &nbsp; fi<br>
}<br>
fmt_seconds() {<br>
&nbsp; &nbsp; seconds=$1<br>
&nbsp; &nbsp; mins=`echo $seconds/60 | bc`<br>
&nbsp; &nbsp; if [ &quot;$mins&quot; != &quot;0&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; seconds=`echo &quot;$seconds - ($mins*60)&quot; | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$mins:$seconds&quot;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$seconds&quot;<br>
&nbsp; &nbsp; fi<br>
}<br>
total() {<br>
&nbsp; &nbsp; end=`now`<br>
&nbsp; &nbsp; total=`echo &quot;$end - $start&quot; | bc`<br>
&nbsp; &nbsp; fmt_seconds $total<br>
}<br>
stop() {<br>
&nbsp; &nbsp; [ &quot;$lapped&quot; ] &amp;&amp; lap &quot;$laptime&quot; &quot;display&quot;<br>
&nbsp; &nbsp; total<br>
&nbsp; &nbsp; exit<br>
}<br>
lap() {<br>
&nbsp; &nbsp; laptime=`echo &quot;$1&quot; | sed -n 's/.*real[^0-9.]*\(.*\)/\1/p'`<br>
&nbsp; &nbsp; [ ! &quot;$laptime&quot; -o &quot;$laptime&quot; = &quot;0.00&quot; ] &amp;&amp; return<br>
&nbsp; &nbsp; # Signals too frequent.<br>
&nbsp; &nbsp; laptotal=`echo $laptime+0$laptotal | bc`<br>
&nbsp; &nbsp; if [ &quot;$2&quot; = &quot;display&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; lapcount=`echo 0$lapcount+1 | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; laptime=`fmt_seconds $laptotal`<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo $laptime &quot;($lapcount)&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; lapped=&quot;true&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; laptotal=&quot;0&quot;<br>
&nbsp; &nbsp; fi<br>
}<br>
echo -n &quot;Space for lap | ? for split | Ctrl-C to stop | Space to start...&quot;&gt;&amp;2<br>
while true; do<br>
&nbsp; &nbsp; trap true INT QUIT &nbsp;# Set signal handlers.<br>
&nbsp; &nbsp; laptime=`/usr/bin/time -p 2&gt;&amp;1 cat &gt;/dev/null`<br>
&nbsp; &nbsp; ret=$?<br>
&nbsp; &nbsp; trap '' INT QUIT &nbsp; &nbsp;# Ignore signals within this script.<br>
&nbsp; &nbsp; if [ $ret -eq 1 -o $ret -eq 2 -o $ret -eq 130 ]; then # SIGINT = stop<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ! &quot;$start&quot; ] &amp;&amp; { echo &gt;&amp;2; exit; }<br>
&nbsp; &nbsp; &nbsp; &nbsp; stop<br>
&nbsp; &nbsp; elif [ $ret -eq 3 -o $ret -eq 131 ]; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # SIGQUIT = lap<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ ! &quot;$start&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start=`now` || exit 1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &gt;&amp;2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; lap &quot;$laptime&quot; &quot;display&quot;<br>
&nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# eof = split<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ ! &quot;$start&quot; ] &amp;&amp; continue<br>
Appendix A. Contributed Scripts<br>
717<br>
<hr>
<A name=724></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; total<br>
&nbsp; &nbsp; &nbsp; &nbsp; lap &quot;$laptime&quot; &nbsp;# Update laptotal.<br>
&nbsp; &nbsp; fi<br>
done<br>
exit $?<br>
<b>Example A-44. An all-purpose shell scripting homework assignment solution</b><br>
#!/bin/bash<br>
# &nbsp;homework.sh: All-purpose homework assignment solution.<br>
# &nbsp;Author: M. Leo Cooper<br>
# &nbsp;If you substitute your own name as author, then it is plagiarism,<br>
#+ possibly a lesser sin than cheating on your homework!<br>
# &nbsp;License: Public Domain<br>
# &nbsp;This script may be turned in to your instructor<br>
#+ in fulfillment of ALL shell scripting homework assignments.<br>
# &nbsp;It's sparsely commented, but you, the student, can easily remedy that.<br>
# &nbsp;The script author repudiates all responsibility!<br>
DLA=1<br>
P1=2<br>
P2=4<br>
P3=7<br>
PP1=0<br>
PP2=8<br>
MAXL=9<br>
E_LZY=99<br>
declare -a L<br>
L[0]=&quot;3 4 0 17 29 8 13 18 19 17 20 2 19 14 17 28&quot;<br>
L[1]=&quot;8 29 12 14 18 19 29 4 12 15 7 0 19 8 2 0 11 11 24 29 17 4 6 17 4 19&quot;<br>
L[2]=&quot;29 19 7 0 19 29 8 29 7 0 21 4 29 13 4 6 11 4 2 19 4 3&quot;<br>
L[3]=&quot;19 14 29 2 14 12 15 11 4 19 4 29 19 7 8 18 29&quot;<br>
L[4]=&quot;18 2 7 14 14 11 22 14 17 10 29 0 18 18 8 6 13 12 4 13 19 26&quot;<br>
L[5]=&quot;15 11 4 0 18 4 29 0 2 2 4 15 19 29 12 24 29 7 20 12 1 11 4 29&quot;<br>
L[6]=&quot;4 23 2 20 18 4 29 14 5 29 4 6 17 4 6 8 14 20 18 29&quot;<br>
L[7]=&quot;11 0 25 8 13 4 18 18 27&quot;<br>
L[8]=&quot;0 13 3 29 6 17 0 3 4 29 12 4 29 0 2 2 14 17 3 8 13 6 11 24 26&quot;<br>
L[9]=&quot;19 7 0 13 10 29 24 14 20 26&quot;<br>
declare -a \<br>
alph=( A B C D E F G H I J K L M N O P Q R S T U V W X Y Z . , : ' ' )<br>
pt_lt ()<br>
{<br>
&nbsp; echo -n &quot;${alph[$1]}&quot;<br>
&nbsp; echo -n -e &quot;\a&quot;<br>
&nbsp; sleep $DLA<br>
}<br>
b_r ()<br>
{<br>
&nbsp;echo -e '\E[31;48m\033[1m'<br>
}<br>
cr ()<br>
{<br>
&nbsp;echo -e &quot;\a&quot;<br>
Appendix A. Contributed Scripts<br>
718<br>
<hr>
<A name=725></a>Advanced Bash-Scripting Guide<br>
&nbsp;sleep $DLA<br>
}<br>
restore ()<br>
{<br>
&nbsp; echo -e '\033[0m' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Bold off.<br>
&nbsp; tput sgr0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Normal.<br>
}<br>
p_l ()<br>
{<br>
&nbsp; for ltr in $1<br>
&nbsp; do<br>
&nbsp; &nbsp; pt_lt &quot;$ltr&quot;<br>
&nbsp; done<br>
}<br>
# ----------------------<br>
b_r<br>
for i in $(seq 0 $MAXL)<br>
do<br>
&nbsp; p_l &quot;${L[i]}&quot;<br>
&nbsp; if [[ &quot;$i&quot; -eq &quot;$P1&quot; || &quot;$i&quot; -eq &quot;$P2&quot; || &quot;$i&quot; -eq &quot;$P3&quot; ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; cr<br>
&nbsp; elif [[ &quot;$i&quot; -eq &quot;$PP1&quot; || &quot;$i&quot; -eq &quot;$PP2&quot; ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; cr; cr<br>
&nbsp; fi<br>
done<br>
restore<br>
# ----------------------<br>
echo<br>
exit $E_LZY<br>
# &nbsp;A typical example of an obfuscated script that is difficult<br>
#+ to understand, and frustrating to maintain.<br>
# &nbsp;In your career as a sysadmin, you'll run into these critters<br>
#+ all too often.<br>
<b>Example A-45. The Knight's Tour</b><br>
#!/bin/bash<br>
# ktour.sh<br>
# author: mendel cooper<br>
# reldate: 12 Jan 2009<br>
# license: public domain<br>
# (Not much sense GPLing something that's pretty much in the common<br>
#+ domain anyhow.)<br>
###################################################################<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The Knight's Tour, a classic problem. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ===================================== &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;The knight must move onto every square of the chess board, &nbsp; &nbsp; #<br>
Appendix A. Contributed Scripts<br>
719<br>
<hr>
<A name=726></a>Advanced Bash-Scripting Guide<br>
# &nbsp;but cannot revisit any square he has already visited. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;And just why is Sir Knight unwelcome for a return visit? &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;Could it be that he has a habit of partying into the wee hours #<br>
#+ of the morning? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp;Possibly he leaves pizza crusts in the bed, empty beer bottles #<br>
#+ all over the floor, and clogs the plumbing. . . . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;------------------------------------------------------------- &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;Usage: ktour.sh [start-square] [stupid] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;Note that start-square can be a square number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
#+ in the range 0 - 63 ... or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;a square designator in conventional chess notation, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp;such as a1, f5, h3, etc. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;If start-square-number not supplied, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
#+ then starts on a random square somewhere on the board. &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &quot;stupid&quot; as second parameter sets the stupid strategy. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;Examples: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
# &nbsp;ktour.sh 23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;starts on square #23 (h3) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp;ktour.sh g6 stupid &nbsp; starts on square #46, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using &quot;stupid&quot; (non-Warnsdorff) strategy. #<br>
###################################################################<br>
DEBUG= &nbsp; &nbsp; &nbsp;# Set this to echo debugging info to stdout.<br>
SUCCESS=0<br>
FAIL=99<br>
BADMOVE=-999<br>
FAILURE=1<br>
LINELEN=21 &nbsp;# How many moves to display per line.<br>
# ---------------------------------------- #<br>
# Board array params<br>
ROWS=8 &nbsp; # 8 x 8 board.<br>
COLS=8<br>
let &quot;SQUARES = $ROWS * $COLS&quot;<br>
let &quot;MAX = $SQUARES - 1&quot;<br>
MIN=0<br>
# 64 squares on board, indexed from 0 to 63.<br>
VISITED=1<br>
UNVISITED=-1<br>
UNVSYM=&quot;##&quot;<br>
# ---------------------------------------- #<br>
# Global variables.<br>
startpos= &nbsp; &nbsp;# Starting position (square #, 0 - 63).<br>
currpos= &nbsp; &nbsp; # Current position.<br>
movenum= &nbsp; &nbsp; # Move number.<br>
CRITPOS=37 &nbsp; # Have to patch for f5 starting position!<br>
declare -i board<br>
# Use a one-dimensional array to simulate a two-dimensional one.<br>
# This can make life difficult and result in ugly kludges; see below.<br>
declare -i moves &nbsp;# Offsets from current knight position.<br>
initialize_board ()<br>
{<br>
&nbsp; local idx<br>
Appendix A. Contributed Scripts<br>
720<br>
<hr>
<A name=727></a>Advanced Bash-Scripting Guide<br>
&nbsp; for idx in {0..63}<br>
&nbsp; do<br>
&nbsp; &nbsp; board[$idx]=$UNVISITED<br>
&nbsp; done<br>
}<br>
print_board ()<br>
{<br>
&nbsp; local idx<br>
&nbsp; echo &quot; &nbsp; &nbsp;_____________________________________&quot;<br>
&nbsp; for row in {7..0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Reverse order of rows ...<br>
&nbsp; do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ so it prints in chessboard order.<br>
&nbsp; &nbsp; let &quot;rownum = $row + 1&quot; &nbsp; &nbsp; &nbsp; # &nbsp;Start numbering rows at 1.<br>
&nbsp; &nbsp; echo -n &quot;$rownum &nbsp;|&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Mark board edge with border and<br>
&nbsp; &nbsp; for column in {0..7} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ &quot;algebraic notation.&quot;<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; let &quot;idx = $ROWS*$row + $column&quot;<br>
&nbsp; &nbsp; &nbsp; if [ ${board[idx]} -eq $UNVISITED ]<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot;$UNVSYM &nbsp; &quot; &nbsp; &nbsp; &nbsp;##<br>
&nbsp; &nbsp; &nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Mark square with move number.<br>
&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;%02d &quot; &quot;${board[idx]}&quot;; echo -n &quot; &nbsp;&quot;<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; echo -e -n &quot;\b\b\b|&quot; &nbsp;# \b is a backspace.<br>
&nbsp; &nbsp; echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# -e enables echoing escaped chars.<br>
&nbsp; done<br>
&nbsp; echo &quot; &nbsp; &nbsp;-------------------------------------&quot;<br>
&nbsp; echo &quot; &nbsp; &nbsp; a &nbsp; &nbsp;b &nbsp; &nbsp;c &nbsp; &nbsp;d &nbsp; &nbsp;e &nbsp; &nbsp;f &nbsp; &nbsp;g &nbsp; &nbsp;h&quot;<br>
}<br>
failure()<br>
{ # Whine, then bail out.<br>
&nbsp; echo<br>
&nbsp; print_board<br>
&nbsp; echo<br>
&nbsp; echo &nbsp; &nbsp;&quot; &nbsp; Waah!!! Ran out of squares to move to!&quot;<br>
&nbsp; echo -n &quot; &nbsp; Knight's Tour attempt ended&quot;<br>
&nbsp; echo &nbsp; &nbsp;&quot; on $(to_algebraic $currpos) [square #$currpos]&quot;<br>
&nbsp; echo &nbsp; &nbsp;&quot; &nbsp; after just $movenum moves!&quot;<br>
&nbsp; echo<br>
&nbsp; exit $FAIL<br>
}<br>
xlat_coords () &nbsp; # &nbsp;Translate x/y coordinates to board position<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ (board-array element #).<br>
&nbsp; # &nbsp;For user input of starting board position as x/y coords.<br>
&nbsp; # &nbsp;This function not used in initial release of ktour.sh.<br>
&nbsp; # &nbsp;May be used in an updated version, for compatibility with<br>
&nbsp; #+ standard implementation of the Knight's Tour in C, Python, etc.<br>
&nbsp; if [ -z &quot;$1&quot; -o -z &quot;$2&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL<br>
Appendix A. Contributed Scripts<br>
721<br>
<hr>
<A name=728></a>Advanced Bash-Scripting Guide<br>
&nbsp; fi<br>
&nbsp; local xc=$1<br>
&nbsp; local yc=$2<br>
&nbsp; let &quot;board_index = $xc * $ROWS + yc&quot;<br>
&nbsp; if [ $board_index -lt $MIN -o $board_index -gt $MAX ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL &nbsp; &nbsp;# Strayed off the board!<br>
&nbsp; else<br>
&nbsp; &nbsp; return $board_index<br>
&nbsp; fi<br>
}<br>
to_algebraic () &nbsp; # &nbsp;Translate board position (board-array element #)<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ to standard algebraic notation used by chess players.<br>
&nbsp; if [ -z &quot;$1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi<br>
&nbsp; local element_no=$1 &nbsp; # Numerical board position.<br>
&nbsp; local col_arr=( a b c d e f g h )<br>
&nbsp; local row_arr=( 1 2 3 4 5 6 7 8 )<br>
&nbsp; let &quot;row_no = $element_no / $ROWS&quot;<br>
&nbsp; let &quot;col_no = $element_no % $ROWS&quot;<br>
&nbsp; t1=${col_arr[col_no]}; t2=${row_arr[row_no]}<br>
&nbsp; local apos=$t1$t2 &nbsp; # Concatenate.<br>
&nbsp; echo $apos<br>
}<br>
from_algebraic () &nbsp; # &nbsp;Translate standard algebraic chess notation<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ to numerical board position (board-array element #).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Or recognize numerical input &amp; return it unchanged.<br>
&nbsp; if [ -z &quot;$1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi &nbsp; # If no command-line arg, then will default to random start pos.<br>
&nbsp; local ix<br>
&nbsp; local ix_count=0<br>
&nbsp; local b_index &nbsp; &nbsp; # Board index [0-63]<br>
&nbsp; local alpos=&quot;$1&quot;<br>
&nbsp; arow=${alpos:0:1} # position = 0, length = 1<br>
&nbsp; acol=${alpos:1:1}<br>
&nbsp; if [[ $arow =~ [[:digit:]] ]] &nbsp; # &nbsp;Numerical input?<br>
&nbsp; then &nbsp; &nbsp; &nbsp; # &nbsp;POSIX char class<br>
&nbsp; &nbsp; if [[ $acol =~ [[:alpha:]] ]] # Number followed by a letter? Illegal!<br>
&nbsp; &nbsp; &nbsp; then return $FAIL<br>
&nbsp; &nbsp; else if [ $alpos -gt $MAX ] &nbsp; # Off board?<br>
&nbsp; &nbsp; &nbsp; then return $FAIL<br>
&nbsp; &nbsp; else return $alpos &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Return digit(s) unchanged . . .<br>
&nbsp; &nbsp; &nbsp; fi &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ if within range.<br>
&nbsp; &nbsp; fi<br>
Appendix A. Contributed Scripts<br>
722<br>
<hr>
<A name=729></a>Advanced Bash-Scripting Guide<br>
&nbsp; fi<br>
&nbsp; if [[ $acol -eq $MIN || $acol -gt $ROWS ]]<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp;# Outside of range 1 - 8?<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi<br>
&nbsp; for ix in a b c d e f g h<br>
&nbsp; do &nbsp;# Convert column letter to column number.<br>
&nbsp; &nbsp;if [ &quot;$arow&quot; = &quot;$ix&quot; ]<br>
&nbsp; &nbsp;then<br>
&nbsp; &nbsp; &nbsp;break<br>
&nbsp; &nbsp;fi<br>
&nbsp; ((ix_count++)) &nbsp; &nbsp;# Find index count.<br>
&nbsp; done<br>
&nbsp; ((acol--)) &nbsp; &nbsp; &nbsp; &nbsp;# Decrementing converts to zero-based array.<br>
&nbsp; let &quot;b_index = $ix_count + $acol * $ROWS&quot;<br>
&nbsp; if [ $b_index -gt $MAX ] &nbsp; # Off board?<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi<br>
&nbsp; return $b_index<br>
}<br>
generate_moves () &nbsp; # &nbsp;Calculate all valid knight moves,<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ relative to current position ($1),<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ and store in ${moves} array.<br>
&nbsp; local kt_hop=1 &nbsp; &nbsp;# &nbsp;One square &nbsp;:: short leg of knight move.<br>
&nbsp; local kt_skip=2 &nbsp; # &nbsp;Two squares :: long leg &nbsp;of knight move.<br>
&nbsp; local valmov=0 &nbsp; &nbsp;# &nbsp;Valid moves.<br>
&nbsp; local row_pos; let &quot;row_pos = $1 % $COLS&quot;<br>
&nbsp; let &quot;move1 = -$kt_skip + $ROWS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2 sideways to-the-left, &nbsp;1 up<br>
&nbsp; &nbsp; if [[ `expr $row_pos - $kt_skip` -lt $MIN ]] &nbsp; # An ugly, ugly kludge!<br>
&nbsp; &nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Can't move off board.<br>
&nbsp; &nbsp; &nbsp; move1=$BADMOVE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Not even temporarily.<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move2 = -$kt_hop + $kt_skip * $ROWS&quot; # 1 sideways to-the-left, &nbsp;2 up<br>
&nbsp; &nbsp; if [[ `expr $row_pos - $kt_hop` -lt $MIN ]] &nbsp; &nbsp;# Kludge continued ...<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move2=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move3 = &nbsp;$kt_hop + $kt_skip * $ROWS&quot; # 1 sideways to-the-right, 2 up<br>
&nbsp; &nbsp; if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move3=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move4 = &nbsp;$kt_skip + $ROWS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2 sideways to-the-right, 1 up<br>
&nbsp; &nbsp; if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]<br>
&nbsp; &nbsp; then<br>
Appendix A. Contributed Scripts<br>
723<br>
<hr>
<A name=730></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; move4=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move5 = &nbsp;$kt_skip - $ROWS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2 sideways to-the-right, 1 dn<br>
&nbsp; &nbsp; if [[ `expr $row_pos + $kt_skip` -ge $COLS ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move5=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move6 = &nbsp;$kt_hop - $kt_skip * $ROWS&quot; # 1 sideways to-the-right, 2 dn<br>
&nbsp; &nbsp; if [[ `expr $row_pos + $kt_hop` -ge $COLS ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move6=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move7 = -$kt_hop - $kt_skip * $ROWS&quot; # 1 sideways to-the-left, &nbsp;2 dn<br>
&nbsp; &nbsp; if [[ `expr $row_pos - $kt_hop` -lt $MIN ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move7=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi<br>
&nbsp; let &quot;move8 = -$kt_skip - $ROWS&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2 sideways to-the-left, &nbsp;1 dn<br>
&nbsp; &nbsp; if [[ `expr $row_pos - $kt_skip` -lt $MIN ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; move8=$BADMOVE<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; ((valmov++))<br>
&nbsp; &nbsp; fi &nbsp; # There must be a better way to do this.<br>
&nbsp; local m=( $valmov $move1 $move2 $move3 $move4 $move5 $move6 $move7 $move8 )<br>
&nbsp; # ${moves[0]} = number of valid moves.<br>
&nbsp; # ${moves[1]} ... ${moves[8]} = possible moves.<br>
&nbsp; echo &quot;${m[*]}&quot; &nbsp; &nbsp;# Elements of array to stdout for capture in a var.<br>
}<br>
is_on_board () &nbsp;# Is position actually on the board?<br>
{<br>
&nbsp; if [[ &quot;$1&quot; -lt &quot;$MIN&quot; || &quot;$1&quot; -gt &quot;$MAX&quot; ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAILURE<br>
&nbsp; else<br>
&nbsp; &nbsp; return $SUCCESS<br>
&nbsp; fi<br>
}<br>
do_move () &nbsp; &nbsp; &nbsp;# Move the knight!<br>
{<br>
&nbsp; local valid_moves=0<br>
&nbsp; local aapos<br>
&nbsp; currposl=&quot;$1&quot;<br>
&nbsp; lmin=$ROWS<br>
&nbsp; iex=0<br>
&nbsp; squarel=<br>
Appendix A. Contributed Scripts<br>
724<br>
<hr>
<A name=731></a>Advanced Bash-Scripting Guide<br>
&nbsp; mpm=<br>
&nbsp; mov=<br>
&nbsp; declare -a p_moves<br>
&nbsp; ########################## DECIDE-MOVE #############################<br>
&nbsp; if [ $startpos -ne $CRITPOS ]<br>
&nbsp; then &nbsp; # CRITPOS = square #37<br>
&nbsp; &nbsp; decide_move<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Needs a special patch for startpos=37 !!!<br>
&nbsp; &nbsp; decide_move_patched &nbsp; &nbsp;# Why this particular move and no other ???<br>
&nbsp; fi<br>
&nbsp; ####################################################################<br>
&nbsp; (( ++movenum )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Increment move count.<br>
&nbsp; let &quot;square = $currposl + ${moves[iex]}&quot;<br>
&nbsp; ################## &nbsp; &nbsp;DEBUG &nbsp; &nbsp;###############<br>
&nbsp; if [ &quot;$DEBUG&quot; ]<br>
&nbsp; &nbsp; then debug &nbsp; # Echo debugging information.<br>
&nbsp; fi<br>
&nbsp; ##############################################<br>
&nbsp; if [[ &quot;$square&quot; -gt $MAX || &quot;$square&quot; -lt $MIN ||<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${board[square]} -ne $UNVISITED ]]<br>
&nbsp; then<br>
&nbsp; &nbsp; (( --movenum )) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Decrement move count,<br>
&nbsp; &nbsp; echo &quot;RAN OUT OF SQUARES!!!&quot; #+ since previous one was invalid.<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi<br>
&nbsp; board[square]=$movenum<br>
&nbsp; currpos=$square &nbsp; &nbsp; &nbsp; # Update current position.<br>
&nbsp; ((valid_moves++)); &nbsp; &nbsp;# moves[0]=$valid_moves<br>
&nbsp; aapos=$(to_algebraic $square)<br>
&nbsp; echo -n &quot;$aapos &quot;<br>
&nbsp; test $(( $Moves % $LINELEN )) -eq 0 &amp;&amp; echo<br>
&nbsp; # Print LINELEN=21 moves per line. A valid tour shows 3 complete lines.<br>
&nbsp; return $valid_moves &nbsp; # Found a square to move to!<br>
}<br>
do_move_stupid() &nbsp; # &nbsp;Dingbat algorithm,<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ courtesy of script author, *not* Warnsdorff.<br>
&nbsp; local valid_moves=0<br>
&nbsp; local movloc<br>
&nbsp; local squareloc<br>
&nbsp; local aapos<br>
&nbsp; local cposloc=&quot;$1&quot;<br>
&nbsp; for movloc in {1..8}<br>
&nbsp; do &nbsp; &nbsp; &nbsp; # Move to first-found unvisited square.<br>
&nbsp; &nbsp; let &quot;squareloc = $cposloc + ${moves[movloc]}&quot;<br>
&nbsp; &nbsp; is_on_board $squareloc<br>
&nbsp; &nbsp; if [ $? -eq $SUCCESS ] &amp;&amp; [ ${board[squareloc]} -eq $UNVISITED ]<br>
&nbsp; &nbsp; then &nbsp; # Add conditions to above if-test to improve algorithm.<br>
&nbsp; &nbsp; &nbsp; (( ++movenum ))<br>
&nbsp; &nbsp; &nbsp; board[squareloc]=$movenum<br>
&nbsp; &nbsp; &nbsp; currpos=$squareloc &nbsp; &nbsp; # Update current position.<br>
&nbsp; &nbsp; &nbsp; ((valid_moves++)); &nbsp; &nbsp; # moves[0]=$valid_moves<br>
&nbsp; &nbsp; &nbsp; aapos=$(to_algebraic $squareloc)<br>
&nbsp; &nbsp; &nbsp; echo -n &quot;$aapos &quot;<br>
Appendix A. Contributed Scripts<br>
725<br>
<hr>
<A name=732></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; test $(( $Moves % $LINELEN )) -eq 0 &amp;&amp; echo &nbsp; # Print 21 moves/line.<br>
&nbsp; &nbsp; &nbsp; return $valid_moves &nbsp; &nbsp;# Found a square to move to!<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; return $FAIL<br>
&nbsp; # &nbsp;If no square found in all 8 loop iterations,<br>
&nbsp; #+ then Knight's Tour attempt ends in failure.<br>
&nbsp; # &nbsp;Dingbat algorithm will typically fail after about 30 - 40 moves,<br>
&nbsp; #+ but executes _much_ faster than Warnsdorff's in do_move() function.<br>
}<br>
decide_move () &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Which move will we make?<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;But, fails on startpos=37 !!!<br>
&nbsp; for mov in {1..8}<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;squarel = $currposl + ${moves[mov]}&quot;<br>
&nbsp; &nbsp; is_on_board $squarel<br>
&nbsp; &nbsp; if [[ $? -eq $SUCCESS &amp;&amp; ${board[squarel]} -eq $UNVISITED ]]<br>
&nbsp; &nbsp; then &nbsp; # &nbsp;Find accessible square with least possible future moves.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This is Warnsdorff's algorithm.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;What happens is that the knight wanders toward the outer edge<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ of the board, then pretty much spirals inward.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Given two or more possible moves with same value of<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ least-possible-future-moves, this implementation chooses<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ the _first_ of those moves.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This means that there is not necessarily a unique solution<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ for any given starting position.<br>
&nbsp; &nbsp; &nbsp; possible_moves $squarel<br>
&nbsp; &nbsp; &nbsp; mpm=$?<br>
&nbsp; &nbsp; &nbsp; p_moves[mov]=$mpm<br>
&nbsp; &nbsp; &nbsp; if [ $mpm -lt $lmin ] &nbsp;# If less than previous minimum ...<br>
&nbsp; &nbsp; &nbsp; then # &nbsp; &nbsp; ^^<br>
&nbsp; &nbsp; &nbsp; &nbsp; lmin=$mpm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Update minimum.<br>
&nbsp; &nbsp; &nbsp; &nbsp; iex=$mov &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Save index.<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
}<br>
decide_move_patched () &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Decide which move to make,<br>
{ &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ but only if startpos=37 !!!<br>
&nbsp; for mov in {1..8}<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;squarel = $currposl + ${moves[mov]}&quot;<br>
&nbsp; &nbsp; is_on_board $squarel<br>
&nbsp; &nbsp; if [[ $? -eq $SUCCESS &amp;&amp; ${board[squarel]} -eq $UNVISITED ]]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; possible_moves $squarel<br>
&nbsp; &nbsp; &nbsp; mpm=$?<br>
&nbsp; &nbsp; &nbsp; p_moves[mov]=$mpm<br>
&nbsp; &nbsp; &nbsp; if [ $mpm -le $lmin ] &nbsp;# If less-than-or equal to prev. minimum!<br>
&nbsp; &nbsp; &nbsp; then # &nbsp; &nbsp; ^^<br>
Appendix A. Contributed Scripts<br>
726<br>
<hr>
<A name=733></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; lmin=$mpm<br>
&nbsp; &nbsp; &nbsp; &nbsp; iex=$mov<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
&nbsp; done &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # There has to be a better way to do this.<br>
}<br>
possible_moves () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Calculate number of possible moves,<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ given the current position.<br>
&nbsp; if [ -z &quot;$1&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; return $FAIL<br>
&nbsp; fi<br>
&nbsp; local curr_pos=$1<br>
&nbsp; local valid_movl=0<br>
&nbsp; local icx=0<br>
&nbsp; local movl<br>
&nbsp; local sq<br>
&nbsp; declare -a movesloc<br>
&nbsp; movesloc=( $(generate_moves $curr_pos) )<br>
&nbsp; for movl in {1..8}<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;sq = $curr_pos + ${movesloc[movl]}&quot;<br>
&nbsp; &nbsp; is_on_board $sq<br>
&nbsp; &nbsp; if [ $? -eq $SUCCESS ] &amp;&amp; [ ${board[sq]} -eq $UNVISITED ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; ((valid_movl++));<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; return $valid_movl &nbsp; &nbsp; &nbsp; &nbsp; # Found a square to move to!<br>
}<br>
strategy ()<br>
{<br>
&nbsp; echo<br>
&nbsp; if [ -n &quot;$STUPID&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; for Moves in {1..63}<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; cposl=$1<br>
&nbsp; &nbsp; &nbsp; moves=( $(generate_moves $currpos) )<br>
&nbsp; &nbsp; &nbsp; do_move_stupid &quot;$currpos&quot;<br>
&nbsp; &nbsp; &nbsp; if [ $? -eq $FAIL ]<br>
&nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; failure<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; done<br>
&nbsp; fi<br>
&nbsp; # &nbsp;Don't need an &quot;else&quot; clause here,<br>
&nbsp; #+ because Stupid Strategy will always fail and exit!<br>
&nbsp; for Moves in {1..63}<br>
Appendix A. Contributed Scripts<br>
727<br>
<hr>
<A name=734></a>Advanced Bash-Scripting Guide<br>
&nbsp; do<br>
&nbsp; &nbsp; cposl=$1<br>
&nbsp; &nbsp; moves=( $(generate_moves $currpos) )<br>
&nbsp; &nbsp; do_move &quot;$currpos&quot;<br>
&nbsp; &nbsp; if [ $? -eq $FAIL ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; failure<br>
&nbsp; &nbsp; fi<br>
&nbsp; done<br>
&nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Could have condensed above two do-loops into a single one,<br>
&nbsp; echo &nbsp;#+ but this would have slowed execution.<br>
&nbsp; print_board<br>
&nbsp; echo<br>
&nbsp; echo &quot;Knight's Tour ends on $(to_algebraic $currpos) [square #$currpos].&quot;<br>
&nbsp; return $SUCCESS<br>
}<br>
debug ()<br>
{ &nbsp; &nbsp; &nbsp; # Enable this by setting DEBUG=1 near beginning of script.<br>
&nbsp; local n<br>
&nbsp; echo &quot;=================================&quot;<br>
&nbsp; echo &quot; &nbsp;At move number &nbsp;$movenum:&quot;<br>
&nbsp; echo &quot; *** possible moves = $mpm ***&quot;<br>
# echo &quot;### square = $square ###&quot;<br>
&nbsp; echo &quot;lmin = $lmin&quot;<br>
&nbsp; echo &quot;${moves[@]}&quot;<br>
&nbsp; for n in {1..8}<br>
&nbsp; do<br>
&nbsp; &nbsp; echo -n &quot;($n):${p_moves[n]} &quot;<br>
&nbsp; done<br>
&nbsp; echo<br>
&nbsp; echo &quot;iex = $iex :: moves[iex] = ${moves[iex]}&quot;<br>
&nbsp; echo &quot;square = $square&quot;<br>
&nbsp; echo &quot;=================================&quot;<br>
&nbsp; echo<br>
} # Gives pretty complete status after ea. move.<br>
# =============================================================== #<br>
# int main () {<br>
from_algebraic &quot;$1&quot;<br>
startpos=$?<br>
if [ &quot;$startpos&quot; -eq &quot;$FAIL&quot; ] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Okay even if no $1.<br>
then &nbsp; # &nbsp; &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Okay even if input -lt 0.<br>
&nbsp; echo &quot;No starting square specified (or illegal input).&quot;<br>
&nbsp; let &quot;startpos = $RANDOM % $SQUARES&quot; &nbsp; # 0 - 63 permissable range.<br>
fi<br>
if [ &quot;$2&quot; = &quot;stupid&quot; ]<br>
then<br>
&nbsp; STUPID=1<br>
&nbsp; echo -n &quot; &nbsp; &nbsp; ### Stupid Strategy ###&quot;<br>
else<br>
&nbsp; STUPID=''<br>
&nbsp; echo -n &quot; &nbsp;*** Warnsdorff's Algorithm ***&quot;<br>
Appendix A. Contributed Scripts<br>
728<br>
<hr>
<A name=735></a>Advanced Bash-Scripting Guide<br>
fi<br>
initialize_board<br>
movenum=0<br>
board[startpos]=$movenum &nbsp; # Mark each board square with move number.<br>
currpos=$startpos<br>
algpos=$(to_algebraic $startpos)<br>
echo; echo &quot;Starting from $algpos [square #$startpos] ...&quot;; echo<br>
echo -n &quot;Moves:&quot;<br>
strategy &quot;$currpos&quot;<br>
echo<br>
exit 0 &nbsp; # return 0;<br>
# } &nbsp; &nbsp; &nbsp;# End of main() pseudo-function.<br>
# =============================================================== #<br>
# Exercises:<br>
# ---------<br>
#<br>
# 1) Extend this example to a 10 x 10 board or larger.<br>
# 2) Improve the &quot;stupid strategy&quot; by modifying the<br>
# &nbsp; &nbsp;do_move_stupid function.<br>
# &nbsp; &nbsp;Hint: Prevent straying into corner squares in early moves<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(the exact opposite of Warnsdorff's algorithm!).<br>
# 3) This script could stand considerable improvement and<br>
# &nbsp; &nbsp;streamlining, especially in the poorly-written<br>
# &nbsp; &nbsp;generate_moves() function<br>
# &nbsp; &nbsp;and in the DECIDE-MOVE patch in the do_move() function.<br>
# &nbsp; &nbsp;Must figure out why standard algorithm fails for startpos=37 ...<br>
#+ &nbsp; but _not_ on any other, including symmetrical startpos=26.<br>
# &nbsp; &nbsp;Possibly, when calculating possible moves, counts the move back<br>
#+ &nbsp; to the originating square. If so, it might be a relatively easy fix.<br>
<b>Example A-46. Magic Squares</b><br>
#!/bin/bash<br>
# msquare.sh<br>
# Magic Square generator (odd-order squares only!)<br>
# Author: mendel cooper<br>
# reldate: 19 Jan. 2009<br>
# License: Public Domain<br>
# A C-program by Kwon Young Shin inspired this script.<br>
# See http://user.chollian.net/~brainstm/MagicSquare.htm ...<br>
# Definition: A &quot;magic square&quot; is a two-dimensional array<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of integers in which all the rows, columns,<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and *long* diagonals add up to the same number.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Being &quot;square,&quot; the array has the same number<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of rows and columns.<br>
# An example of a magic square of order 3 is:<br>
# &nbsp; 8 &nbsp;1 &nbsp;6 &nbsp;&nbsp;<br>
# &nbsp; 3 &nbsp;5 &nbsp;7 &nbsp;&nbsp;<br>
# &nbsp; 4 &nbsp;9 &nbsp;2 &nbsp;&nbsp;<br>
Appendix A. Contributed Scripts<br>
729<br>
<hr>
<A name=736></a>Advanced Bash-Scripting Guide<br>
# All the rows, columns, and long diagonals add up to 15.<br>
# Globals<br>
EVEN=2<br>
MAXSIZE=31 &nbsp; # 31 rows x 31 cols.<br>
E_usage=90 &nbsp; # Invocation error.<br>
dimension=<br>
declare -i square<br>
usage_message ()<br>
{<br>
&nbsp; echo &quot;Usage: $0 square-size&quot;<br>
&nbsp; echo &quot; &nbsp; ... where \&quot;square-size\&quot; is an ODD integer&quot;<br>
&nbsp; echo &quot; &nbsp; &nbsp; &nbsp; in the range 3 - 31.&quot;<br>
&nbsp; # &nbsp;Actually works for squares up to order 159,<br>
&nbsp; #+ but large squares will not display pretty-printed in a term window.<br>
&nbsp; # &nbsp;Try increasing MAXSIZE, above.<br>
&nbsp; exit $E_usage<br>
}<br>
calculate () &nbsp; &nbsp; &nbsp; # Here's where the actual work gets done.<br>
{<br>
&nbsp; local row col index dimadj j k cell_val=1<br>
&nbsp; dimension=$1<br>
&nbsp; let &quot;dimadj = $dimension * 3&quot;; let &quot;dimadj /= 2&quot; &nbsp; # x 1.5, then truncate.<br>
&nbsp; for ((j=0; j &lt; dimension; j++))<br>
&nbsp; do<br>
&nbsp; &nbsp; for ((k=0; k &lt; dimension; k++))<br>
&nbsp; &nbsp; do &nbsp;# Calculate indices, then convert to 1-dim. array index.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Bash doesn't support multidimensional arrays. Pity.<br>
&nbsp; &nbsp; &nbsp; let &quot;col = $k - $j + $dimadj&quot;; let &quot;col %= $dimension&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;row = $j * 2 - $k + $dimension&quot;; let &quot;row %= $dimension&quot;<br>
&nbsp; &nbsp; &nbsp; let &quot;index = $row*($dimension) + $col&quot;<br>
&nbsp; &nbsp; &nbsp; square[$index]=cell_val; ((cell_val++))<br>
&nbsp; &nbsp; done<br>
&nbsp; done<br>
} &nbsp; &nbsp; # Plain math, no visualization required.<br>
print_square () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Output square, one row at a time.<br>
{<br>
&nbsp; local row col idx d1<br>
&nbsp; let &quot;d1 = $dimension - 1&quot; &nbsp; # Adjust for zero-indexed array.<br>
&nbsp; for row in $(seq 0 $d1)<br>
&nbsp; do<br>
&nbsp; &nbsp; for col in $(seq 0 $d1)<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; let &quot;idx = $row * $dimension + $col&quot;<br>
&nbsp; &nbsp; &nbsp; printf &quot;%3d &quot; &quot;${square[idx]}&quot;; echo -n &quot; &nbsp;&quot;<br>
&nbsp; &nbsp; done &nbsp; # Displays up to 13-order neatly in 80-column term window.<br>
&nbsp; &nbsp; echo &nbsp; # Newline after each row.<br>
&nbsp; done<br>
}<br>
Appendix A. Contributed Scripts<br>
730<br>
<hr>
<A name=737></a>Advanced Bash-Scripting Guide<br>
#################################################<br>
if [[ -z &quot;$1&quot; ]] || [[ &quot;$1&quot; -gt $MAXSIZE ]]<br>
then<br>
&nbsp; usage_message<br>
fi<br>
let &quot;test_even = $1 % $EVEN&quot;<br>
if [ $test_even -eq 0 ]<br>
then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Can't handle even-order squares.<br>
&nbsp; usage_message<br>
fi<br>
calculate $1<br>
print_square &nbsp; # echo &quot;${square[@]}&quot; &nbsp; # DEBUG<br>
exit $?<br>
#################################################<br>
# Exercises:<br>
# ---------<br>
# 1) Add a function to calculate the sum of each row, column,<br>
# &nbsp; &nbsp;and *long* diagonal. The sums must match.<br>
# &nbsp; &nbsp;This is the &quot;magic constant&quot; of that particular order square.<br>
# 2) Have the print_square function auto-calculate how much space<br>
# &nbsp; &nbsp;to allot between square elements for optimized display.<br>
# &nbsp; &nbsp;This might require parameterizing the &quot;printf&quot; line.<br>
# 3) Add appropriate functions for generating magic squares<br>
# &nbsp; &nbsp;with an *even* number of rows/columns.<br>
# &nbsp; &nbsp;This is non-trivial(!).<br>
# &nbsp; &nbsp;See the URL for Kwon Young Shin, above, for help.<br>
<b>Example A-47. Fifteen Puzzle</b><br>
#!/bin/bash<br>
# fifteen.sh<br>
# Classic &quot;Fifteen Puzzle&quot;<br>
# Author: Antonio Macchi<br>
# Lightly edited and commented by ABS Guide author.<br>
# Used in ABS Guide with permission. (Thanks!)<br>
# &nbsp;The invention of the Fifteen Puzzle is attributed to either<br>
#+ Sam Loyd or Noyes Palmer Chapman.<br>
# &nbsp;The puzzle was wildly popular in the late 19th-century.<br>
# &nbsp;Object: Rearrange the numbers so they read in order,<br>
#+ from 1 - 15: &nbsp; ________________<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;1 &nbsp; 2 &nbsp; 3 &nbsp; 4 |<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;5 &nbsp; 6 &nbsp; 7 &nbsp; 8 |<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;9 &nbsp;10 &nbsp;11 &nbsp;12 |<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 13 &nbsp;14 &nbsp;15 &nbsp; &nbsp; |<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ----------------<br>
#######################<br>
# Constants &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; SQUARES=16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#<br>
&nbsp; FAIL=70 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; E_PREMATURE_EXIT=80 #<br>
#######################<br>
Appendix A. Contributed Scripts<br>
731<br>
<hr>
<A name=738></a>Advanced Bash-Scripting Guide<br>
########<br>
# Data #<br>
########<br>
Puzzle=( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &quot; &quot; )<br>
#############<br>
# Functions #<br>
#############<br>
function swap<br>
{<br>
&nbsp; local tmp<br>
&nbsp; tmp=${Puzzle[$1]}<br>
&nbsp; Puzzle[$1]=${Puzzle[$2]}<br>
&nbsp; Puzzle[$2]=$tmp<br>
}<br>
function Jumble<br>
{ # Scramble the pieces at beginning of round.<br>
&nbsp; local i pos1 pos2<br>
&nbsp; for i in {1..100}<br>
&nbsp; do<br>
&nbsp; &nbsp; pos1=$(( $RANDOM % $SQUARES))<br>
&nbsp; &nbsp; pos2=$(( $RANDOM % $SQUARES ))<br>
&nbsp; &nbsp; swap $pos1 $pos2<br>
&nbsp; done<br>
}<br>
function PrintPuzzle<br>
{<br>
&nbsp; local i1 i2 puzpos<br>
&nbsp; puzpos=0<br>
&nbsp; clear<br>
&nbsp; echo &quot;Enter &nbsp;quit &nbsp;to exit.&quot;; echo &nbsp; # Better that than Ctl-C.<br>
&nbsp; echo &quot;,----.----.----.----.&quot; &nbsp; # Top border.<br>
&nbsp; for i1 in {1..4}<br>
&nbsp; do<br>
&nbsp; &nbsp; for i2 in {1..4}&nbsp;<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; printf &quot;| %2s &quot; &quot;${Puzzle[$puzpos]}&quot;<br>
&nbsp; &nbsp; &nbsp; (( puzpos++ ))<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; echo &quot;|&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Right-side border.<br>
&nbsp; &nbsp; test $i1 = 4 || echo &quot;+----+----+----+----+&quot;<br>
&nbsp; done<br>
&nbsp; echo &quot;'----'----'----'----'&quot; &nbsp; # Bottom border.<br>
}<br>
function GetNum<br>
{ # Test for valid input.<br>
&nbsp; local puznum garbage<br>
Appendix A. Contributed Scripts<br>
732<br>
<hr>
<A name=739></a>Advanced Bash-Scripting Guide<br>
&nbsp; while true<br>
&nbsp; do&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Moves: $moves&quot; # Also counts invalid moves.<br>
&nbsp; &nbsp; read -p &quot;Number to move: &quot; puznum garbage<br>
&nbsp; &nbsp; &nbsp; if [ &quot;$puznum&quot; = &quot;quit&quot; ]; then echo; exit $E_PREMATURE_EXIT; fi<br>
&nbsp; &nbsp; test -z &quot;$puznum&quot; -o -n &quot;${puznum//[0-9]/}&quot; &amp;&amp; continue<br>
&nbsp; &nbsp; test $puznum -gt 0 -a $puznum -lt $SQUARES &amp;&amp; break<br>
&nbsp; done<br>
&nbsp; return $puznum<br>
}<br>
function GetPosFromNum<br>
{ # $1 = puzzle-number<br>
&nbsp; local puzpos<br>
&nbsp; for puzpos in {0..15}<br>
&nbsp; do<br>
&nbsp; &nbsp; test &quot;${Puzzle[$puzpos]}&quot; = &quot;$1&quot; &amp;&amp; break<br>
&nbsp; done<br>
&nbsp; return $puzpos<br>
}<br>
function Move<br>
{ # $1=Puzzle-pos<br>
&nbsp; test $1 -gt 3 &amp;&amp; test &quot;${Puzzle[$(( $1 - 4 ))]}&quot; = &quot; &quot;\<br>
&nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; swap $1 $(( $1 - 4 )) &amp;&amp; return 0<br>
&nbsp; test $(( $1%4 )) -ne 3 &amp;&amp; test &quot;${Puzzle[$(( $1 + 1 ))]}&quot; = &quot; &quot;\<br>
&nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; swap $1 $(( $1 + 1 )) &amp;&amp; return 0<br>
&nbsp; test $1 -lt 12 &amp;&amp; test &quot;${Puzzle[$(( $1 + 4 ))]}&quot; = &quot; &quot;\<br>
&nbsp; &nbsp; &nbsp; &nbsp;&amp;&amp; swap $1 $(( $1 + 4 )) &amp;&amp; return 0<br>
&nbsp; test $(( $1%4 )) -ne 0 &amp;&amp; test &quot;${Puzzle[$(( $1 - 1 ))]}&quot; = &quot; &quot; &amp;&amp;\<br>
&nbsp; &nbsp; &nbsp; &nbsp;swap $1 $(( $1 - 1 )) &amp;&amp; return 0<br>
&nbsp; return 1<br>
}<br>
function Solved<br>
{<br>
&nbsp; local pos<br>
&nbsp; for pos in {0..14}<br>
&nbsp; do<br>
&nbsp; &nbsp; test &quot;${Puzzle[$pos]}&quot; = $(( $pos + 1 )) || return $FAIL<br>
&nbsp; &nbsp; # Check whether number in each square = square number.<br>
&nbsp; done<br>
&nbsp; return 0 &nbsp; # Successful solution.<br>
}<br>
################### MAIN () ########################<br>
moves=0<br>
Jumble<br>
while true &nbsp; # Loop continuously until puzzle solved.<br>
do<br>
&nbsp; echo; echo<br>
&nbsp; PrintPuzzle<br>
&nbsp; echo<br>
&nbsp; while true<br>
Appendix A. Contributed Scripts<br>
733<br>
<hr>
<A name=740></a>Advanced Bash-Scripting Guide<br>
&nbsp; do<br>
&nbsp; &nbsp; GetNum<br>
&nbsp; &nbsp; puznum=$?<br>
&nbsp; &nbsp; GetPosFromNum $puznum<br>
&nbsp; &nbsp; puzpos=$?<br>
&nbsp; &nbsp; ((moves++))<br>
&nbsp; &nbsp; Move $puzpos &amp;&amp; break<br>
&nbsp; done<br>
&nbsp; Solved &amp;&amp; break<br>
done<br>
echo;echo<br>
PrintPuzzle<br>
echo; echo &quot;BRAVO!&quot;; echo<br>
exit 0<br>
####################################################<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;Rewrite the script to display the letters A - O,<br>
#+ rather than the numbers 1 - 15.<br>
<b>Example A-48.<i>&nbsp;The Towers of Hanoi, graphic version</i></b><br>
#! /bin/bash<br>
# The Towers Of Hanoi<br>
# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.<br>
# All Rights Reserved.<br>
# http://hanoi.kernelthread.com<br>
# &nbsp;hanoi2.bash<br>
# &nbsp;Version 2.00: modded for ASCII-graphic display.<br>
# &nbsp;Version 2.01: fixed no command-line param bug.<br>
# &nbsp;Uses code contributed by Antonio Macchi,<br>
#+ with heavy editing by ABS Guide author.<br>
# &nbsp;This variant falls under the original copyright, see above.<br>
# &nbsp;Used in ABS Guide with Amit Singh's permission (thanks!).<br>
### &nbsp; Variables &amp;&amp; sanity check &nbsp; ###<br>
E_NOPARAM=86<br>
E_BADPARAM=87 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Illegal no. of disks passed to script.<br>
E_NOEXIT=88<br>
DISKS=${1:-$E_NOPARAM} &nbsp; # Must specify how many disks.<br>
Moves=0<br>
MWIDTH=7<br>
MARGIN=2<br>
# Arbitrary &quot;magic&quot; constants; work okay for relatively small # of disks.<br>
# BASEWIDTH=51 &nbsp; # Original code.<br>
let &quot;basewidth = $MWIDTH * $DISKS + $MARGIN&quot; &nbsp; &nbsp; &nbsp; # &quot;Base&quot; beneath rods.<br>
# Above &quot;algorithm&quot; could likely stand improvement.<br>
### &nbsp; Display variables &nbsp; ###<br>
let &quot;disks1 = $DISKS - 1&quot;<br>
let &quot;spaces1 = $DISKS&quot;&nbsp;<br>
let &quot;spaces2 = 2 * $DISKS&quot;&nbsp;<br>
Appendix A. Contributed Scripts<br>
734<br>
<hr>
<A name=741></a>Advanced Bash-Scripting Guide<br>
let &quot;lastmove_t = $DISKS - 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Final move?<br>
declare -a Rod1 Rod2 Rod3<br>
### &nbsp; ######################### &nbsp; ###<br>
function repeat &nbsp;{ &nbsp;# $1=char $2=number of repetitions<br>
&nbsp; local n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Repeat-print a character.<br>
&nbsp; for (( n=0; n&lt;$2; n++ )); do<br>
&nbsp; &nbsp; echo -n &quot;$1&quot;<br>
&nbsp; done<br>
}<br>
function FromRod &nbsp;{<br>
&nbsp; local rod summit weight sequence<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; rod=$1<br>
&nbsp; &nbsp; test ${rod/[^123]/} || continue<br>
&nbsp; &nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; &nbsp; for summit in $sequence; do<br>
&nbsp; &nbsp; &nbsp; eval weight=\${Rod${rod}[$summit]}<br>
&nbsp; &nbsp; &nbsp; test $weight -ne 0 &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ echo &quot;$rod $summit $weight&quot;; return; }<br>
&nbsp; &nbsp; done<br>
&nbsp; done<br>
}<br>
function ToRod &nbsp;{ # $1=previous (FromRod) weight<br>
&nbsp; local rod firstfree weight sequence<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; rod=$2<br>
&nbsp; &nbsp; test ${rod/[^123]} || continue<br>
&nbsp; &nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; &nbsp; for firstfree in $sequence; do<br>
&nbsp; &nbsp; &nbsp; eval weight=\${Rod${rod}[$firstfree]}<br>
&nbsp; &nbsp; &nbsp; test $weight -gt 0 &amp;&amp; { (( firstfree++ )); break; }<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; test $weight -gt $1 -o $firstfree = 0 &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ echo &quot;$rod $firstfree&quot;; return; }<br>
&nbsp; done<br>
}<br>
function PrintRods &nbsp;{<br>
&nbsp; local disk rod empty fill sp sequence<br>
&nbsp; repeat &quot; &quot; $spaces1<br>
&nbsp; echo -n &quot;|&quot;<br>
&nbsp; repeat &quot; &quot; $spaces2<br>
&nbsp; echo -n &quot;|&quot;<br>
&nbsp; repeat &quot; &quot; $spaces2<br>
&nbsp; echo &quot;|&quot;<br>
Appendix A. Contributed Scripts<br>
735<br>
<hr>
<A name=742></a>Advanced Bash-Scripting Guide<br>
&nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; for disk in $sequence; do<br>
&nbsp; &nbsp; for rod in {1..3}; do<br>
&nbsp; &nbsp; &nbsp; eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))<br>
&nbsp; &nbsp; &nbsp; eval fill=\${Rod${rod}[$disk]}<br>
&nbsp; &nbsp; &nbsp; repeat &quot; &quot; $empty<br>
&nbsp; &nbsp; &nbsp; test $fill -gt 0 &amp;&amp; repeat &quot;*&quot; $fill || echo -n &quot;|&quot;<br>
&nbsp; &nbsp; &nbsp; repeat &quot; &quot; $empty<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; echo<br>
&nbsp; done<br>
&nbsp; repeat &quot;=&quot; $basewidth &nbsp; # Print &quot;base&quot; beneath rods.<br>
&nbsp; echo<br>
}<br>
display ()<br>
{<br>
&nbsp; echo<br>
&nbsp; PrintRods<br>
&nbsp; # Get rod-number, summit and weight<br>
&nbsp; first=( `FromRod $1` )<br>
&nbsp; eval Rod${first[0]}[${first[1]}]=0<br>
&nbsp; # Get rod-number and first-free position<br>
&nbsp; second=( `ToRod ${first[2]} $2` )<br>
&nbsp; eval Rod${second[0]}[${second[1]}]=${first[2]}<br>
echo; echo; echo<br>
if [ &quot;${Rod3[lastmove_t]}&quot; = 1 ]<br>
then &nbsp; # Last move? If yes, then display final position.<br>
&nbsp; &nbsp; echo &quot;+ &nbsp;Final Position: $Moves moves&quot;; echo<br>
&nbsp; &nbsp; PrintRods<br>
&nbsp; fi<br>
}<br>
# From here down, almost the same as original (hanoi.bash) script.<br>
dohanoi() { &nbsp; # Recursive function.<br>
&nbsp; &nbsp; case $1 in<br>
&nbsp; &nbsp; 0)<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $2 $4 $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;$Moves&quot; -ne 0 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;+ &nbsp;Position after move $Moves&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((Moves++))<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot; &nbsp; Next move will be: &nbsp;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo $2 &quot;--&gt;&quot; $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; display $2 $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $4 $3 $2<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
Appendix A. Contributed Scripts<br>
736<br>
<hr>
<A name=743></a>Advanced Bash-Scripting Guide<br>
setup_arrays ()<br>
{<br>
&nbsp; local dim n elem<br>
&nbsp; let &quot;dim1 = $1 - 1&quot;<br>
&nbsp; elem=$dim1<br>
&nbsp; for n in $(seq 0 $dim1)<br>
&nbsp; do<br>
&nbsp; &nbsp;let &quot;Rod1[$elem] = 2 * $n + 1&quot;<br>
&nbsp; &nbsp;Rod2[$n]=0<br>
&nbsp; &nbsp;Rod3[$n]=0<br>
&nbsp; &nbsp;((elem--))<br>
&nbsp; done<br>
}<br>
### &nbsp; Main &nbsp; ###<br>
setup_arrays $DISKS<br>
echo; echo &quot;+ &nbsp;Start Position&quot;<br>
case $# in<br>
&nbsp; &nbsp; 1) case $(($1&gt;0)) in &nbsp; &nbsp; # Must have at least one disk.<br>
&nbsp; &nbsp; &nbsp; &nbsp;1)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disks=$1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dohanoi $1 1 3 2<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Total moves = 2^n - 1, where n = number of disks.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit 0;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$0: Illegal value for number of disks&quot;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit $E_BADPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp;clear<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;usage: $0 N&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp; Where \&quot;N\&quot; is the number of disks.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;exit $E_NOPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp;;;<br>
esac<br>
exit $E_NOEXIT &nbsp; # Shouldn't exit here.<br>
# Note:<br>
# Redirect script output to a file, otherwise it scrolls off display.<br>
<b>Example A-49.<i>&nbsp;The Towers of Hanoi, alternate graphic version</i></b><br>
#! /bin/bash<br>
# The Towers Of Hanoi<br>
# Original script (hanoi.bash) copyright (C) 2000 Amit Singh.<br>
# All Rights Reserved.<br>
# http://hanoi.kernelthread.com<br>
# &nbsp;hanoi2.bash<br>
# &nbsp;Version 2: modded for ASCII-graphic display.<br>
Appendix A. Contributed Scripts<br>
737<br>
<hr>
<A name=744></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Uses code contributed by Antonio Macchi,<br>
#+ with heavy editing by ABS Guide author.<br>
# &nbsp;This variant also falls under the original copyright, see above.<br>
# &nbsp;Used in ABS Guide with Amit Singh's permission (thanks!).<br>
# &nbsp; Variables &nbsp; #<br>
E_NOPARAM=86<br>
E_BADPARAM=87 &nbsp; # Illegal no. of disks passed to script.<br>
E_NOEXIT=88<br>
DELAY=2 &nbsp; &nbsp; &nbsp; &nbsp; # Interval, in seconds, between moves. Change, if desired.<br>
DISKS=$1<br>
Moves=0<br>
MWIDTH=7<br>
MARGIN=2<br>
# Arbitrary &quot;magic&quot; constants, work okay for relatively small # of disks.<br>
# BASEWIDTH=51 &nbsp; # Original code.<br>
let &quot;basewidth = $MWIDTH * $DISKS + $MARGIN&quot; # &quot;Base&quot; beneath rods.<br>
# Above &quot;algorithm&quot; could likely stand improvement.<br>
# Display variables.<br>
let &quot;disks1 = $DISKS - 1&quot;<br>
let &quot;spaces1 = $DISKS&quot;&nbsp;<br>
let &quot;spaces2 = 2 * $DISKS&quot;&nbsp;<br>
let &quot;lastmove_t = $DISKS - 1&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Final move?<br>
declare -a Rod1 Rod2 Rod3<br>
#################<br>
function repeat &nbsp;{ &nbsp;# $1=char $2=number of repetitions<br>
&nbsp; local n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Repeat-print a character.<br>
&nbsp; for (( n=0; n&lt;$2; n++ )); do<br>
&nbsp; &nbsp; echo -n &quot;$1&quot;<br>
&nbsp; done<br>
}<br>
function FromRod &nbsp;{<br>
&nbsp; local rod summit weight sequence<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; rod=$1<br>
&nbsp; &nbsp; test ${rod/[^123]/} || continue<br>
&nbsp; &nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; &nbsp; for summit in $sequence; do<br>
&nbsp; &nbsp; &nbsp; eval weight=\${Rod${rod}[$summit]}<br>
&nbsp; &nbsp; &nbsp; test $weight -ne 0 &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ echo &quot;$rod $summit $weight&quot;; return; }<br>
&nbsp; &nbsp; done<br>
&nbsp; done<br>
}<br>
function ToRod &nbsp;{ # $1=previous (FromRod) weight<br>
&nbsp; local rod firstfree weight sequence<br>
Appendix A. Contributed Scripts<br>
738<br>
<hr>
<A name=745></a>Advanced Bash-Scripting Guide<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; rod=$2<br>
&nbsp; &nbsp; test ${rod/[^123]} || continue<br>
&nbsp; &nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; &nbsp; for firstfree in $sequence; do<br>
&nbsp; &nbsp; &nbsp; eval weight=\${Rod${rod}[$firstfree]}<br>
&nbsp; &nbsp; &nbsp; test $weight -gt 0 &amp;&amp; { (( firstfree++ )); break; }<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; test $weight -gt $1 -o $firstfree = 0 &amp;&amp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ echo &quot;$rod $firstfree&quot;; return; }<br>
&nbsp; done<br>
}<br>
function PrintRods &nbsp;{<br>
&nbsp; local disk rod empty fill sp sequence<br>
&nbsp; tput cup 5 0<br>
&nbsp; repeat &quot; &quot; $spaces1<br>
&nbsp; echo -n &quot;|&quot;<br>
&nbsp; repeat &quot; &quot; $spaces2<br>
&nbsp; echo -n &quot;|&quot;<br>
&nbsp; repeat &quot; &quot; $spaces2<br>
&nbsp; echo &quot;|&quot;<br>
&nbsp; sequence=$(echo $(seq 0 $disks1 | tac))<br>
&nbsp; for disk in $sequence; do<br>
&nbsp; &nbsp; for rod in {1..3}; do<br>
&nbsp; &nbsp; &nbsp; eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) ))<br>
&nbsp; &nbsp; &nbsp; eval fill=\${Rod${rod}[$disk]}<br>
&nbsp; &nbsp; &nbsp; repeat &quot; &quot; $empty<br>
&nbsp; &nbsp; &nbsp; test $fill -gt 0 &amp;&amp; repeat &quot;*&quot; $fill || echo -n &quot;|&quot;<br>
&nbsp; &nbsp; &nbsp; repeat &quot; &quot; $empty<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; echo<br>
&nbsp; done<br>
&nbsp; repeat &quot;=&quot; $basewidth &nbsp; # Print &quot;base&quot; beneath rods.<br>
&nbsp; echo<br>
}<br>
display ()<br>
{<br>
&nbsp; echo<br>
&nbsp; PrintRods<br>
&nbsp; # Get rod-number, summit and weight<br>
&nbsp; first=( `FromRod $1` )<br>
&nbsp; eval Rod${first[0]}[${first[1]}]=0<br>
&nbsp; # Get rod-number and first-free position<br>
&nbsp; second=( `ToRod ${first[2]} $2` )<br>
&nbsp; eval Rod${second[0]}[${second[1]}]=${first[2]}<br>
&nbsp; if [ &quot;${Rod3[lastmove_t]}&quot; = 1 ]<br>
&nbsp; then &nbsp; # Last move? If yes, then display final position.<br>
&nbsp; &nbsp; tput cup 0 0<br>
&nbsp; &nbsp; echo; echo &quot;+ &nbsp;Final Position: $Moves moves&quot;<br>
&nbsp; &nbsp; PrintRods<br>
Appendix A. Contributed Scripts<br>
739<br>
<hr>
<A name=746></a>Advanced Bash-Scripting Guide<br>
&nbsp; fi<br>
&nbsp; sleep $DELAY<br>
}<br>
# From here down, almost the same as original (hanoi.bash) script.<br>
dohanoi() { &nbsp; # Recursive function.<br>
&nbsp; &nbsp; case $1 in<br>
&nbsp; &nbsp; 0)<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $2 $4 $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;$Moves&quot; -ne 0 ]<br>
&nbsp; &nbsp; &nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tput cup 0 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo; echo &quot;+ &nbsp;Position after move $Moves&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((Moves++))<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot; &nbsp; Next move will be: &nbsp;&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo $2 &quot;--&gt;&quot; $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; display $2 $3<br>
&nbsp; &nbsp; &nbsp; &nbsp; dohanoi &quot;$(($1-1))&quot; $4 $3 $2<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
setup_arrays ()<br>
{<br>
&nbsp; local dim n elem<br>
&nbsp; let &quot;dim1 = $1 - 1&quot;<br>
&nbsp; elem=$dim1<br>
&nbsp; for n in $(seq 0 $dim1)<br>
&nbsp; do<br>
&nbsp; &nbsp;let &quot;Rod1[$elem] = 2 * $n + 1&quot;<br>
&nbsp; &nbsp;Rod2[$n]=0<br>
&nbsp; &nbsp;Rod3[$n]=0<br>
&nbsp; &nbsp;((elem--))<br>
&nbsp; done<br>
}<br>
### &nbsp; Main &nbsp; ###<br>
trap &quot;tput cnorm&quot; 0<br>
tput civis<br>
clear<br>
setup_arrays $DISKS<br>
tput cup 0 0<br>
echo; echo &quot;+ &nbsp;Start Position&quot;<br>
case $# in<br>
&nbsp; &nbsp; 1) case $(($1&gt;0)) in &nbsp; &nbsp; # Must have at least one disk.<br>
&nbsp; &nbsp; &nbsp; &nbsp;1)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;disks=$1<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dohanoi $1 1 3 2<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Total moves = 2^n - 1, where n = # of disks.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
Appendix A. Contributed Scripts<br>
740<br>
<hr>
<A name=747></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit 0;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$0: Illegal value for number of disks&quot;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit $E_BADPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;usage: $0 N&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;echo &quot; &nbsp; &nbsp; &nbsp; Where \&quot;N\&quot; is the number of disks.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp;exit $E_NOPARAM;<br>
&nbsp; &nbsp; &nbsp; &nbsp;;;<br>
esac<br>
exit $E_NOEXIT &nbsp; # Shouldn't exit here.<br>
# &nbsp;Exercise:<br>
# &nbsp;--------<br>
# &nbsp;There is a minor bug in the script that causes the display of<br>
#+ the next-to-last move to be skipped.<br>
#+ Fix this.<br>
<a href="abs-guides.html#131"><b>Example A-50. An alternate version of the getopt-simple.sh script</b></a><br>
#!/bin/bash<br>
# UseGetOpt.sh<br>
# Author: Peggy Russell &lt;prusselltechgroup@gmail.com&gt;<br>
UseGetOpt () {<br>
&nbsp; declare inputOptions<br>
&nbsp; declare -r E_OPTERR=85<br>
&nbsp; declare -r ScriptName=${0##*/}<br>
&nbsp; declare -r ShortOpts=&quot;adf:hlt&quot;<br>
&nbsp; declare -r LongOpts=&quot;aoption,debug,file:,help,log,test&quot;<br>
DoSomething () {<br>
&nbsp; &nbsp; echo &quot;The function name is '${FUNCNAME}'&quot;<br>
&nbsp; &nbsp; # &nbsp;Recall that $FUNCNAME is an internal variable<br>
&nbsp; &nbsp; #+ holding the name of the function it is in.<br>
&nbsp; }<br>
&nbsp; inputOptions=$(getopt -o &quot;${ShortOpts}&quot; --long \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;${LongOpts}&quot; --name &quot;${ScriptName}&quot; -- &quot;${@}&quot;)<br>
&nbsp; if [[ ($? -ne 0) || ($# -eq 0) ]]; then<br>
&nbsp; &nbsp; echo &quot;Usage: ${ScriptName} [-dhlt] {OPTION...}&quot;<br>
&nbsp; &nbsp; exit $E_OPTERR<br>
&nbsp; fi<br>
&nbsp; eval set -- &quot;${inputOptions}&quot;<br>
&nbsp; # Only for educational purposes. Can be removed.<br>
&nbsp; #-----------------------------------------------<br>
&nbsp; echo &quot;++ Test: Number of arguments: [$#]&quot;<br>
&nbsp; echo '++ Test: Looping through &quot;$@&quot;'<br>
&nbsp; for a in &quot;$@&quot;; do<br>
&nbsp; &nbsp; echo &quot; &nbsp;++ [$a]&quot;<br>
&nbsp; done<br>
&nbsp; #-----------------------------------------------<br>
Appendix A. Contributed Scripts<br>
741<br>
<hr>
<A name=748></a>Advanced Bash-Scripting Guide<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; case &quot;${1}&quot; in<br>
&nbsp; &nbsp; &nbsp; --aoption | -a) &nbsp;# Argument found.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --debug | -d) &nbsp; &nbsp;# Enable informational messages.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Debugging enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --file | -f) &nbsp; &nbsp; # &nbsp;Check for optional argument.<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$2&quot; in &nbsp; #+ Double colon is optional argument.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&quot;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Not there.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Use default&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) # Got it<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Option [$1] Using input [$2]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; DoSomething<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --log | -l) # Enable Logging.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Logging enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --test | -t) # Enable testing.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Testing enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --help | -h)<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Display help&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --) &nbsp; # Done! $# is argument number for &quot;--&quot;, $@ is &quot;--&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Dash Dash&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Major internal error!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit 8<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; echo &quot;Number of arguments: [$#]&quot;<br>
&nbsp; &nbsp; shift<br>
&nbsp; done<br>
&nbsp; shift<br>
&nbsp; # Only for educational purposes. Can be removed.<br>
&nbsp; #----------------------------------------------------------------------<br>
&nbsp; echo &quot;++ Test: Number of arguments after \&quot;--\&quot; is [$#] They are: [$@]&quot;<br>
&nbsp; echo '++ Test: Looping through &quot;$@&quot;'<br>
&nbsp; for a in &quot;$@&quot;; do<br>
&nbsp; &nbsp; echo &quot; &nbsp;++ [$a]&quot;<br>
Appendix A. Contributed Scripts<br>
742<br>
<hr>
<A name=749></a>Advanced Bash-Scripting Guide<br>
&nbsp; done<br>
&nbsp; #----------------------------------------------------------------------<br>
}<br>
################################### M A I N ########################<br>
# &nbsp;If you remove &quot;function UseGetOpt () {&quot; and corresponding &quot;}&quot;,<br>
#+ you can uncomment the &quot;exit 0&quot; line below, and invoke this script<br>
#+ with the various options from the command-line.<br>
#-------------------------------------------------------------------<br>
# exit 0<br>
echo &quot;Test 1&quot;<br>
UseGetOpt -f myfile one &quot;two three&quot; four<br>
echo;echo &quot;Test 2&quot;<br>
UseGetOpt -h<br>
echo;echo &quot;Test 3 - Short Options&quot;<br>
UseGetOpt -adltf myfile &nbsp;anotherfile<br>
echo;echo &quot;Test 4 - Long Options&quot;<br>
UseGetOpt --aoption --debug --log --test --file myfile anotherfile<br>
exit<br>
<b>Example A-51. The version of the<i>&nbsp;UseGetOpt.sh</i></b><a href="abs-guides.html#796"><b>&nbsp;example used in the Tab Expansion appendix</b></a><br>
#!/bin/bash<br>
# &nbsp;UseGetOpt-2.sh<br>
# &nbsp;Modified version of the script for illustrating tab-expansion<br>
#+ of command-line options.<br>
# &nbsp;See the &quot;Introduction to Tab Expansion&quot; appendix.<br>
# &nbsp;Possible options: -a -d -f -l -t -h<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --aoption, --debug --file --log --test -- help --<br>
# &nbsp;Author of original script: Peggy Russell &lt;prusselltechgroup@gmail.com&gt;<br>
# UseGetOpt () {<br>
&nbsp; declare inputOptions<br>
&nbsp; declare -r E_OPTERR=85<br>
&nbsp; declare -r ScriptName=${0##*/}<br>
&nbsp; declare -r ShortOpts=&quot;adf:hlt&quot;<br>
&nbsp; declare -r LongOpts=&quot;aoption,debug,file:,help,log,test&quot;<br>
DoSomething () {<br>
&nbsp; &nbsp; echo &quot;The function name is '${FUNCNAME}'&quot;<br>
&nbsp; }<br>
&nbsp; inputOptions=$(getopt -o &quot;${ShortOpts}&quot; --long \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;${LongOpts}&quot; --name &quot;${ScriptName}&quot; -- &quot;${@}&quot;)<br>
&nbsp; if [[ ($? -ne 0) || ($# -eq 0) ]]; then<br>
&nbsp; &nbsp; echo &quot;Usage: ${ScriptName} [-dhlt] {OPTION...}&quot;<br>
&nbsp; &nbsp; exit $E_OPTERR<br>
&nbsp; fi<br>
&nbsp; eval set -- &quot;${inputOptions}&quot;<br>
Appendix A. Contributed Scripts<br>
743<br>
<hr>
<A name=750></a>Advanced Bash-Scripting Guide<br>
&nbsp; while true; do<br>
&nbsp; &nbsp; case &quot;${1}&quot; in<br>
&nbsp; &nbsp; &nbsp; --aoption | -a) &nbsp;# Argument found.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --debug | -d) &nbsp; &nbsp;# Enable informational messages.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Debugging enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --file | -f) &nbsp; &nbsp; # &nbsp;Check for optional argument.<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$2&quot; in &nbsp; #+ Double colon is optional argument.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&quot;) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Not there.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Use default&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *) # Got it<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Option [$1] Using input [$2]&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shift<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; DoSomething<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --log | -l) # Enable Logging.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Logging enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --test | -t) # Enable testing.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Testing enabled&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --help | -h)<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Display help&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; --) &nbsp; # Done! $# is argument number for &quot;--&quot;, $@ is &quot;--&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Option [$1] Dash Dash&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; break<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp;*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Major internal error!&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; exit 8<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; echo &quot;Number of arguments: [$#]&quot;<br>
&nbsp; &nbsp; shift<br>
&nbsp; done<br>
&nbsp; shift<br>
# &nbsp;}<br>
exit<br>
Appendix A. Contributed Scripts<br>
744<br>
<hr>
<A name=751></a>Advanced Bash-Scripting Guide<br>
<b>Example A-52. Cycling through all the possible color backgrounds</b><br>
#!/bin/bash<br>
# show-all-colors.sh<br>
# Displays all 256 possible background colors, using ANSI escape sequences.<br>
# Author: Chetankumar Phulpagare<br>
# Used in ABS Guide with permission.<br>
T1=8<br>
T2=6<br>
T3=36<br>
offset=0<br>
for num1 in {0..7}<br>
do {<br>
&nbsp; &nbsp;for num2 in {0,1}<br>
&nbsp; &nbsp; &nbsp; &nbsp;do {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shownum=`echo &quot;$offset + $T1 * ${num2} + $num1&quot; | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -en &quot;\E[0;48;5;${shownum}m color ${shownum} \E[0m&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>
&nbsp; &nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp;echo<br>
&nbsp; &nbsp;}<br>
done<br>
offset=16<br>
for num1 in {0..5}<br>
do {<br>
&nbsp; &nbsp;for num2 in {0..5}<br>
&nbsp; &nbsp; &nbsp; &nbsp;do {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for num3 in {0..5}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do {<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;shownum=`echo &quot;$offset + $T2 * ${num3} \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+ $num2 + $T3 * ${num1}&quot; | bc`<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo -en &quot;\E[0;48;5;${shownum}m color ${shownum} \E[0m&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>
&nbsp; &nbsp; &nbsp; &nbsp;done<br>
}<br>
done<br>
offset=232<br>
for num1 in {0..23}<br>
do {<br>
&nbsp; &nbsp;shownum=`expr $offset + $num1`<br>
&nbsp; &nbsp;echo -en &quot;\E[0;48;5;${shownum}m ${shownum}\E[0m&quot;<br>
}<br>
done<br>
echo<br>
<b>Example A-53. Morse Code Practice</b><br>
#!/bin/bash<br>
# sam.sh, v. 01<br>
# Still Another Morse (code training script)<br>
# With apologies to Sam (F.B.) Morse.<br>
# Author: Mendel Cooper<br>
Appendix A. Contributed Scripts<br>
745<br>
<hr>
<A name=752></a>Advanced Bash-Scripting Guide<br>
# License: GPL3<br>
# Reldate: 05/25/11<br>
# Morse code training script.<br>
# Converts arguments to audible dots and dashes.<br>
# Note: lowercase input only at this time.<br>
# Get the wav files from the source tarball:<br>
# http://bash.webofcrafts.net/abs-guide-latest.tar.bz2<br>
DOT='soundfiles/dot.wav'<br>
DASH='soundfiles/dash.wav'<br>
# Maybe move soundfiles to /usr/local/sounds?<br>
LETTERSPACE=300000 &nbsp;# Microseconds.<br>
WORDSPACE=980000<br>
# Nice and slow, for beginners. Maybe 5 wpm?<br>
EXIT_MSG=&quot;May the Morse be with you!&quot;<br>
E_NOARGS=75 &nbsp; &nbsp; &nbsp; &nbsp; # No command-line args?<br>
declare -A morse &nbsp; &nbsp;# Associative array!<br>
# ======================================= #<br>
morse[a]=&quot;dot; dash&quot;<br>
morse[b]=&quot;dash; dot; dot; dot&quot;<br>
morse[c]=&quot;dash; dot; dash; dot&quot;<br>
morse[d]=&quot;dash; dot; dot&quot;<br>
morse[e]=&quot;dot&quot;<br>
morse[f]=&quot;dot; dot; dash; dot&quot;<br>
morse[g]=&quot;dash; dash; dot&quot;<br>
morse[h]=&quot;dot; dot; dot; dot&quot;<br>
morse[i]=&quot;dot; dot;&quot;<br>
morse[j]=&quot;dot; dash; dash; dash&quot;<br>
morse[k]=&quot;dash; dot; dash&quot;<br>
morse[l]=&quot;dot; dash; dot; dot&quot;<br>
morse[m]=&quot;dash; dash&quot;<br>
morse[n]=&quot;dash; dot&quot;<br>
morse[o]=&quot;dash; dash; dash&quot;<br>
morse[p]=&quot;dot; dash; dash; dot&quot;<br>
morse[q]=&quot;dash; dash; dot; dash&quot;<br>
morse[r]=&quot;dot; dash; dot&quot;<br>
morse[s]=&quot;dot; dot; dot&quot;<br>
morse[t]=&quot;dash&quot;<br>
morse[u]=&quot;dot; dot; dash&quot;<br>
morse[v]=&quot;dot; dot; dot; dash&quot;<br>
morse[w]=&quot;dot; dash; dash&quot;<br>
morse[x]=&quot;dash; dot; dot; dash&quot;<br>
morse[y]=&quot;dash; dot; dash; dash&quot;<br>
morse[z]=&quot;dash; dash; dot; dot&quot;<br>
morse[0]=&quot;dash; dash; dash; dash; dash&quot;<br>
morse[1]=&quot;dot; dash; dash; dash; dash&quot;<br>
morse[2]=&quot;dot; dot; dash; dash; dash&quot;<br>
morse[3]=&quot;dot; dot; dot; dash; dash&quot;<br>
morse[4]=&quot;dot; dot; dot; dot; dash&quot;<br>
morse[5]=&quot;dot; dot; dot; dot; dot&quot;<br>
morse[6]=&quot;dash; dot; dot; dot; dot&quot;<br>
morse[7]=&quot;dash; dash; dot; dot; dot&quot;<br>
morse[8]=&quot;dash; dash; dash; dot; dot&quot;<br>
morse[8]=&quot;dash; dash; dash; dash; dot&quot;<br>
Appendix A. Contributed Scripts<br>
746<br>
<hr>
<A name=753></a>Advanced Bash-Scripting Guide<br>
# The following must be escaped or quoted.<br>
morse[?]=&quot;dot; dot; dash; dash; dot; dot&quot;<br>
morse[.]=&quot;dot; dash; dot; dash; dot; dash&quot;<br>
morse[,]=&quot;dash; dash; dot; dot; dash; dash&quot;<br>
morse[/]=&quot;dash; dot; dot; dash; dot&quot;<br>
morse[\@]=&quot;dot; dash; dash; dot; dash; dot&quot;<br>
# ======================================= #<br>
play_letter ()<br>
{<br>
&nbsp; eval ${morse[$1]} &nbsp; # Play dots, dashes from appropriate sound files.<br>
&nbsp; # Why is 'eval' necessary here?<br>
&nbsp; usleep $LETTERSPACE # Pause in between letters.<br>
}<br>
extract_letters ()<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Slice string apart, letter by letter.<br>
&nbsp; local pos=0 &nbsp; &nbsp; &nbsp; &nbsp; # Starting at left end of string.<br>
&nbsp; local len=1 &nbsp; &nbsp; &nbsp; &nbsp; # One letter at a time.<br>
&nbsp; strlen=${#1}<br>
&nbsp; while [ $pos -lt $strlen ]<br>
&nbsp; do<br>
&nbsp; &nbsp; letter=${1:pos:len}<br>
&nbsp; &nbsp; # &nbsp; &nbsp; &nbsp;^^^^^^^^^^^^ &nbsp; &nbsp;See Chapter 10.1.<br>
&nbsp; &nbsp; play_letter $letter<br>
&nbsp; &nbsp; echo -n &quot;*&quot; &nbsp; &nbsp; &nbsp; # &nbsp; &nbsp;Mark letter just played.<br>
&nbsp; &nbsp; ((pos++))<br>
&nbsp; done<br>
}<br>
######### Play the sounds ############<br>
dot() &nbsp;{ aplay &quot;$DOT&quot; 2&amp;&gt;/dev/null; &nbsp;}<br>
dash() { aplay &quot;$DASH&quot; 2&amp;&gt;/dev/null; }<br>
######################################<br>
no_args ()<br>
{<br>
&nbsp; &nbsp; declare -a usage<br>
&nbsp; &nbsp; usage=( $0 word1 word2 ... )<br>
&nbsp; &nbsp; echo &quot;Usage:&quot;; echo<br>
&nbsp; &nbsp; echo ${usage[*]}<br>
&nbsp; &nbsp; for index in 0 1 2 3<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; extract_letters ${usage[index]} &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; &nbsp; usleep $WORDSPACE<br>
&nbsp; &nbsp; &nbsp; echo -n &quot; &quot; &nbsp; &nbsp; # Print space between words.<br>
&nbsp; &nbsp; done<br>
# &nbsp; echo &quot;Usage: $0 word1 word2 ... &quot;<br>
&nbsp; &nbsp; echo; echo<br>
}<br>
# int main()<br>
# {<br>
clear &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Clear the terminal screen.<br>
echo &quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SAM&quot;<br>
echo &quot;Still Another Morse code trainer&quot;<br>
echo &quot; &nbsp; &nbsp;Author: Mendel Cooper&quot;<br>
echo; echo;<br>
Appendix A. Contributed Scripts<br>
747<br>
<hr>
<A name=754></a>Advanced Bash-Scripting Guide<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; no_args<br>
&nbsp; echo; echo; echo &quot;$EXIT_MSG&quot;; echo<br>
&nbsp; exit $E_NOARGS<br>
fi<br>
echo; echo &quot;$*&quot; &nbsp; &nbsp; &nbsp; # Print text that will be played.<br>
until [ -z &quot;$1&quot; ]<br>
do<br>
&nbsp; extract_letters $1<br>
&nbsp; shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # On to next word.<br>
&nbsp; usleep $WORDSPACE<br>
&nbsp; echo -n &quot; &quot; &nbsp; &nbsp; # Print space between words.<br>
done<br>
echo; echo; echo &quot;$EXIT_MSG&quot;; echo<br>
exit 0<br>
# }<br>
# &nbsp;Exercises:<br>
# &nbsp;---------<br>
# &nbsp;1) Have the script accept either lowercase or uppercase words<br>
#+ &nbsp; &nbsp;as arguments. Hint: Use 'tr' . . .<br>
# &nbsp;2) Have the script optionally accept input from a text file.<br>
<b>Example A-54. Base64 encoding/decoding</b><br>
#!/bin/bash<br>
# base64.sh: Bash implementation of Base64 encoding and decoding.<br>
#<br>
# Copyright (c) 2011 vladz &lt;vladz@devzero.fr&gt;<br>
# Used in ABSG with permission (thanks!).<br>
#<br>
# &nbsp;Encode or decode original Base64 (and also Base64url)<br>
#+ from STDIN to STDOUT.<br>
#<br>
# &nbsp; &nbsp;Usage:<br>
#<br>
# &nbsp; &nbsp;Encode<br>
# &nbsp; &nbsp;$ ./base64.sh &lt; binary-file &gt; binary-file.base64<br>
# &nbsp; &nbsp;Decode<br>
# &nbsp; &nbsp;$ ./base64.sh -d &lt; binary-file.base64 &gt; binary-file<br>
#<br>
# Reference:<br>
#<br>
# &nbsp; &nbsp;[1] &nbsp;RFC4648 - &quot;The Base16, Base32, and Base64 Data Encodings&quot;<br>
# &nbsp; &nbsp; &nbsp; &nbsp; http://tools.ietf.org/html/rfc4648#section-5<br>
# The base64_charset[] array contains entire base64 charset,<br>
# and additionally the character &quot;=&quot; ...<br>
base64_charset=( {A..Z} {a..z} {0..9} + / = )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Nice illustration of brace expansion.<br>
# &nbsp;Uncomment the ### line below to use base64url encoding instead of<br>
#+ original base64.<br>
### base64_charset=( {A..Z} {a..z} {0..9} - _ = )<br>
Appendix A. Contributed Scripts<br>
748<br>
<hr>
<A name=755></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Output text width when encoding<br>
#+ (64 characters, just like openssl output).<br>
text_width=64<br>
function display_base64_char {<br>
# &nbsp;Convert a 6-bit number (between 0 and 63) into its corresponding values<br>
#+ in Base64, then display the result with the specified text width.<br>
&nbsp; printf &quot;${base64_charset[$1]}&quot;; (( width++ ))<br>
&nbsp; (( width % text_width == 0 )) &amp;&amp; printf &quot;\n&quot;<br>
}<br>
function encode_base64 {<br>
# Encode three 8-bit hexadecimal codes into four 6-bit numbers.<br>
&nbsp; # &nbsp; &nbsp;We need two local int array variables:<br>
&nbsp; # &nbsp; &nbsp;c8[]: to store the codes of the 8-bit characters to encode<br>
&nbsp; # &nbsp; &nbsp;c6[]: to store the corresponding encoded values on 6-bit<br>
&nbsp; declare -a -i c8 c6<br>
&nbsp; # &nbsp;Convert hexadecimal to decimal.<br>
&nbsp; c8=( $(printf &quot;ibase=16; ${1:0:2}\n${1:2:2}\n${1:4:2}\n&quot; | bc) )<br>
&nbsp; # &nbsp;Let's play with bitwise operators<br>
&nbsp; #+ (3x8-bit into 4x6-bits conversion).<br>
&nbsp; (( c6[0] = c8[0] &gt;&gt; 2 ))<br>
&nbsp; (( c6[1] = ((c8[0] &amp; &nbsp;3) &lt;&lt; 4) | (c8[1] &gt;&gt; 4) ))<br>
&nbsp; # The following operations depend on the c8 element number.<br>
&nbsp; case ${#c8[*]} in&nbsp;<br>
&nbsp; &nbsp; 3) (( c6[2] = ((c8[1] &amp; 15) &lt;&lt; 2) | (c8[2] &gt;&gt; 6) ))<br>
&nbsp; &nbsp; &nbsp; &nbsp;(( c6[3] = c8[2] &amp; 63 )) ;;<br>
&nbsp; &nbsp; 2) (( c6[2] = (c8[1] &amp; 15) &lt;&lt; 2 ))<br>
&nbsp; &nbsp; &nbsp; &nbsp;(( c6[3] = 64 )) ;;<br>
&nbsp; &nbsp; 1) (( c6[2] = c6[3] = 64 )) ;;<br>
&nbsp; esac<br>
&nbsp; for char in ${c6[@]}; do<br>
&nbsp; &nbsp; display_base64_char ${char}<br>
&nbsp; done<br>
}<br>
function decode_base64 {<br>
# Decode four base64 characters into three hexadecimal ASCII characters.<br>
&nbsp; # &nbsp;c8[]: to store the codes of the 8-bit characters<br>
&nbsp; # &nbsp;c6[]: to store the corresponding Base64 values on 6-bit<br>
&nbsp; declare -a -i c8 c6<br>
&nbsp; # Find decimal value corresponding to the current base64 character.<br>
&nbsp; for current_char in ${1:0:1} ${1:1:1} ${1:2:1} ${1:3:1}; do<br>
&nbsp; &nbsp; &nbsp;[ &quot;${current_char}&quot; = &quot;=&quot; ] &amp;&amp; break<br>
&nbsp; &nbsp; &nbsp;position=0<br>
&nbsp; &nbsp; &nbsp;while [ &quot;${current_char}&quot; != &quot;${base64_charset[${position}]}&quot; ]; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; (( position++ ))<br>
&nbsp; &nbsp; &nbsp;done<br>
&nbsp; &nbsp; &nbsp;c6=( ${c6[*]} ${position} )<br>
&nbsp; done<br>
&nbsp; # &nbsp;Let's play with bitwise operators<br>
&nbsp; #+ (4x8-bit into 3x6-bits conversion).<br>
&nbsp; (( c8[0] = (c6[0] &lt;&lt; 2) | (c6[1] &gt;&gt; 4) ))<br>
Appendix A. Contributed Scripts<br>
749<br>
<hr>
<A name=756></a>Advanced Bash-Scripting Guide<br>
&nbsp; # The next operations depends on the c6 elements number.<br>
&nbsp; case ${#c6[*]} in<br>
&nbsp; &nbsp; 3) (( c8[1] = ( (c6[1] &amp; 15) &lt;&lt; 4) | (c6[2] &gt;&gt; 2) ))<br>
&nbsp; &nbsp; &nbsp; &nbsp;(( c8[2] = (c6[2] &amp; 3) &lt;&lt; 6 )); unset c8[2] ;;<br>
&nbsp; &nbsp; 4) (( c8[1] = ( (c6[1] &amp; 15) &lt;&lt; 4) | (c6[2] &gt;&gt; 2) ))<br>
&nbsp; &nbsp; &nbsp; &nbsp;(( c8[2] = ( (c6[2] &amp; &nbsp;3) &lt;&lt; 6) | &nbsp;c6[3] )) ;;<br>
&nbsp; esac<br>
&nbsp; for char in ${c8[*]}; do<br>
&nbsp; &nbsp; &nbsp;printf &quot;\x$(printf &quot;%x&quot; ${char})&quot;<br>
&nbsp; done<br>
}<br>
# main ()<br>
if [ &quot;$1&quot; = &quot;-d&quot; ]; then &nbsp; # decode<br>
&nbsp; # Reformat STDIN in pseudo 4x6-bit groups.<br>
&nbsp; content=$(cat - | tr -d &quot;\n&quot; | sed -r &quot;s/(.{4})/\1 /g&quot;)<br>
&nbsp; for chars in ${content}; do decode_base64 ${chars}; done<br>
else<br>
&nbsp; # Make a hexdump of stdin and reformat in 3-byte groups.<br>
&nbsp; content=$(cat - | xxd -ps -u | sed -r &quot;s/(\w{6})/\1 /g&quot; |<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tr -d &quot;\n&quot;)<br>
&nbsp; for chars in ${content}; do encode_base64 ${chars}; done<br>
&nbsp; echo<br>
fi<br>
<b>Example A-55. The Gronsfeld Cipher</b><br>
#!/bin/bash<br>
# gronsfeld.bash<br>
# License: GPL3<br>
# Reldate 06/23/11<br>
# &nbsp;This is an implementation of the Gronsfeld Cipher.<br>
# &nbsp;It's essentially a stripped-down variant of the&nbsp;<br>
#+ polyalphabetic Vigenère Tableau, but with only 10 alphabets.<br>
# &nbsp;The classic Gronsfeld has a numerical sequence as the key word,<br>
#+ but instead we substitute a letter string, for ease of use.<br>
# &nbsp;Allegedly, this cipher was invented by the eponymous Count Gronsfeld<br>
#+ in the 17th Century. It was at one time considered to be unbreakable.<br>
# &nbsp;Note that this is ###not### a secure cipher by modern standards.<br>
# &nbsp;Global Variables &nbsp;#<br>
Enc_suffix=&quot;29378&quot; &nbsp; # &nbsp;Encrypted text output with this 5-digit suffix.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;This functions as a decryption flag,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ and when used to generate passwords adds security.<br>
Default_key=&quot;gronsfeldk&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;The script uses this if key not entered below<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;(at &quot;Keychain&quot;).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Change the above two values frequently<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ for added security.<br>
Appendix A. Contributed Scripts<br>
750<br>
<hr>
<A name=757></a>Advanced Bash-Scripting Guide<br>
GROUPLEN=5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Output in groups of 5 letters, per tradition.<br>
alpha1=( abcdefghijklmnopqrstuvwxyz )<br>
alpha2=( {A..Z} ) &nbsp; &nbsp;# &nbsp;Output in all caps, per tradition.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Use &nbsp; alpha2=( {a..z} ) &nbsp; for password generator.<br>
wraplen=26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Wrap around if past end of alphabet.<br>
dflag= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Decrypt flag (set if $Enc_suffix present).<br>
E_NOARGS=76 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Missing command-line args?<br>
DEBUG=77 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Debugging flag.<br>
declare -a offsets &nbsp; # &nbsp;This array holds the numerical shift values for<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ encryption/decryption.<br>
########Keychain#########<br>
key= &nbsp;### Put key here!!!<br>
&nbsp; &nbsp; &nbsp; # 10 characters!<br>
#########################<br>
# Function<br>
: ()<br>
{ # Encrypt or decrypt, depending on whether $dflag is set.<br>
&nbsp; # Why &quot;: ()&quot; as a function name? Just to prove that it can be done.<br>
&nbsp; local idx keydx mlen off1 shft<br>
&nbsp; local plaintext=&quot;$1&quot;<br>
&nbsp; local mlen=${#plaintext}<br>
for (( idx=0; idx&lt;$mlen; idx++ ))<br>
do<br>
&nbsp; let &quot;keydx = $idx % $keylen&quot;<br>
&nbsp; shft=${offsets[keydx]}<br>
&nbsp; if [ -n &quot;$dflag&quot; ]<br>
&nbsp; then &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Decrypt!<br>
&nbsp; &nbsp; let &quot;off1 = $(expr index &quot;${alpha1[*]}&quot; ${plaintext:idx:1}) - $shft&quot;<br>
&nbsp; &nbsp; # Shift backward to decrypt.<br>
&nbsp; else &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Encrypt!<br>
&nbsp; &nbsp; let &quot;off1 = $(expr index &quot;${alpha1[*]}&quot; ${plaintext:idx:1}) + $shft&quot;<br>
&nbsp; &nbsp; # Shift forward to encrypt.<br>
&nbsp; &nbsp; test $(( $idx % $GROUPLEN)) = 0 &amp;&amp; echo -n &quot; &quot; &nbsp;# Groups of 5 letters.<br>
&nbsp; &nbsp; # &nbsp;Comment out above line for output as a string without whitespace,<br>
&nbsp; &nbsp; # &nbsp;for example, if using the script as a password generator.<br>
&nbsp; fi<br>
&nbsp; ((off1--)) &nbsp; # Normalize.<br>
&nbsp; &nbsp; &nbsp; if [ $off1 -lt 0 ]<br>
&nbsp; &nbsp; &nbsp; then &nbsp; &nbsp; # Catch negative indices.<br>
&nbsp; &nbsp; &nbsp; &nbsp; let &quot;off1 += $wraplen&quot;<br>
&nbsp; &nbsp; &nbsp; fi<br>
&nbsp; ((off1 %= $wraplen)) &nbsp; # Wrap around if past end of alphabet.<br>
&nbsp; echo -n &quot;${alpha2[off1]}&quot;<br>
done<br>
&nbsp; if [ -z &quot;$dflag&quot; ]<br>
&nbsp; then<br>
&nbsp; &nbsp; echo &quot; $Enc_suffix&quot;<br>
# &nbsp; echo &quot;$Enc_suffix&quot; &nbsp;# For password generator.<br>
Appendix A. Contributed Scripts<br>
751<br>
<hr>
<A name=758></a>Advanced Bash-Scripting Guide<br>
&nbsp; else<br>
&nbsp; &nbsp; echo<br>
&nbsp; fi<br>
} # End encrypt/decrypt function.<br>
# int main () {<br>
# Check if command-line args.<br>
if [ -z &quot;$1&quot; ]<br>
then<br>
&nbsp; &nbsp;echo &quot;Usage: $0 TEXT TO ENCODE/DECODE&quot;<br>
&nbsp; &nbsp;exit $E_NOARGS<br>
fi<br>
if [ ${!#} == &quot;$Enc_suffix&quot; ]<br>
# &nbsp; &nbsp;^^^^^ Final command-line arg.<br>
then<br>
&nbsp; dflag=ON<br>
&nbsp; echo -n &quot;+&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Flag decrypted text with a &quot;+&quot; for easy ID.<br>
fi<br>
if [ -z &quot;$key&quot; ]<br>
then<br>
&nbsp; key=&quot;$Default_key&quot; &nbsp; &nbsp;# &quot;gronsfeldk&quot; per above.<br>
fi<br>
keylen=${#key}<br>
for (( idx=0; idx&lt;$keylen; idx++ ))<br>
do &nbsp;# Calculate shift values for encryption/decryption.<br>
&nbsp; offsets[idx]=$(expr index &quot;${alpha1[*]}&quot; ${key:idx:1}) &nbsp; # Normalize.<br>
&nbsp; ((offsets[idx]--)) &nbsp;# &nbsp;Necessary because &quot;expr index&quot; starts at 1,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ whereas array count starts at 0.<br>
&nbsp; # Generate array of numerical offsets corresponding to the key.<br>
&nbsp; # There are simpler ways to accomplish this.<br>
done<br>
args=$(echo &quot;$*&quot; | sed -e 's/ //g' | tr A-Z a-z | sed -e 's/[0-9]//g')<br>
# Remove whitespace and digits from command-line args.<br>
# Can modify to also remove punctuation characters, if desired.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Debug:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# echo &quot;$args&quot;; exit $DEBUG<br>
: &quot;$args&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Call the function named &quot;:&quot;.<br>
# : is a null operator, except . . . when it's a function name!<br>
exit $? &nbsp; &nbsp;# } End-of-script<br>
# &nbsp; ************************************************************** &nbsp; #<br>
# &nbsp; This script can function as a &nbsp;password generator,<br>
#+ &nbsp;with several minor mods, see above.<br>
# &nbsp; That would allow an easy-to-remember password, even the word<br>
#+ &quot;password&quot; itself, which encrypts to vrgfotvo29378<br>
#+ &nbsp;a fairly secure password not susceptible to a dictionary attack.<br>
# &nbsp; Or, you could use your own name (surely that's easy to remember!).<br>
# &nbsp; For example, Bozo Bozeman encrypts to hfnbttdppkt29378.<br>
# &nbsp; ************************************************************** &nbsp; #<br>
To end this section, a review of the basics . . . and more.<br>
Appendix A. Contributed Scripts<br>
752<br>
<hr>
<A name=759></a>Advanced Bash-Scripting Guide<br>
<b>Example A-56. Basics Reviewed</b><br>
#!/bin/bash<br>
# basics-reviewed.bash<br>
# File extension == *.bash == specific to Bash<br>
# &nbsp; Copyright (c) Michael S. Zick, 2003; All rights reserved.<br>
# &nbsp; License: Use in any form, for any purpose.<br>
# &nbsp; Revision: $ID$<br>
#<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Edited for layout by M.C.<br>
# &nbsp; (author of the &quot;Advanced Bash Scripting Guide&quot;)<br>
# &nbsp; Fixes and updates (04/08) by Cliff Bamford.<br>
# &nbsp;This script tested under Bash versions 2.04, 2.05a and 2.05b.<br>
# &nbsp;It may not work with earlier versions.<br>
# &nbsp;This demonstration script generates one --intentional--<br>
#+ &quot;command not found&quot; error message. See line 436.<br>
# &nbsp;The current Bash maintainer, Chet Ramey, has fixed the items noted<br>
#+ for later versions of Bash.<br>
&nbsp; &nbsp; &nbsp; &nbsp; ###-------------------------------------------###<br>
&nbsp; &nbsp; &nbsp; &nbsp; ### &nbsp;Pipe the output of this script to 'more' ###<br>
&nbsp; &nbsp; &nbsp; &nbsp; ###+ else it will scroll off the page. &nbsp; &nbsp; &nbsp; &nbsp;###<br>
&nbsp; &nbsp; &nbsp; &nbsp; ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ###<br>
&nbsp; &nbsp; &nbsp; &nbsp; ### &nbsp;You may also redirect its output &nbsp; &nbsp; &nbsp; &nbsp; ###<br>
&nbsp; &nbsp; &nbsp; &nbsp; ###+ to a file for examination. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ### &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; ###-------------------------------------------###<br>
# &nbsp;Most of the following points are described at length in<br>
#+ the text of the foregoing &quot;Advanced Bash Scripting Guide.&quot;<br>
# &nbsp;This demonstration script is mostly just a reorganized presentation.<br>
# &nbsp; &nbsp; &nbsp;-- msz<br>
# Variables are not typed unless otherwise specified.<br>
# &nbsp;Variables are named. Names must contain a non-digit.<br>
# &nbsp;File descriptor names (as in, for example: 2&gt;&amp;1)<br>
#+ contain ONLY digits.<br>
# Parameters and Bash array elements are numbered.<br>
# (Parameters are very similar to Bash arrays.)<br>
# A variable name may be undefined (null reference).<br>
unset VarNull<br>
# A variable name may be defined but empty (null contents).<br>
VarEmpty='' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Two, adjacent, single quotes.<br>
# A variable name may be defined and non-empty.<br>
VarSomething='Literal'<br>
# A variable may contain:<br>
# &nbsp; * A whole number as a signed 32-bit (or larger) integer<br>
# &nbsp; * A string<br>
Appendix A. Contributed Scripts<br>
753<br>
<hr>
<A name=760></a>Advanced Bash-Scripting Guide<br>
# A variable may also be an array.<br>
# &nbsp;A string may contain embedded blanks and may be treated<br>
#+ as if it where a function name with optional arguments.<br>
# &nbsp;The names of variables and the names of functions<br>
#+ are in different namespaces.<br>
# &nbsp;A variable may be defined as a Bash array either explicitly or<br>
#+ implicitly by the syntax of the assignment statement.<br>
# &nbsp;Explicit:<br>
declare -a ArrayVar<br>
# The echo command is a builtin.<br>
echo $VarSomething<br>
# The printf command is a builtin.<br>
# Translate %s as: String-Format<br>
printf %s $VarSomething &nbsp; &nbsp; &nbsp; &nbsp; # No linebreak specified, none output.<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Default, only linebreak output.<br>
# The Bash parser word breaks on whitespace.<br>
# Whitespace, or the lack of it is significant.<br>
# (This holds true in general; there are, of course, exceptions.)<br>
# Translate the DOLLAR_SIGN character as: Content-Of.<br>
# Extended-Syntax way of writing Content-Of:<br>
echo ${VarSomething}<br>
# &nbsp;The ${ ... } Extended-Syntax allows more than just the variable<br>
#+ name to be specified.<br>
# &nbsp;In general, $VarSomething can always be written as: ${VarSomething}.<br>
# Call this script with arguments to see the following in action.<br>
# &nbsp;Outside of double-quotes, the special characters @ and *<br>
#+ specify identical behavior.<br>
# &nbsp;May be pronounced as: All-Elements-Of.<br>
# &nbsp;Without specification of a name, they refer to the<br>
#+ pre-defined parameter Bash-Array.<br>
# Glob-Pattern references<br>
echo $* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # All parameters to script or function<br>
echo ${*} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Same<br>
# Bash disables filename expansion for Glob-Patterns.<br>
# Only character matching is active.<br>
Appendix A. Contributed Scripts<br>
754<br>
<hr>
<A name=761></a>Advanced Bash-Scripting Guide<br>
# All-Elements-Of references<br>
echo $@ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Same as above<br>
echo ${@} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Same as above<br>
# &nbsp;Within double-quotes, the behavior of Glob-Pattern references<br>
#+ depends on the setting of IFS (Input Field Separator).<br>
# &nbsp;Within double-quotes, All-Elements-Of references behave the same.<br>
# &nbsp;Specifying only the name of a variable holding a string refers<br>
#+ to all elements (characters) of a string.<br>
# &nbsp;To specify an element (character) of a string,<br>
#+ the Extended-Syntax reference notation (see below) MAY be used.<br>
# &nbsp;Specifying only the name of a Bash array references<br>
#+ the subscript zero element,<br>
#+ NOT the FIRST DEFINED nor the FIRST WITH CONTENTS element.<br>
# &nbsp;Additional qualification is needed to reference other elements,<br>
#+ which means that the reference MUST be written in Extended-Syntax.<br>
# &nbsp;The general form is: ${name[subscript]}.<br>
# &nbsp;The string forms may also be used: ${name:subscript}<br>
#+ for Bash-Arrays when referencing the subscript zero element.<br>
# Bash-Arrays are implemented internally as linked lists,<br>
#+ not as a fixed area of storage as in some programming languages.<br>
# &nbsp; Characteristics of Bash arrays (Bash-Arrays):<br>
# &nbsp; --------------------------------------------<br>
# &nbsp; If not otherwise specified, Bash-Array subscripts begin with<br>
#+ &nbsp;subscript number zero. Literally: [0]<br>
# &nbsp; This is called zero-based indexing.<br>
###<br>
# &nbsp; If not otherwise specified, Bash-Arrays are subscript packed<br>
#+ &nbsp;(sequential subscripts without subscript gaps).<br>
###<br>
# &nbsp; Negative subscripts are not allowed.<br>
###<br>
# &nbsp; Elements of a Bash-Array need not all be of the same type.<br>
###<br>
# &nbsp; Elements of a Bash-Array may be undefined (null reference).<br>
# &nbsp; &nbsp; &nbsp; That is, a Bash-Array may be &quot;subscript sparse.&quot;<br>
###<br>
# &nbsp; Elements of a Bash-Array may be defined and empty (null contents).<br>
###<br>
# &nbsp; Elements of a Bash-Array may contain:<br>
# &nbsp; &nbsp; * A whole number as a signed 32-bit (or larger) integer<br>
# &nbsp; &nbsp; * A string<br>
Appendix A. Contributed Scripts<br>
755<br>
<hr>
<A name=762></a>Advanced Bash-Scripting Guide<br>
# &nbsp; &nbsp; * A string formated so that it appears to be a function name<br>
# &nbsp; &nbsp; + with optional arguments<br>
###<br>
# &nbsp; Defined elements of a Bash-Array may be undefined (unset).<br>
# &nbsp; &nbsp; &nbsp; That is, a subscript packed Bash-Array may be changed<br>
# &nbsp; + &nbsp; into a subscript sparse Bash-Array.<br>
###<br>
# &nbsp; Elements may be added to a Bash-Array by defining an element<br>
#+ &nbsp;not previously defined.<br>
###<br>
# For these reasons, I have been calling them &quot;Bash-Arrays&quot;.<br>
# I'll return to the generic term &quot;array&quot; from now on.<br>
# &nbsp; &nbsp; -- msz<br>
echo &quot;=========================================================&quot;<br>
# &nbsp;Lines 202 - 334 supplied by Cliff Bamford. (Thanks!)<br>
# &nbsp;Demo --- Interaction with Arrays, quoting, IFS, echo, * and @ &nbsp; --- &nbsp;<br>
#+ all affect how things work<br>
ArrayVar[0]='zero' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 0 normal<br>
ArrayVar[1]=one &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 1 unquoted literal<br>
ArrayVar[2]='two' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 2 normal<br>
ArrayVar[3]='three' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 3 normal<br>
ArrayVar[4]='I am four' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 4 normal with spaces<br>
ArrayVar[5]='five' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 5 normal<br>
unset ArrayVar[6] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 6 undefined<br>
ArrayValue[7]='seven' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 7 normal<br>
ArrayValue[8]='' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 8 defined but empty<br>
ArrayValue[9]='nine' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 9 normal<br>
echo '--- Here is the array we are using for this test'<br>
echo<br>
echo &quot;ArrayVar[0]='zero' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 0 normal&quot;<br>
echo &quot;ArrayVar[1]=one &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 1 unquoted literal&quot;<br>
echo &quot;ArrayVar[2]='two' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 2 normal&quot;<br>
echo &quot;ArrayVar[3]='three' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 3 normal&quot;<br>
echo &quot;ArrayVar[4]='I am four' &nbsp; &nbsp; &nbsp; &nbsp;# 4 normal with spaces&quot;<br>
echo &quot;ArrayVar[5]='five' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 5 normal&quot;<br>
echo &quot;unset ArrayVar[6] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 6 undefined&quot;<br>
echo &quot;ArrayValue[7]='seven' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 7 normal&quot;<br>
echo &quot;ArrayValue[8]='' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 8 defined but empty&quot;<br>
echo &quot;ArrayValue[9]='nine' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 9 normal&quot;<br>
echo<br>
echo<br>
echo '---Case0: No double-quotes, Default IFS of space,tab,newline ---'<br>
IFS=$'\x20'$'\x09'$'\x0A' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# In exactly this order.<br>
echo 'Here is: printf %q {${ArrayVar[*]}'<br>
printf %q ${ArrayVar[*]}<br>
echo<br>
echo 'Here is: printf %q {${ArrayVar[@]}'<br>
printf %q ${ArrayVar[@]}<br>
echo<br>
echo 'Here is: echo ${ArrayVar[*]}'<br>
echo &nbsp;${ArrayVar[@]}<br>
echo 'Here is: echo {${ArrayVar[@]}'<br>
echo ${ArrayVar[@]}<br>
Appendix A. Contributed Scripts<br>
756<br>
<hr>
<A name=763></a>Advanced Bash-Scripting Guide<br>
echo<br>
echo '---Case1: Within double-quotes - Default IFS of space-tab-&nbsp;<br>
newline ---'<br>
IFS=$'\x20'$'\x09'$'\x0A' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;These three bytes,<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---Case2: Within double-quotes - IFS is q'<br>
IFS='q'<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---Case3: Within double-quotes - IFS is ^'<br>
IFS='^'<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---Case4: Within double-quotes - IFS is ^ followed by &nbsp;<br>
space,tab,newline'<br>
IFS=$'^'$'\x20'$'\x09'$'\x0A' &nbsp; &nbsp; &nbsp; # ^ + space tab newline<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---Case6: Within double-quotes - IFS set and empty '<br>
IFS=''<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
Appendix A. Contributed Scripts<br>
757<br>
<hr>
<A name=764></a>Advanced Bash-Scripting Guide<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---Case7: Within double-quotes - IFS is unset'<br>
unset IFS<br>
echo 'Here is: printf %q &quot;{${ArrayVar[*]}&quot;'<br>
printf %q &quot;${ArrayVar[*]}&quot;<br>
echo<br>
echo 'Here is: printf %q &quot;{${ArrayVar[@]}&quot;'<br>
printf %q &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo 'Here is: echo &quot;${ArrayVar[*]}&quot;'<br>
echo &nbsp;&quot;${ArrayVar[@]}&quot;<br>
echo 'Here is: echo &quot;{${ArrayVar[@]}&quot;'<br>
echo &quot;${ArrayVar[@]}&quot;<br>
echo<br>
echo '---End of Cases---'<br>
echo &quot;=========================================================&quot;; echo<br>
# Put IFS back to the default.<br>
# Default is exactly these three bytes.<br>
IFS=$'\x20'$'\x09'$'\x0A' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # In exactly this order.<br>
# Interpretation of the above outputs:<br>
# &nbsp; A Glob-Pattern is I/O; the setting of IFS matters.<br>
###<br>
# &nbsp; An All-Elements-Of does not consider IFS settings.<br>
###<br>
# &nbsp; Note the different output using the echo command and the<br>
#+ &nbsp;quoted format operator of the printf command.<br>
# &nbsp;Recall:<br>
# &nbsp; Parameters are similar to arrays and have the similar behaviors.<br>
###<br>
# &nbsp;The above examples demonstrate the possible variations.<br>
# &nbsp;To retain the shape of a sparse array, additional script<br>
#+ programming is required.<br>
###<br>
# &nbsp;The source code of Bash has a routine to output the<br>
#+ [subscript]=value &nbsp; array assignment format.<br>
# &nbsp;As of version 2.05b, that routine is not used,<br>
#+ but that might change in future releases.<br>
# The length of a string, measured in non-null elements (characters):<br>
echo<br>
echo '- - Non-quoted references - -'<br>
echo 'Non-Null character count: '${#VarSomething}' characters.'<br>
Appendix A. Contributed Scripts<br>
758<br>
<hr>
<A name=765></a>Advanced Bash-Scripting Guide<br>
# test='Lit'$'\x00''eral' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $'\x00' is a null character.<br>
# echo ${#test} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # See that?<br>
# &nbsp;The length of an array, measured in defined elements,<br>
#+ including null content elements.<br>
echo<br>
echo 'Defined content count: '${#ArrayVar[@]}' elements.'<br>
# That is NOT the maximum subscript (4).<br>
# That is NOT the range of the subscripts (1 . . 4 inclusive).<br>
# It IS the length of the linked list.<br>
###<br>
# &nbsp;Both the maximum subscript and the range of the subscripts may<br>
#+ be found with additional script programming.<br>
# The length of a string, measured in non-null elements (characters):<br>
echo<br>
echo '- - Quoted, Glob-Pattern references - -'<br>
echo 'Non-Null character count: '&quot;${#VarSomething}&quot;' characters.'<br>
# &nbsp;The length of an array, measured in defined elements,<br>
#+ including null-content elements.<br>
echo<br>
echo 'Defined element count: '&quot;${#ArrayVar[*]}&quot;' elements.'<br>
# &nbsp;Interpretation: Substitution does not effect the ${# ... } operation.<br>
# &nbsp;Suggestion:<br>
# &nbsp;Always use the All-Elements-Of character<br>
#+ if that is what is intended (independence from IFS).<br>
# &nbsp;Define a simple function.<br>
# &nbsp;I include an underscore in the name<br>
#+ to make it distinctive in the examples below.<br>
###<br>
# &nbsp;Bash separates variable names and function names<br>
#+ in different namespaces.<br>
# &nbsp;The Mark-One eyeball isn't that advanced.<br>
###<br>
_simple() {<br>
&nbsp; &nbsp; echo -n 'SimpleFunc'$@ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Newlines are swallowed in<br>
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ result returned in any case.<br>
# The ( ... ) notation invokes a command or function.<br>
# The $( ... ) notation is pronounced: Result-Of.<br>
# Invoke the function _simple<br>
echo<br>
echo '- - Output of function _simple - -'<br>
_simple &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Try passing arguments.<br>
echo<br>
# or<br>
(_simple) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Try passing arguments.<br>
echo<br>
echo '- Is there a variable of that name? -'<br>
echo $_simple not defined &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # No variable by that name.<br>
Appendix A. Contributed Scripts<br>
759<br>
<hr>
<A name=766></a>Advanced Bash-Scripting Guide<br>
# Invoke the result of function _simple (Error msg intended)<br>
###<br>
$(_simple) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Gives an error message:<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;line 436: SimpleFunc: command not found<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;---------------------------------------<br>
echo<br>
###<br>
# &nbsp;The first word of the result of function _simple<br>
#+ is neither a valid Bash command nor the name of a defined function.<br>
###<br>
# This demonstrates that the output of _simple is subject to evaluation.<br>
###<br>
# Interpretation:<br>
# &nbsp; A function can be used to generate in-line Bash commands.<br>
# A simple function where the first word of result IS a bash command:<br>
###<br>
_print() {<br>
&nbsp; &nbsp; echo -n 'printf %q '$@<br>
}<br>
echo '- - Outputs of function _print - -'<br>
_print parm1 parm2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# An Output NOT A Command.<br>
echo<br>
$(_print parm1 parm2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Executes: printf %q parm1 parm2<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;See above IFS examples for the<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ various possibilities.<br>
echo<br>
$(_print $VarSomething) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # The predictable result.<br>
echo<br>
# Function variables<br>
# ------------------<br>
echo<br>
echo '- - Function variables - -'<br>
# A variable may represent a signed integer, a string or an array.<br>
# A string may be used like a function name with optional arguments.<br>
# set -vx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Enable if desired<br>
declare -f funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ in namespace of functions<br>
funcVar=_print &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Contains name of function.<br>
$funcVar parm1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Same as _print at this point.<br>
echo<br>
funcVar=$(_print ) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Contains result of function.<br>
$funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No input, No output.<br>
$funcVar $VarSomething &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# The predictable result.<br>
echo<br>
funcVar=$(_print $VarSomething) &nbsp; &nbsp; # &nbsp;$VarSomething replaced HERE.<br>
$funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;The expansion is part of the<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ variable contents.<br>
Appendix A. Contributed Scripts<br>
760<br>
<hr>
<A name=767></a>Advanced Bash-Scripting Guide<br>
funcVar=&quot;$(_print $VarSomething)&quot; &nbsp; # &nbsp;$VarSomething replaced HERE.<br>
$funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;The expansion is part of the<br>
echo &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ variable contents.<br>
# &nbsp;The difference between the unquoted and the double-quoted versions<br>
#+ above can be seen in the &quot;protect_literal.sh&quot; example.<br>
# &nbsp;The first case above is processed as two, unquoted, Bash-Words.<br>
# &nbsp;The second case above is processed as one, quoted, Bash-Word.<br>
# Delayed replacement<br>
# -------------------<br>
echo<br>
echo '- - Delayed replacement - -'<br>
funcVar=&quot;$(_print '$VarSomething')&quot; # No replacement, single Bash-Word.<br>
eval $funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $VarSomething replaced HERE.<br>
echo<br>
VarSomething='NewThing'<br>
eval $funcVar &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # $VarSomething replaced HERE.<br>
echo<br>
# Restore the original setting trashed above.<br>
VarSomething=Literal<br>
# &nbsp;There are a pair of functions demonstrated in the<br>
#+ &quot;protect_literal.sh&quot; and &quot;unprotect_literal.sh&quot; examples.<br>
# &nbsp;These are general purpose functions for delayed replacement literals<br>
#+ containing variables.<br>
# REVIEW:<br>
# ------<br>
# &nbsp;A string can be considered a Classic-Array of elements (characters).<br>
# &nbsp;A string operation applies to all elements (characters) of the string<br>
#+ (in concept, anyway).<br>
###<br>
# &nbsp;The notation: ${array_name[@]} represents all elements of the<br>
#+ Bash-Array: array_name.<br>
###<br>
# &nbsp;The Extended-Syntax string operations can be applied to all<br>
#+ elements of an array.<br>
###<br>
# &nbsp;This may be thought of as a For-Each operation on a vector of strings.<br>
###<br>
# &nbsp;Parameters are similar to an array.<br>
# &nbsp;The initialization of a parameter array for a script<br>
#+ and a parameter array for a function only differ<br>
#+ in the initialization of ${0}, which never changes its setting.<br>
###<br>
# &nbsp;Subscript zero of the script's parameter array contains<br>
#+ the name of the script.<br>
###<br>
# &nbsp;Subscript zero of a function's parameter array DOES NOT contain<br>
Appendix A. Contributed Scripts<br>
761<br>
<hr>
<A name=768></a>Advanced Bash-Scripting Guide<br>
#+ the name of the function.<br>
# &nbsp;The name of the current function is accessed by the $FUNCNAME variable.<br>
###<br>
# &nbsp;A quick, review list follows (quick, not short).<br>
echo<br>
echo '- - Test (but not change) - -'<br>
echo '- null reference -'<br>
echo -n ${VarNull-'NotSet'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# NotSet<br>
echo ${VarNull} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NewLine only<br>
echo -n ${VarNull:-'NotSet'}' ' &nbsp; &nbsp; &nbsp; &nbsp; # NotSet<br>
echo ${VarNull} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Newline only<br>
echo '- null contents -'<br>
echo -n ${VarEmpty-'Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Only the space<br>
echo ${VarEmpty} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Newline only<br>
echo -n ${VarEmpty:-'Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; # Empty<br>
echo ${VarEmpty} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Newline only<br>
echo '- contents -'<br>
echo ${VarSomething-'Content'} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Literal<br>
echo ${VarSomething:-'Content'} &nbsp; &nbsp; &nbsp; &nbsp; # Literal<br>
echo '- Sparse Array -'<br>
echo ${ArrayVar[@]-'not set'}<br>
# ASCII-Art time<br>
# State &nbsp; &nbsp; Y==yes, N==no<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - &nbsp; &nbsp; &nbsp; :-<br>
# Unset &nbsp; &nbsp; Y &nbsp; &nbsp; &nbsp; Y &nbsp; &nbsp; &nbsp; ${# ... } == 0<br>
# Empty &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; Y &nbsp; &nbsp; &nbsp; ${# ... } == 0<br>
# Contents &nbsp;N &nbsp; &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; ${# ... } &gt; 0<br>
# &nbsp;Either the first and/or the second part of the tests<br>
#+ may be a command or a function invocation string.<br>
echo<br>
echo '- - Test 1 for undefined - -'<br>
declare -i t<br>
_decT() {<br>
&nbsp; &nbsp; t=$t-1<br>
}<br>
# Null reference, set: t == -1<br>
t=${#VarNull} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Results in zero.<br>
${VarNull- _decT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Function executes, t now -1.<br>
echo $t<br>
# Null contents, set: t == 0<br>
t=${#VarEmpty} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Results in zero.<br>
${VarEmpty- _decT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # _decT function NOT executed.<br>
echo $t<br>
# Contents, set: t == number of non-null characters<br>
VarSomething='_simple' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Set to valid function name.<br>
t=${#VarSomething} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# non-zero length<br>
${VarSomething- _decT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Function _simple executed.<br>
echo $t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Note the Append-To action.<br>
# Exercise: clean up that example.<br>
unset t<br>
unset _decT<br>
VarSomething=Literal<br>
Appendix A. Contributed Scripts<br>
762<br>
<hr>
<A name=769></a>Advanced Bash-Scripting Guide<br>
echo<br>
echo '- - Test and Change - -'<br>
echo '- Assignment if null reference -'<br>
echo -n ${VarNull='NotSet'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# NotSet NotSet<br>
echo ${VarNull}<br>
unset VarNull<br>
echo '- Assignment if null reference -'<br>
echo -n ${VarNull:='NotSet'}' ' &nbsp; &nbsp; &nbsp; &nbsp; # NotSet NotSet<br>
echo ${VarNull}<br>
unset VarNull<br>
echo '- No assignment if null contents -'<br>
echo -n ${VarEmpty='Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Space only<br>
echo ${VarEmpty}<br>
VarEmpty=''<br>
echo '- Assignment if null contents -'<br>
echo -n ${VarEmpty:='Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; # Empty Empty<br>
echo ${VarEmpty}<br>
VarEmpty=''<br>
echo '- No change if already has contents -'<br>
echo ${VarSomething='Content'} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Literal<br>
echo ${VarSomething:='Content'} &nbsp; &nbsp; &nbsp; &nbsp; # Literal<br>
# &quot;Subscript sparse&quot; Bash-Arrays<br>
###<br>
# &nbsp;Bash-Arrays are subscript packed, beginning with<br>
#+ subscript zero unless otherwise specified.<br>
###<br>
# &nbsp;The initialization of ArrayVar was one way<br>
#+ to &quot;otherwise specify&quot;. &nbsp;Here is the other way:<br>
###<br>
echo<br>
declare -a ArraySparse<br>
ArraySparse=( [1]=one [2]='' [4]='four' )<br>
# [0]=null reference, [2]=null content, [3]=null reference<br>
echo '- - Array-Sparse List - -'<br>
# Within double-quotes, default IFS, Glob-Pattern<br>
IFS=$'\x20'$'\x09'$'\x0A'<br>
printf %q &quot;${ArraySparse[*]}&quot;<br>
echo<br>
# &nbsp;Note that the output does not distinguish between &quot;null content&quot;<br>
#+ and &quot;null reference&quot;.<br>
# &nbsp;Both print as escaped whitespace.<br>
###<br>
# &nbsp;Note also that the output does NOT contain escaped whitespace<br>
#+ for the &quot;null reference(s)&quot; prior to the first defined element.<br>
###<br>
# This behavior of 2.04, 2.05a and 2.05b has been reported<br>
#+ and may change in a future version of Bash.<br>
# &nbsp;To output a sparse array and maintain the [subscript]=value<br>
#+ relationship without change requires a bit of programming.<br>
# &nbsp;One possible code fragment:<br>
###<br>
Appendix A. Contributed Scripts<br>
763<br>
<hr>
<A name=770></a>Advanced Bash-Scripting Guide<br>
# local l=${#ArraySparse[@]} &nbsp; &nbsp; &nbsp; &nbsp;# Count of defined elements<br>
# local f=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Count of found subscripts<br>
# local i=0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Subscript to test<br>
( &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Anonymous in-line function<br>
&nbsp; &nbsp; for (( l=${#ArraySparse[@]}, f = 0, i = 0 ; f &lt; l ; i++ ))<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; # 'if defined then...'<br>
&nbsp; &nbsp; &nbsp; &nbsp; ${ArraySparse[$i]+ eval echo '\ ['$i']='${ArraySparse[$i]} ; (( f++ )) }<br>
&nbsp; &nbsp; done<br>
)<br>
# The reader coming upon the above code fragment cold<br>
#+ might want to review &quot;command lists&quot; and &quot;multiple commands on a line&quot;<br>
#+ in the text of the foregoing &quot;Advanced Bash Scripting Guide.&quot;<br>
###<br>
# &nbsp;Note:<br>
# &nbsp;The &quot;read -a array_name&quot; version of the &quot;read&quot; command<br>
#+ begins filling array_name at subscript zero.<br>
# &nbsp;ArraySparse does not define a value at subscript zero.<br>
###<br>
# &nbsp;The user needing to read/write a sparse array to either<br>
#+ external storage or a communications socket must invent<br>
#+ a read/write code pair suitable for their purpose.<br>
###<br>
# Exercise: clean it up.<br>
unset ArraySparse<br>
echo<br>
echo '- - Conditional alternate (But not change)- -'<br>
echo '- No alternate if null reference -'<br>
echo -n ${VarNull+'NotSet'}' '<br>
echo ${VarNull}<br>
unset VarNull<br>
echo '- No alternate if null reference -'<br>
echo -n ${VarNull:+'NotSet'}' '<br>
echo ${VarNull}<br>
unset VarNull<br>
echo '- Alternate if null contents -'<br>
echo -n ${VarEmpty+'Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Empty<br>
echo ${VarEmpty}<br>
VarEmpty=''<br>
echo '- No alternate if null contents -'<br>
echo -n ${VarEmpty:+'Empty'}' ' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Space only<br>
echo ${VarEmpty}<br>
VarEmpty=''<br>
echo '- Alternate if already has contents -'<br>
# Alternate literal<br>
echo -n ${VarSomething+'Content'}' ' &nbsp; &nbsp; &nbsp; &nbsp;# Content Literal<br>
echo ${VarSomething}<br>
# Invoke function<br>
echo -n ${VarSomething:+ $(_simple) }' ' &nbsp; &nbsp;# SimpleFunc Literal<br>
echo ${VarSomething}<br>
echo<br>
echo '- - Sparse Array - -'<br>
Appendix A. Contributed Scripts<br>
764<br>
<hr>
<A name=771></a>Advanced Bash-Scripting Guide<br>
echo ${ArrayVar[@]+'Empty'} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # An array of 'Empty'(ies)<br>
echo<br>
echo '- - Test 2 for undefined - -'<br>
declare -i t<br>
_incT() {<br>
&nbsp; &nbsp; t=$t+1<br>
}<br>
# &nbsp;Note:<br>
# &nbsp;This is the same test used in the sparse array<br>
#+ listing code fragment.<br>
# Null reference, set: t == -1<br>
t=${#VarNull}-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Results in minus-one.<br>
${VarNull+ _incT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Does not execute.<br>
echo $t' Null reference'<br>
# Null contents, set: t == 0<br>
t=${#VarEmpty}-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Results in minus-one.<br>
${VarEmpty+ _incT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Executes.<br>
echo $t' &nbsp;Null content'<br>
# Contents, set: t == (number of non-null characters)<br>
t=${#VarSomething}-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# non-null length minus-one<br>
${VarSomething+ _incT } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Executes.<br>
echo $t' &nbsp;Contents'<br>
# Exercise: clean up that example.<br>
unset t<br>
unset _incT<br>
# ${name?err_msg} ${name:?err_msg}<br>
# &nbsp;These follow the same rules but always exit afterwards<br>
#+ if an action is specified following the question mark.<br>
# &nbsp;The action following the question mark may be a literal<br>
#+ or a function result.<br>
###<br>
# &nbsp;${name?} ${name:?} are test-only, the return can be tested.<br>
# Element operations<br>
# ------------------<br>
echo<br>
echo '- - Trailing sub-element selection - -'<br>
# &nbsp;Strings, Arrays and Positional parameters<br>
# &nbsp;Call this script with multiple arguments<br>
#+ to see the parameter selections.<br>
echo '- All -'<br>
echo ${VarSomething:0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# all non-null characters<br>
echo ${ArrayVar[@]:0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # all elements with content<br>
echo ${@:0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # all parameters with content;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ignoring parameter[0]<br>
echo<br>
Appendix A. Contributed Scripts<br>
765<br>
<hr>
<A name=772></a>Advanced Bash-Scripting Guide<br>
echo '- All after -'<br>
echo ${VarSomething:1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# all non-null after character[0]<br>
echo ${ArrayVar[@]:1} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # all after element[0] with content<br>
echo ${@:2} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # all after param[1] with content<br>
echo<br>
echo '- Range after -'<br>
echo ${VarSomething:4:3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ral<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Three characters after<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # character[3]<br>
echo '- Sparse array gotch -'<br>
echo ${ArrayVar[@]:1:2} &nbsp; &nbsp; # &nbsp;four - The only element with content.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Two elements after (if that many exist).<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;the FIRST WITH CONTENTS<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ (the FIRST WITH &nbsp;CONTENTS is being<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ considered as if it<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ were subscript zero).<br>
# &nbsp;Executed as if Bash considers ONLY array elements with CONTENT<br>
# &nbsp;printf %q &quot;${ArrayVar[@]:0:3}&quot; &nbsp; &nbsp;# Try this one<br>
# &nbsp;In versions 2.04, 2.05a and 2.05b,<br>
#+ Bash does not handle sparse arrays as expected using this notation.<br>
#<br>
# &nbsp;The current Bash maintainer, Chet Ramey, has corrected this.<br>
echo '- Non-sparse array -'<br>
echo ${@:2:2} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Two parameters following parameter[1]<br>
# New victims for string vector examples:<br>
stringZ=abcABC123ABCabc<br>
arrayZ=( abcabc ABCABC 123123 ABCABC abcabc )<br>
sparseZ=( [1]='abcabc' [3]='ABCABC' [4]='' [5]='123123' )<br>
echo<br>
echo ' - - Victim string - -'$stringZ'- - '<br>
echo ' - - Victim array - -'${arrayZ[@]}'- - '<br>
echo ' - - Sparse array - -'${sparseZ[@]}'- - '<br>
echo ' - [0]==null ref, [2]==null ref, [4]==null content - '<br>
echo ' - [1]=abcabc [3]=ABCABC [5]=123123 - '<br>
echo ' - non-null-reference count: '${#sparseZ[@]}' elements'<br>
echo<br>
echo '- - Prefix sub-element removal - -'<br>
echo '- - Glob-Pattern match must include the first character. - -'<br>
echo '- - Glob-Pattern may be a literal or a function result. - -'<br>
echo<br>
# Function returning a simple, Literal, Glob-Pattern<br>
_abc() {<br>
&nbsp; &nbsp; echo -n 'abc'<br>
}<br>
echo '- Shortest prefix -'<br>
echo ${stringZ#123} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unchanged (not a prefix).<br>
echo ${stringZ#$(_abc)} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # ABC123ABCabc<br>
echo ${arrayZ[@]#abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to each element.<br>
# echo ${sparseZ[@]#abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Version-2.05b core dumps.<br>
# Has since been fixed by Chet Ramey.<br>
Appendix A. Contributed Scripts<br>
766<br>
<hr>
<A name=773></a>Advanced Bash-Scripting Guide<br>
# The -it would be nice- First-Subscript-Of<br>
# echo ${#sparseZ[@]#*} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This is NOT valid Bash.<br>
echo<br>
echo '- Longest prefix -'<br>
echo ${stringZ##1*3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Unchanged (not a prefix)<br>
echo ${stringZ##a*C} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# abc<br>
echo ${arrayZ[@]##a*c} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# ABCABC 123123 ABCABC<br>
# echo ${sparseZ[@]##a*c} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Version-2.05b core dumps.<br>
# Has since been fixed by Chet Ramey.<br>
echo<br>
echo '- - Suffix sub-element removal - -'<br>
echo '- - Glob-Pattern match must include the last character. - -'<br>
echo '- - Glob-Pattern may be a literal or a function result. - -'<br>
echo<br>
echo '- Shortest suffix -'<br>
echo ${stringZ%1*3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unchanged (not a suffix).<br>
echo ${stringZ%$(_abc)} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABC<br>
echo ${arrayZ[@]%abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to each element.<br>
# echo ${sparseZ[@]%abc} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Version-2.05b core dumps.<br>
# Has since been fixed by Chet Ramey.<br>
# The -it would be nice- Last-Subscript-Of<br>
# echo ${#sparseZ[@]%*} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # This is NOT valid Bash.<br>
echo<br>
echo '- Longest suffix -'<br>
echo ${stringZ%%1*3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Unchanged (not a suffix)<br>
echo ${stringZ%%b*c} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# a<br>
echo ${arrayZ[@]%%b*c} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# a ABCABC 123123 ABCABC a<br>
# echo ${sparseZ[@]%%b*c} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Version-2.05b core dumps.<br>
# Has since been fixed by Chet Ramey.<br>
echo<br>
echo '- - Sub-element replacement - -'<br>
echo '- - Sub-element at any location in string. - -'<br>
echo '- - First specification is a Glob-Pattern - -'<br>
echo '- - Glob-Pattern may be a literal or Glob-Pattern function result. - -'<br>
echo '- - Second specification may be a literal or function result. - -'<br>
echo '- - Second specification may be unspecified. Pronounce that'<br>
echo ' &nbsp; &nbsp;as: Replace-With-Nothing (Delete) - -'<br>
echo<br>
# Function returning a simple, Literal, Glob-Pattern<br>
_123() {<br>
&nbsp; &nbsp; echo -n '123'<br>
}<br>
echo '- Replace first occurrence -'<br>
echo ${stringZ/$(_123)/999} &nbsp; &nbsp; &nbsp; &nbsp; # Changed (123 is a component).<br>
echo ${stringZ/ABC/xyz} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # xyzABC123ABCabc<br>
echo ${arrayZ[@]/ABC/xyz} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to each element.<br>
echo ${sparseZ[@]/ABC/xyz} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Works as expected.<br>
echo<br>
Appendix A. Contributed Scripts<br>
767<br>
<hr>
<A name=774></a>Advanced Bash-Scripting Guide<br>
echo '- Delete first occurrence -'<br>
echo ${stringZ/$(_123)/}<br>
echo ${stringZ/ABC/}<br>
echo ${arrayZ[@]/ABC/}<br>
echo ${sparseZ[@]/ABC/}<br>
# &nbsp;The replacement need not be a literal,<br>
#+ since the result of a function invocation is allowed.<br>
# &nbsp;This is general to all forms of replacement.<br>
echo<br>
echo '- Replace first occurrence with Result-Of -'<br>
echo ${stringZ/$(_123)/$(_simple)} &nbsp;# Works as expected.<br>
echo ${arrayZ[@]/ca/$(_simple)} &nbsp; &nbsp; # Applied to each element.<br>
echo ${sparseZ[@]/ca/$(_simple)} &nbsp; &nbsp;# Works as expected.<br>
echo<br>
echo '- Replace all occurrences -'<br>
echo ${stringZ//[b2]/X} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # X-out b's and 2's<br>
echo ${stringZ//abc/xyz} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# xyzABC123ABCxyz<br>
echo ${arrayZ[@]//abc/xyz} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to each element.<br>
echo ${sparseZ[@]//abc/xyz} &nbsp; &nbsp; &nbsp; &nbsp; # Works as expected.<br>
echo<br>
echo '- Delete all occurrences -'<br>
echo ${stringZ//[b2]/}<br>
echo ${stringZ//abc/}<br>
echo ${arrayZ[@]//abc/}<br>
echo ${sparseZ[@]//abc/}<br>
echo<br>
echo '- - Prefix sub-element replacement - -'<br>
echo '- - Match must include the first character. - -'<br>
echo<br>
echo '- Replace prefix occurrences -'<br>
echo ${stringZ/#[b2]/X} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unchanged (neither is a prefix).<br>
echo ${stringZ/#$(_abc)/XYZ} &nbsp; &nbsp; &nbsp; &nbsp;# XYZABC123ABCabc<br>
echo ${arrayZ[@]/#abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to each element.<br>
echo ${sparseZ[@]/#abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; # Works as expected.<br>
echo<br>
echo '- Delete prefix occurrences -'<br>
echo ${stringZ/#[b2]/}<br>
echo ${stringZ/#$(_abc)/}<br>
echo ${arrayZ[@]/#abc/}<br>
echo ${sparseZ[@]/#abc/}<br>
echo<br>
echo '- - Suffix sub-element replacement - -'<br>
echo '- - Match must include the last character. - -'<br>
echo<br>
echo '- Replace suffix occurrences -'<br>
echo ${stringZ/%[b2]/X} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Unchanged (neither is a suffix).<br>
echo ${stringZ/%$(_abc)/XYZ} &nbsp; &nbsp; &nbsp; &nbsp;# abcABC123ABCXYZ<br>
echo ${arrayZ[@]/%abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to each element.<br>
echo ${sparseZ[@]/%abc/XYZ} &nbsp; &nbsp; &nbsp; &nbsp; # Works as expected.<br>
echo<br>
echo '- Delete suffix occurrences -'<br>
echo ${stringZ/%[b2]/}<br>
echo ${stringZ/%$(_abc)/}<br>
Appendix A. Contributed Scripts<br>
768<br>
<hr>
<A name=775></a>Advanced Bash-Scripting Guide<br>
echo ${arrayZ[@]/%abc/}<br>
echo ${sparseZ[@]/%abc/}<br>
echo<br>
echo '- - Special cases of null Glob-Pattern - -'<br>
echo<br>
echo '- Prefix all -'<br>
# null substring pattern means 'prefix'<br>
echo ${stringZ/#/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # NEWabcABC123ABCabc<br>
echo ${arrayZ[@]/#/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to each element.<br>
echo ${sparseZ[@]/#/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to null-content also.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # That seems reasonable.<br>
echo<br>
echo '- Suffix all -'<br>
# null substring pattern means 'suffix'<br>
echo ${stringZ/%/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # abcABC123ABCabcNEW<br>
echo ${arrayZ[@]/%/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Applied to each element.<br>
echo ${sparseZ[@]/%/NEW} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Applied to null-content also.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # That seems reasonable.<br>
echo<br>
echo '- - Special case For-Each Glob-Pattern - -'<br>
echo '- - - - This is a nice-to-have dream - - - -'<br>
echo<br>
_GenFunc() {<br>
&nbsp; &nbsp; echo -n ${0} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Illustration only.<br>
&nbsp; &nbsp; # Actually, that would be an arbitrary computation.<br>
}<br>
# All occurrences, matching the AnyThing pattern.<br>
# Currently //*/ does not match null-content nor null-reference.<br>
# /#/ and /%/ does match null-content but not null-reference.<br>
echo ${sparseZ[@]//*/$(_GenFunc)}<br>
# &nbsp;A possible syntax would be to make<br>
#+ the parameter notation used within this construct mean:<br>
# &nbsp; ${1} - The full element<br>
# &nbsp; ${2} - The prefix, if any, to the matched sub-element<br>
# &nbsp; ${3} - The matched sub-element<br>
# &nbsp; ${4} - The suffix, if any, to the matched sub-element<br>
#<br>
# echo ${sparseZ[@]//*/$(_GenFunc ${3})} &nbsp; # Same as ${1} here.<br>
# Perhaps it will be implemented in a future version of Bash.<br>
exit 0<br>
Appendix A. Contributed Scripts<br>
769<br>
<hr>
<A name=776></a><b>Appendix B. Reference Cards</b><br>
The following reference cards provide a useful<i>&nbsp;summary</i>&nbsp;of certain scripting concepts. The foregoing text<br>treats these matters in more depth, as well as giving usage examples.<br>
<b>Table B-1. Special Shell Variables</b><br>
<b>Variable</b><br>
<b>Meaning</b><br>
$0<br>
Filename of script<br>
$1<br>
Positional parameter #1<br>
$2 - $9<br>
Positional parameters #2 - #9<br>
${10}<br>
Positional parameter #10<br>
$#<br>
Number of positional parameters<br>
&quot;$*&quot;<br>
All the positional parameters (as a single<br>word) *<br>
&quot;$@&quot;<br>
All the positional parameters (as separate<br>strings)<br>
${#*}<br>
Number of positional parameters<br>
${#@}<br>
Number of positional parameters<br>
$?<br>
Return value<br>
$$<br>
Process ID (PID) of script<br>
$-<br>
Flags passed to script (using<i>&nbsp;set</i>)<br>
$_<br>
Last argument of previous command<br>
$!<br>
Process ID (PID) of last job run in<br>background<br>
<b>*</b><i>&nbsp;Must be quoted</i>, otherwise it defaults to &quot;$@&quot;.<br>
<b>Table B-2. TEST Operators: Binary Comparison</b><br>
<b>Operator</b><br>
<b>Meaning</b><br>
<b>-----&nbsp;Operator</b><br>
<b>Meaning</b><br>
<a href="abs-guides.html#71">Arithmetic Comparison</a><br>
<a href="abs-guides.html#72">String Comparison</a><br>
-eq<br>
Equal to<br>
=<br>
Equal to<br>
==<br>
Equal to<br>
-ne<br>
Not equal to<br>
!=<br>
Not equal to<br>
-lt<br>
Less than<br>
\&lt;<br>
<a href="abs-guides.html#882">Less than (ASCII) *</a><br>
-le<br>
Less than or equal to<br>
-gt<br>
Greater than<br>
\&gt;<br>
Greater than (ASCII) *<br>
-ge<br>
Greater than or equal to<br>
-z<br>
String is empty<br>
Appendix B. Reference Cards<br>
770<br>
<hr>
<A name=777></a>Advanced Bash-Scripting Guide<br>
-n<br>
String is not empty<br>
Arithmetic Comparison&nbsp;<a href="abs-guides.html#66">within double parentheses (( ... ))</a><br>
&gt;<br>
Greater than<br>
&gt;=<br>
Greater than or equal to<br>
&lt;<br>
Less than<br>
&lt;=<br>
Less than or equal to<br>
<b>*</b><i>&nbsp;If within a double-bracket</i>&nbsp;[[ ... ]]<i>&nbsp;test construct, then no escape</i>&nbsp;\<i>&nbsp;is needed.</i><br>
<b>Table B-3. TEST Operators: Files</b><br>
<b>Operator</b><br>
<b>Tests Whether</b><br>
<b>-----</b><br>
<b>Operator</b><br>
<b>Tests Whether</b><br>
-e<br>
File exists<br>
-s<br>
File is not zero size<br>
-f<br>
File is a<i>&nbsp;regular</i>&nbsp;file<br>
-d<br>
File is a<i>&nbsp;directory</i><br>
-r<br>
File has<i>&nbsp;read</i>&nbsp;permission<br>
-h<br>
<a href="abs-guides.html#224">File is a symbolic link</a><br>
-w<br>
File has<i>&nbsp;write</i>&nbsp;permission<br>
-L<br>
File is a<i>&nbsp;symbolic link</i><br>
-x<br>
File has<i>&nbsp;execute</i>&nbsp;permission<br>
-b<br>
<a href="abs-guides.html#889">File is a block device</a><br>
-c<br>
<a href="abs-guides.html#889">File is a character device</a><br>
-g<br>
<i>sgid</i>&nbsp;flag set<br>
-p<br>
<a href="abs-guides.html#24">File is a pipe</a><br>
-u<br>
<i>suid</i>&nbsp;flag set<br>
-S<br>
<a href="abs-guides.html#461">File is a socket</a><br>
-k<br>
&quot;sticky bit&quot; set<br>
-t<br>
File is associated with a<i>&nbsp;terminal</i><br>
-N<br>
File modified since it was last read<br>
F1 -nt F2<br>
File F1 is<i>&nbsp;newer</i>&nbsp;than F2 *<br>
-O<br>
You own the file<br>
F1 -ot F2<br>
File F1 is<i>&nbsp;older</i>&nbsp;than F2 *<br>
-G<br>
<i>Group id</i>&nbsp;of file same as yours<br>
F1 -ef F2<br>
Files F1 and F2 are<i>&nbsp;hard links</i>&nbsp;to the<br>same file *<br>
!<br>
NOT (inverts sense of above tests)<br>
<b>*</b><i>&nbsp;Binary</i>&nbsp;operator (requires two operands).<br>
<b>Table B-4. Parameter Substitution and Expansion</b><br>
<b>Expression</b><br>
<b>Meaning</b><br>
${var}<br>
Value of&nbsp;<i>var</i>&nbsp;(same as&nbsp;<i>$var</i>)<br>
${var-DEFAULT}<br>
If&nbsp;<i>var</i>&nbsp;not set, evaluate expression as&nbsp;<i>$DEFAULT</i>&nbsp;*<br>
${var:-DEFAULT}&nbsp;If&nbsp;<i>var</i>&nbsp;not set or is empty, evaluate expression as&nbsp;<i>$DEFAULT</i>&nbsp;*<br>
${var=DEFAULT}<br>
If&nbsp;<i>var</i>&nbsp;not set, evaluate expression as&nbsp;<i>$DEFAULT</i>&nbsp;*<br>
Appendix B. Reference Cards<br>
771<br>
<hr>
<A name=778></a>Advanced Bash-Scripting Guide<br>
${var:=DEFAULT}&nbsp;If&nbsp;<i>var</i>&nbsp;not set, evaluate expression as&nbsp;<i>$DEFAULT</i>&nbsp;*<br>
${var+OTHER}<br>
If&nbsp;<i>var</i>&nbsp;set, evaluate expression as&nbsp;<i>$OTHER</i>, otherwise as null string<br>
${var:+OTHER}<br>
If&nbsp;<i>var</i>&nbsp;set, evaluate expression as&nbsp;<i>$OTHER</i>, otherwise as null string<br>
${var?ERR_MSG}<br>
If&nbsp;<i>var</i>&nbsp;not set, print&nbsp;<i>$ERR_MSG</i>&nbsp;and abort script with an exit status of 1.*<br>
${var:?ERR_MSG}&nbsp;If&nbsp;<i>var</i>&nbsp;not set, print&nbsp;<i>$ERR_MSG</i>&nbsp;and abort script with an exit status of 1.*<br>
${!varprefix*}<br>
Matches all previously declared variables beginning with&nbsp;<i>varprefix</i><br>
${!varprefix@}<br>
Matches all previously declared variables beginning with&nbsp;<i>varprefix</i><br>
<b>*</b>&nbsp;If&nbsp;<i>var&nbsp;is</i>&nbsp;set, evaluate the expression as&nbsp;<i>$var</i>&nbsp;with no side-effects.<br>
<b>Table B-5. String Operations</b><br>
<b>Expression</b><br>
<b>Meaning</b><br>
${#string}<br>
Length of&nbsp;<i>$string</i><br>
${string:position}<br>
Extract substring from&nbsp;<i>$string</i>&nbsp;at&nbsp;<i>$position</i><br>
${string:position:length}<br>
Extract&nbsp;<i>$length</i>&nbsp;characters substring from&nbsp;<i>$string<br></i>at&nbsp;<i>$position</i>&nbsp;[zero-indexed, first character is at<br>position 0]<br>
${string#substring}<br>
Strip shortest match of&nbsp;<i>$substring</i>&nbsp;from front of<br><i>$string</i><br>
${string##substring}<br>
Strip longest match of&nbsp;<i>$substring</i>&nbsp;from front of<br><i>$string</i><br>
${string%substring}<br>
Strip shortest match of&nbsp;<i>$substring</i>&nbsp;from back of<br><i>$string</i><br>
${string%%substring}<br>
Strip longest match of&nbsp;<i>$substring</i>&nbsp;from back of<br><i>$string</i><br>
${string/substring/replacement}<br>
Replace first match of&nbsp;<i>$substring</i>&nbsp;with<br><i>$replacement</i><br>
${string//substring/replacement}<br>
Replace<i>&nbsp;all</i>&nbsp;matches of&nbsp;<i>$substring</i>&nbsp;with<br><i>$replacement</i><br>
${string/#substring/replacement}<br>
If&nbsp;<i>$substring</i>&nbsp;matches<i>&nbsp;front</i>&nbsp;end of&nbsp;<i>$string</i>,<br>substitute&nbsp;<i>$replacement</i>&nbsp;for&nbsp;<i>$substring</i><br>
${string/%substring/replacement}<br>
If&nbsp;<i>$substring</i>&nbsp;matches<i>&nbsp;back</i>&nbsp;end of&nbsp;<i>$string</i>,<br>substitute&nbsp;<i>$replacement</i>&nbsp;for&nbsp;<i>$substring</i><br>
expr match &quot;$string&quot; '$substring'<br>
Length of matching&nbsp;<i>$substring</i>* at beginning of<br><i>$string</i><br>
Appendix B. Reference Cards<br>
772<br>
<hr>
<A name=779></a>Advanced Bash-Scripting Guide<br>
expr &quot;$string&quot; : '$substring'<br>
Length of matching&nbsp;<i>$substring</i>* at beginning of<br><i>$string</i><br>
expr index &quot;$string&quot; $substring<br>
Numerical position in&nbsp;<i>$string</i>&nbsp;of first character in<br><i>$substring</i>* that matches [0 if no match, first<br>character counts as position 1]<br>
expr substr $string $position<br>
Extract&nbsp;<i>$length</i>&nbsp;characters from&nbsp;<i>$string</i>&nbsp;starting at<br>
$length<br>
<i>$position</i>&nbsp;[0 if no match, first character counts as<br>position 1]<br>
expr match &quot;$string&quot;<br>
Extract&nbsp;<i>$substring</i>*, searching from beginning of<br>
'\($substring\)'<br>
<i>$string</i><br>
expr &quot;$string&quot; : '\($substring\)'<br>
Extract&nbsp;<i>$substring</i>* , searching from beginning of<br><i>$string</i><br>
expr match &quot;$string&quot;<br>
Extract&nbsp;<i>$substring</i>*, searching from end of<br>
'.*\($substring\)'<br>
<i>$string</i><br>
expr &quot;$string&quot; :<br>
Extract&nbsp;<i>$substring</i>*, searching from end of<br>
'.*\($substring\)'<br>
<i>$string</i><br>
<b>*</b>&nbsp;Where&nbsp;<i>$substring</i><a href="abs-guides.html#354">&nbsp;is a Regular Expression.</a><br>
<b>Table B-6. Miscellaneous Constructs</b><br>
<b>Expression</b><br>
<b>Interpretation</b><br>
<a href="abs-guides.html#355">Brackets</a><br>
if [ CONDITION ]<br>
<a href="abs-guides.html#22">Test construct</a><br>
if [[ CONDITION ]]<br>
<a href="abs-guides.html#65">Extended test construct</a><br>
Array[1]=element1<br>
<a href="abs-guides.html#427">Array initialization</a><br>
[a-z]<br>
<a href="abs-guides.html#355">Range of characters within a Regular Expression</a><br>
Curly Brackets<br>
${variable}<br>
<a href="abs-guides.html#133">Parameter substitution</a><br>
${!variable}<br>
<a href="abs-guides.html#456">Indirect variable reference</a><br>
{ command1; command2; . . . commandN; }&nbsp;<a href="abs-guides.html#20">Block of code</a><br>
{string1,string2,string3,...}<br>
<a href="abs-guides.html#20">Brace expansion</a><br>
{a..z}<br>
<a href="abs-guides.html#546">Extended brace expansion</a><br>
{}<br>
<a href="abs-guides.html#226">Text replacement, after find and xargs</a><br>
<a href="abs-guides.html#19">Parentheses</a><br>
( command1; command2 )<br>
<a href="abs-guides.html#387">Command group executed within a subshell</a><br>
Array=(element1 element2 element3)<br>
<a href="abs-guides.html#428">Array initialization</a><br>
result=$(COMMAND)<br>
<a href="abs-guides.html#174">Command substitution, new style</a><br>
&gt;(COMMAND)<br>
<a href="abs-guides.html#394">Process substitution</a><br>
Appendix B. Reference Cards<br>
773<br>
<hr>
<A name=780></a>Advanced Bash-Scripting Guide<br>
&lt;(COMMAND)<br>
Process substitution<br>
<a href="abs-guides.html#86">Double Parentheses</a><br>
(( var = 78 ))<br>
<a href="abs-guides.html#86">Integer arithmetic</a><br>
var=$(( 20 + 5 ))<br>
Integer arithmetic, with variable assignment<br>
(( var++ ))<br>
<i>C-style</i><a href="abs-guides.html#86">&nbsp; variable increment</a><br>
(( var-- ))<br>
<i>C-style</i><a href="abs-guides.html#86">&nbsp; variable decrement</a><br>
(( var0 = var1&lt;98?9:21 ))<br>
<i>C-style</i><a href="abs-guides.html#19">&nbsp; trinary operation</a><br>
<a href="abs-guides.html#47">Quoting</a><br>
&quot;$variable&quot;<br>
<a href="abs-guides.html#36">&quot;Weak&quot; quoting</a><br>
'string'<br>
<a href="abs-guides.html#36">'Strong' quoting</a><br>
<a href="abs-guides.html#170">Back Quotes</a><br>
result=`COMMAND`<br>
<a href="abs-guides.html#170">Command substitution, classic style</a><br>
Appendix B. Reference Cards<br>
774<br>
<hr>
<A name=781></a><IMG src="abs-guide-781_1.png"><br>
<b>Appendix C. A Sed and Awk Micro-Primer</b><br>
This is a very brief introduction to the<b>&nbsp;sed</b>&nbsp;and<b>&nbsp;awk</b>&nbsp;text processing utilities. We will deal with only a few<br>basic commands here, but that will suffice for understanding simple sed and awk constructs within shell<br>scripts.<br>
<b>sed</b>: a non-interactive text file editor<br>
<b>awk</b>: a field-oriented pattern processing language with a<b>&nbsp;C</b>-style syntax<br>
<a href="abs-guides.html#354">For all their differences, the two utilities share a similar invocation syntax, use regular expressions , read input<br></a>by default from&nbsp;stdin, and output to&nbsp;stdout. These are well-behaved UNIX tools, and they work together<br>well. The output from one can be piped to the other, and their combined capabilities give shell scripts some of<br><a href="abs-guides.html#507">the power of Perl.</a><br>
One important difference between the utilities is that while shell scripts can easily pass arguments<br><a href="abs-guides.html#506">to sed, it is more complicated for awk (see Example 36-5 and Example 28-2).</a><br>
<b>C.1. Sed</b><br>
<i>Sed</i>&nbsp;is a non-interactive&nbsp;[139]<b>&nbsp;s</b>tream<b>&nbsp;ed</b>itor. It receives text input, whether from&nbsp;stdin&nbsp;or from a file,<br>performs certain operations on specified lines of the input, one line at a time, then outputs the result to<br>stdout&nbsp;or to a file. Within a shell script,<i>&nbsp;sed</i>&nbsp;is usually one of several tool components in a pipe.<br>
<i>Sed</i>&nbsp;determines which lines of its input that it will operate on from the<i>&nbsp;address range</i>&nbsp;passed to it.&nbsp;[140]<br>Specify this address range either by line number or by a pattern to match. For example,&nbsp;<i>3d</i>&nbsp;signals<i>&nbsp;sed</i>&nbsp;to<br>delete line 3 of the input, and&nbsp;<i>/Windows/d</i>&nbsp;tells sed that you want every line of the input containing a match<br>to &quot;Windows&quot; deleted.<br>
Of all the operations in the<i>&nbsp;sed</i>&nbsp;toolkit, we will focus primarily on the three most commonly used ones. These<br>are<b>&nbsp;p</b>rinting (to&nbsp;stdout),<b>&nbsp;d</b>eletion, and<b>&nbsp;s</b>ubstitution.<br>
<b>Table C-1. Basic sed operators</b><br>
<b>Operator</b><br>
<b>Name</b><br>
<b>Effect</b><br>
[address-range]/p<br>
print<br>
Print [specified address range]<br>
[address-range]/d<br>
delete<br>
Delete [specified address range]<br>
s/pattern1/pattern2/<br>
substitute&nbsp;Substitute pattern2 for first instance of<br>
pattern1 in a line<br>
[address-range]/s/pattern1/pattern2/&nbsp;substitute&nbsp;Substitute pattern2 for first instance of<br>
pattern1 in a line, over&nbsp;<i>address-range</i><br>
[address-range]/y/pattern1/pattern2/&nbsp;transform&nbsp;replace any character in pattern1 with the<br>
corresponding character in pattern2, over<br><i>address-range</i>&nbsp;(equivalent of<b>&nbsp;tr</b>)<br>
Appendix C. A Sed and Awk Micro-Primer<br>
775<br>
<hr>
<A name=782></a><IMG src="abs-guide-782_1.png"><br>
<IMG src="abs-guide-782_2.png"><br>
Advanced Bash-Scripting Guide<br>
g<br>
global<br>
Operate on<i>&nbsp;every</i>&nbsp;pattern match within each<br>matched line of input<br>
Unless the&nbsp;g&nbsp;(<i>global</i>) operator is appended to a<i>&nbsp;substitute</i>&nbsp;command, the substitution operates only on the<br><i>first</i>&nbsp;instance of a pattern match within each line.<br>
From the command-line and in a shell script, a sed operation may require quoting and certain options.<br>
sed -e '/^$/d' $filename<br>
# The -e option causes the next string to be interpreted as an editing instruction.<br>
# &nbsp;(If passing only a single instruction to sed, the &quot;-e&quot; is optional.)<br>
# &nbsp;The &quot;strong&quot; quotes ('') protect the RE characters in the instruction<br>
#+ from reinterpretation as special characters by the body of the script.<br>
# (This reserves RE expansion of the instruction for sed.)<br>
#<br>
# Operates on the text contained in file $filename.<br>
In certain cases, a<i>&nbsp;sed</i>&nbsp;editing command will not work with single quotes.<br>
filename=file1.txt<br>
pattern=BEGIN<br>
&nbsp; sed &quot;/^$pattern/d&quot; &quot;$filename&quot; &nbsp;# Works as specified.<br>
# sed '/^$pattern/d' &quot;$filename&quot; &nbsp; &nbsp;has unexpected results.<br>
# &nbsp; &nbsp; &nbsp; &nbsp;In this instance, with strong quoting (' ... '),<br>
#+ &nbsp; &nbsp; &nbsp;&quot;$pattern&quot; will not expand to &quot;BEGIN&quot;.<br>
<i>Sed</i>&nbsp;uses the&nbsp;-e&nbsp;option to specify that the following string is an instruction or set of instructions. If<br>there is only a single instruction contained in the string, then this may be omitted.<br>
sed -n '/xzy/p' $filename<br>
# The -n option tells sed to print only those lines matching the pattern.<br>
# Otherwise all input lines would print.<br>
# The -e option not necessary here since there is only a single editing instruction.<br>
<b>Table C-2. Examples of sed operators</b><br>
<b>Notation</b><br>
<b>Effect</b><br>
8d<br>
Delete 8th line of input.<br>
/^$/d<br>
Delete all blank lines.<br>
1,/^$/d<br>
Delete from beginning of input up to, and including first blank line.<br>
/Jones/p<br>
Print only lines containing &quot;Jones&quot; (with -n option).<br>
s/Windows/Linux/<br>
Substitute &quot;Linux&quot; for first instance of &quot;Windows&quot; found in each input line.<br>
s/BSOD/stability/g&nbsp;Substitute &quot;stability&quot; for every instance of &quot;BSOD&quot; found in each input line.<br>
s/ *$//<br>
Delete all spaces at the end of every line.<br>
s/00*/0/g<br>
Compress all consecutive sequences of zeroes into a single zero.<br>
/GUI/d<br>
Delete all lines containing &quot;GUI&quot;.<br>
s/GUI//g<br>
Delete all instances of &quot;GUI&quot;, leaving the remainder of each line intact.<br>
Substituting a zero-length string for another is equivalent to deleting that string within a line of input. This<br>leaves the remainder of the line intact. Applying&nbsp;<b>s/GUI//</b>&nbsp;to the line<br>
Appendix C. A Sed and Awk Micro-Primer<br>
776<br>
<hr>
<A name=783></a><IMG src="abs-guide-783_1.png"><br>
<IMG src="abs-guide-783_2.png"><br>
Advanced Bash-Scripting Guide<br>
<b>The most important parts of any application are its GUI and sound effects</b><br>
results in<br>
The most important parts of any application are its &nbsp;and sound effects<br>
A backslash forces the<b>&nbsp;sed</b>&nbsp;replacement command to continue on to the next line. This has the effect of using<br>the<i>&nbsp;newline</i>&nbsp;at the end of the first line as the<i>&nbsp;replacement string</i>.<br>
s/^ &nbsp;*/\<br>
/g<br>
This substitution replaces line-beginning spaces with a newline. The net result is to replace paragraph indents<br>with a blank line between paragraphs.<br>
An address range followed by one or more operations may require open and closed curly brackets, with<br>appropriate newlines.<br>
/[0-9A-Za-z]/,/^$/{<br>
/^$/d<br>
}<br>
This deletes only the first of each set of consecutive blank lines. That might be useful for single-spacing a text<br>file, but retaining the blank line(s) between paragraphs.<br>
The usual delimiter that<i>&nbsp;sed</i>&nbsp;uses is /. However,<i>&nbsp;sed</i>&nbsp;allows other delimiters, such as %. This is useful<br><a href="abs-guides.html#149">when / is part of a replacement string, as in a file pathname. See Example 11-9 and Example 16-32.</a><br>
A quick way to double-space a text file is&nbsp;<b>sed G filename</b>.<br>
For illustrative examples of sed within shell scripts, see:<br>
<a href="abs-guides.html#504">Example 36-1</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#504">Example 36-2</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#226">Example 16-3</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#572">Example A-2</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#248">Example 16-17</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#259">Example 16-27</a><br>
6.&nbsp;<br>
<a href="abs-guides.html#590">Example A-12</a><br>
7.&nbsp;<br>
<a href="abs-guides.html#593">Example A-16</a><br>
8.&nbsp;<br>
<a href="abs-guides.html#594">Example A-17</a><br>
9.&nbsp;<br>
<a href="abs-guides.html#266">Example 16-32</a><br>
10.&nbsp;<br>
<a href="abs-guides.html#149">Example 11-9</a><br>
11.&nbsp;<br>
<a href="abs-guides.html#299">Example 16-48</a><br>
12.&nbsp;<br>
<a href="abs-guides.html#572">Example A-1</a><br>
13.&nbsp;<br>
<a href="abs-guides.html#244">Example 16-14</a><br>
14.&nbsp;<br>
<a href="abs-guides.html#241">Example 16-12</a><br>
15.&nbsp;<br>
<a href="abs-guides.html#583">Example A-10</a><br>
16.&nbsp;<br>
<a href="abs-guides.html#368">Example 19-12</a><br>
17.&nbsp;<br>
<a href="abs-guides.html#251">Example 16-19</a><br>
18.&nbsp;<br>
<a href="abs-guides.html#662">Example A-29</a><br>
19.&nbsp;<br>
<a href="abs-guides.html#674">Example A-31</a><br>
20.&nbsp;<br>
<a href="abs-guides.html#618">Example A-24</a><br>
21.&nbsp;<br>
<a href="abs-guides.html#721">Example A-43</a><br>
22.&nbsp;<br>
For a more extensive treatment of<i>&nbsp;sed</i>, check the appropriate references in the&nbsp;<a href="abs-guides.html#565"><i>Bibliography</i>.</a><br>
Appendix C. A Sed and Awk Micro-Primer<br>
777<br>
<hr>
<A name=784></a>Advanced Bash-Scripting Guide<br>
<b>C.2. Awk</b><br>
<i>Awk&nbsp;</i>[141] is a full-featured text processing language with a syntax reminiscent of<i>&nbsp;C</i>. While it possesses an<br>extensive set of operators and capabilities, we will cover only a few of these here - the ones most useful in<br>shell scripts.<br>
Awk breaks each line of input passed to it into&nbsp;<a href="abs-guides.html#35">&nbsp;fields. By default, a field is a string of consecutive characters<br></a><a href="abs-guides.html#34">delimited by whitespace, though there are options for changing this. Awk parses and operates on each separate<br></a>field. This makes it ideal for handling structured text files -- especially tables -- data organized into consistent<br>chunks, such as rows and columns.<br>
<a href="abs-guides.html#36">Strong quoting and curly brackets enclose blocks of awk code within a shell script.</a><br>
# $1 is field #1, $2 is field #2, etc.<br>
echo one two | awk '{print $1}'<br>
# one<br>
echo one two | awk '{print $2}'<br>
# two<br>
# But what is field #0 ($0)?<br>
echo one two | awk '{print $0}'<br>
# one two<br>
# All the fields!<br>
awk '{print $3}' $filename<br>
# Prints field #3 of file $filename to stdout.<br>
awk '{print $1 $5 $6}' $filename<br>
# Prints fields #1, #5, and #6 of file $filename.<br>
awk '{print $0}' $filename<br>
# Prints the entire file!<br>
# Same effect as: &nbsp; cat $filename . . . or . . . sed '' $filename<br>
We have just seen the awk<i>&nbsp;print</i>&nbsp;command in action. The only other feature of awk we need to deal with here<br>is variables. Awk handles variables similarly to shell scripts, though a bit more flexibly.<br>
{ total += ${column_number} }<br>
This adds the value of&nbsp;<i>column_number</i>&nbsp;to the running total of&nbsp;<i>total</i>&gt;. Finally, to print &quot;total&quot;, there is an<br><b>END</b>&nbsp;command block, executed after the script has processed all its input.<br>
END { print total }<br>
Corresponding to the<b>&nbsp;END</b>, there is a<b>&nbsp;BEGIN</b>, for a code block to be performed before awk starts processing<br>its input.<br>
The following example illustrates how<b>&nbsp;awk</b>&nbsp;can add text-parsing tools to a shell script.<br>
<b>Example C-1. Counting Letter Occurrences</b><br>
#! /bin/sh<br>
Appendix C. A Sed and Awk Micro-Primer<br>
778<br>
<hr>
<A name=785></a>Advanced Bash-Scripting Guide<br>
# letter-count2.sh: Counting letter occurrences in a text file.<br>
#<br>
# Script by nyal [nyal@voila.fr].<br>
# Used in ABS Guide with permission.<br>
# Recommented and reformatted by ABS Guide author.<br>
# Version 1.1: Modified to work with gawk 3.1.3.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Will still work with earlier versions.)<br>
INIT_TAB_AWK=&quot;&quot;<br>
# Parameter to initialize awk script.<br>
count_case=0<br>
FILE_PARSE=$1<br>
E_PARAMERR=85<br>
usage()<br>
{<br>
&nbsp; &nbsp; echo &quot;Usage: letter-count.sh file letters&quot; 2&gt;&amp;1<br>
&nbsp; &nbsp; # For example: &nbsp; ./letter-count2.sh filename.txt a b c<br>
&nbsp; &nbsp; exit $E_PARAMERR &nbsp;# Too few arguments passed to script.<br>
}<br>
if [ ! -f &quot;$1&quot; ] ; then<br>
&nbsp; &nbsp; echo &quot;$1: No such file.&quot; 2&gt;&amp;1<br>
&nbsp; &nbsp; usage &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Print usage message and exit.<br>
fi&nbsp;<br>
if [ -z &quot;$2&quot; ] ; then<br>
&nbsp; &nbsp; echo &quot;$2: No letters specified.&quot; 2&gt;&amp;1<br>
&nbsp; &nbsp; usage<br>
fi&nbsp;<br>
shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Letters specified.<br>
for letter in `echo $@` &nbsp; &nbsp;# For each one . . .<br>
&nbsp; do<br>
&nbsp; INIT_TAB_AWK=&quot;$INIT_TAB_AWK tab_search[${count_case}] = \<br>
&nbsp; \&quot;$letter\&quot;; final_tab[${count_case}] = 0; &quot;&nbsp;<br>
&nbsp; # Pass as parameter to awk script below.<br>
&nbsp; count_case=`expr $count_case + 1`<br>
done<br>
# DEBUG:<br>
# echo $INIT_TAB_AWK;<br>
cat $FILE_PARSE |<br>
# Pipe the target file to the following awk script.<br>
# ---------------------------------------------------------------------<br>
# Earlier version of script:<br>
# awk -v tab_search=0 -v final_tab=0 -v tab=0 -v \<br>
# nb_letter=0 -v chara=0 -v chara2=0 \<br>
awk \<br>
&quot;BEGIN { $INIT_TAB_AWK } \<br>
{ split(\$0, tab, \&quot;\&quot;); \<br>
for (chara in tab) \<br>
{ for (chara2 in tab_search) \<br>
{ if (tab_search[chara2] == tab[chara]) { final_tab[chara2]++ } } } } \<br>
END { for (chara in final_tab) \<br>
{ print tab_search[chara] \&quot; =&gt; \&quot; final_tab[chara] } }&quot;<br>
# ---------------------------------------------------------------------<br>
Appendix C. A Sed and Awk Micro-Primer<br>
779<br>
<hr>
<A name=786></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Nothing all that complicated, just . . .<br>
#+ for-loops, if-tests, and a couple of specialized functions.<br>
exit $?<br>
# Compare this script to letter-count.sh.<br>
For simpler examples of awk within shell scripts, see:<br>
<a href="abs-guides.html#202">Example 15-14</a><br>
1.&nbsp;<br>
<a href="abs-guides.html#382">Example 20-8</a><br>
2.&nbsp;<br>
<a href="abs-guides.html#266">Example 16-32</a><br>
3.&nbsp;<br>
<a href="abs-guides.html#506">Example 36-5</a><br>
4.&nbsp;<br>
<a href="abs-guides.html#458">Example 28-2</a><br>
5.&nbsp;<br>
<a href="abs-guides.html#207">Example 15-20</a><br>
6.&nbsp;<br>
<a href="abs-guides.html#465">Example 29-3</a><br>
7.&nbsp;<br>
<a href="abs-guides.html#467">Example 29-4</a><br>
8.&nbsp;<br>
<a href="abs-guides.html#145">Example 11-3</a><br>
9.&nbsp;<br>
<a href="abs-guides.html#315">Example 16-60</a><br>
10.&nbsp;<br>
<a href="abs-guides.html#122">Example 9-16</a><br>
11.&nbsp;<br>
<a href="abs-guides.html#227">Example 16-4</a><br>
12.&nbsp;<br>
<a href="abs-guides.html#132">Example 10-6</a><br>
13.&nbsp;<br>
<a href="abs-guides.html#531">Example 36-17</a><br>
14.&nbsp;<br>
<a href="abs-guides.html#148">Example 11-8</a><br>
15.&nbsp;<br>
<a href="abs-guides.html#505">Example 36-4</a><br>
16.&nbsp;<br>
<a href="abs-guides.html#306">Example 16-53</a><br>
17.&nbsp;<br>
That's all the awk we'll cover here, folks, but there's lots more to learn. See the appropriate references in the<br><a href="abs-guides.html#565"><i>Bibliography</i></a>.<br>
Appendix C. A Sed and Awk Micro-Primer<br>
780<br>
<hr>
<A name=787></a><IMG src="abs-guide-787_1.png"><br>
<b>Appendix D. Exit Codes With Special Meanings</b><br>
<b>Table D-1.<i>&nbsp;Reserved</i></b><b>&nbsp;Exit Codes</b><br>
<b>Exit Code</b><br>
<b>Meaning</b><br>
<b>Example</b><br>
<b>Comments</b><br>
<b>Number</b><br>
1<br>
Catchall for general errors<br>
let &quot;var1 = 1/0&quot;<br>
Miscellaneous errors, such as<br>&quot;divide by zero&quot; and other<br>impermissible operations<br>
2<br>
Misuse of shell builtins (according<br>
empty_function() {}<br>
Seldom seen, usually defaults<br>
to Bash documentation)<br>
to exit code 1<br>
126<br>
Command invoked cannot execute<br>
Permission problem or<br>command is not an<br>executable<br>
127<br>
&quot;command not found&quot;<br>
illegal_command<br>
Possible problem with<br>$PATH&nbsp;or a typo<br>
128<br>
<a href="abs-guides.html#57">Invalid argument to exit</a><br>
exit 3.14159<br>
<b>exit</b>&nbsp;takes only integer args in<br>the range 0 - 255 (see first<br>footnote)<br>
128+n<br>
Fatal error signal &quot;n&quot;<br>
<i>kill -9&nbsp;</i>$PPID&nbsp;of script&nbsp;<b>$?</b>&nbsp;returns 137 (128 + 9)<br>
130<br>
Script terminated by Control-C<br>
Control-C is fatal error signal<br>2, (130 = 128 + 2, see above)<br>
255*<br>
Exit status out of range<br>
exit -1<br>
<b>exit</b>&nbsp;takes only integer args in<br>the range 0 - 255<br>
According to the above table, exit codes 1 - 2, 126 - 165, and 255&nbsp;[142] have special meanings, and should<br>therefore be avoided for user-specified exit parameters. Ending a script with<i>&nbsp;exit 127</i>&nbsp;would certainly cause<br>confusion when troubleshooting (is the error code a &quot;command not found&quot; or a user-defined one?). However,<br>many scripts use an<i>&nbsp;exit 1</i>&nbsp;as a general bailout-upon-error. Since exit code 1 signifies so many possible errors,<br>it is not particularly useful in debugging.<br>
There has been an attempt to systematize exit status numbers (see&nbsp;/usr/include/sysexits.h), but this<br>is intended for C and C++ programmers. A similar standard for scripting might be appropriate. The author of<br>this document proposes restricting user-defined exit codes to the range 64 - 113 (in addition to 0, for success),<br>to conform with the C/C++ standard. This would allot 50 valid codes, and make troubleshooting scripts more<br>straightforward.&nbsp;[143] All user-defined exit codes in the accompanying examples to this document conform to<br><a href="abs-guides.html#100">this standard, except where overriding circumstances exist, as in Example 9-2.</a><br>
<a href="abs-guides.html#109">Issuing a $? from the command-line after a shell script exits gives results consistent with the table above<br></a>only from the Bash or<i>&nbsp;sh</i>&nbsp;prompt. Running the<i>&nbsp;C-shell</i>&nbsp;or<i>&nbsp;tcsh</i>&nbsp;may give different values in some cases.<br>
Appendix D. Exit Codes With Special Meanings<br>
781<br>
<hr>
<A name=788></a><b>Appendix E. A Detailed Introduction to I/O and I/O<br>Redirection</b><br>
<i>written by Stéphane Chazelas, and revised by the document author</i><br>
<a href="abs-guides.html#374">A command expects the first three file descriptors to be available. The first,</a><i>&nbsp;fd 0</i>&nbsp;(standard input,&nbsp;stdin), is<br>for reading. The other two (<i>fd 1</i>,&nbsp;stdout&nbsp;and<i>&nbsp;fd 2</i>,&nbsp;stderr) are for writing.<br>
There is a&nbsp;stdin,&nbsp;stdout, and a&nbsp;stderr&nbsp;associated with each command.&nbsp;<b>ls 2&gt;&amp;1</b>&nbsp;means temporarily<br>connecting the&nbsp;stderr&nbsp;of the<b>&nbsp;ls</b>&nbsp;command to the same &quot;resource&quot; as the shell's&nbsp;stdout.<br>
By convention, a command reads its input from fd 0 (stdin), prints normal output to fd 1 (stdout), and<br>error ouput to fd 2 (stderr). If one of those three fd's is not open, you may encounter problems:<br>
bash$&nbsp;<b>cat /etc/passwd &gt;&amp;-<br></b>cat: standard output: Bad file descriptor<br>
For example, when<b>&nbsp;xterm</b>&nbsp;runs, it first initializes itself. Before running the user's shell,<b>&nbsp;xterm</b>&nbsp;opens the<br>terminal device (/dev/pts/&lt;n&gt; or something similar) three times.<br>
At this point, Bash inherits these three file descriptors, and each command (child process) run by Bash inherits<br><a href="abs-guides.html#374">them in turn, except when you redirect the command. Redirection means reassigning one of the file<br></a>descriptors to another file (or a pipe, or anything permissible). File descriptors may be reassigned locally (for<br><a href="abs-guides.html#387">a command, a command group, a subshell, a while or if or case or for loop...), or globally, for the remainder of<br></a><a href="abs-guides.html#212">the shell (using exec).</a><br>
<b>ls &gt; /dev/null</b>&nbsp;means running<b>&nbsp;ls</b>&nbsp;with its fd 1 connected to&nbsp;/dev/null.<br>
bash$&nbsp;<b>lsof -a -p $$ -d0,1,2<br></b>COMMAND PID &nbsp; &nbsp; USER &nbsp; FD &nbsp; TYPE DEVICE SIZE NODE NAME<br>
&nbsp;bash &nbsp; &nbsp;363 bozo &nbsp; &nbsp; &nbsp; &nbsp;0u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
&nbsp;bash &nbsp; &nbsp;363 bozo &nbsp; &nbsp; &nbsp; &nbsp;1u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
&nbsp;bash &nbsp; &nbsp;363 bozo &nbsp; &nbsp; &nbsp; &nbsp;2u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
bash$&nbsp;<b>exec 2&gt; /dev/null<br></b>bash$&nbsp;<b>lsof -a -p $$ -d0,1,2<br></b>COMMAND PID &nbsp; &nbsp; USER &nbsp; FD &nbsp; TYPE DEVICE SIZE NODE NAME<br>
&nbsp;bash &nbsp; &nbsp;371 bozo &nbsp; &nbsp; &nbsp; &nbsp;0u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
&nbsp;bash &nbsp; &nbsp;371 bozo &nbsp; &nbsp; &nbsp; &nbsp;1u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
&nbsp;bash &nbsp; &nbsp;371 bozo &nbsp; &nbsp; &nbsp; &nbsp;2w &nbsp; CHR &nbsp; &nbsp;1,3 &nbsp; &nbsp; &nbsp; 120 /dev/null<br>
bash$&nbsp;<b>bash -c 'lsof -a -p $$ -d0,1,2' | cat<br></b>COMMAND PID USER &nbsp; FD &nbsp; TYPE DEVICE SIZE NODE NAME<br>
&nbsp;lsof &nbsp; &nbsp;379 root &nbsp; &nbsp;0u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
&nbsp;lsof &nbsp; &nbsp;379 root &nbsp; &nbsp;1w &nbsp;FIFO &nbsp; &nbsp;0,0 &nbsp; &nbsp; &nbsp;7118 pipe<br>
&nbsp;lsof &nbsp; &nbsp;379 root &nbsp; &nbsp;2u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
bash$&nbsp;<b>echo &quot;$(bash -c 'lsof -a -p $$ -d0,1,2' 2&gt;&amp;1)&quot;<br></b>COMMAND PID USER &nbsp; FD &nbsp; TYPE DEVICE SIZE NODE NAME<br>
&nbsp;lsof &nbsp; &nbsp;426 root &nbsp; &nbsp;0u &nbsp; CHR &nbsp;136,1 &nbsp; &nbsp; &nbsp; &nbsp; 3 /dev/pts/1<br>
Appendix E. A Detailed Introduction to I/O and I/O Redirection<br>
782<br>
<hr>
<A name=789></a>Advanced Bash-Scripting Guide<br>
&nbsp;lsof &nbsp; &nbsp;426 root &nbsp; &nbsp;1w &nbsp;FIFO &nbsp; &nbsp;0,0 &nbsp; &nbsp; &nbsp;7520 pipe<br>
&nbsp;lsof &nbsp; &nbsp;426 root &nbsp; &nbsp;2w &nbsp;FIFO &nbsp; &nbsp;0,0 &nbsp; &nbsp; &nbsp;7520 pipe<br>
This works for different types of redirection.<br>
<b>Exercise:</b>&nbsp;Analyze the following script.<br>
#! /usr/bin/env bash<br>
mkfifo /tmp/fifo1 /tmp/fifo2<br>
while read a; do echo &quot;FIFO1: $a&quot;; done &lt; /tmp/fifo1 &amp; exec 7&gt; /tmp/fifo1<br>
exec 8&gt; &gt;(while read a; do echo &quot;FD8: $a, to fd7&quot;; done &gt;&amp;7)<br>
exec 3&gt;&amp;1<br>
(<br>
&nbsp;(<br>
&nbsp; (<br>
&nbsp; &nbsp;while read a; do echo &quot;FIFO2: $a&quot;; done &lt; /tmp/fifo2 | tee /dev/stderr \<br>
&nbsp; &nbsp;| tee /dev/fd/4 | tee /dev/fd/5 | tee /dev/fd/6 &gt;&amp;7 &amp; exec 3&gt; /tmp/fifo2<br>
&nbsp; &nbsp;echo 1st, to stdout<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 2nd, to stderr &gt;&amp;2<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 3rd, to fd 3 &gt;&amp;3<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 4th, to fd 4 &gt;&amp;4<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 5th, to fd 5 &gt;&amp;5<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 6th, through a pipe | sed 's/.*/PIPE: &amp;, to fd 5/' &gt;&amp;5<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 7th, to fd 6 &gt;&amp;6<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 8th, to fd 7 &gt;&amp;7<br>
&nbsp; &nbsp;sleep 1<br>
&nbsp; &nbsp;echo 9th, to fd 8 &gt;&amp;8<br>
&nbsp; ) 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | while read a; do echo &quot;FD4: $a&quot;; done 1&gt;&amp;3 5&gt;&amp;- 6&gt;&amp;-<br>
&nbsp;) 5&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD5: $a&quot;; done 1&gt;&amp;3 6&gt;&amp;-<br>
) 6&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD6: $a&quot;; done 3&gt;&amp;-<br>
rm -f /tmp/fifo1 /tmp/fifo2<br>
# For each command and subshell, figure out which fd points to what.<br>
# Good luck!<br>
exit 0<br>
Appendix E. A Detailed Introduction to I/O and I/O Redirection<br>
783<br>
<hr>
<A name=790></a><b>Appendix F. Command-Line Options</b><br>
Many executables, whether binaries or script files, accept options to modify their run-time behavior. For<br>example: from the command-line, typing<b>&nbsp;command -o</b>&nbsp;would invoke<i>&nbsp;command</i>, with option&nbsp;o.<br>
<b>F.1. Standard Command-Line Options</b><br>
Over time, there has evolved a loose standard for the meanings of command-line option flags. The GNU<br>utilities conform more closely to this &quot;standard&quot; than older UNIX utilities.<br>
Traditionally, UNIX command-line options consist of a dash, followed by one or more lowercase letters. The<br>GNU utilities added a double-dash, followed by a complete word or compound word.<br>
The two most widely-accepted options are:<br>
-h<br>
•&nbsp;<br>
--help<br>
<i>Help</i>: Give usage message and exit.<br>-v<br>
•&nbsp;<br>
--version<br>
<i>Version</i>: Show program version and exit.<br>
Other common options are:<br>
-a<br>
•&nbsp;<br>
--all<br>
<i>All</i>: show<i>&nbsp;all</i>&nbsp;information or operate on<i>&nbsp;all</i>&nbsp;arguments.<br>-l<br>
•&nbsp;<br>
--list<br>
<i>List</i>: list files or arguments without taking other action.<br>-o<br>
•&nbsp;<br>
<i>Output</i>&nbsp;filename<br>-q<br>
•&nbsp;<br>
--quiet<br>
<i>Quiet</i>: suppress&nbsp;stdout.<br>-r<br>
•&nbsp;<br>
-R<br>
Appendix F. Command-Line Options<br>
784<br>
<hr>
<A name=791></a><IMG src="abs-guide-791_1.png"><br>
Advanced Bash-Scripting Guide<br>
--recursive<br>
<i>Recursive</i>: Operate recursively (down directory tree).<br>-v<br>
•&nbsp;<br>
--verbose<br>
<i>Verbose</i>: output additional information to&nbsp;stdout&nbsp;or&nbsp;stderr.<br>-z<br>
•&nbsp;<br>
--compress<br>
<i>Compress</i><a href="abs-guides.html#265">: apply compression (usually gzip).</a><br>
However:<br>
In<br>
•&nbsp;&nbsp;<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;gawk</b>:<br>
-f<br>
--file<br>
<i>File</i>: filename follows.<br>In<br>
•&nbsp;&nbsp;<b>&nbsp;cp</b>,<b>&nbsp;mv</b>,<b>&nbsp;rm</b>:<br>
-f<br>
--force<br>
<i>Force</i>: force overwrite of target file(s).<br>
Many UNIX and Linux utilities deviate from this &quot;standard,&quot; so it is dangerous to<i>&nbsp;assume</i>&nbsp;that a given<br>option will behave in a standard way. Always check the man page for the command in question when in<br>doubt.<br>
<a href="http://www.gnu.org/prep/standards/">A complete table of recommended options for the GNU utilities is available at the GNU standards page.</a><br>
<b>F.2. Bash Command-Line Options</b><br>
<i>Bash</i>&nbsp;itself has a number of command-line options. Here are some of the more useful ones.<br>
-c<br>
•&nbsp;<br>
<a href="abs-guides.html#104"><i>Read commands from the following string and assign any arguments to the positional parameters.</i></a><br>
bash$&nbsp;<b>bash -c 'set a b c d; IFS=&quot;+-;&quot;; echo &quot;$*&quot;'<br></b>a+b+c+d<br>
-r<br>
•&nbsp;<br>
Appendix F. Command-Line Options<br>
785<br>
<hr>
<A name=792></a>Advanced Bash-Scripting Guide<br>
--restricted<br>
<a href="abs-guides.html#392"><i>Runs the shell, or a script, in restricted mode.<br></i></a>--posix<br>
•&nbsp;<br>
<a href="abs-guides.html#881"><i>Forces Bash to conform to POSIX mode.<br></i></a>--version<br>
•&nbsp;<br>
<i>Display Bash version information and exit.<br></i>--<br>
•&nbsp;<br>
<i>End of options. Anything further on the command line is an argument, not an option.</i><br>
Appendix F. Command-Line Options<br>
786<br>
<hr>
<A name=793></a><IMG src="abs-guide-793_1.png"><br>
<b>Appendix G. Important Files</b><br>
<b>startup files</b><br>
<a href="abs-guides.html#41">These files contain the aliases and environmental variables made available to Bash running as a user<br></a>shell and to all Bash scripts invoked after system initialization.<br>
/etc/profile<br>
Systemwide defaults, mostly setting the environment (all Bourne-type shells, not just Bash&nbsp;[144])<br>
/etc/bashrc<br>
<a href="abs-guides.html#421">systemwide functions and aliases for Bash</a><br>
$HOME/.bash_profile<br>
user-specific Bash environmental default settings, found in each user's home directory (the local<br>counterpart to&nbsp;/etc/profile)<br>
$HOME/.bashrc<br>
user-specific Bash init file, found in each user's home directory (the local counterpart to<br>/etc/bashrc<a href="abs-guides.html#804">). Only interactive shells and user scripts read this file. See Appendix L for a sample<br></a>.bashrc&nbsp;file.<br>
<b>logout file</b><br>
$HOME/.bash_logout<br>
user-specific instruction file, found in each user's home directory. Upon exit from a login (Bash) shell,<br>the commands in this file execute.<br>
<b>data files</b><br>
/etc/passwd<br>
A listing of all the user accounts on the system, their identities, their home directories, the groups they<br>belong to, and their default shell. Note that the user passwords are<i>&nbsp;not</i>&nbsp;stored in this file,&nbsp;[145] but in<br>/etc/shadow&nbsp;in encrypted form.<br>
<b>system configuration files</b><br>
/etc/sysconfig/hwconf<br>
Listing and description of attached hardware devices. This information is in text form and can be<br>extracted and parsed.<br>
bash$&nbsp;<b>grep -A 5 AUDIO /etc/sysconfig/hwconf<br></b>class: AUDIO<br>
&nbsp;bus: PCI<br>
&nbsp;detached: 0<br>
&nbsp;driver: snd-intel8x0<br>
&nbsp;desc: &quot;Intel Corporation 82801CA/CAM AC'97 Audio Controller&quot;<br>
&nbsp;vendorId: 8086<br>
This file is present on Red Hat and Fedora Core installations, but may be missing from<br>other distros.<br>
Appendix G. Important Files<br>
787<br>
<hr>
<A name=794></a><b>Appendix H. Important System Directories</b><br>
Sysadmins and anyone else writing administrative scripts should be intimately familiar with the following<br>system directories.<br>
/bin<br>
•&nbsp;<br>
Binaries (executables). Basic system programs and utilities (such as<b>&nbsp;bash</b>).<br>/usr/bin<br>
•&nbsp;<br>
[146]<br>
More system binaries.<br>/usr/local/bin<br>
•&nbsp;<br>
Miscellaneous binaries local to the particular machine.<br>/sbin<br>
•&nbsp;<br>
System binaries. Basic system administrative programs and utilities (such as<b>&nbsp;fsck</b>).<br>/usr/sbin<br>
•&nbsp;<br>
More system administrative programs and utilities.<br>/etc<br>
•&nbsp;<br>
<i>Et cetera</i>. Systemwide configuration scripts.<br>
Of particular interest are the&nbsp;<a href="abs-guides.html#342">/etc/fstab&nbsp;(filesystem table),&nbsp;</a>/etc/mtab&nbsp;(mounted filesystem<br><a href="abs-guides.html#338">table), and the&nbsp;/etc/inittab&nbsp;files.<br></a>/etc/rc.d<br>
•&nbsp;<br>
Boot scripts, on Red Hat and derivative distributions of Linux.<br>/usr/share/doc<br>
•&nbsp;<br>
Documentation for installed packages.<br>/usr/man<br>
•&nbsp;<br>
<a href="abs-guides.html#225">The systemwide manpages.<br></a>/dev<br>
•&nbsp;<br>
Device directory. Entries (but<i>&nbsp;not</i><a href="abs-guides.html#460">&nbsp;mount points) for physical and virtual devices. See Chapter 29.<br></a>/proc<br>
•&nbsp;<br>
Process directory. Contains information and statistics about running processes and kernel parameters.<br><a href="abs-guides.html#460">See Chapter 29.<br></a>/sys<br>
•&nbsp;<br>
Systemwide device directory. Contains information and statistics about device and device names. This<br>is newly added to Linux with the 2.6.X kernels.<br>/mnt<br>
•&nbsp;<br>
<i>Mount</i>. Directory for mounting hard drive partitions, such as&nbsp;/mnt/dos, and physical devices. In<br>newer Linux distros, the&nbsp;/media&nbsp;directory has taken over as the preferred mount point for I/O<br>
Appendix H. Important System Directories<br>
788<br>
<hr>
<A name=795></a><IMG src="abs-guide-795_1.png"><br>
Advanced Bash-Scripting Guide<br>
devices.<br>/media<br>
•&nbsp;<br>
In newer Linux distros, the preferred mount point for I/O devices, such as CD/DVD drives or USB<br>flash drives.<br>/var<br>
•&nbsp;<br>
<i>Variable</i>&nbsp;(changeable) system files. This is a catchall &quot;scratchpad&quot; directory for data generated while<br>a Linux/UNIX machine is running.<br>/var/log<br>
•&nbsp;<br>
Systemwide log files.<br>/var/spool/mail<br>
•&nbsp;<br>
User mail spool.<br>/lib<br>
•&nbsp;<br>
Systemwide library files.<br>/usr/lib<br>
•&nbsp;<br>
More systemwide library files.<br>/tmp<br>
•&nbsp;<br>
System temporary files.<br>/boot<br>
•&nbsp;<br>
System<i>&nbsp;boot</i>&nbsp;directory. The kernel, module links, system map, and boot manager reside here.<br>
Altering files in this directory may result in an unbootable system.<br>
Appendix H. Important System Directories<br>
789<br>
<hr>
<A name=796></a><b>Appendix I. An Introduction to Programmable<br>Completion</b><br>
The<i>&nbsp;programmable completion</i>&nbsp;feature in Bash permits typing a partial command, then pressing the<b>&nbsp;[Tab]</b>&nbsp;key<br>to auto-complete the command sequence.&nbsp;[147] If multiple completions are possible, then<b>&nbsp;[Tab]</b>&nbsp;lists them all.<br>Let's see how it works.<br>
bash$&nbsp;<b>xtra[Tab]<br></b>xtraceroute &nbsp; &nbsp; &nbsp; xtrapin &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xtrapproto<br>
&nbsp;xtraceroute.real &nbsp;xtrapinfo &nbsp; &nbsp; &nbsp; &nbsp; xtrapreset<br>
&nbsp;xtrapchar &nbsp; &nbsp; &nbsp; &nbsp; xtrapout &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xtrapstats<br>
bash$&nbsp;<b>xtrac[Tab]<br></b>xtraceroute &nbsp; &nbsp; &nbsp; xtraceroute.real<br>
bash$&nbsp;<b>xtraceroute.r[Tab]<br></b>xtraceroute.real<br>
Tab completion also works for variables and path names.<br>
bash$&nbsp;<b>echo $BASH[Tab]<br></b>$BASH &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $BASH_COMPLETION &nbsp; &nbsp; &nbsp;$BASH_SUBSHELL<br>
&nbsp;$BASH_ARGC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$BASH_COMPLETION_DIR &nbsp;$BASH_VERSINFO<br>
&nbsp;$BASH_ARGV &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$BASH_LINENO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$BASH_VERSION<br>
&nbsp;$BASH_COMMAND &nbsp; &nbsp; &nbsp; &nbsp; $BASH_SOURCE<br>
bash$&nbsp;<b>echo /usr/local/[Tab]<br></b>bin/ &nbsp; &nbsp; etc/ &nbsp; &nbsp; include/ libexec/ sbin/ &nbsp; &nbsp;src/ &nbsp; &nbsp;&nbsp;<br>
&nbsp;doc/ &nbsp; &nbsp; games/ &nbsp; lib/ &nbsp; &nbsp; man/ &nbsp; &nbsp; share/<br>
The Bash<b>&nbsp;complete</b>&nbsp;and<b>&nbsp;compgen</b><a href="abs-guides.html#186">&nbsp;builtins make it possible for</a><i>&nbsp;tab completion</i>&nbsp;to recognize partial<i>&nbsp;parameters<br></i>and<i>&nbsp;options</i>&nbsp;to commands. In a very simple case, we can use<b>&nbsp;complete</b>&nbsp;from the command-line to specify a<br>short list of acceptable parameters.<br>
bash$&nbsp;<b>touch sample_command<br></b>bash$&nbsp;<b>touch file1.txt file2.txt file2.doc file30.txt file4.zzz<br></b>bash$&nbsp;<b>chmod +x sample_command<br></b>bash$&nbsp;<b>complete -f -X '!*.txt' sample_command</b><br>
bash$&nbsp;<b>./sample[Tab][Tab]<br></b>sample_command<br>
file1.txt &nbsp; file2.txt &nbsp; file30.txt<br>
The&nbsp;-f&nbsp;option to<i>&nbsp;complete</i>&nbsp;specifies filenames, and&nbsp;-X&nbsp;the filter pattern.<br>
For anything more complex, we could write a script that specifies a list of acceptable command-line<br>parameters. The<b>&nbsp;compgen</b>&nbsp;builtin expands a list of<i>&nbsp;arguments</i>&nbsp;to<i>&nbsp;generate</i>&nbsp;completion matches.<br>
Appendix I. An Introduction to Programmable Completion<br>
790<br>
<hr>
<A name=797></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#749">Let us take a modified version of the</a><i>&nbsp;UseGetOpt.sh</i>&nbsp;script as an example command. This script accepts a<br>number of command-line parameters, preceded by either a single or double dash. And here is the<br>corresponding<i>&nbsp;completion script</i>, by convention given a filename corresponding to its associated command.<br>
<b>Example I-1. Completion script for<i>&nbsp;UseGetOpt.sh</i></b><br>
# file: UseGetOpt-2<br>
# UseGetOpt-2.sh parameter-completion<br>
_UseGetOpt-2 () &nbsp; # &nbsp;By convention, the function name<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ starts with an underscore.<br>
&nbsp; local cur<br>
&nbsp; # Pointer to current completion word.<br>
&nbsp; # By convention, it's named &quot;cur&quot; but this isn't strictly necessary.<br>
&nbsp; COMPREPLY=() &nbsp; # Array variable storing the possible completions.<br>
&nbsp; cur=${COMP_WORDS[COMP_CWORD]}<br>
&nbsp; case &quot;$cur&quot; in<br>
&nbsp; &nbsp; -*)<br>
&nbsp; &nbsp; COMPREPLY=( $( compgen -W '-a -d -f -l -t -h --aoption --debug \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--file --log --test --help --' -- $cur ) );;<br>
# &nbsp; Generate the completion matches and load them into $COMPREPLY array.<br>
# &nbsp; xx) May add more cases here.<br>
# &nbsp; yy)<br>
# &nbsp; zz)<br>
&nbsp; esac<br>
&nbsp; return 0<br>
}<br>
complete -F _UseGetOpt-2 -o filenames ./UseGetOpt-2.sh<br>
# &nbsp; &nbsp; &nbsp; &nbsp;^^ ^^^^^^^^^^^^ &nbsp;Invokes the function _UseGetOpt-2.<br>
Now, let's try it.<br>
bash$&nbsp;<b>source UseGetOpt-2</b><br>
bash$&nbsp;<b>./UseGetOpt-2.sh -[Tab]<br></b>-- &nbsp; &nbsp; &nbsp; &nbsp; --aoption &nbsp;--debug &nbsp; &nbsp;--file &nbsp; &nbsp; --help &nbsp; &nbsp; --log &nbsp; &nbsp; --test<br>
&nbsp;-a &nbsp; &nbsp; &nbsp; &nbsp; -d &nbsp; &nbsp; &nbsp; &nbsp; -f &nbsp; &nbsp; &nbsp; &nbsp; -h &nbsp; &nbsp; &nbsp; &nbsp; -l &nbsp; &nbsp; &nbsp; &nbsp; -t<br>
bash$&nbsp;<b>./UseGetOpt-2.sh --[Tab]<br></b>-- &nbsp; &nbsp; &nbsp; &nbsp; --aoption &nbsp;--debug &nbsp; &nbsp;--file &nbsp; &nbsp; --help &nbsp; &nbsp; --log &nbsp; &nbsp; --test<br>
<a href="abs-guides.html#210">We begin by sourcing the &quot;completion script.&quot; This sets the command-line parameters.&nbsp;</a>[148]<br>
In the first instance, hitting<b>&nbsp;[Tab]</b>&nbsp;after a single dash, the output is all the possible parameters preceded by<i>&nbsp;one<br>or more</i>&nbsp;dashes. Hitting<b>&nbsp;[Tab]</b>&nbsp;after<i>&nbsp;two</i>&nbsp;dashes gives the possible parameters preceded by<i>&nbsp;two or more</i>&nbsp;dashes.<br>
Now, just what is the point of having to jump through flaming hoops to enable command-line tab completion?<br><i>It saves keystrokes.&nbsp;</i>[149]<br>
--<br>
<i>Resources:</i><br>
Appendix I. An Introduction to Programmable Completion<br>
791<br>
<hr>
<A name=798></a>Advanced Bash-Scripting Guide<br>
<a href="http://freshmeat.net/projects/bashcompletion">Bash &nbsp;programmable completion project</a><br>
<a href="http://www.linuxjournal.com">Mitch Frazier's&nbsp;<i>Linux Journal</i></a>&nbsp;article,&nbsp;<a href="http://www.linuxjournal.com/content/more-using-bash-complete-command"><i>More on Using the Bash Complete Command</i></a><br>
<a href="http://www.debian-administration.org/article/An_introduction_to_bash_completion_part_1">Steve's excellent two-part article, &quot;An Introduction to Bash Completion&quot;: Part 1 and Part 2</a><br>
Appendix I. An Introduction to Programmable Completion<br>
792<br>
<hr>
<A name=799></a><b>Appendix J. Localization</b><br>
Localization is an undocumented Bash feature.<br>
A localized shell script echoes its text output in the language defined as the system's locale. A Linux user in<br>Berlin, Germany, would get script output in German, whereas his cousin in Berlin, Maryland, would get<br>output from the same script in English.<br>
To create a localized script, use the following template to write all messages to the user (error messages,<br>prompts, etc.).<br>
#!/bin/bash<br>
# localized.sh<br>
# &nbsp;Script by Stéphane Chazelas,<br>
#+ modified by Bruno Haible, bugfixed by Alfredo Pironti.<br>
. gettext.sh<br>
E_CDERROR=65<br>
error()<br>
{<br>
&nbsp; printf &quot;$@&quot; &gt;&amp;2<br>
&nbsp; exit $E_CDERROR<br>
}<br>
cd $var || error &quot;`eval_gettext \&quot;Can\'t cd to \\\$var.\&quot;`&quot;<br>
# &nbsp;The triple backslashes (escapes) in front of $var needed<br>
#+ &quot;because eval_gettext expects a string<br>
#+ where the variable values have not yet been substituted.&quot;<br>
# &nbsp; &nbsp;-- per Bruno Haible<br>
read -p &quot;`gettext \&quot;Enter the value: \&quot;`&quot; var<br>
# &nbsp;...<br>
# &nbsp;------------------------------------------------------------------<br>
# &nbsp;Alfredo Pironti comments:<br>
# &nbsp;This script has been modified to not use the $&quot;...&quot; syntax in<br>
#+ favor of the &quot;`gettext \&quot;...\&quot;`&quot; syntax.<br>
# &nbsp;This is ok, but with the new localized.sh program, the commands<br>
#+ &quot;bash -D filename&quot; and &quot;bash --dump-po-string filename&quot;<br>
#+ will produce no output<br>
#+ (because those command are only searching for the $&quot;...&quot; strings)!<br>
# &nbsp;The ONLY way to extract strings from the new file is to use the<br>
# 'xgettext' program. However, the xgettext program is buggy.<br>
# Note that 'xgettext' has another bug.<br>
#<br>
# The shell fragment:<br>
# &nbsp; &nbsp;gettext -s &quot;I like Bash&quot;<br>
# will be correctly extracted, but . . .<br>
# &nbsp; &nbsp;xgettext -s &quot;I like Bash&quot;<br>
# . . . fails!<br>
# &nbsp;'xgettext' will extract &quot;-s&quot; because<br>
#+ the command only extracts the<br>
#+ very first argument after the 'gettext' word.<br>
Appendix J. Localization<br>
793<br>
<hr>
<A name=800></a><IMG src="abs-guide-800_1.png"><br>
Advanced Bash-Scripting Guide<br>
# &nbsp;Escape characters:<br>
#<br>
# &nbsp;To localize a sentence like<br>
# &nbsp; &nbsp; echo -e &quot;Hello\tworld!&quot;<br>
#+ you must use<br>
# &nbsp; &nbsp; echo -e &quot;`gettext \&quot;Hello\\tworld\&quot;`&quot;<br>
# &nbsp;The &quot;double escape character&quot; before the `t' is needed because<br>
#+ 'gettext' will search for a string like: 'Hello\tworld'<br>
# &nbsp;This is because gettext will read one literal `\')<br>
#+ and will output a string like &quot;Bonjour\tmonde&quot;,<br>
#+ so the 'echo' command will display the message correctly.<br>
#<br>
# &nbsp;You may not use<br>
# &nbsp; &nbsp; echo &quot;`gettext -e \&quot;Hello\tworld\&quot;`&quot;<br>
#+ due to the xgettext bug explained above.<br>
# Let's localize the following shell fragment:<br>
# &nbsp; &nbsp; echo &quot;-h display help and exit&quot;<br>
#<br>
# First, one could do this:<br>
# &nbsp; &nbsp; echo &quot;`gettext \&quot;-h display help and exit\&quot;`&quot;<br>
# &nbsp;This way 'xgettext' will work ok,<br>
#+ but the 'gettext' program will read &quot;-h&quot; as an option!<br>
#<br>
# One solution could be<br>
# &nbsp; &nbsp; echo &quot;`gettext -- \&quot;-h display help and exit\&quot;`&quot;<br>
# &nbsp;This way 'gettext' will work,<br>
#+ but 'xgettext' will extract &quot;--&quot;, as referred to above.<br>
#<br>
# The workaround you may use to get this string localized is<br>
# &nbsp; &nbsp; echo -e &quot;`gettext \&quot;\\0-h display help and exit\&quot;`&quot;<br>
# &nbsp;We have added a \0 (NULL) at the beginning of the sentence.<br>
# &nbsp;This way 'gettext' works correctly, as does 'xgettext.'<br>
# &nbsp;Moreover, the NULL character won't change the behavior<br>
#+ of the 'echo' command.<br>
# &nbsp;------------------------------------------------------------------<br>
bash$&nbsp;<b>bash -D localized.sh<br></b>&quot;Can't cd to %s.&quot;<br>
&nbsp;&quot;Enter the value: &quot;<br>
This lists all the localized text. (The&nbsp;-D&nbsp;option lists double-quoted strings prefixed by a $, without executing<br>the script.)<br>
bash$&nbsp;<b>bash --dump-po-strings localized.sh<br></b>#: a:6<br>
&nbsp;msgid &quot;Can't cd to %s.&quot;<br>
&nbsp;msgstr &quot;&quot;<br>
&nbsp;#: a:7<br>
&nbsp;msgid &quot;Enter the value: &quot;<br>
&nbsp;msgstr &quot;&quot;<br>
The&nbsp;--dump-po-strings&nbsp;option to Bash resembles the&nbsp;-D<a href="abs-guides.html#260">&nbsp;option, but uses gettext &quot;po&quot; format.</a><br>
Bruno Haible points out:<br>
Starting with gettext-0.12.2,<b>&nbsp;xgettext -o - localized.sh</b>&nbsp;is recommended instead of<b>&nbsp;bash<br>--dump-po-strings localized.sh</b>, because<b>&nbsp;xgettext</b>&nbsp;. . .<br>
Appendix J. Localization<br>
794<br>
<hr>
<A name=801></a><IMG src="abs-guide-801_1.png"><br>
Advanced Bash-Scripting Guide<br>
1. understands the gettext and eval_gettext commands (whereas bash --dump-po-strings understands only<br>its deprecated $&quot;...&quot; syntax)<br>
2. can extract comments placed by the programmer, intended to be read by the translator.<br>
This shell code is then not specific to Bash any more; it works the same way with Bash 1.x and other<br>/bin/sh implementations.<br>
Now, build a&nbsp;language.po&nbsp;file for each language that the script will be translated into, specifying the<br><i>msgstr</i>. Alfredo Pironti gives the following example:<br>
fr.po:<br>
#: a:6<br>
msgid &quot;Can't cd to $var.&quot;<br>
msgstr &quot;Impossible de se positionner dans le repertoire $var.&quot;<br>
#: a:7<br>
msgid &quot;Enter the value: &quot;<br>
msgstr &quot;Entrez la valeur : &quot;<br>
# &nbsp;The string are dumped with the variable names, not with the %s syntax,<br>
#+ similar to C programs.<br>
#+ This is a very cool feature if the programmer uses<br>
#+ variable names that make sense!<br>
<a href="abs-guides.html#260">Then, run msgfmt.</a><br>
<b>msgfmt -o localized.sh.mo fr.po</b><br>
Place the resulting&nbsp;localized.sh.mo&nbsp;file in the&nbsp;/usr/local/share/locale/fr/LC_MESSAGES<br>directory, and at the beginning of the script, insert the lines:<br>
TEXTDOMAINDIR=/usr/local/share/locale<br>
TEXTDOMAIN=localized.sh<br>
If a user on a French system runs the script, she will get French messages.<br>
<a href="abs-guides.html#260">With older versions of Bash or other shells, localization requires gettext, using the&nbsp;</a>-s&nbsp;option. In this<br>case, the script becomes:<br>
#!/bin/bash<br>
# localized.sh<br>
E_CDERROR=65<br>
error() {<br>
&nbsp; local format=$1<br>
&nbsp; shift<br>
&nbsp; printf &quot;$(gettext -s &quot;$format&quot;)&quot; &quot;$@&quot; &gt;&amp;2<br>
&nbsp; exit $E_CDERROR<br>
}<br>
cd $var || error &quot;Can't cd to %s.&quot; &quot;$var&quot;<br>
read -p &quot;$(gettext -s &quot;Enter the value: &quot;)&quot; var<br>
# ...<br>
The&nbsp;TEXTDOMAIN&nbsp;and&nbsp;TEXTDOMAINDIR&nbsp;variables need to be set and exported to the environment. This<br>should be done within the script itself.<br>
Appendix J. Localization<br>
795<br>
<hr>
<A name=802></a>Advanced Bash-Scripting Guide<br>
---<br>
This appendix written by Stéphane Chazelas, with modifications suggested by Alfredo Pironti, and by Bruno<br><a href="abs-guides.html#260">Haible, maintainer of GNU gettext.</a><br>
Appendix J. Localization<br>
796<br>
<hr>
<A name=803></a><b>Appendix K. History Commands</b><br>
The Bash shell provides command-line tools for editing and manipulating a user's<i>&nbsp;command history</i>. This is<br>primarily a convenience, a means of saving keystrokes.<br>
Bash history commands:<br>
<b>history</b><br>
1.&nbsp;<br>
<b>fc</b><br>
2.&nbsp;<br>
bash$&nbsp;<b>history</b><br>
&nbsp; 1 &nbsp;mount /mnt/cdrom<br>
&nbsp; &nbsp; 2 &nbsp;cd /mnt/cdrom<br>
&nbsp; &nbsp; 3 &nbsp;ls<br>
&nbsp; &nbsp; &nbsp;...<br>
Internal variables associated with Bash history commands:<br>
$HISTCMD<br>
1.&nbsp;<br>
$HISTCONTROL<br>
2.&nbsp;<br>
$HISTIGNORE<br>
3.&nbsp;<br>
$HISTFILE<br>
4.&nbsp;<br>
$HISTFILESIZE<br>
5.&nbsp;<br>
$HISTSIZE<br>
6.&nbsp;<br>
$HISTTIMEFORMAT (Bash, ver. 3.0 or later)<br>
7.&nbsp;<br>
!!<br>
8.&nbsp;<br>
!$<br>
9.&nbsp;<br>
!#<br>
10.&nbsp;<br>
!N<br>
11.&nbsp;<br>
!-N<br>
12.&nbsp;<br>
!STRING<br>
13.&nbsp;<br>
!?STRING?<br>
14.&nbsp;<br>
^STRING^string^<br>
15.&nbsp;<br>
Unfortunately, the Bash history tools find no use in scripting.<br>
#!/bin/bash<br>
# history.sh<br>
# A (vain) attempt to use the 'history' command in a script.<br>
history &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No output.<br>
var=$(history); echo &quot;$var&quot; &nbsp;# $var is empty.<br>
# History commands disabled within a script.<br>
bash$&nbsp;<b>./history.sh<br></b>(no output)<br>
<a href="http://samrowe.com/wordpress/advancing-in-the-bash-shell/">The Advancing in the Bash Shell site gives a good introduction to the use of history commands in Bash.</a><br>
Appendix K. History Commands<br>
797<br>
<hr>
<A name=804></a><b>Appendix L. Sample&nbsp;.bashrc&nbsp;and&nbsp;.bash_profile<br>Files</b><br>
The&nbsp;~/.bashrc&nbsp;file determines the behavior of interactive shells. A good look at this file can lead to a<br>better understanding of Bash.<br>
<a href="mailto:emmanuel.rouat@wanadoo.fr">Emmanuel Rouat contributed the following very elaborate&nbsp;</a>.bashrc&nbsp;file, written for a Linux system. He<br>welcomes reader feedback on it.<br>
Study the file carefully, and feel free to reuse code snippets and functions from it in your own&nbsp;.bashrc&nbsp;file<br>or even in your scripts.<br>
<b>Example L-1. Sample&nbsp;.bashrc&nbsp;file</b><br>
#=============================================================<br>
#<br>
# PERSONAL $HOME/.bashrc FILE for bash-3.0 (or later)<br>
# By Emmanuel Rouat &lt;no-email&gt;<br>
#<br>
# Last modified: Sun Nov 30 16:27:45 CET 2008<br>
# This file is read (normally) by interactive shells only.<br>
# Here is the place to define your aliases, functions and<br>
# other interactive features like your prompt.<br>
#<br>
# The majority of the code here assumes you are on a GNU&nbsp;<br>
# system (most likely a Linux box) and is based on code found<br>
# on Usenet or internet. See for instance:<br>
#<br>
# http://tldp.org/LDP/abs/html/index.html<br>
# http://www.caliban.org/bash/<br>
# http://www.shelldorado.com/scripts/categories.html<br>
# http://www.dotfiles.org/<br>
#<br>
# This bashrc file is a bit overcrowded -- remember it is just<br>
# just an example. Tailor it to your needs.<br>
#<br>
#<br>
#=============================================================<br>
# --&gt; Comments added by HOWTO author.<br>
#-------------------------------------------------------------<br>
# Source global definitions (if any)<br>
#-------------------------------------------------------------<br>
if [ -f /etc/bashrc ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; . /etc/bashrc &nbsp; # --&gt; Read /etc/bashrc, if present.<br>
fi<br>
#-------------------------------------------------------------<br>
# Automatic setting of $DISPLAY (if not set already).<br>
# This works for linux - your mileage may vary. ...&nbsp;<br>
# The problem is that different types of terminals give<br>
# different answers to 'who am i' (rxvt in particular can be<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
798<br>
<hr>
<A name=805></a>Advanced Bash-Scripting Guide<br>
# troublesome).<br>
# I have not found a 'universal' method yet.<br>
#-------------------------------------------------------------<br>
function get_xserver ()<br>
{<br>
&nbsp; &nbsp; case $TERM in<br>
&nbsp; &nbsp; &nbsp; &nbsp;xterm )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' )&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Ane-Pieter Wieringa suggests the following alternative:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # I_AM=$(who am i)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # SERVER=${I_AM#*(}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # SERVER=${SERVER%*)}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XSERVER=${XSERVER%%:*}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; aterm | rxvt)<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Find some code that works here. ...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac &nbsp;<br>
}<br>
if [ -z ${DISPLAY:=&quot;&quot;} ]; then<br>
&nbsp; &nbsp; get_xserver<br>
&nbsp; &nbsp; if [[ -z ${XSERVER} &nbsp;|| ${XSERVER} == $(hostname) || \<br>
&nbsp; &nbsp; &nbsp; ${XSERVER} == &quot;unix&quot; ]]; then&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; DISPLAY=&quot;:0.0&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Display on local host.<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; DISPLAY=${XSERVER}:0.0 &nbsp;# Display on remote host.<br>
&nbsp; &nbsp; fi<br>
fi<br>
export DISPLAY<br>
#-------------------------------------------------------------<br>
# Some settings<br>
#-------------------------------------------------------------<br>
ulimit -S -c 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Don't want any coredumps.<br>
set -o notify<br>
set -o noclobber<br>
set -o ignoreeof<br>
set -o nounset<br>
#set -o xtrace &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Useful for debuging.<br>
# Enable options:<br>
shopt -s cdspell<br>
shopt -s cdable_vars<br>
shopt -s checkhash<br>
shopt -s checkwinsize<br>
shopt -s sourcepath<br>
shopt -s no_empty_cmd_completion<br>
shopt -s cmdhist<br>
shopt -s histappend histreedit histverify<br>
shopt -s extglob &nbsp; &nbsp; &nbsp; &nbsp;# Necessary for programmable completion.<br>
# Disable options:<br>
shopt -u mailwarn<br>
unset MAILCHECK &nbsp; &nbsp; &nbsp; &nbsp; # Don't want my shell to warn me of incoming mail.<br>
export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
799<br>
<hr>
<A name=806></a>Advanced Bash-Scripting Guide<br>
export HISTTIMEFORMAT=&quot;%H:%M &gt; &quot;<br>
export HISTIGNORE=&quot;&amp;:bg:fg:ll:h&quot;<br>
export HOSTFILE=$HOME/.hosts &nbsp; &nbsp;# Put list of remote hosts in ~/.hosts ...<br>
#-------------------------------------------------------------<br>
# Greeting, motd etc...<br>
#-------------------------------------------------------------<br>
# Define some colors first:<br>
red='\e[0;31m'<br>
RED='\e[1;31m'<br>
blue='\e[0;34m'<br>
BLUE='\e[1;34m'<br>
cyan='\e[0;36m'<br>
CYAN='\e[1;36m'<br>
NC='\e[0m' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# No Color<br>
# --&gt; Nice. Has the same effect as using &quot;ansi.sys&quot; in DOS.<br>
# Looks best on a terminal with black background.....<br>
echo -e &quot;${CYAN}This is BASH ${RED}${BASH_VERSION%.*}\<br>
${CYAN} - DISPLAY on ${RED}$DISPLAY${NC}\n&quot;<br>
date<br>
if [ -x /usr/games/fortune ]; then<br>
&nbsp; &nbsp; /usr/games/fortune -s &nbsp; &nbsp; # Makes our day a bit more fun.... :-)<br>
fi<br>
function _exit() &nbsp; &nbsp; &nbsp; &nbsp;# Function to run upon exit of shell.<br>
{<br>
&nbsp; &nbsp; echo -e &quot;${RED}Hasta la vista, baby${NC}&quot;<br>
}<br>
trap _exit EXIT<br>
#-------------------------------------------------------------<br>
# Shell Prompt<br>
#-------------------------------------------------------------<br>
if [[ &quot;${DISPLAY%%:0*}&quot; != &quot;&quot; ]]; then &nbsp;<br>
&nbsp; &nbsp; HILIT=${red} &nbsp; # remote machine: prompt will be partly red<br>
else<br>
&nbsp; &nbsp; HILIT=${cyan} &nbsp;# local machine: prompt will be partly cyan<br>
fi<br>
# &nbsp;--&gt; Replace instances of \W with \w in prompt functions below<br>
#+ --&gt; to get display of full path name.<br>
function fastprompt()<br>
{<br>
&nbsp; &nbsp; unset PROMPT_COMMAND<br>
&nbsp; &nbsp; case $TERM in<br>
&nbsp; &nbsp; &nbsp; &nbsp; *term | rxvt )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;${HILIT}[\h]$NC \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; linux )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;${HILIT}[\h]$NC \W &gt; &quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;[\h] \W &gt; &quot; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
800<br>
<hr>
<A name=807></a>Advanced Bash-Scripting Guide<br>
_powerprompt()<br>
{<br>
&nbsp; &nbsp; LOAD=$(uptime|sed -e &quot;s/.*: \([^,]*\).*/\1/&quot; -e &quot;s/ //g&quot;)<br>
}<br>
function powerprompt()<br>
{<br>
&nbsp; &nbsp; PROMPT_COMMAND=_powerprompt<br>
&nbsp; &nbsp; case $TERM in<br>
&nbsp; &nbsp; &nbsp; &nbsp; *term | rxvt &nbsp;)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W &gt; \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; linux )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;${HILIT}[\A - \$LOAD]$NC\n[\u@\h \#] \W &gt; &quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; * )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PS1=&quot;[\A - \$LOAD]\n[\u@\h \#] \W &gt; &quot; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
powerprompt &nbsp; &nbsp; # This is the default prompt -- might be slow.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # If too slow, use fastprompt instead. ...<br>
#===============================================================<br>
#<br>
# ALIASES AND FUNCTIONS<br>
#<br>
# Arguably, some functions defined here are quite big.<br>
# If you want to make this file smaller, these functions can<br>
# be converted into scripts and removed from here.<br>
#<br>
# Many functions were taken (almost) straight from the bash-2.04<br>
# examples.<br>
#<br>
#===============================================================<br>
#-------------------<br>
# Personnal Aliases<br>
#-------------------<br>
alias rm='rm -i'<br>
alias cp='cp -i'<br>
alias mv='mv -i'<br>
# -&gt; Prevents accidentally clobbering files.<br>
alias mkdir='mkdir -p'<br>
alias h='history'<br>
alias j='jobs -l'<br>
alias which='type -a'<br>
alias ..='cd ..'<br>
alias path='echo -e ${PATH//:/\\n}'<br>
alias libpath='echo -e ${LD_LIBRARY_PATH//:/\\n}'<br>
alias print='/usr/bin/lp -o nobanner -d $LPDEST'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Assumes LPDEST is defined (default printer)<br>
alias pjet='enscript -h -G -fCourier9 -d $LPDEST'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Pretty-print using enscript<br>
alias du='du -kh' &nbsp; &nbsp; &nbsp; # Makes a more readable output.<br>
alias df='df -kTh'<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
801<br>
<hr>
<A name=808></a>Advanced Bash-Scripting Guide<br>
#-------------------------------------------------------------<br>
# The 'ls' family (this assumes you use a recent GNU ls)<br>
#-------------------------------------------------------------<br>
alias ll=&quot;ls -l --group-directories-first&quot;<br>
alias ls='ls -hF --color' &nbsp;# add colors for filetype recognition<br>
alias la='ls -Al' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# show hidden files<br>
alias lx='ls -lXB' &nbsp; &nbsp; &nbsp; &nbsp; # sort by extension<br>
alias lk='ls -lSr' &nbsp; &nbsp; &nbsp; &nbsp; # sort by size, biggest last<br>
alias lc='ls -ltcr' &nbsp; &nbsp; &nbsp; &nbsp;# sort by and show change time, most recent last<br>
alias lu='ls -ltur' &nbsp; &nbsp; &nbsp; &nbsp;# sort by and show access time, most recent last<br>
alias lt='ls -ltr' &nbsp; &nbsp; &nbsp; &nbsp; # sort by date, most recent last<br>
alias lm='ls -al |more' &nbsp; &nbsp;# pipe through 'more'<br>
alias lr='ls -lR' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# recursive ls<br>
alias tree='tree -Csu' &nbsp; &nbsp; # nice alternative to 'recursive ls'<br>
# If your version of 'ls' doesn't support --group-directories-first try this:<br>
# function ll(){ ls -l &quot;$@&quot;| egrep &quot;^d&quot; ; ls -lXB &quot;$@&quot; 2&gt;&amp;-| \<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;egrep -v &quot;^d|total &quot;; }<br>
#-------------------------------------------------------------<br>
# tailoring 'less'<br>
#-------------------------------------------------------------<br>
alias more='less'<br>
export PAGER=less<br>
export LESSCHARSET='latin1'<br>
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2&gt;&amp;-'<br>
&nbsp; &nbsp;# Use this if lesspipe.sh exists<br>
export LESS='-i -N -w &nbsp;-z-4 -g -e -M -X -F -R -P%t?f%f \<br>
:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...'<br>
#-------------------------------------------------------------<br>
# spelling typos - highly personnal and keyboard-dependent :-)<br>
#-------------------------------------------------------------<br>
alias xs='cd'<br>
alias vf='cd'<br>
alias moer='more'<br>
alias moew='more'<br>
alias kk='ll'<br>
#-------------------------------------------------------------<br>
# A few fun ones<br>
#-------------------------------------------------------------<br>
function xtitle() &nbsp; &nbsp; &nbsp;# Adds some text in the terminal frame.<br>
{<br>
&nbsp; &nbsp; case &quot;$TERM&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; *term | rxvt)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -n -e &quot;\033]0;$*\007&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
# aliases that use xtitle<br>
alias top='xtitle Processes on $HOST &amp;&amp; top'<br>
alias make='xtitle Making $(basename $PWD) ; make'<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
802<br>
<hr>
<A name=809></a>Advanced Bash-Scripting Guide<br>
alias ncftp=&quot;xtitle ncFTP ; ncftp&quot;<br>
# .. and functions<br>
function man()<br>
{<br>
&nbsp; &nbsp; for i ; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; xtitle The $(basename $1|tr -d .[:digit:]) manual<br>
&nbsp; &nbsp; &nbsp; &nbsp; command man -F -a &quot;$i&quot;<br>
&nbsp; &nbsp; done<br>
}<br>
#-------------------------------------------------------------<br>
# Make the following commands run in background automatically:<br>
#-------------------------------------------------------------<br>
function te() &nbsp;# Wrapper around xemacs/gnuserv ...<br>
{<br>
&nbsp; &nbsp; if [ &quot;$(gnuclient -batch -eval t 2&gt;&amp;-)&quot; == &quot;t&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; gnuclient -q &quot;$@&quot;;<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; ( xemacs &quot;$@&quot; &amp;);<br>
&nbsp; &nbsp; fi<br>
}<br>
function soffice() { command soffice &quot;$@&quot; &amp; }<br>
function firefox() { command firefox &quot;$@&quot; &amp; }<br>
function xpdf() { command xpdf &quot;$@&quot; &amp; }<br>
#-------------------------------------------------------------<br>
# File &amp; string-related functions:<br>
#-------------------------------------------------------------<br>
# Find a file with a pattern in name:<br>
function ff() { find . -type f -iname '*'$*'*' -ls ; }<br>
# Find a file with pattern $1 in name and Execute $2 on it:<br>
function fe()<br>
{ find . -type f -iname '*'${1:-}'*' -exec ${2:-file} {} \; &nbsp;; }<br>
# Find a pattern in a set of files and highlight them:<br>
# (needs a recent version of egrep)<br>
function fstr()<br>
{<br>
&nbsp; &nbsp; OPTIND=1<br>
&nbsp; &nbsp; local case=&quot;&quot;<br>
&nbsp; &nbsp; local usage=&quot;fstr: find string in files.<br>
Usage: fstr [-i] \&quot;pattern\&quot; [\&quot;filename pattern\&quot;] &quot;<br>
&nbsp; &nbsp; while getopts :it opt<br>
&nbsp; &nbsp; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$opt&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; i) case=&quot;-i &quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) echo &quot;$usage&quot;; return;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; shift $(( $OPTIND - 1 ))<br>
&nbsp; &nbsp; if [ &quot;$#&quot; -lt 1 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$usage&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; return;<br>
&nbsp; &nbsp; fi<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
803<br>
<hr>
<A name=810></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; find . -type f -name &quot;${2:-*}&quot; -print0 | \<br>
&nbsp; &nbsp; xargs -0 egrep --color=always -sn ${case} &quot;$1&quot; 2&gt;&amp;- | more&nbsp;<br>
}<br>
function cuttail() # cut last n lines in file, 10 by default<br>
{<br>
&nbsp; &nbsp; nlines=${2:-10}<br>
&nbsp; &nbsp; sed -n -e :a -e &quot;1,${nlines}!{P;N;D;};N;ba&quot; $1<br>
}<br>
function lowercase() &nbsp;# move filenames to lowercase<br>
{<br>
&nbsp; &nbsp; for file ; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; filename=${file##*/}<br>
&nbsp; &nbsp; &nbsp; &nbsp; case &quot;$filename&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; */*) dirname==${file%/*} ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) dirname=.;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; esac<br>
&nbsp; &nbsp; &nbsp; &nbsp; nf=$(echo $filename | tr A-Z a-z)<br>
&nbsp; &nbsp; &nbsp; &nbsp; newname=&quot;${dirname}/${nf}&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;$nf&quot; != &quot;$filename&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mv &quot;$file&quot; &quot;$newname&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;lowercase: $file --&gt; $newname&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;lowercase: $file not changed.&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
}<br>
function swap() &nbsp;# Swap 2 filenames around, if they exist<br>
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#(from Uzi's bashrc).<br>
&nbsp; &nbsp; local TMPFILE=tmp.$$&nbsp;<br>
&nbsp; &nbsp; [ $# -ne 2 ] &amp;&amp; echo &quot;swap: 2 arguments needed&quot; &amp;&amp; return 1<br>
&nbsp; &nbsp; [ ! -e $1 ] &amp;&amp; echo &quot;swap: $1 does not exist&quot; &amp;&amp; return 1<br>
&nbsp; &nbsp; [ ! -e $2 ] &amp;&amp; echo &quot;swap: $2 does not exist&quot; &amp;&amp; return 1<br>
&nbsp; &nbsp; mv &quot;$1&quot; $TMPFILE&nbsp;<br>
&nbsp; &nbsp; mv &quot;$2&quot; &quot;$1&quot;<br>
&nbsp; &nbsp; mv $TMPFILE &quot;$2&quot;<br>
}<br>
function extract() &nbsp; &nbsp; &nbsp;# Handy Extract Program.<br>
{<br>
&nbsp; &nbsp; &nbsp;if [ -f $1 ] ; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;case $1 in<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.tar.bz2) &nbsp; tar xvjf $1 &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.tar.gz) &nbsp; &nbsp;tar xvzf $1 &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.bz2) &nbsp; &nbsp; &nbsp; bunzip2 $1 &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.rar) &nbsp; &nbsp; &nbsp; unrar x $1 &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.gz) &nbsp; &nbsp; &nbsp; &nbsp;gunzip $1 &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.tar) &nbsp; &nbsp; &nbsp; tar xvf $1 &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.tbz2) &nbsp; &nbsp; &nbsp;tar xvjf $1 &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.tgz) &nbsp; &nbsp; &nbsp; tar xvzf $1 &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.zip) &nbsp; &nbsp; &nbsp; unzip $1 &nbsp; &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.Z) &nbsp; &nbsp; &nbsp; &nbsp; uncompress $1 &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*.7z) &nbsp; &nbsp; &nbsp; &nbsp;7z x $1 &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;'$1' cannot be extracted via &gt;extract&lt;&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;esac<br>
&nbsp; &nbsp; &nbsp;else<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
804<br>
<hr>
<A name=811></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;'$1' is not a valid file&quot;<br>
&nbsp; &nbsp; &nbsp;fi<br>
}<br>
#-------------------------------------------------------------<br>
# Process/system related functions:<br>
#-------------------------------------------------------------<br>
function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }<br>
function pp() { my_ps f | awk '!/awk/ &amp;&amp; $0~var' var=${1:-&quot;.*&quot;} ; }<br>
function killps() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Kill by process name.<br>
{<br>
&nbsp; &nbsp; local pid pname sig=&quot;-TERM&quot; &nbsp; # Default signal.<br>
&nbsp; &nbsp; if [ &quot;$#&quot; -lt 1 ] || [ &quot;$#&quot; -gt 2 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo &quot;Usage: killps [-SIGNAL] pattern&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; return;<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; if [ $# = 2 ]; then sig=$1 ; fi<br>
&nbsp; &nbsp; for pid in $(my_ps| awk '!/awk/ &amp;&amp; $0~pat { print $1 }' pat=${!#} ) ; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; pname=$(my_ps | awk '$1~var { print $5 }' var=$pid )<br>
&nbsp; &nbsp; &nbsp; &nbsp; if ask &quot;Kill process $pid &lt;$pname&gt; with signal $sig?&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then kill $sig $pid<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
}<br>
function my_ip() # Get IP adresses.<br>
{<br>
&nbsp; &nbsp; MY_IP=$(/sbin/ifconfig ppp0 | awk '/inet/ { print $2 } ' | \<br>
sed -e s/addr://)<br>
&nbsp; &nbsp; MY_ISP=$(/sbin/ifconfig ppp0 | awk '/P-t-P/ { print $3 } ' | \<br>
sed -e s/P-t-P://)<br>
}<br>
function ii() &nbsp; # Get current host related info.<br>
{<br>
&nbsp; &nbsp; echo -e &quot;\nYou are logged on ${RED}$HOST&quot;<br>
&nbsp; &nbsp; echo -e &quot;\nAdditionnal information:$NC &quot; ; uname -a<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Users logged on:$NC &quot; ; w -h<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Current date :$NC &quot; ; date<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Machine stats :$NC &quot; ; uptime<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Memory stats :$NC &quot; ; free<br>
&nbsp; &nbsp; my_ip 2&gt;&amp;- ;<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Local IP Address :$NC&quot; ; echo ${MY_IP:-&quot;Not connected&quot;}<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}ISP Address :$NC&quot; ; echo ${MY_ISP:-&quot;Not connected&quot;}<br>
&nbsp; &nbsp; echo -e &quot;\n${RED}Open connections :$NC &quot;; netstat -pan --inet;<br>
&nbsp; &nbsp; echo<br>
}<br>
#-------------------------------------------------------------<br>
# Misc utilities:<br>
#-------------------------------------------------------------<br>
function repeat() &nbsp; &nbsp; &nbsp; # Repeat n times command.<br>
{<br>
&nbsp; &nbsp; local i max<br>
&nbsp; &nbsp; max=$1; shift;<br>
&nbsp; &nbsp; for ((i=1; i &lt;= max ; i++)); do &nbsp;# --&gt; C-like syntax<br>
&nbsp; &nbsp; &nbsp; &nbsp; eval &quot;$@&quot;;<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
805<br>
<hr>
<A name=812></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; done<br>
}<br>
function ask() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# See 'killps' for example of use.<br>
{<br>
&nbsp; &nbsp; echo -n &quot;$@&quot; '[y/n] ' ; read ans<br>
&nbsp; &nbsp; case &quot;$ans&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; y*|Y*) return 0 ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) return 1 ;;<br>
&nbsp; &nbsp; esac<br>
}<br>
function corename() &nbsp; # Get name of app that created a corefile.<br>
{&nbsp;<br>
&nbsp; &nbsp; for file ; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n $file : ; gdb --core=$file --batch | head -1<br>
&nbsp; &nbsp; done&nbsp;<br>
}<br>
#=========================================================================<br>
# PROGRAMMABLE COMPLETION - ONLY SINCE BASH-2.04<br>
# Most are taken from the bash 2.05 documentation and from Ian McDonald's<br>
# 'Bash completion' package (http://www.caliban.org/bash/#completion).<br>
# You will in fact need bash more recent than 3.0 for some features.<br>
#=========================================================================<br>
if [ &quot;${BASH_VERSION%.*}&quot; \&lt; &quot;3.0&quot; ]; then<br>
&nbsp; &nbsp; echo &quot;You will need to upgrade to version 3.0 \<br>
for full programmable completion features.&quot;<br>
&nbsp; &nbsp; return<br>
fi<br>
shopt -s extglob &nbsp; &nbsp; &nbsp; &nbsp; # Necessary,<br>
#set +o nounset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# otherwise some completions will fail.<br>
complete -A hostname &nbsp; rsh rcp telnet rlogin r ftp ping disk<br>
complete -A export &nbsp; &nbsp; printenv<br>
complete -A variable &nbsp; export local readonly unset<br>
complete -A enabled &nbsp; &nbsp;builtin<br>
complete -A alias &nbsp; &nbsp; &nbsp;alias unalias<br>
complete -A function &nbsp; function<br>
complete -A user &nbsp; &nbsp; &nbsp; su mail finger<br>
complete -A helptopic &nbsp;help &nbsp; &nbsp; # Currently, same as builtins.<br>
complete -A shopt &nbsp; &nbsp; &nbsp;shopt<br>
complete -A stopped -P '%' bg<br>
complete -A job -P '%' &nbsp; &nbsp; fg jobs disown<br>
complete -A directory &nbsp;mkdir rmdir<br>
complete -A directory &nbsp; -o default cd<br>
# Compression<br>
complete -f -o default -X '*.+(zip|ZIP)' &nbsp;zip<br>
complete -f -o default -X '!*.+(zip|ZIP)' unzip<br>
complete -f -o default -X '*.+(z|Z)' &nbsp; &nbsp; &nbsp;compress<br>
complete -f -o default -X '!*.+(z|Z)' &nbsp; &nbsp; uncompress<br>
complete -f -o default -X '*.+(gz|GZ)' &nbsp; &nbsp;gzip<br>
complete -f -o default -X '!*.+(gz|GZ)' &nbsp; gunzip<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
806<br>
<hr>
<A name=813></a>Advanced Bash-Scripting Guide<br>
complete -f -o default -X '*.+(bz2|BZ2)' &nbsp;bzip2<br>
complete -f -o default -X '!*.+(bz2|BZ2)' bunzip2<br>
complete -f -o default -X '!*.+(zip|ZIP|z|Z|gz|GZ|bz2|BZ2)' extract<br>
# Documents - Postscript,pdf,dvi.....<br>
complete -f -o default -X '!*.+(ps|PS)' &nbsp;gs ghostview ps2pdf ps2ascii<br>
complete -f -o default -X '!*.+(dvi|DVI)' dvips dvipdf xdvi dviselect dvitype<br>
complete -f -o default -X '!*.+(pdf|PDF)' acroread pdf2ps<br>
complete -f -o default -X \<br>
'!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))' gv ggv<br>
complete -f -o default -X '!*.texi*' makeinfo texi2dvi texi2html texi2pdf<br>
complete -f -o default -X '!*.tex' tex latex slitex<br>
complete -f -o default -X '!*.lyx' lyx<br>
complete -f -o default -X '!*.+(htm*|HTM*)' lynx html2ps<br>
complete -f -o default -X \<br>
'!*.+(doc|DOC|xls|XLS|ppt|PPT|sx?|SX?|csv|CSV|od?|OD?|ott|OTT)' soffice<br>
# Multimedia<br>
complete -f -o default -X \<br>
'!*.+(gif|GIF|jp*g|JP*G|bmp|BMP|xpm|XPM|png|PNG)' xv gimp ee gqview<br>
complete -f -o default -X '!*.+(mp3|MP3)' mpg123 mpg321<br>
complete -f -o default -X '!*.+(ogg|OGG)' ogg123<br>
complete -f -o default -X \<br>
'!*.@(mp[23]|MP[23]|ogg|OGG|wav|WAV|pls|m3u|xm|mod|s[3t]m|it|mtm|ult|flac)' xmms<br>
complete -f -o default -X \<br>
'!*.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|vcd|\<br>
ps|pes|fli|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp3|MP3|ogg|OGG|\<br>
ogm|OGM|mp4|MP4|wav|WAV|asx|ASX)' xine<br>
complete -f -o default -X '!*.pl' &nbsp;perl perl5<br>
# This is a 'universal' completion function - it works when commands have<br>
# a so-called 'long options' mode , ie: 'ls --all' instead of 'ls -a'<br>
# Needs the '-o' option of grep<br>
# &nbsp;(try the commented-out version if not available).<br>
# First, remove '=' from completion word separators<br>
# (this will allow completions like 'ls --color=auto' to work correctly).<br>
COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}<br>
_get_longopts()&nbsp;<br>
{&nbsp;<br>
&nbsp; &nbsp; #$1 --help | sed &nbsp;-e '/--/!d' -e 's/.*--\([^[:space:].,]*\).*/--\1/'| \<br>
#grep ^&quot;$2&quot; |sort -u ;<br>
&nbsp; &nbsp; $1 --help | grep -o -e &quot;--[^[:space:].,]*&quot; | grep -e &quot;$2&quot; |sort -u&nbsp;<br>
}<br>
_longopts()<br>
{<br>
&nbsp; &nbsp; local cur<br>
&nbsp; &nbsp; cur=${COMP_WORDS[COMP_CWORD]}<br>
&nbsp; &nbsp; case &quot;${cur:-*}&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp;-*) &nbsp; &nbsp; &nbsp;;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;return ;;<br>
&nbsp; &nbsp; esac<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
807<br>
<hr>
<A name=814></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; case &quot;$1&quot; in<br>
&nbsp; &nbsp; &nbsp; \~*) &nbsp; &nbsp; &nbsp;eval cmd=&quot;$1&quot; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *) &nbsp; &nbsp; &nbsp;cmd=&quot;$1&quot; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; COMPREPLY=( $(_get_longopts ${1} ${cur} ) )<br>
}<br>
complete &nbsp;-o default -F _longopts configure bash<br>
complete &nbsp;-o default -F _longopts wget id info a2ps ls recode<br>
_tar()<br>
{<br>
&nbsp; &nbsp; local cur ext regex tar untar<br>
&nbsp; &nbsp; COMPREPLY=()<br>
&nbsp; &nbsp; cur=${COMP_WORDS[COMP_CWORD]}<br>
&nbsp; &nbsp; # If we want an option, return the possible long options.<br>
&nbsp; &nbsp; case &quot;$cur&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; -*) &nbsp; &nbsp; COMPREPLY=( $(_get_longopts $1 $cur ) ); return 0;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; if [ $COMP_CWORD -eq 1 ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( compgen -W 'c t x u r d A' -- $cur ) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; case &quot;${COMP_WORDS[1]}&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; ?(-)c*f)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( compgen -f $cur ) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +([^Izjy])f)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ext='tar'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regex=$ext<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *z*f)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ext='tar.gz'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regex='t\(ar\.\)\(gz\|Z\)'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *[Ijy]*f)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ext='t?(ar.)bz?(2)'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regex='t\(ar\.\)bz2\?'<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; &nbsp; &nbsp; *)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( compgen -f $cur ) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac<br>
&nbsp; &nbsp; if [[ &quot;$COMP_LINE&quot; == tar*.$ext' '* ]]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Complete on files in tar file.<br>
&nbsp; &nbsp; &nbsp; &nbsp; #<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Get name of tar file from command line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; tar=$( echo &quot;$COMP_LINE&quot; | \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sed -e 's|^.* \([^ ]*'$regex'\) .*$|\1|' )<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Devise how to untar and list it.<br>
&nbsp; &nbsp; &nbsp; &nbsp; untar=t${COMP_WORDS[1]//[^Izjyf]/}<br>
&nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( compgen -W &quot;$( echo $( tar $untar $tar \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2&gt;/dev/null ) )&quot; -- &quot;$cur&quot; ) )<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
808<br>
<hr>
<A name=815></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; # File completion on relevant files.<br>
&nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( compgen -G $cur\*.$ext ) )<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; return 0<br>
}<br>
complete -F _tar -o default tar<br>
_make()<br>
{<br>
&nbsp; &nbsp; local mdef makef makef_dir=&quot;.&quot; makef_inc gcmd cur prev i;<br>
&nbsp; &nbsp; COMPREPLY=();<br>
&nbsp; &nbsp; cur=${COMP_WORDS[COMP_CWORD]};<br>
&nbsp; &nbsp; prev=${COMP_WORDS[COMP_CWORD-1]};<br>
&nbsp; &nbsp; case &quot;$prev&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; -*f)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=($(compgen -f $cur ));<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac;<br>
&nbsp; &nbsp; case &quot;$cur&quot; in<br>
&nbsp; &nbsp; &nbsp; &nbsp; -*)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=($(_get_longopts $1 $cur ));<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0<br>
&nbsp; &nbsp; &nbsp; &nbsp; ;;<br>
&nbsp; &nbsp; esac;<br>
&nbsp; &nbsp; # make reads `GNUmakefile', then `makefile', then `Makefile'<br>
&nbsp; &nbsp; if [ -f ${makef_dir}/GNUmakefile ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; makef=${makef_dir}/GNUmakefile<br>
&nbsp; &nbsp; elif [ -f ${makef_dir}/makefile ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; makef=${makef_dir}/makefile<br>
&nbsp; &nbsp; elif [ -f ${makef_dir}/Makefile ]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; makef=${makef_dir}/Makefile<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; makef=${makef_dir}/*.mk &nbsp; &nbsp; &nbsp; &nbsp;# Local convention.<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; # Before we scan for targets, see if a Makefile name was<br>
&nbsp; &nbsp; # specified with -f ...<br>
&nbsp; &nbsp; for (( i=0; i &lt; ${#COMP_WORDS[@]}; i++ )); do<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [[ ${COMP_WORDS[i]} == -f ]]; then<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# eval for tilde expansion<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;eval makef=${COMP_WORDS[i+1]}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; done<br>
&nbsp; &nbsp; [ ! -f $makef ] &amp;&amp; return 0<br>
&nbsp; &nbsp; # deal with included Makefiles<br>
&nbsp; &nbsp; makef_inc=$( grep -E '^-?include' $makef | \<br>
&nbsp; &nbsp; sed -e &quot;s,^.* ,&quot;$makef_dir&quot;/,&quot; )<br>
&nbsp; &nbsp; for file in $makef_inc; do<br>
&nbsp; &nbsp; &nbsp; &nbsp; [ -f $file ] &amp;&amp; makef=&quot;$makef $file&quot;<br>
&nbsp; &nbsp; done<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
809<br>
<hr>
<A name=816></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; # If we have a partial word to complete, restrict completions to<br>
&nbsp; &nbsp; # matches of that word.<br>
&nbsp; &nbsp; if [ -n &quot;$cur&quot; ]; then gcmd='grep &quot;^$cur&quot;' ; else gcmd=cat ; fi<br>
&nbsp; &nbsp; COMPREPLY=( $( awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {split($1,A,/ /);for(i in A)print A[i]}' \<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $makef 2&gt;/dev/null | eval $gcmd &nbsp;))<br>
}<br>
complete -F _make -X '+($*|*.[cho])' make gmake pmake<br>
_killall()<br>
{<br>
&nbsp; &nbsp; local cur prev<br>
&nbsp; &nbsp; COMPREPLY=()<br>
&nbsp; &nbsp; cur=${COMP_WORDS[COMP_CWORD]}<br>
&nbsp; &nbsp; # get a list of processes (the first sed evaluation<br>
&nbsp; &nbsp; # takes care of swapped out processes, the second<br>
&nbsp; &nbsp; # takes care of getting the basename of the process)<br>
&nbsp; &nbsp; COMPREPLY=( $( /usr/bin/ps -u $USER -o comm &nbsp;| \<br>
&nbsp; &nbsp; &nbsp; &nbsp; sed -e '1,1d' -e 's#[]\[]##g' -e 's#^.*/##'| \<br>
&nbsp; &nbsp; &nbsp; &nbsp; awk '{if ($0 ~ /^'$cur'/) print $0}' ))<br>
&nbsp; &nbsp; return 0<br>
}<br>
complete -F _killall killall killps<br>
# A meta-command completion function for commands like sudo(8), which need to<br>
# first complete on a command, then complete according to that command's own<br>
# completion definition - currently not quite foolproof,<br>
# but still quite useful (By Ian McDonald, modified by me).<br>
_meta_comp()<br>
{<br>
&nbsp; &nbsp; local cur func cline cspec<br>
&nbsp; &nbsp; COMPREPLY=()<br>
&nbsp; &nbsp; cur=${COMP_WORDS[COMP_CWORD]}<br>
&nbsp; &nbsp; cmdline=${COMP_WORDS[@]}<br>
&nbsp; &nbsp; if [ $COMP_CWORD = 1 ]; then &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;COMPREPLY=( $( compgen -c $cur ) )<br>
&nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; cmd=${COMP_WORDS[1]} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# Find command.<br>
&nbsp; &nbsp; &nbsp; &nbsp; cspec=$( complete -p ${cmd} ) &nbsp; # Find spec of that command.<br>
&nbsp; &nbsp; &nbsp; &nbsp; # COMP_CWORD and COMP_WORDS() are not read-only,<br>
&nbsp; &nbsp; &nbsp; &nbsp; # so we can set them before handing off to regular<br>
&nbsp; &nbsp; &nbsp; &nbsp; # completion routine:<br>
&nbsp; &nbsp; &nbsp; &nbsp; # Get current command line minus initial command,<br>
&nbsp; &nbsp; &nbsp; &nbsp; cline=&quot;${COMP_LINE#$1 }&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; # split current command line tokens into array,<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
810<br>
<hr>
<A name=817></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; COMP_WORDS=( $cline )<br>
&nbsp; &nbsp; &nbsp; &nbsp; # set current token number to 1 less than now.<br>
&nbsp; &nbsp; &nbsp; &nbsp; COMP_CWORD=$(( $COMP_CWORD - 1 ))<br>
&nbsp; &nbsp; &nbsp; &nbsp; # If current arg is empty, add it to COMP_WORDS array<br>
&nbsp; &nbsp; &nbsp; &nbsp; # (otherwise that information will be lost).<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ -z $cur ]; then COMP_WORDS[COMP_CWORD]=&quot;&quot; &nbsp;; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; if [ &quot;${cspec%%-F *}&quot; != &quot;${cspec}&quot; ]; then<br>
&nbsp; &nbsp; &nbsp; # if -F then get function:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func=${cspec#*-F }<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func=${func%% *}<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eval $func $cline &nbsp; # Evaluate it.<br>
&nbsp; &nbsp; &nbsp; &nbsp; else<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func=$( echo $cspec | sed -e 's/^complete//' -e 's/[^ ]*$//' )<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COMPREPLY=( $( eval compgen $func $cur ) )<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; fi<br>
}<br>
complete -o default -F _meta_comp nohup \<br>
eval exec trace truss strace sotruss gdb<br>
complete -o default -F _meta_comp command type which man nice time<br>
# Local Variables:<br>
# mode:shell-script<br>
# sh-shell:bash<br>
# End:<br>
And, here is a snippet from Andrzej Szelachowski's instructive&nbsp;.bash_profile&nbsp;file.<br>
<b>Example L-2.&nbsp;.bash_profile&nbsp;file</b><br>
# From Andrzej Szelachowski's ~/.bash_profile:<br>
# &nbsp;Note that a variable may require special treatment<br>
#+ if it will be exported.<br>
DARKGRAY='\e[1;30m'<br>
LIGHTRED='\e[1;31m'<br>
GREEN='\e[32m'<br>
YELLOW='\e[1;33m'<br>
LIGHTBLUE='\e[1;34m'<br>
NC='\e[m'<br>
PCT=&quot;\`if [[ \$EUID -eq 0 ]]; then T='$LIGHTRED' ; else T='$LIGHTBLUE'; fi;&nbsp;<br>
echo \$T \`&quot;<br>
# &nbsp;For &quot;literal&quot; command substitution to be assigned to a variable,<br>
#+ use escapes and double quotes:<br>
#+ &nbsp; &nbsp; &nbsp; PCT=&quot;\` ... \`&quot; . . .<br>
# &nbsp;Otherwise, the value of PCT variable is assigned only once,<br>
#+ when the variable is exported/read from .bash_profile,<br>
#+ and it will not change afterwards even if the user ID changes.<br>
PS1=&quot;\n$GREEN[\w] \n$DARKGRAY($PCT\t$DARKGRAY)-($PCT\u$DARKGRAY)-($PCT\!<br>
$DARKGRAY)$YELLOW-&gt; $NC&quot;<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
811<br>
<hr>
<A name=818></a>Advanced Bash-Scripting Guide<br>
# &nbsp;Escape a variables whose value changes:<br>
# &nbsp; &nbsp; &nbsp; &nbsp;if [[ \$EUID -eq 0 ]],<br>
# &nbsp;Otherwise the value of the EUID variable will be assigned only once,<br>
#+ as above.<br>
# &nbsp;When a variable is assigned, it should be called escaped:<br>
#+ &nbsp; &nbsp; &nbsp; echo \$T,<br>
# &nbsp;Otherwise the value of the T variable is taken from the moment the PCT&nbsp;<br>
#+ variable is exported/read from .bash_profile.<br>
# &nbsp;So, in this example it would be null.<br>
# &nbsp;When a variable's value contains a semicolon it should be strong quoted:<br>
# &nbsp; &nbsp; &nbsp; &nbsp;T='$LIGHTRED',<br>
# &nbsp;Otherwise, the semicolon will be interpreted as a command separator.<br>
# &nbsp;Variables PCT and PS1 can be merged into a new PS1 variable:<br>
PS1=&quot;\`if [[ \$EUID -eq 0 ]]; then PCT='$LIGHTRED';<br>
else PCT='$LIGHTBLUE'; fi;&nbsp;<br>
echo '\n$GREEN[\w] \n$DARKGRAY('\$PCT'\t$DARKGRAY)-\<br>
('\$PCT'\u$DARKGRAY)-('\$PCT'\!$DARKGRAY)$YELLOW-&gt; $NC'\`&quot;<br>
# The trick is to use strong quoting for parts of old PS1 variable.<br>
Appendix L. Sample .bashrc and .bash_profile Files<br>
812<br>
<hr>
<A name=819></a><b>Appendix M. Converting DOS Batch Files to Shell<br>Scripts</b><br>
Quite a number of programmers learned scripting on a PC running DOS. Even the crippled DOS batch file<br>language allowed writing some fairly powerful scripts and applications, though they often required extensive<br>kludges and workarounds. Occasionally, the need still arises to convert an old DOS batch file to a UNIX shell<br>script. This is generally not difficult, as DOS batch file operators are only a limited subset of the equivalent<br>shell scripting ones.<br>
<b>Table M-1. Batch file keywords / variables / operators, and their shell equivalents</b><br>
<b>Batch File Operator</b><br>
<b>Shell Script Equivalent</b><br>
<b>Meaning</b><br>
%<br>
$<br>
command-line parameter prefix<br>
/<br>
-<br>
command option flag<br>
\<br>
/<br>
directory path separator<br>
==<br>
=<br>
(equal-to) string comparison test<br>
!==!<br>
!=<br>
(not equal-to) string comparison<br>test<br>
|<br>
|<br>
pipe<br>
@<br>
set&nbsp;+v<br>
do not echo current command<br>
*<br>
*<br>
filename &quot;wild card&quot;<br>
&gt;<br>
&gt;<br>
file redirection (overwrite)<br>
&gt;&gt;<br>
&gt;&gt;<br>
file redirection (append)<br>
&lt;<br>
&lt;<br>
redirect&nbsp;stdin<br>
%VAR%<br>
$VAR<br>
environmental variable<br>
REM<br>
#<br>
comment<br>
NOT<br>
!<br>
negate following test<br>
NUL<br>
/dev/null<br>
&quot;black hole&quot; for burying<br>command output<br>
ECHO<br>
echo<br>
echo (many more option in<br>Bash)<br>
ECHO.<br>
echo<br>
echo blank line<br>
ECHO OFF<br>
set&nbsp;+v<br>
do not echo command(s)<br>following<br>
FOR %%VAR IN (LIST) DO<br>
for var in [list]; do<br>
&quot;for&quot; loop<br>
:LABEL<br>
none (unnecessary)<br>
label<br>
GOTO<br>
none (use a function)<br>
jump to another location in the<br>script<br>
PAUSE<br>
sleep<br>
pause or wait an interval<br>
CHOICE<br>
case or select<br>
menu choice<br>
IF<br>
if<br>
if-test<br>
Appendix M. Converting DOS Batch Files to Shell Scripts<br>
813<br>
<hr>
<A name=820></a>Advanced Bash-Scripting Guide<br>
IF EXIST&nbsp;<i>FILENAME</i><br>
if [ -e filename ]<br>
test if file exists<br>
IF !%N==!<br>
if [ -z &quot;$N&quot; ]<br>
if replaceable parameter &quot;N&quot; not<br>present<br>
CALL<br>
source or . (dot operator)<br>
&quot;include&quot; another script<br>
COMMAND /C<br>
source or . (dot operator)<br>
&quot;include&quot; another script (same<br>as CALL)<br>
SET<br>
export<br>
set an environmental variable<br>
SHIFT<br>
shift<br>
left shift command-line<br>argument list<br>
SGN<br>
-lt or -gt<br>
sign (of integer)<br>
ERRORLEVEL<br>
$?<br>
exit status<br>
CON<br>
stdin<br>
&quot;console&quot; (stdin)<br>
PRN<br>
/dev/lp0<br>
(generic) printer device<br>
LPT1<br>
/dev/lp0<br>
first printer device<br>
COM1<br>
/dev/ttyS0<br>
first serial port<br>
Batch files usually contain DOS commands. These must be translated into their UNIX equivalents in order to<br>convert a batch file into a shell script.<br>
<b>Table M-2. DOS commands and their UNIX equivalents</b><br>
<b>DOS Command</b><br>
<b>UNIX Equivalent</b><br>
<b>Effect</b><br>
ASSIGN<br>
ln<br>
link file or<br>directory<br>
ATTRIB<br>
chmod<br>
change file<br>permissions<br>
CD<br>
cd<br>
change directory<br>
CHDIR<br>
cd<br>
change directory<br>
CLS<br>
clear<br>
clear screen<br>
COMP<br>
diff, comm, cmp<br>
file compare<br>
COPY<br>
cp<br>
file copy<br>
Ctl-C<br>
Ctl-C<br>
break (signal)<br>
Ctl-Z<br>
Ctl-D<br>
EOF (end-of-file)<br>
DEL<br>
rm<br>
delete file(s)<br>
DELTREE<br>
rm -rf<br>
delete directory<br>recursively<br>
DIR<br>
ls -l<br>
directory listing<br>
ERASE<br>
rm<br>
delete file(s)<br>
EXIT<br>
exit<br>
exit current<br>process<br>
FC<br>
comm, cmp<br>
file compare<br>
FIND<br>
grep<br>
find strings in files<br>
MD<br>
mkdir<br>
make directory<br>
Appendix M. Converting DOS Batch Files to Shell Scripts<br>
814<br>
<hr>
<A name=821></a><IMG src="abs-guide-821_1.png"><br>
Advanced Bash-Scripting Guide<br>
MKDIR<br>
mkdir<br>
make directory<br>
MORE<br>
more<br>
text file paging<br>filter<br>
MOVE<br>
mv<br>
move<br>
PATH<br>
$PATH<br>
path to executables<br>
REN<br>
mv<br>
rename (move)<br>
RENAME<br>
mv<br>
rename (move)<br>
RD<br>
rmdir<br>
remove directory<br>
RMDIR<br>
rmdir<br>
remove directory<br>
SORT<br>
sort<br>
sort file<br>
TIME<br>
date<br>
display system<br>time<br>
TYPE<br>
cat<br>
output file to<br>stdout<br>
XCOPY<br>
cp<br>
(extended) file<br>copy<br>
Virtually all UNIX and shell operators and commands have many more options and enhancements than<br>their DOS and batch file counterparts. Many DOS batch files rely on auxiliary utilities, such as<b>&nbsp;ask.com</b>,<br><a href="abs-guides.html#190">a crippled counterpart to read.</a><br>
<a href="abs-guides.html#358">DOS supports only a very limited and incompatible subset of filename wild-card expansion, recognizing<br></a>just the * and ? characters.<br>
Converting a DOS batch file into a shell script is generally straightforward, and the result ofttimes reads better<br>than the original.<br>
<b>Example M-1. VIEWDATA.BAT: DOS Batch File</b><br>
REM VIEWDATA<br>
REM INSPIRED BY AN EXAMPLE IN &quot;DOS POWERTOOLS&quot;<br>
REM &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BY PAUL SOMERSON<br>
@ECHO OFF<br>
IF !%1==! GOTO VIEWDATA<br>
REM &nbsp;IF NO COMMAND-LINE ARG...<br>
FIND &quot;%1&quot; C:\BOZO\BOOKLIST.TXT<br>
GOTO EXIT0<br>
REM &nbsp;PRINT LINE WITH STRING MATCH, THEN EXIT.<br>
:VIEWDATA<br>
TYPE C:\BOZO\BOOKLIST.TXT | MORE<br>
REM &nbsp;SHOW ENTIRE FILE, 1 PAGE AT A TIME.<br>
:EXIT0<br>
The script conversion is somewhat of an improvement.&nbsp;[150]<br>
Appendix M. Converting DOS Batch Files to Shell Scripts<br>
815<br>
<hr>
<A name=822></a>Advanced Bash-Scripting Guide<br>
<b>Example M-2.<i>&nbsp;viewdata.sh</i></b><b>: Shell Script Conversion of VIEWDATA.BAT</b><br>
#!/bin/bash<br>
# viewdata.sh<br>
# Conversion of VIEWDATA.BAT to shell script.<br>
DATAFILE=/home/bozo/datafiles/book-collection.data<br>
ARGNO=1<br>
# @ECHO OFF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Command unnecessary here.<br>
if [ $# -lt &quot;$ARGNO&quot; ] &nbsp; &nbsp;# IF !%1==! GOTO VIEWDATA<br>
then<br>
&nbsp; less $DATAFILE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# TYPE C:\MYDIR\BOOKLIST.TXT | MORE<br>
else<br>
&nbsp; grep &quot;$1&quot; $DATAFILE &nbsp; &nbsp; # FIND &quot;%1&quot; C:\MYDIR\BOOKLIST.TXT<br>
fi &nbsp;<br>
exit 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# :EXIT0<br>
# &nbsp;GOTOs, labels, smoke-and-mirrors, and flimflam unnecessary.<br>
# &nbsp;The converted script is short, sweet, and clean,<br>
#+ which is more than can be said for the original.<br>
<a href="http://www.maem.umr.edu/batch/">Ted Davis' Shell Scripts on the PC site has a set of comprehensive tutorials on the old-fashioned art of batch<br></a>file programming. Certain of his ingenious techniques could conceivably have relevance for shell scripts.<br>
Appendix M. Converting DOS Batch Files to Shell Scripts<br>
816<br>
<hr>
<A name=823></a><b>Appendix N. Exercises</b><br>
The exercises that follow test and extend your knowledge of scripting. Think of them as a challenge, as an<br>entertaining way to take you further along the stony path toward UNIX wizardry.<br>
&nbsp; &nbsp; &nbsp; On a dingy side street in a run-down section of Hoboken, New Jersey,<br>
&nbsp; &nbsp; &nbsp; there sits a nondescript squat two-story brick building with an inscription<br>
&nbsp; &nbsp; &nbsp; incised on a marble plate in its wall:<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bash Scripting Hall of Fame.<br>
&nbsp; &nbsp; &nbsp; Inside, among various dusty uninteresting exhibits is a corroding,<br>
&nbsp; &nbsp; &nbsp; cobweb-festooned brass plaque inscribed with a short, very short<br>
&nbsp; &nbsp; &nbsp; list of those few persons who have successfully mastered the material<br>
&nbsp; &nbsp; &nbsp; in the&nbsp;<i>Advanced Bash Scripting</i><br>
<i>Guide</i>, as evidenced by their performance<br>
&nbsp; &nbsp; &nbsp; on the following Exercise sections.<br>
&nbsp; &nbsp; &nbsp; (Alas, the author of the&nbsp;<i>ABS</i><br>
<i>Guide</i>&nbsp;is not represented among the exhibits.<br>
<a href="abs-guides.html#561">&nbsp; &nbsp; &nbsp; This is possibly due to malicious rumors about lack of</a><br>
<a href="abs-guides.html#561">credentials and</a><br>
<a href="abs-guides.html#725">&nbsp; &nbsp; &nbsp; deficient scripting skills.)</a><br>
<b>N.1. Analyzing Scripts</b><br>
Examine the following script. Run it, then explain what it does. Annotate the script and rewrite it in a more<br>compact and elegant manner.<br>
#!/bin/bash<br>
MAX=10000<br>
&nbsp; for((nr=1; nr&lt;$MAX; nr++))<br>
&nbsp; do<br>
&nbsp; &nbsp; let &quot;t1 = nr % 5&quot;<br>
&nbsp; &nbsp; if [ &quot;$t1&quot; -ne 3 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; continue<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; let &quot;t2 = nr % 7&quot;<br>
&nbsp; &nbsp; if [ &quot;$t2&quot; -ne 4 ]<br>
&nbsp; &nbsp; then<br>
&nbsp; &nbsp; &nbsp; continue<br>
&nbsp; &nbsp; fi<br>
&nbsp; &nbsp; let &quot;t3 = nr % 9&quot;<br>
&nbsp; &nbsp; if [ &quot;$t3&quot; -ne 5 ]<br>
&nbsp; &nbsp; then<br>
Appendix N. Exercises<br>
817<br>
<hr>
<A name=824></a>Advanced Bash-Scripting Guide<br>
&nbsp; &nbsp; &nbsp; continue<br>
&nbsp; &nbsp; fi<br>
&nbsp; break &nbsp; # What happens when you comment out this line? Why?<br>
&nbsp; done<br>
&nbsp; echo &quot;Number = $nr&quot;<br>
exit 0<br>
---<br>
Explain what the following script does. It is really just a parameterized command-line pipe.<br>
#!/bin/bash<br>
DIRNAME=/usr/bin<br>
FILETYPE=&quot;shell script&quot;<br>
LOGFILE=logfile<br>
file &quot;$DIRNAME&quot;/* | fgrep &quot;$FILETYPE&quot; | tee $LOGFILE | wc -l<br>
exit 0<br>
---<br>
<a href="abs-guides.html#225">Examine and explain the following script. For hints, you might refer to the listings for find and stat.</a><br>
#!/bin/bash<br>
# Author: &nbsp;Nathan Coulter<br>
# This code is released to the public domain.<br>
# The author gave permission to use this code snippet in the ABS Guide.<br>
find -maxdepth 1 -type f -printf '%f\000' &nbsp;| {<br>
&nbsp; &nbsp;while read -d $'\000'; do<br>
&nbsp; &nbsp; &nbsp; mv &quot;$REPLY&quot; &quot;$(date -d &quot;$(stat -c '%y' &quot;$REPLY&quot;) &quot; '+%Y%m%d%H%M%S'<br>
&nbsp; &nbsp; &nbsp; )-$REPLY&quot;<br>
&nbsp; &nbsp;done<br>
}<br>
# Warning: Test-drive this script in a &quot;scratch&quot; directory.<br>
# It will somehow affect all the files there.<br>
---<br>
A reader sent in the following code snippet.<br>
while read LINE<br>
do<br>
&nbsp; echo $LINE<br>
done &lt; `tail -f /var/log/messages`<br>
He wished to write a script tracking changes to the system log file,&nbsp;/var/log/messages. Unfortunately,<br>the above code block hangs and does nothing useful. Why? Fix this so it does work. (Hint: rather than<br><a href="abs-guides.html#380">redirecting the&nbsp;stdin&nbsp;of the loop, try a pipe.)</a><br>
---<br>
Appendix N. Exercises<br>
818<br>
<hr>
<A name=825></a>Advanced Bash-Scripting Guide<br>
Analyze the following &quot;one-liner&quot; (here split into two lines for clarity) contributed by Rory Winston:<br>
export SUM=0; for f in $(find src -name &quot;*.java&quot;);<br>
do export SUM=$(($SUM + $(wc -l $f | awk '{ print $1 }'))); done; echo $SUM<br>
<a href="abs-guides.html#86">Hint: First, break the script up into bite-sized sections. Then, carefully examine its use of double-parentheses<br></a><a href="abs-guides.html#206">arithmetic, the export command, the find command, the wc command, and awk.</a><br>
---<br>
<a href="abs-guides.html#583">Analyze Example A-10, and reorganize it in a simplified and more logical style. See how many of the<br></a>variables can be eliminated, and try to optimize the script to speed up its execution time.<br>
Alter the script so that it accepts any ordinary ASCII text file as input for its initial &quot;generation&quot;. The script<br>will read the first&nbsp;<i>$ROW*$COL</i>&nbsp;characters, and set the occurrences of vowels as &quot;living&quot; cells. Hint: be sure to<br>translate the spaces in the input file to underscore characters.<br>
<b>N.2. Writing Scripts</b><br>
Write a script to carry out each of the following tasks.<br>
<b>EASY</b><br>
<b>Self-reproducing Script</b><br>
Write a script that backs itself up, that is, copies itself to a file named&nbsp;backup.sh.<br>
<a href="abs-guides.html#221">Hint: Use the cat command and the appropriate positional parameter.</a><br>
<b>Home Directory Listing</b><br>
Perform a recursive directory listing on the user's home directory and save the information to a file.<br>Compress the file, have the script prompt the user to insert a USB flash drive, then press<b>&nbsp;ENTER</b>.<br>Finally, save the file to the flash drive after making certain the flash drive has properly mounted by<br><a href="abs-guides.html#332">parsing the output of df. Note that the flash drive must be</a><i>&nbsp;unmounted</i>&nbsp;before it is removed.<br>
<a href="abs-guides.html#144"><b>Converting for loops to while and until loops</b></a><br>
Convert the<i>&nbsp;for loops</i><a href="abs-guides.html#144">&nbsp;in Example 11-1 to</a><i>&nbsp;while loops</i><a href="abs-guides.html#427">. Hint: store the data in an array and step through<br></a>the array elements.<br>
Having already done the &quot;heavy lifting,&quot; now convert the loops in the example to<i>&nbsp;until loops</i>.<br>
<b>Changing the line spacing of a text file</b><br>
Write a script that reads each line of a target file, then writes the line back to&nbsp;stdout, but with an<br>extra blank line following. This has the effect of<i>&nbsp;double-spacing</i>&nbsp;the file.<br>
Include all necessary code to check whether the script gets the necessary command-line argument (a<br>filename), and whether the specified file exists.<br>
When the script runs correctly, modify it to<i>&nbsp;triple-space</i>&nbsp;the target file.<br>
Finally, write a script to remove all blank lines from the target file,<i>&nbsp;single-spacing</i>&nbsp;it.<br>
<b>Backwards Listing</b><br>
Write a script that echoes itself to&nbsp;stdout, but<i>&nbsp;backwards</i>.<br>
<b>Automatically Decompressing Files</b><br>
Appendix N. Exercises<br>
819<br>
<hr>
<A name=826></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#266">Given a list of filenames as input, this script queries each target file (parsing the output of the file<br></a>command) for the type of compression used on it. Then the script automatically invokes the<br>appropriate decompression command (<b>gunzip</b>,<b>&nbsp;bunzip2</b>,<b>&nbsp;unzip</b>,<b>&nbsp;uncompress</b>, or whatever). If a target<br>file is not compressed, the script emits a warning message, but takes no other action on that particular<br>file.<br>
<b>Unique System ID</b><br>
Generate a &quot;unique&quot; 6-digit hexadecimal identifier for your computer. Do<i>&nbsp;not</i><a href="abs-guides.html#333">&nbsp;use the flawed hostid<br></a>command. Hint:<a href="abs-guides.html#275"><b>&nbsp;md5sum&nbsp;</b></a><a href="abs-guides.html#793"><b>/etc/passwd</b>, then select the first 6 digits of output.</a><br>
<b>Backup</b><br>
Archive as a &quot;tarball&quot; (*.tar.gz&nbsp;file) all the files in your home directory tree<br>(/home/your-name<a href="abs-guides.html#225">) that have been modified in the last 24 hours. Hint: use find.</a><br>
Optional: you may use this as the basis of a<i>&nbsp;backup</i>&nbsp;script.<br>
<b>Checking whether a process is still running</b><br>
<a href="abs-guides.html#19">Given a process ID (</a><i>PID</i>) as an argument, this script will check, at user-specified intervals, whether<br><a href="abs-guides.html#335">the given process is still running. You may use the ps and sleep commands.</a><br>
<b>Primes</b><br>
Print (to&nbsp;stdout) all prime numbers between 60000 and 63000. The output should be nicely<br><a href="abs-guides.html#188">formatted in columns (hint: use printf).</a><br>
<b>Lottery Numbers</b><br>
One type of lottery involves picking five different numbers, in the range of 1 - 50. Write a script that<br>generates five pseudorandom numbers in this range,<i>&nbsp;with no duplicates</i>. The script will give the<br>option of echoing the numbers to&nbsp;stdout&nbsp;or saving them to a file, along with the date and time the<br>particular number set was generated. (If your script consistently generates<i>&nbsp;winning</i>&nbsp;lottery numbers,<br>then you can retire on the proceeds and leave shell scripting to those of us who have to work for a<br>living.)<br>
<b>INTERMEDIATE</b><br>
<b>Integer or String</b><br>
<a href="abs-guides.html#399">Write a script function that determines if an argument passed to it is an integer or a string. The<br></a>function will return TRUE (0) if passed an integer, and FALSE (1) if passed a string.<br>
Hint: What does the following expression return when&nbsp;$1&nbsp;is<i>&nbsp;not</i>&nbsp;an integer?<br>
expr $1 + 0<br>
<a href="abs-guides.html#882"><b>ASCII to Integer</b></a><br>
The<i>&nbsp;atoi</i>&nbsp;function in<b>&nbsp;C</b>&nbsp;converts a string character to an integer. Write a shell script function that<br>performs the same operation. Likewise, write a shell script function that does the inverse, mirroring<br>the<b>&nbsp;C</b><i>&nbsp;itoa</i>&nbsp;function which converts an integer into an ASCII character.<br>
<b>Managing Disk Space</b><br>
List, one at a time, all files larger than 100K in the&nbsp;/home/username&nbsp;directory tree. Give the user<br>the option to delete or compress the file, then proceed to show the next one. Write to a logfile the<br>names of all deleted files and the deletion times.<br>
<b>Banner</b><br>
<a href="abs-guides.html#311">Simulate the functionality of the deprecated banner command in a script.</a><br>
<b>Removing Inactive Accounts</b><br>
Inactive accounts on a network server waste disk space and may become a security risk. Write an<br>administrative script (to be invoked by<i>&nbsp;root</i><a href="abs-guides.html#338">&nbsp;or the cron daemon) that checks for and deletes user<br></a>accounts that have not been accessed within the last 90 days.<br>
<b>Enforcing Disk Quotas</b><br>
Appendix N. Exercises<br>
820<br>
<hr>
<A name=827></a>Advanced Bash-Scripting Guide<br>
Write a script for a multi-user system that checks users' disk usage. If a user surpasses a preset limit<br>(500 MB, for example) in her&nbsp;/home/username&nbsp;directory, then the script automatically sends her a<br>&quot;pigout&quot; warning e-mail.<br>
<a href="abs-guides.html#331">The script will use the du and mail commands. As an option, it will allow setting and enforcing quotas<br></a><a href="abs-guides.html#348">using the quota and setquota commands.</a><br>
<b>Logged in User Information</b><br>
For all logged in users, show their real names and the time and date of their last login.<br>
<a href="abs-guides.html#322">Hint: use who, lastlog, and parse&nbsp;</a><a href="abs-guides.html#793">/etc/passwd</a>.<br>
<b>Safe Delete</b><br>
Implement, as a script, a &quot;safe&quot; delete command,&nbsp;sdel.sh. Filenames passed as command-line<br><a href="abs-guides.html#265">arguments to this script are not deleted, but instead gzipped if not already compressed (use file to<br></a>check), then moved to a&nbsp;~/TRASH&nbsp;directory. Upon invocation, the script checks the&nbsp;~/TRASH<br><a href="abs-guides.html#222">directory for files older than 48 hours and permanently deletes them. (An better alternative might be<br></a><a href="abs-guides.html#338">to have a second script handle this, periodically invoked by the cron daemon.)</a><br>
<i>Extra credit:</i><a href="abs-guides.html#223">&nbsp;Write the script so it can handle files and directories recursively. This would give it the<br></a>capability of &quot;safely deleting&quot; entire directory structures.<br>
<b>Making Change</b><br>
What is the most efficient way to make change for $1.68, using only coins in common circulations<br>(up to 25c)? It's 6 quarters, 1 dime, a nickel, and three cents.<br>
Given any arbitrary command-line input in dollars and cents ($*.??), calculate the change, using the<br>minimum number of coins. If your home country is not the United States, you may use your local<br>currency units instead. The script will need to parse the command-line input, then change it to<br><a href="abs-guides.html#408">multiples of the smallest monetary unit (cents or whatever). Hint: look at Example 24-8.</a><br>
<b>Quadratic Equations</b><br>
Solve a<i>&nbsp;quadratic</i>&nbsp;equation of the form&nbsp;<i>Ax^2 + Bx + C = 0</i>. Have a script take as arguments the<br>coefficients,&nbsp;<b>A</b>,&nbsp;<b>B</b>, and&nbsp;<b>C</b>, and return the solutions to five decimal places.<br>
<a href="abs-guides.html#297">Hint: pipe the coefficients to bc, using the well-known formula,&nbsp;</a><i>x = ( -B +/- sqrt( B^2 -<br>4AC ) ) / 2A</i>.<br>
<b>Table of Logarithms</b><br>
<a href="abs-guides.html#297">Using the bc and printf commands, print out a nicely-formatted table of eight-place natural logarithms<br></a>in the interval between 0.00 and 100.00, in steps of .01.<br>
Hint:<i>&nbsp;bc</i>&nbsp;requires the&nbsp;-l&nbsp;option to load the math library.<br>
<b>Unicode Table</b><br>
<a href="abs-guides.html#843">Using Example S-1 as a template, write a script that prints to a file a complete Unicode table.</a><br>
Hint: Use the&nbsp;-e<a href="abs-guides.html#187">&nbsp;option to echo:</a><b>&nbsp;echo -e '\uXXXX'</b>, where&nbsp;<i>XXXX</i>&nbsp;is the Unicode numerical character<br><a href="abs-guides.html#557">designation. This requires version 4.2 or later of Bash.</a><br>
<b>Sum of Matching Numbers</b><br>
Find the sum of all five-digit numbers (in the range 10000 - 99999) containing<i>&nbsp;exactly two</i>&nbsp;out of the<br>following set of digits: { 4, 5, 6 }. These may repeat within the same number, and if so, they count<br>once for each occurrence.<br>
Some examples of<i>&nbsp;matching numbers</i>&nbsp;are 42057, 74638, and 89515.<br>
<b>Lucky Numbers</b><br>
Appendix N. Exercises<br>
821<br>
<hr>
<A name=828></a>Advanced Bash-Scripting Guide<br>
A<i>&nbsp;lucky number</i>&nbsp;is one whose individual digits add up to 7, in successive additions. For example,<br>62431 is a<i>&nbsp;lucky number</i>&nbsp;(6 + 2 + 4 + 3 + 1 = 16, 1 + 6 = 7). Find all the<i>&nbsp;lucky numbers</i>&nbsp;between 1000<br>and 10000.<br>
<b>Craps</b><br>
<a href="abs-guides.html#706">Borrowing the ASCII graphics from Example A-40, write a script that plays the well-known gambling<br></a>game of<i>&nbsp;craps</i>. The script will accept bets from one or more players, roll the dice, and keep track of<br>wins and losses, as well as of each player's bankroll.<br>
<b>Tic-tac-toe</b><br>
Write a script that plays the child's game of<i>&nbsp;tic-tac-toe</i>&nbsp;against a human player. The script will let the<br>human choose whether to take the first move. The script will follow an optimal strategy, and therefore<br>never lose. To simplify matters, you may use ASCII graphics:<br>
&nbsp; &nbsp;o | x |<br>
&nbsp; &nbsp;----------<br>
&nbsp; &nbsp; &nbsp;| x |<br>
&nbsp; &nbsp;----------<br>
&nbsp; &nbsp; &nbsp;| o |<br>
&nbsp; &nbsp;Your move, human (row, column)?<br>
<b>Alphabetizing a String</b><br>
Alphabetize (in ASCII order) an arbitrary string read from the command-line.<br>
<b>Parsing</b><br>
Parse&nbsp;<a href="abs-guides.html#793">/etc/passwd</a>, and output its contents in nice, easy-to-read tabular form.<br>
<b>Logging Logins</b><br>
Parse&nbsp;/var/log/messages&nbsp;to produce a nicely formatted file of user logins and login times. The<br>script may need to run as<i>&nbsp;root</i>. (Hint: Search for the string &quot;LOGIN.&quot;)<br>
<b>Pretty-Printing a Data File</b><br>
Certain database and spreadsheet packages use save-files with the fields separated by commas,<br>commonly referred to as<i>&nbsp;comma-separated values</i>&nbsp;or CSVs. Other applications often need to parse<br>these files.<br>
<a href="abs-guides.html#35">Given a data file with comma-separated fields, of the form:</a><br>
Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989<br>
Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612<br>
...<br>
Reformat the data and print it out to&nbsp;stdout&nbsp;in labeled, evenly-spaced columns.<br>
<b>Justification</b><br>
Given ASCII text input either from&nbsp;stdin&nbsp;or a file, adjust the word spacing to right-justify each line<br>to a user-specified line-width, then send the output to&nbsp;stdout.<br>
<b>Mailing List</b><br>
<a href="abs-guides.html#293">Using the mail command, write a script that manages a simple mailing list. The script automatically<br></a>e-mails the monthly company newsletter, read from a specified text file, and sends it to all the<br>addresses on the mailing list, which the script reads from another specified file.<br>
<b>Generating Passwords</b><br>
Generate pseudorandom 8-character passwords, using characters in the ranges [0-9], [A-Z], [a-z].<br>Each password must contain at least two digits.<br>
<b>Monitoring a User</b><br>
You suspect that one particular user on the network has been abusing her privileges and possibly<br>attempting to hack the system. Write a script to automatically monitor and log her activities when<br>she's signed on. The log file will save entries for the previous week, and delete those entries more<br>than seven days old.<br>
Appendix N. Exercises<br>
822<br>
<hr>
<A name=829></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#324">You may use last, lastlog, and lastcomm to aid your surveillance of the suspected fiend.</a><br>
<b>Checking for Broken Links</b><br>
<a href="abs-guides.html#288">Using lynx with the&nbsp;</a>-traversal&nbsp;option, write a script that checks a Web site for broken links.<br>
<b>DIFFICULT</b><br>
<b>Testing Passwords</b><br>
Write a script to check and validate passwords. The object is to flag &quot;weak&quot; or easily guessed<br>password candidates.<br>
A trial password will be input to the script as a command-line parameter. To be considered<br>acceptable, a password must meet the following minimum qualifications:<br>
Minimum length of 8 characters<br>
◊&nbsp;<br>
Must contain at least one numeric character<br>
◊&nbsp;<br>
Must contain at least one of the following non-alphabetic characters: @, #, $, %, &amp;, *, +, -, =<br>
◊&nbsp;<br>
Optional:<br>
Do a dictionary check on every sequence of at least four consecutive alphabetic characters in<br>
◊&nbsp;<br>
the password under test. This will eliminate passwords containing embedded &quot;words&quot; found<br>in a standard dictionary.<br>Enable the script to check all the passwords on your system. These do not reside in<br>
◊&nbsp;<br>
<a href="abs-guides.html#793">/etc/passwd.</a><br>
<a href="abs-guides.html#354">This exercise tests mastery of Regular Expressions.</a><br>
<b>Cross Reference</b><br>
Write a script that generates a<i>&nbsp;cross-reference</i>&nbsp;(<i>concordance</i>) on a target file. The output will be a<br>listing of all word occurrences in the target file, along with the line numbers in which each word<br>occurs. Traditionally,<i>&nbsp;linked list</i>&nbsp;constructs would be used in such applications. Therefore, you should<br><a href="abs-guides.html#427">investigate arrays in the course of this exercise. Example 16-12 is probably</a><i>&nbsp;not</i>&nbsp;a good place to start.<br>
<b>Square Root</b><br>
Write a script to calculate square roots of numbers using<i>&nbsp;Newton's Method</i>.<br>
<a href="abs-guides.html#525">The algorithm for this, expressed as a snippet of Bash pseudo-code is:</a><br>
# &nbsp;(Isaac) Newton's Method for speedy extraction<br>
#+ of square roots.<br>
guess = $argument<br>
# &nbsp;$argument is the number to find the square root of.<br>
# &nbsp;$guess is each successive calculated &quot;guess&quot; -- or trial solution --<br>
#+ of the square root.<br>
# &nbsp;Our first &quot;guess&quot; at a square root is the argument itself.<br>
oldguess = 0<br>
# $oldguess is the previous $guess.<br>
tolerance = .000001<br>
# To how close a tolerance we wish to calculate.<br>
loopcnt = 0<br>
# Let's keep track of how many times through the loop.<br>
# Some arguments will require more loop iterations than others.<br>
Appendix N. Exercises<br>
823<br>
<hr>
<A name=830></a>Advanced Bash-Scripting Guide<br>
while [ ABS( $guess $oldguess ) -gt $tolerance ]<br>
# &nbsp; &nbsp; &nbsp; ^^^^^^^^^^^^^^^^^^^^^^^ Fix up syntax, of course.<br>
# &nbsp; &nbsp; &nbsp;&quot;ABS&quot; is a (floating point) function to find the absolute value<br>
#+ &nbsp; &nbsp; &nbsp;of the difference between the two terms.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; So, as long as difference between current and previous<br>
#+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;trial solution (guess) exceeds the tolerance, keep looping.<br>
do<br>
&nbsp; &nbsp;oldguess = $guess &nbsp;# Update $oldguess to previous $guess.<br>
# &nbsp;=======================================================<br>
&nbsp; &nbsp;guess = ( $oldguess + ( $argument / $oldguess ) ) / 2.0<br>
# &nbsp; &nbsp; &nbsp; &nbsp;= 1/2 ( ($oldguess **2 + $argument) / $oldguess )<br>
# &nbsp;equivalent to:<br>
# &nbsp; &nbsp; &nbsp; &nbsp;= 1/2 ( $oldguess + $argument / $oldguess )<br>
# &nbsp;that is, &quot;averaging out&quot; the trial solution and<br>
#+ the proportion of argument deviation<br>
#+ (in effect, splitting the error in half).<br>
# &nbsp;This converges on an accurate solution<br>
#+ with surprisingly few loop iterations . . .<br>
#+ for arguments &gt; $tolerance, of course.<br>
# &nbsp;=======================================================<br>
&nbsp; &nbsp;(( loopcnt++ )) &nbsp; &nbsp; # Update loop counter.<br>
done<br>
It's a simple enough recipe, and<i>&nbsp;seems</i>&nbsp;at first glance easy enough to convert into a working Bash<br><a href="abs-guides.html#81">script. The problem, though, is that Bash has no native support for floating point numbers. So, the<br></a><a href="abs-guides.html#297">script writer needs to use bc or possibly awk to convert the numbers and do the calculations. It could<br></a>get rather messy . . .<br>
<b>Logging File Accesses</b><br>
Log all accesses to the files in&nbsp;/etc&nbsp;during the course of a single day. This information should<br>include the filename, user name, and access time. If any alterations to the files take place, that will be<br>flagged. Write this data as tabular (tab-separated) formatted records in a logfile.<br>
<b>Monitoring Processes</b><br>
Write a script to continually monitor all running processes and to keep track of how many child<br>processes each parent spawns. If a process spawns more than five children, then the script sends an<br>e-mail to the system administrator (or<i>&nbsp;root</i>) with all relevant information, including the time, PID of<br>the parent, PIDs of the children, etc. The script appends a report to a log file every ten minutes.<br>
<b>Strip Comments</b><br>
Strip all comments from a shell script whose name is specified on the command-line. Note that the<br><a href="abs-guides.html#11">initial #! line must not be stripped out.</a><br>
<b>Strip HTML Tags</b><br>
Strip all the HTML tags from a specified HTML file, then reformat it into lines between 60 and 75<br>characters in length. Reset paragraph and block spacing, as appropriate, and convert HTML tables to<br>their approximate text equivalent.<br>
<b>XML Conversion</b><br>
Convert an XML file to both HTML and text format.<br>
Optional: A script that converts Docbook/SGML to XML.<br>
<b>Chasing Spammers</b><br>
Write a script that analyzes a spam e-mail by doing DNS lookups on the IP addresses in the headers to<br>identify the relay hosts as well as the originating ISP. The script will forward the unaltered spam<br>message to the responsible ISPs. Of course, it will be necessary to filter out<i>&nbsp;your own ISP's IP<br>address</i>, so you don't end up complaining about yourself.<br>
Appendix N. Exercises<br>
824<br>
<hr>
<A name=831></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#280">As necessary, use the appropriate network analysis commands.</a><br>
<a href="abs-guides.html#282">For some ideas, see Example 16-41 and Example A-28.</a><br>
Optional: Write a script that searches through a list of e-mail messages and deletes the spam<br>according to specified filters.<br>
<b>Creating man pages</b><br>
<a href="abs-guides.html#225">Write a script that automates the process of creating man pages.</a><br>
Given a text file which contains information to be formatted into a<i>&nbsp;man page</i>, the script will read the<br><a href="abs-guides.html#261">file, then invoke the appropriate groff commands to output the corresponding</a><i>&nbsp;man page</i>&nbsp;to&nbsp;stdout.<br>The text file contains blocks of information under the standard<i>&nbsp;man page</i>&nbsp;headings, i.e., NAME,<br>SYNOPSIS, DESCRIPTION, etc.<br>
<a href="abs-guides.html#704">Example A-39 is an instructive first step.</a><br>
<b>Hex Dump</b><br>
Do a hex(adecimal) dump on a binary file specified as an argument to the script. The output should be<br><a href="abs-guides.html#35">in neat tabular fields, with the first field showing the address, each of the next 8 fields a 4-byte hex<br></a>number, and the final field the ASCII equivalent of the previous 8 fields.<br>
The obvious followup to this is to extend the hex dump script into a disassembler. Using a lookup<br>table, or some other clever gimmick, convert the hex values into 80x86 op codes.<br>
<b>Emulating a Shift Register</b><br>
<a href="abs-guides.html#449">Using Example 27-15 as an inspiration, write a script that emulates a 64-bit shift register as an array.<br></a>Implement functions to<i>&nbsp;load</i>&nbsp;the register,<i>&nbsp;shift left</i>,<i>&nbsp;shift right</i>, and<i>&nbsp;rotate</i>&nbsp;it. Finally, write a function<br>that interprets the register contents as eight 8-bit ASCII characters.<br>
<b>Calculating Determinants</b><br>
Write a script that calculates determinants&nbsp;<a href="abs-guides.html#415">[151] by recursively expanding the</a><i>&nbsp;minors</i>. Use a 4 x 4<br>determinant as a test case.<br>
<b>Hidden Words</b><br>
Write a &quot;word-find&quot; puzzle generator, a script that hides 10 input words in a 10 x 10 array of random<br>letters. The words may be hidden across, down, or diagonally.<br>
Optional: Write a script that<i>&nbsp;solves</i>&nbsp;word-find puzzles. To keep this from becoming too difficult, the<br>solution script will find only horizontal and vertical words. (Hint: Treat each row and column as a<br>string, and search for substrings.)<br>
<b>Anagramming</b><br>
Anagram 4-letter input. For example, the anagrams of<i>&nbsp;word</i>&nbsp;are:<i>&nbsp;do or rod row word</i>. You may use<br>/usr/share/dict/linux.words&nbsp;as the reference list.<br>
<b>Word Ladders</b><br>
A &quot;word ladder&quot; is a sequence of words, with each successive word in the sequence differing from the<br>previous one by a single letter.<br>
For example, to &quot;ladder&quot; from<i>&nbsp;mark</i>&nbsp;to<i>&nbsp;vase</i>:<br>
mark --&gt; park --&gt; part --&gt; past --&gt; vast --&gt; vase<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp; ^ &nbsp; &nbsp; &nbsp;^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
Write a script that solves word ladder puzzles. Given a starting and an ending word, the script will list<br>all intermediate steps in the &quot;ladder.&quot; Note that<i>&nbsp;all</i>&nbsp;words in the sequence must be legitimate<br>dictionary words.<br>
<b>Fog Index</b><br>
Appendix N. Exercises<br>
825<br>
<hr>
<A name=832></a>Advanced Bash-Scripting Guide<br>
The &quot;fog index&quot; of a passage of text estimates its reading difficulty, as a number corresponding<br>roughly to a school grade level. For example, a passage with a fog index of 12 should be<br>comprehensible to anyone with 12 years of schooling.<br>
The Gunning version of the fog index uses the following algorithm.<br>
Choose a section of the text at least 100 words in length.<br>
1.&nbsp;<br>
Count the number of sentences (a portion of a sentence truncated by the boundary of the text<br>
2.&nbsp;<br>
section counts as one).<br>Find the average number of words per sentence.<br>
3.&nbsp;<br>
AVE_WDS_SEN = TOTAL_WORDS / SENTENCES<br>Count the number of &quot;difficult&quot; words in the segment -- those containing at least 3 syllables.<br>
4.&nbsp;<br>
Divide this quantity by total words to get the proportion of difficult words.<br>
PRO_DIFF_WORDS = LONG_WORDS / TOTAL_WORDS<br>The Gunning fog index is the sum of the above two quantities, multiplied by 0.4, then<br>
5.&nbsp;<br>
rounded to the nearest integer.<br>
G_FOG_INDEX = int ( 0.4 * ( AVE_WDS_SEN + PRO_DIFF_WORDS ) )<br>
Step 4 is by far the most difficult portion of the exercise. There exist various algorithms for estimating<br>the syllable count of a word. A rule-of-thumb formula might consider the number of letters in a word<br>and the vowel-consonant mix.<br>
A strict interpretation of the Gunning fog index does not count compound words and proper nouns as<br>&quot;difficult&quot; words, but this would enormously complicate the script.<br>
<b>Calculating PI using Buffon's Needle</b><br>
The Eighteenth Century French mathematician de Buffon came up with a novel experiment.<br>Repeatedly drop a needle of length&nbsp;<i>n</i>&nbsp;onto a wooden floor composed of long and narrow parallel<br>boards. The cracks separating the equal-width floorboards are a fixed distance&nbsp;<i>d</i>&nbsp;apart. Keep track of<br>the total drops and the number of times the needle intersects a crack on the floor. The ratio of these<br>two quantities turns out to be a fractional multiple of PI.<br>
<a href="abs-guides.html#302">In the spirit of Example 16-50, write a script that runs a Monte Carlo simulation of</a><i>&nbsp;Buffon's Needle</i>.<br>To simplify matters, set the needle length equal to the distance between the cracks,&nbsp;<i>n = d</i>.<br>
Hint: there are actually two critical variables: the distance from the center of the needle to the nearest<br><a href="abs-guides.html#297">crack, and the inclination angle of the needle to that crack. You may use bc to handle the calculations.</a><br>
<b>Playfair Cipher</b><br>
Implement the Playfair (Wheatstone) Cipher in a script.<br>
The Playfair Cipher encrypts text by substitution of<i>&nbsp;digrams</i>&nbsp;(2-letter groupings). It is traditional to<br>use a 5 x 5 letter scrambled-alphabet<i>&nbsp;key square</i>&nbsp;for the encryption and decryption.<br>
&nbsp; &nbsp;C O D E S<br>
&nbsp; &nbsp;A B F G H<br>
&nbsp; &nbsp;I K L M N<br>
&nbsp; &nbsp;P Q R T U<br>
&nbsp; &nbsp;V W X Y Z<br>
Each letter of the alphabet appears once, except &quot;I&quot; also represents<br>
&quot;J&quot;. The arbitrarily chosen key word, &quot;CODES&quot; comes first, then all<br>
Appendix N. Exercises<br>
826<br>
<hr>
<A name=833></a>Advanced Bash-Scripting Guide<br>
the rest of the alphabet, in order from left to right, skipping letters<br>
already used.<br>
To encrypt, separate the plaintext message into digrams (2-letter<br>
groups). If a group has two identical letters, delete the second, and<br>
form a new group. If there is a single letter left over at the end,<br>
insert a &quot;null&quot; character, typically an &quot;X.&quot;<br>
THIS IS A TOP SECRET MESSAGE<br>
TH IS IS AT OP SE CR ET ME SA GE<br>
For each digram, there are three possibilities.<br>
-----------------------------------------------<br>
1) Both letters will be on the same row of the key square:<br>
&nbsp; &nbsp;For each letter, substitute the one immediately to the right, in that<br>
&nbsp; &nbsp;row. If necessary, wrap around left to the beginning of the row.<br>
or<br>
2) Both letters will be in the same column of the key square:<br>
&nbsp; &nbsp;For each letter, substitute the one immediately below it, in that<br>
&nbsp; &nbsp;row. If necessary, wrap around to the top of the column.<br>
or<br>
3) Both letters will form the corners of a rectangle within the key square:<br>
&nbsp; &nbsp;For each letter, substitute the one on the other corner the rectangle<br>
&nbsp; &nbsp;which lies on the same row.<br>
The &quot;TH&quot; digram falls under case #3.<br>
G H<br>
M N<br>
T U &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Rectangle with &quot;T&quot; and &quot;H&quot; at corners)<br>
T --&gt; U<br>
H --&gt; G<br>
The &quot;SE&quot; digram falls under case #1.<br>
C O D E S &nbsp; &nbsp; (Row containing &quot;S&quot; and &quot;E&quot;)<br>
S --&gt; C &nbsp;(wraps around left to beginning of row)<br>
E --&gt; S<br>
=========================================================================<br>
To decrypt encrypted text, reverse the above procedure under cases #1<br>
and #2 (move in opposite direction for substitution). Under case #3,<br>
just take the remaining two corners of the rectangle.<br>
Helen Fouche Gaines' classic work, ELEMENTARY CRYPTANALYSIS (1939), gives a<br>
fairly detailed description of the Playfair Cipher and its solution methods.<br>
This script will have three main sections<br>
Generating the<br>
I.&nbsp;<br>
<i>&nbsp;key square</i>, based on a user-input keyword.<br>
Appendix N. Exercises<br>
827<br>
<hr>
<A name=834></a>Advanced Bash-Scripting Guide<br>
Encrypting a<br>
II.&nbsp;<br>
<i>&nbsp;plaintext</i>&nbsp;message.<br>
Decrypting encrypted text.<br>
III.&nbsp;<br>
<a href="abs-guides.html#427">The script will make extensive use of arrays and functions. You may use Example A-55 as an<br></a>inspiration.<br>
--<br>
Please do not send the author your solutions to these exercises. There are more appropriate ways to impress<br>him with your cleverness, such as submitting bugfixes and suggestions for improving the book.<br>
Appendix N. Exercises<br>
828<br>
<hr>
<A name=835></a><b>Appendix O. Revision History</b><br>
&nbsp; &nbsp; &nbsp; This document first appeared as a 60-page HOWTO in the late spring<br>
&nbsp; &nbsp; &nbsp; of 2000. Since then, it has gone through quite a number of updates<br>
&nbsp; &nbsp; &nbsp; and revisions. This book could not have been written without the<br>
&nbsp; &nbsp; &nbsp; assistance of the Linux community, and especially of the volunteers<br>
&nbsp; &nbsp; &nbsp; of the&nbsp;<a href="http://www.tldp.org">Linux Documentation Project</a>.<br>
Here is the e-mail to the LDP requesting permission to submit version 0.1.<br>
From thegrendel@theriver.com Sat Jun 10 09:05:33 2000 -0700<br>
Date: Sat, 10 Jun 2000 09:05:28 -0700 (MST)<br>
From: &quot;M. Leo Cooper&quot; &lt;thegrendel@theriver.com&gt;<br>
X-Sender: thegrendel@localhost<br>
To: ldp-discuss@lists.linuxdoc.org<br>
Subject: Permission to submit HOWTO<br>
Dear HOWTO Coordinator,<br>
I am working on and would like to submit to the LDP a HOWTO on the subject<br>
of &quot;Bash Scripting&quot; (shell scripting, using 'bash'). As it happens,<br>
I have been writing this document, off and on, for about the last eight<br>
months or so, and I could produce a first draft in ASCII text format in<br>
a matter of just a few more days.<br>
I began writing this out of frustration at being unable to find a<br>
decent book on shell scripting. I managed to locate some pretty good<br>
articles on various aspects of scripting, but nothing like a complete,<br>
beginning-to-end tutorial. &nbsp;Well, in keeping with my philosophy, if all<br>
else fails, do it yourself.<br>
As it stands, this proposed &quot;Bash-Scripting HOWTO&quot; would serve as a<br>
combination tutorial and reference, with the heavier emphasis on the<br>
tutorial. It assumes Linux experience, but only a very basic level<br>
of programming skills. Interspersed with the text are 79 illustrative<br>
example scripts of varying complexity, all liberally commented. There<br>
are even exercises for the reader.<br>
At this stage, I'm up to 18,000+ words (124k), and that's over 50 pages of<br>
text (whew!).<br>
I haven't mentioned that I've previously authored an LDP HOWTO, the<br>
&quot;Software-Building HOWTO&quot;, which I wrote in Linuxdoc/SGML. I don't know<br>
if I could handle Docbook/SGML, and I'm glad you have volunteers to do<br>
the conversion. You people seem to have gotten on a more organized basis<br>
these last few months. Working with Greg Hankins and Tim Bynum was nice,<br>
but a professional team is even nicer.<br>
Anyhow, please advise.<br>
Mendel Cooper<br>
thegrendel@theriver.com<br>
<b>Table O-1. Revision History</b><br>
<b>Release&nbsp;Date</b><br>
<b>Comments</b><br>
Appendix O. Revision History<br>
829<br>
<hr>
<A name=836></a>Advanced Bash-Scripting Guide<br>
0.1<br>
14 Jun 2000<br>
Initial release.<br>
0.2<br>
30 Oct 2000<br>
Bugs fixed, plus much additional material and more example scripts.<br>
0.3<br>
12 Feb 2001&nbsp;Major update.<br>
0.4<br>
08 Jul 2001<br>
Complete revision and expansion of the book.<br>
0.5<br>
03 Sep 2001&nbsp;Major update: Bugfixes, material added, sections reorganized.<br>
1.0<br>
14 Oct 2001<br>
Stable release: Bugfixes, reorganization, material added.<br>
1.1<br>
06 Jan 2002<br>
Bugfixes, material and scripts added.<br>
1.2<br>
31 Mar 2002&nbsp;Bugfixes, material and scripts added.<br>
1.3<br>
02 Jun 2002<br>
TANGERINE release: A few bugfixes, much more material and scripts added.<br>
1.4<br>
16 Jun 2002<br>
MANGO release: A number of typos fixed, more material and scripts.<br>
1.5<br>
13 Jul 2002<br>
PAPAYA release: A few bugfixes, much more material and scripts added.<br>
1.6<br>
29 Sep 2002&nbsp;POMEGRANATE release: Bugfixes, more material, one more script.<br>
1.7<br>
05 Jan 2003<br>
COCONUT release: A couple of bugfixes, more material, one more script.<br>
1.8<br>
10 May 2003&nbsp;BREADFRUIT release: A number of bugfixes, more scripts and material.<br>
1.9<br>
21 Jun 2003<br>
PERSIMMON release: Bugfixes, and more material.<br>
2.0<br>
24 Aug 2003&nbsp;GOOSEBERRY release: Major update.<br>
2.1<br>
14 Sep 2003&nbsp;HUCKLEBERRY release: Bugfixes, and more material.<br>
2.2<br>
31 Oct 2003<br>
CRANBERRY release: Major update.<br>
2.3<br>
03 Jan 2004<br>
STRAWBERRY release: Bugfixes and more material.<br>
2.4<br>
25 Jan 2004<br>
MUSKMELON release: Bugfixes.<br>
2.5<br>
15 Feb 2004&nbsp;STARFRUIT release: Bugfixes and more material.<br>
2.6<br>
15 Mar 2004&nbsp;SALAL release: Minor update.<br>
2.7<br>
18 Apr 2004&nbsp;MULBERRY release: Minor update.<br>
2.8<br>
11 Jul 2004<br>
ELDERBERRY release: Minor update.<br>
3.0<br>
03 Oct 2004<br>
LOGANBERRY release: Major update.<br>
3.1<br>
14 Nov 2004&nbsp;BAYBERRY release: Bugfix update.<br>
3.2<br>
06 Feb 2005&nbsp;BLUEBERRY release: Minor update.<br>
3.3<br>
20 Mar 2005&nbsp;RASPBERRY release: Bugfixes, much material added.<br>
3.4<br>
08 May 2005&nbsp;TEABERRY release: Bugfixes, stylistic revisions.<br>
3.5<br>
05 Jun 2005<br>
BOXBERRY release: Bugfixes, some material added.<br>
3.6<br>
28 Aug 2005&nbsp;POKEBERRY release: Bugfixes, some material added.<br>
3.7<br>
23 Oct 2005<br>
WHORTLEBERRY release: Bugfixes, some material added.<br>
3.8<br>
26 Feb 2006&nbsp;BLAEBERRY release: Bugfixes, some material added.<br>
3.9<br>
15 May 2006&nbsp;SPICEBERRY release: Bugfixes, some material added.<br>
4.0<br>
18 Jun 2006<br>
WINTERBERRY release: Major reorganization.<br>
4.1<br>
08 Oct 2006<br>
WAXBERRY release: Minor update.<br>
4.2<br>
10 Dec 2006&nbsp;SPARKLEBERRY release: Important update.<br>
4.3<br>
29 Apr 2007&nbsp;INKBERRY release: Bugfixes, material added.<br>
5.0<br>
24 Jun 2007<br>
SERVICEBERRY release: Major update.<br>
5.1<br>
10 Nov 2007&nbsp;LINGONBERRY release: Minor update.<br>
5.2<br>
16 Mar 2008&nbsp;SILVERBERRY release: Important update.<br>
5.3<br>
11 May 2008&nbsp;GOLDENBERRY release: Minor update.<br>
Appendix O. Revision History<br>
830<br>
<hr>
<A name=837></a>Advanced Bash-Scripting Guide<br>
5.4<br>
21 Jul 2008<br>
ANGLEBERRY release: Major update.<br>
5.5<br>
23 Nov 2008&nbsp;FARKLEBERRY release: Minor update.<br>
5.6<br>
26 Jan 2009<br>
WORCESTERBERRY release: Minor update.<br>
6.0<br>
23 Mar 2009&nbsp;THIMBLEBERRY release: Major update.<br>
6.1<br>
30 Sep 2009&nbsp;BUFFALOBERRY release: Minor update.<br>
6.2<br>
17 Mar 2010&nbsp;ROWANBERRY release: Minor update.<br>
6.3<br>
30 Apr 2011&nbsp;SWOZZLEBERRY release: Major update.<br>
6.4<br>
30 Aug 2011&nbsp;VORTEXBERRY release: Minor update.<br>
Appendix O. Revision History<br>
831<br>
<hr>
<A name=838></a><b>Appendix P. Download and Mirror Sites</b><br>
<a href="abs-guides.html#265">The latest update of this document, as an archived, bzip2-ed &quot;tarball&quot; including both the SGML source and<br></a><a href="http://bash.webofcrafts.net/abs-guide-latest.tar.bz2">rendered HTML, may be downloaded from the author's home site). A &nbsp;pdf version is also available. There is<br></a><a href="http://bash.webofcrafts.net/abs-guide.epub">likewise an &nbsp;epub version, courtesy of Craig Barnes. The change log gives a detailed revision history. The<br></a><i>ABS Guide</i><a href="http://freshmeat.net/projects/advancedbashscriptingguide/">&nbsp;even has &nbsp;its own&nbsp;freshmeat.net&nbsp;page to keep track of major updates, user comments, and<br></a>popularity ratings for the project.<br>
<a href="http://www.tldp.org/LDP/abs/">The legacy hosting site for this document is the Linux Documentation Project, which maintains many other<br></a>Guides and HOWTOs as well.<br>
<a href="http://bash.webofcrafts.net/">Many thanks to Ronny Bangsund for donating server space to host this project.</a><br>
Appendix P. Download and Mirror Sites<br>
832<br>
<hr>
<A name=839></a><b>Appendix Q. To Do List</b><br>
<a href="abs-guides.html#538">A comprehensive survey of incompatibilities between Bash and the classic Bourne shell.</a><br>
•&nbsp;<br>
Same as above, but for the Korn shell (<br>
•&nbsp;<br>
<i>ksh</i>).<br>
Appendix Q. To Do List<br>
833<br>
<hr>
<A name=840></a><b>Appendix R. Copyright</b><br>
The<i>&nbsp;Advanced Bash Scripting Guide</i>&nbsp;is copyright © 2000, by Mendel Cooper. The author also asserts<br>copyright on all previous versions of this document.&nbsp;[152]<br>
This blanket copyright recognizes and protects the rights of all contributors to this document.<br>
This document may only be distributed subject to the terms and conditions set forth in the Open Publication<br><a href="">License (version 1.0 or later), http://www.opencontent.org/openpub/. The following license options also<br></a>apply.<br>
A. &nbsp;Distribution of substantively modified versions of this document<br>
&nbsp; &nbsp; is permitted only under the following provisions.<br>
A1. The modified document must clearly indicate that it is derivative<br>
&nbsp; &nbsp; of the original Advanced Bash Scripting Guide, and the original<br>
&nbsp; &nbsp; author, Mendel Cooper, must be listed as the primary author.<br>
A2. The modified or derivative document must clearly indicate which portions<br>
&nbsp; &nbsp; of the text differ or deviate from the original document. A notice must<br>
&nbsp; &nbsp; be present, stating that the original author does not necessarily<br>
&nbsp; &nbsp; endorse the changes to the original.<br>
A3. The modified or derivative document must be distributed under this<br>
&nbsp; &nbsp; same license, and the original author's copyright, as applicable,<br>
&nbsp; &nbsp; may not be modified.<br>
A4. This License Appendix is invariant, may not be modified, and may not<br>
&nbsp; &nbsp; be omitted from any otherwise modified variants or derivatives of<br>
&nbsp; &nbsp; this document.<br>
B. &nbsp;This document, or any modified or derivative version thereof, may<br>
&nbsp; &nbsp; NOT be distributed encrypted or with any form of DRM (Digital Rights<br>
&nbsp; &nbsp; Management) or content-control mechanism embedded in it. Nor may this<br>
&nbsp; &nbsp; document or any derivative thereof be bundled with other DRM-ed works.<br>
C. &nbsp;If this document (or any previous version or derivative thereof)<br>
&nbsp; &nbsp; is made available on a Web or ftp site, then the file(s) must be<br>
&nbsp; &nbsp; publicly accessible. No password or other access restrictions to<br>
&nbsp; &nbsp; its download may be imposed.<br>
D. &nbsp;Distribution of the original work in any standard (paper) book form<br>
&nbsp; &nbsp; requires permission from the copyright holder.<br>
E. &nbsp;In the event that the author or maintainer of this document cannot<br>
&nbsp; &nbsp; be contacted, the Linux Documentation Project is authorized to<br>
&nbsp; &nbsp; take over custodianship of the document and name a new maintainer,<br>
&nbsp; &nbsp; who would then have the right to update and modify the document.<br>
Without<i>&nbsp;explicit written permission</i>&nbsp;from the author, distributors and publishers (including on-line publishers)<br>are prohibited from imposing any additional conditions, strictures, or provisions on this document, any<br>previous versions, or any derivative versions. As of this update, the author asserts that he has<i>&nbsp;not</i>&nbsp;entered into<br>any contractual obligations that would alter the foregoing declarations.<br>
Essentially, you may freely distribute this book or any derivative thereof in electronic form.<br>
Appendix R. Copyright<br>
834<br>
<hr>
<A name=841></a><IMG src="abs-guide-841_1.png"><br>
Advanced Bash-Scripting Guide<br>
If you display or distribute this document, any previous versions thereof, or any derivatives thereof under any<br>license except the one above, then you are required to obtain the author's written permission. Failure to do so<br>may terminate your distribution rights.<br>
<i>Additionally, the following waiver applies:</i><br>
By copying or distributing this book you WAIVE THE RIGHT<br>
to use the materials within, or any portion thereof, in a patent or copyright<br>
lawsuit against the Open Source community, its developers, its<br>
distributors, or against any of its associated software or documentation<br>
including, but not limited to, the Linux kernel, Open Office, Samba,<br>
and Wine. You further WAIVE THE RIGHT to use any of the materials within<br>
this book in testimony or depositions as a plaintiff's &quot;expert witness&quot; in<br>
any lawsuit against the Open Source community, any of its developers, its<br>
distributors, or any of its associated software or documentation.<br>
These are very liberal terms, and they should not hinder any legitimate distribution or use of this book. The<br>author especially encourages its use for classroom and instructional purposes.<br>
Certain of the scripts contained in this document are, where noted, in the Public Domain. These scripts<br>are exempt from the foregoing license and copyright restrictions.<br>
<a href="mailto:thegrendel.abs@gmail.com">The commercial print and other rights to this book are available. Please contact the author if interested. As of<br></a>this date, August 2011, limited print rights (Lulu edition) have been granted to Steve Glines and to<i>&nbsp;no one<br>else</i>.<br>
<a href="http://www.tldp.org/manifesto.html">The author produced this book in a manner consistent with the spirit of the LDP Manifesto.</a><br>
Linux is a trademark registered to Linus Torvalds.<br>
Fedora is a trademark registered to Red Hat.<br>
Unix and UNIX are trademarks registered to the Open Group.<br>
MS Windows is a trademark registered to the Microsoft Corp.<br>
Solaris is a trademark registered to Oracle, Inc.<br>
OSX is a trademark registered to Apple, Inc.<br>
Yahoo is a trademark registered to Yahoo, Inc.<br>
Pentium is a trademark registered to Intel, Inc.<br>
Thinkpad is a trademark registered to Lenovo, Inc.<br>
Scrabble is a trademark registered to Hasbro, Inc.<br>
Librie, PRS-500, and PRS-505 are trademarks registered to Sony, Inc.<br>
All other commercial trademarks mentioned in the body of this work are registered to their respective<br>owners.<br>
Appendix R. Copyright<br>
835<br>
<hr>
<A name=842></a>Advanced Bash-Scripting Guide<br>
<a href="http://kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/index.html">Hyun Jin Cha has done a Korean translation of version 1.0.11 of this book. Spanish, Portuguese, French,<br></a><a href="http://it.tldp.org/guide/abs/index.html">German, Italian, Russian, Czech, Chinese, Indonesian, Dutch, and Romanian translations are also available or<br></a>in progress. If you wish to translate this document into another language, please feel free to do so, subject to<br>the terms stated above. The author wishes to be notified of such efforts.<br>
For those readers who absolutely insist on making a donation to the author, you may contribute a small<br>amount via Paypal to my e-mail address,&nbsp;<a href="mailto:thegrendel.abs@gmail.com">&lt;thegrendel.abs@gmail.com&gt;</a>. Note that this is<br>emphatically<i>&nbsp;not</i>&nbsp;necessary, or even recommended. This book is a free and freely distributed document for<br>the use and enjoyment of the Linux community.<br>
Appendix R. Copyright<br>
836<br>
<hr>
<A name=843></a><b>Appendix S. ASCII Table</b><br>
<a href="abs-guides.html#882">By tradition, a book of this sort has an ASCII Table appendix. This book does not. Instead, here is a short<br></a>shell script that generates a complete ASCII table and writes it to the file&nbsp;ASCII.txt.<br>
<b>Example S-1. A script that generates an ASCII table</b><br>
#!/bin/bash<br>
# ascii.sh<br>
# ver. 0.2, reldate 26 Aug 2008<br>
# Patched by ABS Guide author.<br>
# Original script by Sebastian Arming.<br>
# Used with permission (thanks!).<br>
exec &gt;ASCII.txt &nbsp; &nbsp; &nbsp; &nbsp; # &nbsp;Save stdout to file,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ as in the example scripts<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #+ reassign-stdout.sh and upperconv.sh.<br>
MAXNUM=256<br>
COLUMNS=5<br>
OCT=8<br>
OCTSQU=64<br>
LITTLESPACE=-3<br>
BIGSPACE=-5<br>
i=1 # Decimal counter<br>
o=1 # Octal counter<br>
while [ &quot;$i&quot; -lt &quot;$MAXNUM&quot; ]; do &nbsp;# We don't have to count past 400 octal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; paddi=&quot; &nbsp; &nbsp;$i&quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot;${paddi: $BIGSPACE} &nbsp;&quot; &nbsp; &nbsp; &nbsp; # Column spacing.<br>
&nbsp; &nbsp; &nbsp; &nbsp; paddo=&quot;00$o&quot;<br>
# &nbsp; &nbsp; &nbsp; echo -ne &quot;\\${paddo: $LITTLESPACE}&quot; &nbsp; # Original.<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -ne &quot;\\0${paddo: $LITTLESPACE}&quot; &nbsp;# Fixup.<br>
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br>
&nbsp; &nbsp; &nbsp; &nbsp; echo -n &quot; &nbsp; &nbsp; &quot;<br>
&nbsp; &nbsp; &nbsp; &nbsp; if (( i % $COLUMNS == 0)); then &nbsp; &nbsp; &nbsp; # New line.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo<br>
&nbsp; &nbsp; &nbsp; &nbsp; fi<br>
&nbsp; &nbsp; &nbsp; &nbsp; ((i++, o++))<br>
&nbsp; &nbsp; &nbsp; &nbsp; # The octal notation for 8 is 10, and 64 decimal is 100 octal.<br>
&nbsp; &nbsp; &nbsp; &nbsp; (( i % $OCT == 0)) &nbsp; &nbsp;&amp;&amp; ((o+=2))<br>
&nbsp; &nbsp; &nbsp; &nbsp; (( i % $OCTSQU == 0)) &amp;&amp; ((o+=20))<br>
done<br>
exit $?<br>
# Compare this script with the &quot;pr-asc.sh&quot; example.<br>
# This one handles &quot;unprintable&quot; characters.<br>
# Exercise:<br>
# Rewrite this script to use decimal numbers, rather than octal.<br>
Appendix S. ASCII Table<br>
837<br>
<hr>
<A name=844></a>Advanced Bash-Scripting Guide<br>
<b>Index</b><br>
This index / glossary / quick-reference lists many of the important topics covered in the text. Terms are<br>arranged in<i>&nbsp;approximate</i>&nbsp;ASCII sorting order,<i>&nbsp;modified as necessary</i>&nbsp;for enhanced clarity.<br>
Note that<i>&nbsp;commands</i><a href="abs-guides.html#178">&nbsp;are indexed in Part 4.</a><br>
* * *<br>
<b>^</b>&nbsp;(caret)<br>
<a href="abs-guides.html#31">Beginning-of-line, in a Regular Expression</a><br>
•&nbsp;<br>
<b>^</b><br>
•&nbsp;<br>
<b>^^</b><br>
<a href="abs-guides.html#553">Uppercase conversion in</a><i>&nbsp;parameter substitution</i><br>
<b>~</b><i>&nbsp;Tilde</i><br>
<b>~</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#30">&nbsp;home directory, corresponds to&nbsp;</a><a href="abs-guides.html#93">$HOME</a><br>
<b>~/</b><br>
•&nbsp;<br>
<a href="abs-guides.html#30"><i>&nbsp;Current user's</i>&nbsp;home directory</a><br>
<b>~+</b><br>
•&nbsp;<br>
<a href="abs-guides.html#31"><i>Current</i>&nbsp;working directory</a><br>
<b>~-</b><br>
•&nbsp;<br>
<a href="abs-guides.html#31"><i>Previous</i>&nbsp;working directory</a><br>
<b>=</b><i>&nbsp;Equals</i>&nbsp;sign<br>
<b>=</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#39">&nbsp;Variable assignment operator</a><br>
<b>=</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#72">&nbsp;String comparison operator</a><br>
<b>==</b><a href="abs-guides.html#72">&nbsp;String comparison operator<br></a><b>=~</b><br>
•&nbsp;<br>
<i>&nbsp;Regular Expression</i><a href="abs-guides.html#547">&nbsp;match operator</a><br>
<a href="abs-guides.html#696"><i>Example script</i></a><br>
<b>&lt;</b>&nbsp;Left angle bracket<br>
Is-less-than<br>
•&nbsp;<br>
<a href="abs-guides.html#72">String comparison</a><br>
<a href="abs-guides.html#71">Integer comparison within double parentheses<br></a>Redirection<br>
•&nbsp;<br>
<b>&lt;&nbsp;</b><a href="abs-guides.html#375">stdin</a><br>
<b>&lt;&lt;&nbsp;</b><a href="abs-guides.html#24"><i>Here document</i></a><br>
<b>&lt;&lt;&lt;&nbsp;</b><a href="abs-guides.html#24"><i>Here string</i></a><br>
Appendix S. ASCII Table<br>
838<br>
<hr>
<A name=845></a>Advanced Bash-Scripting Guide<br>
<b>&lt;&gt;</b><a href="abs-guides.html#23">&nbsp;Opening a file for</a><i>&nbsp;both</i>&nbsp;reading and writing<br>
<b>&gt;</b>&nbsp;Right angle bracket<br>
Is-greater-than<br>
•&nbsp;<br>
<a href="abs-guides.html#73">String comparison</a><br>
<a href="abs-guides.html#72">Integer comparison, within</a><i>&nbsp;double parentheses<br></i>Redirection<br>
•&nbsp;<br>
<b>&gt;</b><a href="abs-guides.html#374">&nbsp;Redirect&nbsp;stdout&nbsp;to a file</a><br>
<b>&gt;&gt;</b><a href="abs-guides.html#374">&nbsp;Redirect&nbsp;stdout&nbsp;to a file, but</a><i>&nbsp;append</i><br>
<b>i&gt;&amp;j</b><a href="abs-guides.html#375">&nbsp;Redirect<i>&nbsp;file descriptor&nbsp;</i>i</a>&nbsp;to<i>&nbsp;file descriptor&nbsp;</i>j<br>
<b>&gt;&amp;j</b><a href="abs-guides.html#375">&nbsp;Redirect&nbsp;stdout&nbsp;to</a><i>&nbsp;file descriptor&nbsp;</i>j<br>
<b>&gt;&amp;2</b><a href="abs-guides.html#23">&nbsp;Redirect&nbsp;stdout</a>&nbsp;of a command to&nbsp;stderr<br>
<b>2&gt;&amp;1</b><a href="abs-guides.html#375">&nbsp;Redirect&nbsp;stderr&nbsp;to&nbsp;</a>stdout<br>
<b>&amp;&gt;</b><a href="abs-guides.html#23">&nbsp;Redirect<i>&nbsp;both&nbsp;</i>stdout&nbsp;and&nbsp;stderr</a>&nbsp;of a command to a file<br>
<b>:&gt;&nbsp;file</b><a href="abs-guides.html#374">&nbsp;Truncate file to zero length</a><br>
<b>|</b><a href="abs-guides.html#24">&nbsp;Pipe, a device for passing the output of a command to another command or to the shell</a><br>
<b>||</b><a href="abs-guides.html#83">&nbsp;Logical OR test operator</a><br>
<b>-</b>&nbsp;(dash)<br>
<a href="abs-guides.html#134">Prefix to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#134"><i>&nbsp;default parameter</i></a>, in<i>&nbsp;parameter substitution</i><br>
<a href="abs-guides.html#26">Prefix to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#26"><i>&nbsp;option flag</i></a><br>
<a href="abs-guides.html#27">Indicating</a><br>
•&nbsp;<br>
<a href="abs-guides.html#27"><i>&nbsp;redirection</i></a>&nbsp;from&nbsp;stdin&nbsp;or&nbsp;stdout<br>
<b>--</b><br>
•&nbsp;&nbsp;&nbsp;(double-dash)<br>
<a href="abs-guides.html#27">Prefix to<i>&nbsp;long</i>&nbsp;command options</a><br>
<a href="abs-guides.html#86"><i>C-style</i>&nbsp;variable decrement within double parentheses</a><br>
<b>;</b>&nbsp;(semicolon)<br>
<a href="abs-guides.html#14">As command separator</a><br>
•&nbsp;<br>
<b>\;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#225"><i>Escaped</i>&nbsp;semicolon, terminates a find command</a><br>
<b>;;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#15">&nbsp;Double-semicolon, terminator in a case option</a><br>
Required when ...<br>
<a href="abs-guides.html#144"><i>do</i>&nbsp;keyword is on the first line of<i>&nbsp;loop</i></a><br>
Appendix S. ASCII Table<br>
839<br>
<hr>
<A name=846></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#491">terminating<i>&nbsp;curly-bracketed</i>&nbsp;code block<br></a><b>;;&amp; ;&amp;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#550">&nbsp;Terminators in a</a><i>&nbsp;case</i><a href="abs-guides.html#549">&nbsp;option (version 4+ of Bash).</a><br>
<b>:</b>&nbsp;Colon<br>
<b>:&gt;&nbsp;</b><br>
•&nbsp;<br>
<b>filename</b><a href="abs-guides.html#374">&nbsp;Truncate file to zero length</a><br>
<a href="abs-guides.html#17"><i>null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#17">&nbsp;command, equivalent to the true Bash builtin</a><br>
<a href="abs-guides.html#367">Used in an anonymous here document</a><br>
•&nbsp;<br>
<a href="abs-guides.html#402">Used as a function name</a><br>
•&nbsp;<br>
<b>!</b><a href="abs-guides.html#18">&nbsp;Negation operator, inverts exit status of a test or command</a><br>
<b>!=</b><br>
•&nbsp;<br>
<a href="abs-guides.html#72">&nbsp;not-equal-to String comparison operator</a><br>
<b>?</b>&nbsp;(question mark)<br>
<a href="abs-guides.html#356">Match zero or one characters, in an &nbsp;Extended Regular Expression</a><br>
•&nbsp;<br>
<a href="abs-guides.html#19">Single-character</a><br>
•&nbsp;<br>
<a href="abs-guides.html#19"><i>&nbsp;wild card</i>, in globbing</a><br>
In a&nbsp;<br>
•&nbsp;<br>
<a href="abs-guides.html#19"><i>C</i>-style Trinary operator</a><br>
<b>//</b><a href="abs-guides.html#197">&nbsp;Double forward slash, behavior of cd command toward</a><br>
<b>.</b>&nbsp;(dot / period)<br>
<b>.</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#15">&nbsp;Load a file (into a script), equivalent to source command</a><br>
<b>.</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#354">&nbsp;Match single character, in a Regular Expression</a><br>
<b>.</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#15">&nbsp;Current working directory</a><br>
<b>./</b><a href="abs-guides.html#96">&nbsp;Current working directory<br></a><b>..</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#15"><i>Parent</i>&nbsp;directory</a><br>
<b>' ... '</b><a href="abs-guides.html#36">&nbsp;(single quotes)&nbsp;<i>strong</i>&nbsp;quoting</a><br>
<b>&quot; ... &quot;</b><a href="abs-guides.html#36">&nbsp;(double quotes)&nbsp;<i>weak</i>&nbsp;quoting</a><br>
<a href="abs-guides.html#883"><i>Double-quoting</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#883">&nbsp;the<i>&nbsp;backslash</i>&nbsp;(<b>\</b>) character</a><br>
<b>,</b><br>
<a href="abs-guides.html#84">Comma operator</a><br>
•&nbsp;<br>
<b>,</b><br>
•&nbsp;<br>
<b>,,</b><br>
<a href="abs-guides.html#553">Lowercase conversion in</a><i>&nbsp;parameter substitution</i><br>
<b>()</b>&nbsp;Parentheses<br>
<b>( ... )</b><br>
•&nbsp;<br>
<a href="abs-guides.html#19">&nbsp;Command group; starts a subshell</a><br>
<b>( ... )</b><br>
•&nbsp;<br>
<a href="abs-guides.html#356">&nbsp;Enclose group of</a><i>&nbsp;Extended Regular Expressions</i><br>
<b>&gt;( ... )</b><br>
•&nbsp;<br>
Appendix S. ASCII Table<br>
840<br>
<hr>
<A name=847></a>Advanced Bash-Scripting Guide<br>
<b>&lt;( ... )</b><a href="abs-guides.html#394">&nbsp;Process substitution<br></a><b>... )</b><br>
•&nbsp;<br>
<a href="abs-guides.html#162">&nbsp;Terminates test-condition in</a><i>&nbsp;case</i>&nbsp;construct<br>
<b>(( ... ))</b><br>
•&nbsp;<br>
<a href="abs-guides.html#86">&nbsp;Double parentheses, in arithmetic expansion</a><br>
<b>[</b><a href="abs-guides.html#22">&nbsp;Left bracket,</a><i>&nbsp;test</i>&nbsp;construct<br>
<b>[ ]</b>Brackets<br>
<a href="abs-guides.html#427"><i>Array</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#427">&nbsp;element</a><br>
<a href="abs-guides.html#355">Enclose character set to match in a</a><br>
•&nbsp;<br>
<i>&nbsp;Regular Expression</i><br>
<a href="abs-guides.html#22"><i>Test</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#22">&nbsp;construct</a><br>
<b>[[ ... ]]</b><a href="abs-guides.html#65">&nbsp;Double brackets, extended</a><i>&nbsp;test</i>&nbsp;construct<br>
<b>$&nbsp;</b><a href="abs-guides.html#354"><i>Anchor</i>, in a Regular Expression</a><br>
<b>$</b><a href="abs-guides.html#36">&nbsp;Prefix to a variable name</a><br>
<b>$( ... )</b><a href="abs-guides.html#40">&nbsp;Command substitution, setting a variable with output of a command, using parentheses notation</a><br>
<b>` ... `</b><a href="abs-guides.html#170">&nbsp;Command substitution, using backquotes notation</a><br>
<b>$[ ... ]</b><a href="abs-guides.html#23">&nbsp;Integer expansion (deprecated)</a><br>
<b>${ ... }</b>&nbsp;Variable manipulation / evaluation<br>
<b>${var}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#133">&nbsp;Value of a variable</a><br>
<b>${#var}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#137">&nbsp;Length of a variable</a><br>
<b>${#@}</b><br>
•&nbsp;<br>
<b>${#*}</b><a href="abs-guides.html#137">&nbsp;Number of<i>&nbsp;positional parameters<br></i></a><b>${parameter?err_msg}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#136">&nbsp;Parameter-unset message</a><br>
<b>${parameter-default}</b><br>
•&nbsp;<br>
<b>${parameter:-default}</b><br>
<b>${parameter=default}</b><br>
<b>${parameter:=default}</b><a href="abs-guides.html#134">&nbsp;Set default parameter<br></a><b>${parameter+alt_value}</b><br>
•&nbsp;<br>
<b>${parameter:+alt_value}</b><br>
<a href="abs-guides.html#135">Alternate value of parameter, if set<br></a><b>${!var}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#459">Indirect referencing of a variable, new notation<br></a><b>${!#}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#43">Final<i>&nbsp;positional parameter</i>. (This is an</a><i>&nbsp;indirect reference</i><a href="abs-guides.html#104">&nbsp;to $#.)<br></a><b>${!varprefix*}</b><br>
•&nbsp;<br>
Appendix S. ASCII Table<br>
841<br>
<hr>
<A name=848></a>Advanced Bash-Scripting Guide<br>
<b>${!varprefix@}</b><br>
<a href="abs-guides.html#142">Match<i>&nbsp;names</i>&nbsp;of all previously declared variables beginning with&nbsp;</a>varprefix<br><b>${string:position}</b><br>
•&nbsp;<br>
<b>${string:position:length}</b><a href="abs-guides.html#126">&nbsp;Substring extraction<br></a><b>${var#Pattern}</b><br>
•&nbsp;<br>
<b>${var##Pattern}</b><a href="abs-guides.html#138">&nbsp;Substring removal<br></a><b>${var%Pattern}</b><br>
•&nbsp;<br>
<b>${var%%Pattern}</b><a href="abs-guides.html#139">&nbsp;Substring removal<br></a><b>${string/substring/replacement}</b><br>
•&nbsp;<br>
<b>${string//substring/replacement}</b><br>
<b>${string/#substring/replacement}</b><br>
<b>${string/%substring/replacement}</b><a href="abs-guides.html#132">&nbsp;Substring replacement</a><br>
<b>$' ... '</b><a href="abs-guides.html#50">&nbsp;String expansion, using</a><i>&nbsp;escaped</i>&nbsp;characters.<br>
<b>\</b><a href="abs-guides.html#49">&nbsp;Escape the character following</a><br>
<b>\&lt; ... \&gt;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#355">&nbsp;Angle brackets,</a><i>&nbsp;escaped</i><a href="abs-guides.html#354">, word boundary in a Regular Expression</a><br>
<b>\{ N \}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#356">&nbsp;&quot;Curly&quot; brackets,</a><i>&nbsp;escaped</i><a href="abs-guides.html#356">, number of character sets to match in an Extended RE</a><br>
<b>\;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#225"><i>Semicolon</i></a>,<i>&nbsp;escaped</i><a href="abs-guides.html#225">, terminates a find command</a><br>
<b>\$$</b><br>
•&nbsp;<br>
<a href="abs-guides.html#456">&nbsp;Indirect reverencing of a variable, old-style notation</a><br>
<a href="abs-guides.html#55">Escaping a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#55"><i>&nbsp;newline</i>, to write a multi-line command</a><br>
<b>&amp;</b><br>
<b>&amp;&gt;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#23">&nbsp;Redirect<i>&nbsp;both&nbsp;</i>stdout&nbsp;and&nbsp;stderr</a>&nbsp;of a command to a file<br>
<b>&gt;&amp;j</b><br>
•&nbsp;<br>
<a href="abs-guides.html#375">&nbsp;Redirect&nbsp;stdout&nbsp;to</a><i>&nbsp;file descriptor j</i><br>
<b>&gt;&amp;2</b><a href="abs-guides.html#23">&nbsp;Redirect&nbsp;stdout</a>&nbsp;of a command to&nbsp;stderr<br><b>i&gt;&amp;j</b><br>
•&nbsp;<br>
<a href="abs-guides.html#375">&nbsp;Redirect<i>&nbsp;file descriptor i</i></a>&nbsp;to<i>&nbsp;file descriptor j</i><br>
<b>2&gt;&amp;1</b><a href="abs-guides.html#375">&nbsp;Redirect&nbsp;stderr&nbsp;to&nbsp;</a>stdout<br><a href="abs-guides.html#376">Closing</a><br>
<a href="abs-guides.html#376">•&nbsp;</a><br>
<a href="abs-guides.html#376"><i>&nbsp;file descriptors</i></a><br>
<b>n&lt;&amp;-</b>&nbsp;Close input file descriptor<i>&nbsp;n</i><br>
<b>0&lt;&amp;-</b>,<b>&nbsp;&lt;&amp;-</b>&nbsp;Close&nbsp;stdin<br>
<b>n&gt;&amp;-</b>&nbsp;Close output file descriptor<i>&nbsp;n</i><br>
<b>1&gt;&amp;-</b>,<b>&nbsp;&gt;&amp;-</b>&nbsp;Close&nbsp;stdout<br><b>&amp;&amp;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#26">&nbsp;Logical AND test operator</a><br>
<b>Command &amp;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#25">&nbsp;Run job in<i>&nbsp;background</i></a><br>
Appendix S. ASCII Table<br>
842<br>
<hr>
<A name=849></a>Advanced Bash-Scripting Guide<br>
<b>#</b><a href="abs-guides.html#14">&nbsp;Hashmark, special symbol beginning a script</a><i>&nbsp;comment</i><br>
<b>#!</b><a href="abs-guides.html#11">&nbsp;Sha-bang, special string starting a shell script</a><br>
<b>*</b>&nbsp;Asterisk<br>
<a href="abs-guides.html#18"><i>Wild card</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#18">, in globbing</a><br>
<a href="abs-guides.html#18">Any number of characters in a Regular Expression</a><br>
•&nbsp;<br>
<b>**</b><br>
•&nbsp;<br>
<a href="abs-guides.html#78">&nbsp;Exponentiation, arithmetic operator</a><br>
<b>**</b><br>
•&nbsp;<br>
&nbsp;Extended<i>&nbsp;globbing</i><a href="abs-guides.html#555">&nbsp;file-match operator</a><br>
<b>%</b>&nbsp;Percent sign<br>
<a href="abs-guides.html#78">Modulo, division-remainder arithmetic operation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#139">Substring removal (pattern matching) operator</a><br>
•&nbsp;<br>
<b>+</b>&nbsp;Plus sign<br>
<a href="abs-guides.html#356"><i>Character match</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#356">, in an extended Regular Expression</a><br>
<a href="abs-guides.html#135">Prefix to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#135"><i>&nbsp;alternate parameter</i></a>, in<i>&nbsp;parameter substitution</i><br>
<b>++</b><br>
•&nbsp;<br>
<a href="abs-guides.html#86"><i>C-style</i>&nbsp;variable increment, within double parentheses</a><br>
* * *<br>
<i>Shell Variables</i><br>
<b>$_</b><a href="abs-guides.html#109">&nbsp;Last argument to previous command</a><br>
<b>$-</b><a href="abs-guides.html#108">&nbsp;Flags passed to script, using set</a><br>
<b>$!&nbsp;</b><a href="abs-guides.html#108"><i>Process ID</i>&nbsp;of last background job</a><br>
<b>$?&nbsp;</b><a href="abs-guides.html#58"><i>Exit status</i>&nbsp;of a command</a><br>
<b>$@</b>&nbsp;All the<i>&nbsp;positional parameters</i><a href="abs-guides.html#104">, as<i>&nbsp;separate</i>&nbsp;words</a><br>
<b>$*</b>&nbsp;All the<i>&nbsp;positional parameters</i><a href="abs-guides.html#104">, as a<i>&nbsp;single</i>&nbsp;word</a><br>
<b>$$</b><a href="abs-guides.html#19">&nbsp;Process ID of the script</a><br>
<b>$#</b><a href="abs-guides.html#104">&nbsp;Number of arguments passed to a function, or to the script itself</a><br>
<b>$0</b><a href="abs-guides.html#42">&nbsp;Filename of the script</a><br>
<b>$1</b><a href="abs-guides.html#42">&nbsp;First argument passed to script</a><br>
<b>$9</b><a href="abs-guides.html#42">&nbsp;Ninth argument passed to script</a><br>
<a href="abs-guides.html#776"><b>Table</b>&nbsp;of</a><i>&nbsp;shell variables</i><br>
* * * * * *<br>
Appendix S. ASCII Table<br>
843<br>
<hr>
<A name=850></a><IMG src="abs-guide-850_1.png"><br>
Advanced Bash-Scripting Guide<br>
<b>-a</b><a href="abs-guides.html#76">&nbsp;Logical AND compound comparison test</a><br>
<a href="abs-guides.html#163">Address database, script example</a><br>
<i>Advanced Bash Scripting Guide</i><a href="abs-guides.html#838">, where to download</a><br>
<a href="abs-guides.html#421">Alias</a><br>
<a href="abs-guides.html#422">Removing an</a><br>
•&nbsp;<br>
<a href="abs-guides.html#422"><i>&nbsp;alias</i></a>, using<i>&nbsp;unalias</i><br>
<a href="abs-guides.html#174">Anagramming</a><br>
<a href="abs-guides.html#424"><i>And</i>&nbsp;list</a><br>
<a href="abs-guides.html#425">To supply default command-line argument</a><br>
•&nbsp;<br>
<a href="abs-guides.html#82"><i>And</i>&nbsp;logical operator<b>&nbsp;&amp;&amp;</b></a><br>
<a href="abs-guides.html#355">Angle brackets,</a><i>&nbsp;escaped</i>,<b>&nbsp;\&lt; . . . \&gt;</b><a href="abs-guides.html#354">&nbsp;word boundary in a Regular Expression</a><br>
<a href="abs-guides.html#367">Anonymous<i>&nbsp;here document</i>, using</a><b>&nbsp;:</b><br>
<a href="abs-guides.html#262">Archiving</a><br>
<a href="abs-guides.html#263">rpm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#262">tar</a><br>
•&nbsp;<br>
<a href="abs-guides.html#176">Arithmetic expansion</a><br>
<a href="abs-guides.html#61"><i>exit status</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#61">&nbsp;of</a><br>
<a href="abs-guides.html#176">variations of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#78">Arithmetic operators</a><br>
<a href="abs-guides.html#80">combination operators,</a><br>
•&nbsp;<br>
<i>&nbsp;C</i>-style<br>
<b>+= -= *= /= %=</b><br>
<a href="abs-guides.html#548">In certain contexts,</a><b>&nbsp;+=</b>&nbsp;can also function as a<i>&nbsp;string concatenation</i>&nbsp;operator.<br>
<a href="abs-guides.html#427">Arrays</a><br>
<a href="abs-guides.html#549">Associative arrays</a><br>
•&nbsp;<br>
<a href="abs-guides.html#427">Bracket notation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#439">Concatenating,</a><br>
•&nbsp;<br>
<i>&nbsp;example script</i><br>
<a href="abs-guides.html#437">Copying</a><br>
•&nbsp;<br>
<a href="abs-guides.html#110">Declaring</a><br>
•&nbsp;<br>
declare -a array_name<br><a href="abs-guides.html#445">Embedded arrays</a><br>
•&nbsp;<br>
Appendix S. ASCII Table<br>
844<br>
<hr>
<A name=851></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#434">Empty arrays, empty elements,</a><br>
•&nbsp;<br>
<i>&nbsp;example script</i><br>
<a href="abs-guides.html#445">Indirect references</a><br>
•&nbsp;<br>
<a href="abs-guides.html#428">Initialization</a><br>
•&nbsp;<br>
array=( element1 element2 ... elementN)<br>
<a href="abs-guides.html#438"><i>Example script</i></a><br>
<a href="abs-guides.html#437">Using command substitution<br>Loading a file into an array</a><br>
•&nbsp;<br>
<a href="abs-guides.html#452">Multidimensional, simulating</a><br>
•&nbsp;<br>
<a href="abs-guides.html#444">Nesting and embedding</a><br>
•&nbsp;<br>
<a href="abs-guides.html#427">Notation and usage</a><br>
•&nbsp;<br>
<a href="abs-guides.html#434">Number of elements in</a><br>
•&nbsp;<br>
${#array_name[@]}<br>
${#array_name[*]}<br><a href="abs-guides.html#429">Operations</a><br>
•&nbsp;<br>
<a href="abs-guides.html#531">Passing an</a><br>
•&nbsp;<br>
<a href="abs-guides.html#531"><i>&nbsp;array</i>&nbsp;to a function</a><br>
As&nbsp;<br>
•&nbsp;<br>
<a href="abs-guides.html#532"><i>&nbsp;return value</i>&nbsp;from a function</a><br>
<a href="abs-guides.html#433">Special properties, example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#430">String operations, example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#433"><i>unset</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#433">&nbsp;deletes array elements</a><br>
<a href="abs-guides.html#192">Arrow keys, detecting</a><br>
ASCII<br>
<a href="abs-guides.html#882">Definition</a><br>
•&nbsp;<br>
<a href="abs-guides.html#843">Script to generate ASCII table</a><br>
•&nbsp;<br>
<a href="abs-guides.html#784">awk field-oriented text processing language</a><br>
<a href="abs-guides.html#123">rand()</a><br>
•&nbsp;<br>
<a href="abs-guides.html#123">, random function</a><br>
<a href="abs-guides.html#132">String manipulation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#207">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#207"><i>&nbsp;export</i></a>&nbsp;to pass a variable to an embedded<i>&nbsp;awk</i>&nbsp;script<br>
* * *<br>
<a href="abs-guides.html#16">Backquotes, used in command substitution</a><br>
<a href="abs-guides.html#299">Base conversion,</a><i>&nbsp;example script</i><br>
<a href="abs-guides.html#8">Bash</a><br>
<a href="abs-guides.html#490">Bad scripting practices</a><br>
•&nbsp;<br>
<a href="abs-guides.html#758">Basics reviewed,</a><br>
•&nbsp;<br>
<i>&nbsp;script example</i><br>
<a href="abs-guides.html#791">Command-line options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#488"><b>Table</b></a><br>
Appendix S. ASCII Table<br>
845<br>
<hr>
<A name=852></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#538">Features that classic</a><br>
•&nbsp;<br>
<a href="abs-guides.html#538"><i>&nbsp;Bourne</i>&nbsp;shell lacks</a><br>
<a href="abs-guides.html#91">Internal variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#541">Version 2</a><br>
•&nbsp;<br>
<a href="abs-guides.html#545">Version 3</a><br>
•&nbsp;<br>
<a href="abs-guides.html#549">Version 4</a><br>
•&nbsp;<br>
<a href="abs-guides.html#556">Version 4.1</a><br>
<a href="abs-guides.html#557">Version 4.2</a><br>
<a href="abs-guides.html#804">.bashrc</a><br>
<a href="abs-guides.html#91">$BASH_SUBSHELL</a><br>
<a href="abs-guides.html#220">Basic commands, external</a><br>
<a href="abs-guides.html#819">Batch files,</a><i>&nbsp;DOS</i><br>
<a href="abs-guides.html#239">Batch processing</a><br>
<a href="abs-guides.html#297">bc, calculator utility</a><br>
<a href="abs-guides.html#300">In a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#300"><i>&nbsp;here document</i></a><br>
<a href="abs-guides.html#297">Template for calculating a script variable</a><br>
•&nbsp;<br>
<a href="abs-guides.html#565">Bibliography</a><br>
<a href="abs-guides.html#262">Bison utility</a><br>
<a href="abs-guides.html#82">Bitwise operators</a><br>
<a href="abs-guides.html#754">Example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#889">Block devices</a><br>
<a href="abs-guides.html#68">testing for</a><br>
•&nbsp;<br>
<a href="abs-guides.html#20">Blocks of code</a><br>
<a href="abs-guides.html#21">Redirection</a><br>
•&nbsp;<br>
<a href="abs-guides.html#21"><i>Script example</i>: redirecting output of a a code block</a><br>
<a href="abs-guides.html#20">Brace expansion</a><br>
<a href="abs-guides.html#20">Extended,&nbsp;</a><br>
•&nbsp;<br>
<i>{a..z}</i><br>
<a href="abs-guides.html#554">With increment and zero-padding (new feature in Bash, version 4)</a><br>
•&nbsp;<br>
Brackets,<b>&nbsp;[ ]</b><br>
<a href="abs-guides.html#427"><i>Array</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#427">&nbsp;element</a><br>
Appendix S. ASCII Table<br>
846<br>
<hr>
<A name=853></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#355">Enclose character set to match in a</a><br>
•&nbsp;<br>
<i>&nbsp;Regular Expression</i><br>
<a href="abs-guides.html#22"><i>Test</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#22">&nbsp;construct</a><br>
Brackets,<i>&nbsp;curly</i>,<b>&nbsp;{}</b>, used in<br>
<a href="abs-guides.html#20">Code block</a><br>
•&nbsp;<br>
<a href="abs-guides.html#226"><i>find</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#356"><i>Extended Regular Expressions</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#42"><i>Positional parameters</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#230"><i>xargs</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#158">break</a><i>&nbsp;loop</i>&nbsp;control command<br>
<a href="abs-guides.html#159">Parameter (optional)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#186">Builtins in</a><i>&nbsp;Bash</i><br>
<a href="abs-guides.html#186">Do not fork a subprocess</a><br>
•&nbsp;<br>
* * *<br>
<a href="abs-guides.html#162"><i>case</i>&nbsp;construct</a><br>
<a href="abs-guides.html#164">Command-line parameters, handling</a><br>
•&nbsp;<br>
<a href="abs-guides.html#165">Globbing, filtering strings with</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">cat, con</a><i>cat</i>entate file(s)<br>
<a href="abs-guides.html#524">Abuse of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#361"><i>cat</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#361">&nbsp;scripts</a><br>
<a href="abs-guides.html#221">Less efficient than redirecting&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">stdin</a><br>
<a href="abs-guides.html#195">Piping the output of, to a read</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">Uses of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#889">Character devices</a><br>
<a href="abs-guides.html#68">testing for</a><br>
•&nbsp;<br>
<a href="abs-guides.html#275">Checksum</a><br>
<a href="abs-guides.html#42">Child processes</a><br>
<a href="abs-guides.html#17">Colon,</a><b>&nbsp;:</b><a href="abs-guides.html#214">&nbsp;, equivalent to the true Bash builtin</a><br>
<a href="abs-guides.html#511">Colorizing scripts</a><br>
<a href="abs-guides.html#750">Cycling through the background colors, example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#516"><b>Table</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#516">&nbsp;of color escape sequences</a><br>
<a href="abs-guides.html#515">Template, colored text on colored background</a><br>
•&nbsp;<br>
<a href="abs-guides.html#84">Comma operator, linking commands or operations</a><br>
Appendix S. ASCII Table<br>
847<br>
<hr>
<A name=854></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#791">Command-line options</a><br>
<a href="abs-guides.html#555">command_not_found_handle ()</a><i>&nbsp;builtin</i><a href="abs-guides.html#549">&nbsp;error-handling function (version 4+ of Bash)</a><br>
<a href="abs-guides.html#170">Command substitution</a><br>
<a href="abs-guides.html#174"><b>$( ... )</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#174">, preferred notation</a><br>
<a href="abs-guides.html#170"><i>Backquotes</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#173">Extending the</a><br>
•&nbsp;<br>
<a href="abs-guides.html#173"><i>&nbsp;Bash</i>&nbsp;toolset</a><br>
<a href="abs-guides.html#170">Invokes a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170"><i>&nbsp;subshell</i></a><br>
<a href="abs-guides.html#174">Nesting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170">Removes trailing newlines</a><br>
•&nbsp;<br>
<a href="abs-guides.html#173">Setting variable from loop output</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170">Word splitting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#528">Comment headers, special purpose</a><br>
Commenting out blocks of code<br>
<a href="abs-guides.html#367">Using an&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#367"><i>anonymous</i>&nbsp;here document</a><br>
<a href="abs-guides.html#529">Using an&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#529"><i>&nbsp;if-then</i>&nbsp;construct</a><br>
<a href="abs-guides.html#280">Communications and hosts</a><br>
<a href="abs-guides.html#76">Compound comparison operators</a><br>
<a href="abs-guides.html#265">Compression utilities</a><br>
<a href="abs-guides.html#265">bzip2</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">compress</a><br>
•&nbsp;<br>
<a href="abs-guides.html#265">gzip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#266">zip</a><br>
•&nbsp;<br>
<a href="abs-guides.html#158">continue loop control command</a><br>
<a href="abs-guides.html#31">Control characters</a><br>
<a href="abs-guides.html#31">Control-C,</a><br>
•&nbsp;<br>
<i>&nbsp;break</i><br>
<a href="abs-guides.html#31">Control-D, terminate / log out / erase</a><br>
•&nbsp;<br>
<a href="abs-guides.html#31">Control-G,&nbsp;</a><br>
•&nbsp;<br>
<b>BEL</b>&nbsp;(<i>beep</i>)<br>
<a href="abs-guides.html#31">Control-H,</a><br>
•&nbsp;<br>
<i>&nbsp;rubout</i><br>
<a href="abs-guides.html#32">Control-J,</a><br>
•&nbsp;<br>
<i>&nbsp;newline</i><br>
<a href="abs-guides.html#32">Control-M, carriage return</a><br>
•&nbsp;<br>
<a href="abs-guides.html#551">Coprocesses</a><br>
<a href="abs-guides.html#338">cron, scheduling</a><i>&nbsp;daemon</i><br>
<a href="abs-guides.html#533"><i>C</i>-style syntax , for handling variables</a><br>
<a href="abs-guides.html#249">Crossword puzzle solver</a><br>
Appendix S. ASCII Table<br>
848<br>
<hr>
<A name=855></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#756">Cryptography</a><br>
Curly brackets {}<br>
<a href="abs-guides.html#226">in</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#226"><i>&nbsp;find</i>&nbsp;command</a><br>
<a href="abs-guides.html#356">in an</a><br>
•&nbsp;<br>
<a href="abs-guides.html#356"><i>&nbsp;Extended Regular Expression</i></a><br>
<a href="abs-guides.html#230">in</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#230"><i>&nbsp;xargs</i></a><br>
* * *<br>
<a href="abs-guides.html#886">Daemons, in UNIX-type OS</a><br>
<a href="abs-guides.html#236">date</a><br>
<a href="abs-guides.html#304">dc, calculator utility</a><br>
<a href="abs-guides.html#313">dd,</a><i>&nbsp;data duplicator</i>&nbsp;command<br>
<a href="abs-guides.html#313">Conversions</a><br>
•&nbsp;<br>
<a href="abs-guides.html#315">Copying raw data to/from devices</a><br>
•&nbsp;<br>
<a href="abs-guides.html#315">File deletion,</a><br>
•&nbsp;<br>
<i>&nbsp;secure</i><br>
<a href="abs-guides.html#314">Keystrokes, capturing</a><br>
•&nbsp;<br>
<a href="abs-guides.html#313">Options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#315">Random access on a data stream</a><br>
•&nbsp;<br>
<a href="abs-guides.html#315">Swapfiles, initializing</a><br>
•&nbsp;<br>
<a href="abs-guides.html#571">Thread on</a><br>
•&nbsp;<br>
<a href="abs-guides.html#571"><i>&nbsp;www.linuxquestions.org</i></a><br>
<a href="abs-guides.html#476">Debugging scripts</a><br>
<a href="abs-guides.html#477">Tools</a><br>
•&nbsp;<br>
<a href="abs-guides.html#479"><i>Trapping</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#479">&nbsp;at exit</a><br>
<a href="abs-guides.html#479"><i>Trapping</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#479">&nbsp;signals</a><br>
<a href="abs-guides.html#84">Decimal number, Bash interprets numbers as</a><br>
<a href="abs-guides.html#110">declare builtin</a><br>
<a href="abs-guides.html#110">options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#553">case-modification options (version 4+ of Bash)</a><br>
<a href="abs-guides.html#135">Default parameters</a><br>
<a href="abs-guides.html#460">/dev</a>&nbsp;directory<br>
<a href="abs-guides.html#472">/dev/null</a><br>
•&nbsp;<br>
&nbsp;pseudo-device file<br>
<a href="abs-guides.html#123">/dev/urandom</a><br>
•&nbsp;<br>
&nbsp;pseudo-device file, generating pseudorandom numbers with<br>
<a href="abs-guides.html#473">/dev/zero</a><br>
•&nbsp;<br>
, pseudo-device file<br>
<a href="abs-guides.html#460">Device file</a><br>
Appendix S. ASCII Table<br>
849<br>
<hr>
<A name=856></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#536"><i>dialog</i></a>, utility for generating<i>&nbsp;dialog</i>&nbsp;boxes in a script<br>
<a href="abs-guides.html#92">$DIRSTACK</a><i>&nbsp;directory stack</i><br>
<a href="abs-guides.html#392">Disabled commands, in</a><i>&nbsp;restricted shells</i><br>
<a href="abs-guides.html#144">do keyword, begins execution of commands within a loop</a><br>
<a href="abs-guides.html#144">done keyword, terminates a loop</a><br>
<a href="abs-guides.html#819"><i>DOS</i>&nbsp;batch files, converting to shell scripts</a><br>
<a href="abs-guides.html#820"><i>DOS</i>&nbsp;commands, UNIX equivalents of (</a><b>table</b>)<br>
<a href="abs-guides.html#886"><i>dot files</i></a>, &quot;hidden&quot; setup and configuration files<br>
<a href="abs-guides.html#65">Double brackets<b>&nbsp;[[ ... ]]</b></a><a href="abs-guides.html#60">&nbsp;test construct</a><br>
<a href="abs-guides.html#65">and evaluation of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#65"><i>&nbsp;octal/hex</i>&nbsp;constants</a><br>
<a href="abs-guides.html#86">Double parentheses</a><b>&nbsp;(( ... ))</b>&nbsp;arithmetic expansion/evaluation construct<br>
<a href="abs-guides.html#36">Double quotes<b>&nbsp;&quot; ... &quot;</b></a><i>&nbsp;weak</i>&nbsp;quoting<br>
<a href="abs-guides.html#883"><i>Double-quoting</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#883">&nbsp;the<i>&nbsp;backslash</i>&nbsp;(<b>\</b>) character</a><br>
<a href="abs-guides.html#783">Double-spacing a text file, using sed</a><br>
* * *<br>
<b>-e</b><a href="abs-guides.html#68">&nbsp;File exists test</a><br>
<a href="abs-guides.html#187">echo</a><br>
<a href="abs-guides.html#187">Feeding commands down a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#187"><i>&nbsp;pipe</i></a><br>
<a href="abs-guides.html#187">Setting a variable using command substitution</a><br>
•&nbsp;<br>
<a href="abs-guides.html#188">/bin/echo</a><br>
•&nbsp;<br>
, external<i>&nbsp;echo</i>&nbsp;command<br>
<a href="abs-guides.html#64">elif, Contraction of</a><i>&nbsp;else</i><a href="abs-guides.html#60">&nbsp;and if</a><br>
<a href="abs-guides.html#63">else</a><br>
<a href="abs-guides.html#278">Encrypting files, using openssl</a><br>
<a href="abs-guides.html#162">esac, keyword terminating</a><i>&nbsp;case</i>&nbsp;construct<br>
<a href="abs-guides.html#41"><i>Environmental</i>&nbsp;variables</a><br>
<a href="abs-guides.html#71">-eq ,</a><i>&nbsp;is-equal-to</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
<a href="abs-guides.html#446">Eratosthenes, Sieve of, algorithm for generating prime numbers</a><br>
Appendix S. ASCII Table<br>
850<br>
<hr>
<A name=857></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#49">Escaped characters, special meanings of</a><br>
<a href="abs-guides.html#50">Within $' ... ' string expansion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#557">Used with</a><br>
•&nbsp;<br>
<a href="abs-guides.html#557"><i>&nbsp;Unicode</i>&nbsp;characters</a><br>
<a href="abs-guides.html#342">/etc/fstab</a>&nbsp;(filesystem mount) file<br>
<a href="abs-guides.html#793">/etc/passwd&nbsp;(user account) file</a><br>
<a href="abs-guides.html#92">$EUID</a>,<i>&nbsp;Effective user ID</i><br>
<a href="abs-guides.html#199">eval, Combine and</a><i>&nbsp;evaluate</i>&nbsp;expression(s), with variable expansion<br>
<a href="abs-guides.html#200">Effects of,</a><br>
•&nbsp;<br>
<i>&nbsp;Example script</i><br>
<a href="abs-guides.html#199">Forces</a><br>
•&nbsp;<br>
<a href="abs-guides.html#199"><i>&nbsp;reevaluation</i>&nbsp;of arguments</a><br>
<a href="abs-guides.html#456">And indirect references</a><br>
•&nbsp;<br>
<a href="abs-guides.html#203">Risk of using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#751">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#751"><i>&nbsp;eval</i>&nbsp;to convert<i>&nbsp;array</i>&nbsp;elements into a command list</a><br>
<a href="abs-guides.html#200">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#200"><i>&nbsp;eval</i>&nbsp;to select among variables</a><br>
<a href="abs-guides.html#65">Evaluation of<i>&nbsp;octal/hex</i>&nbsp;constants within [[ ... ]]</a><br>
<a href="abs-guides.html#377">exec command, using in redirection</a><br>
<a href="abs-guides.html#823">Exercises</a><br>
Exit and Exit status<br>
<a href="abs-guides.html#57">exit command</a><br>
•&nbsp;<br>
<a href="abs-guides.html#57">Exit status (</a><br>
•&nbsp;<br>
<i>exit code</i>,<i>&nbsp;return</i>&nbsp;status of a command)<br>
<a href="abs-guides.html#787"><b>Table</b>,</a><i>&nbsp;Exit codes</i>&nbsp;with special meanings<br>
<a href="abs-guides.html#493">Anomalous</a><br>
<a href="abs-guides.html#890">Out of range</a><br>
<a href="abs-guides.html#58"><i>Pipe</i></a>&nbsp;exit status<br>
<a href="abs-guides.html#406">Specified by a<i>&nbsp;function return</i></a><br>
<a href="abs-guides.html#57"><i>Successful</i>,</a><b>&nbsp;0</b><br>
<a href="abs-guides.html#787">/usr/include/sysexits.h, system file listing C/C++ standard exit codes</a><br>
<a href="abs-guides.html#206">Export, to make available variables to child processes</a><br>
<a href="abs-guides.html#207">Passing a variable to an embedded</a><br>
•&nbsp;<br>
<a href="abs-guides.html#207"><i>&nbsp;awk</i>&nbsp;script</a><br>
<a href="abs-guides.html#232">expr,</a><i>&nbsp;Expression</i>&nbsp;evaluator<br>
Appendix S. ASCII Table<br>
851<br>
<hr>
<A name=858></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#233">Substring extraction</a><br>
•&nbsp;<br>
<a href="abs-guides.html#126">Substring</a><br>
•&nbsp;<br>
<a href="abs-guides.html#126"><i>&nbsp;index</i>&nbsp;(numerical position in string)</a><br>
<a href="abs-guides.html#126">Substring matching</a><br>
•&nbsp;<br>
<a href="abs-guides.html#356">Extended<i>&nbsp;Regular Expressions</i></a><br>
<b>?</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#356">&nbsp;(question mark) Match zero / one characters</a><br>
<b>( ... )</b><br>
•&nbsp;<br>
<a href="abs-guides.html#356">&nbsp;Group of expressions</a><br>
<b>\{ N \}</b><br>
•&nbsp;<br>
<a href="abs-guides.html#356">&nbsp;&quot;Curly&quot; brackets,</a><i>&nbsp;escaped</i>, number of character sets to match<br>
<b>+</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#356"><i>Character match</i></a><br>
* * *<br>
<a href="abs-guides.html#296">factor, decomposes an integer into its prime factors</a><br>
<a href="abs-guides.html#296">Application: Generating prime numbers</a><br>
•&nbsp;<br>
<a href="abs-guides.html#214">false, returns</a><i>&nbsp;unsuccessful</i><a href="abs-guides.html#57">&nbsp;(1) exit status</a><br>
<a href="abs-guides.html#35">Field, a group of characters that comprises an item of data</a><br>
<a href="abs-guides.html#262">Files / Archiving</a><br>
<a href="abs-guides.html#374">File descriptors</a><br>
<a href="abs-guides.html#376">Closing</a><br>
•&nbsp;<br>
<b>n&lt;&amp;-</b>&nbsp;Close input file descriptor<i>&nbsp;n</i><br>
<b>0&lt;&amp;-</b>,<b>&nbsp;&lt;&amp;-</b>&nbsp;Close&nbsp;stdin<br>
<b>n&gt;&amp;-</b>&nbsp;Close output file descriptor<i>&nbsp;n</i><br>
<b>1&gt;&amp;-</b>,<b>&nbsp;&gt;&amp;-</b>&nbsp;Close&nbsp;stdout<br><a href="abs-guides.html#888">File handles in</a><br>
•&nbsp;<br>
<a href="abs-guides.html#888"><i>&nbsp;C</i>, similarity to</a><br>
<a href="abs-guides.html#278">File encryption</a><br>
<a href="abs-guides.html#225">find</a><br>
<b>{}</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#226">&nbsp;Curly brackets</a><br>
<b>\;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#225"><i>Escaped</i>&nbsp;semicolon</a><br>
<a href="abs-guides.html#24">Filter</a><br>
<a href="abs-guides.html#28">Using - with file-processing utility as a filter</a><br>
•&nbsp;<br>
<a href="abs-guides.html#533">Feeding output of a filter back to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#533"><i>&nbsp;same</i>&nbsp;filter</a><br>
<a href="abs-guides.html#81">Floating point numbers, Bash does not recognize</a><br>
<a href="abs-guides.html#258">fold, a filter to wrap lines of text</a><br>
Appendix S. ASCII Table<br>
852<br>
<hr>
<A name=859></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#186">Forking a</a><i>&nbsp;child</i>&nbsp;process<br>
<a href="abs-guides.html#144"><i>for</i>&nbsp;loops</a><br>
<a href="abs-guides.html#399">Functions</a><br>
<a href="abs-guides.html#403">Arguments passed referred to by position</a><br>
•&nbsp;<br>
<a href="abs-guides.html#410">Capturing the return value of a function using echo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#18"><i>Colon</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#18">&nbsp;as function name</a><br>
<a href="abs-guides.html#400">Definition must precede first call to function</a><br>
•&nbsp;<br>
<a href="abs-guides.html#406">Exit status</a><br>
•&nbsp;<br>
<a href="abs-guides.html#413">Local variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#415">and recursion<br></a><a href="abs-guides.html#531">Passing an</a><br>
•&nbsp;<br>
<a href="abs-guides.html#531"><i>&nbsp;array</i>&nbsp;to a function</a><br>
<a href="abs-guides.html#405">Passing pointers to a function</a><br>
•&nbsp;<br>
<a href="abs-guides.html#403">Positional parameters</a><br>
•&nbsp;<br>
<a href="abs-guides.html#415">Recursion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#412">Redirecting&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#412">stdin</a>&nbsp;of a function<br>
<a href="abs-guides.html#407">return</a><br>
•&nbsp;<br>
Multiple<i>&nbsp;return values</i><a href="abs-guides.html#698">&nbsp;from a function, example script</a><br>
<a href="abs-guides.html#532">Returning an<i>&nbsp;array</i></a>&nbsp;from a function<br>
<a href="abs-guides.html#530"><i>Return</i>&nbsp;range limits, workarounds<br></a><a href="abs-guides.html#404"><i>Shift</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#404">&nbsp;arguments passed to a function</a><br>
<a href="abs-guides.html#402">Unusual function names</a><br>
•&nbsp;<br>
* * *<br>
Games and amusements<br>
<a href="abs-guides.html#533">Anagrams</a><br>
•&nbsp;<br>
<a href="abs-guides.html#174">Anagrams, again</a><br>
•&nbsp;<br>
<a href="abs-guides.html#249">Crossword puzzle solver</a><br>
•&nbsp;<br>
<a href="abs-guides.html#257">Crypto-Quotes</a><br>
•&nbsp;<br>
<a href="abs-guides.html#543">Dealing a deck of cards</a><br>
•&nbsp;<br>
<a href="abs-guides.html#737">Fifteen Puzzle</a><br>
•&nbsp;<br>
<a href="abs-guides.html#517">Horse race</a><br>
•&nbsp;<br>
<a href="abs-guides.html#725">Knight's Tour</a><br>
•&nbsp;<br>
<a href="abs-guides.html#583">&quot;Life&quot; game</a><br>
•&nbsp;<br>
<a href="abs-guides.html#735">Magic Squares</a><br>
•&nbsp;<br>
<a href="abs-guides.html#462">Music-playing script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#717">Nim</a><br>
•&nbsp;<br>
<a href="abs-guides.html#115">Pachinko</a><br>
•&nbsp;<br>
<a href="abs-guides.html#709">Perquackey</a><br>
•&nbsp;<br>
<a href="abs-guides.html#706">Petals Around the Rose</a><br>
•&nbsp;<br>
<a href="abs-guides.html#674">Podcasting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#428">Poem</a><br>
•&nbsp;<br>
<a href="abs-guides.html#418">Towers of Hanoi</a><br>
•&nbsp;<br>
Appendix S. ASCII Table<br>
853<br>
<hr>
<A name=860></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#740">Graphic version</a><br>
<a href="abs-guides.html#743">Alternate graphic version</a><br>
<a href="abs-guides.html#309">getopt,</a><i>&nbsp;external</i>&nbsp;command for parsing script<i>&nbsp;command-line</i>&nbsp;arguments<br>
<a href="abs-guides.html#131">Emulated in a script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#208">getopts, Bash</a><i>&nbsp;builtin</i>&nbsp;for parsing script<i>&nbsp;command-line</i>&nbsp;arguments<br>
<a href="abs-guides.html#208">$OPTIND</a><br>
•&nbsp;<br>
<a href="abs-guides.html#208">&nbsp;/&nbsp;$OPTARG</a><br>
<a href="abs-guides.html#389">Global variable</a><br>
<a href="abs-guides.html#358">Globbing, filename expansion</a><br>
<a href="abs-guides.html#18"><i>Wild cards</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#358">Will not match&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#358">dot files</a><br>
<a href="abs-guides.html#305">Golden Ratio (</a><i>Phi</i>)<br>
<a href="abs-guides.html#71">-ge ,</a><i>&nbsp;greater-than or equal</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
<a href="abs-guides.html#71">-gt ,</a><i>&nbsp;greater-than</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
<a href="abs-guides.html#261"><i>groff</i></a>, text markup and formatting language<br>
<a href="abs-guides.html#756">Gronsfeld cipher</a><br>
<a href="abs-guides.html#93">$GROUPS</a>,<i>&nbsp;Groups</i>&nbsp;user belongs to<br>
<a href="abs-guides.html#265">gzip, compression utility</a><br>
* * *<br>
<a href="abs-guides.html#885">Hashing, creating lookup keys in a table</a><br>
<a href="abs-guides.html#614"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#243">head,</a><i>&nbsp;echo</i>&nbsp;to&nbsp;stdout&nbsp;lines at the beginning of a text file<br>
<a href="abs-guides.html#215">help, gives usage summary of a Bash builtin</a><br>
<a href="abs-guides.html#360"><i>Here</i>&nbsp;documents</a><br>
<a href="abs-guides.html#367"><i>Anonymous</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#367">&nbsp;here documents, using</a><b>&nbsp;:</b><br>
<a href="abs-guides.html#367">Commenting out blocks of code</a><br>
<a href="abs-guides.html#368">Self-documenting scripts<br></a><a href="abs-guides.html#300"><i>bc</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#300">&nbsp;in a<i>&nbsp;here document</i></a><br>
Appendix S. ASCII Table<br>
854<br>
<hr>
<A name=861></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#361"><i>cat</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#361">&nbsp;scripts</a><br>
<a href="abs-guides.html#366">Command substitution</a><br>
•&nbsp;<br>
<a href="abs-guides.html#361"><i>ex</i></a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#361">&nbsp;scripts</a><br>
<a href="abs-guides.html#366"><i>Function</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#366">, supplying input to</a><br>
<a href="abs-guides.html#370"><i>Here</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#370">&nbsp;strings</a><br>
<a href="abs-guides.html#305">Calculating the Golden Ratio</a><br>
<a href="abs-guides.html#371">Prepending text</a><br>
<a href="abs-guides.html#371">As the&nbsp;stdin&nbsp;of a<i>&nbsp;loop</i></a><br>
<a href="abs-guides.html#371">Using<i>&nbsp;read<br></i></a><a href="abs-guides.html#360"><i>Limit</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#360">&nbsp;string</a><br>
<a href="abs-guides.html#370">! as a<i>&nbsp;limit string</i></a><br>
<a href="abs-guides.html#369">Closing<i>&nbsp;limit string</i>&nbsp;may not be indented</a><br>
<a href="abs-guides.html#362">Dash option to limit string,&nbsp;</a>&lt;&lt;-LimitString<br><a href="abs-guides.html#365">Literal text output, for generating program code</a><br>
•&nbsp;<br>
<a href="abs-guides.html#363">Parameter substitution</a><br>
•&nbsp;<br>
<a href="abs-guides.html#364">Disabling<i>&nbsp;parameter substitution<br></i></a><a href="abs-guides.html#363">Passing parameters</a><br>
•&nbsp;<br>
<a href="abs-guides.html#369">Temporary files</a><br>
•&nbsp;<br>
<a href="abs-guides.html#360">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#360"><i>&nbsp;vi</i>&nbsp;non-interactively</a><br>
<a href="abs-guides.html#803">History commands</a><br>
<a href="abs-guides.html#93">$HOME</a>,<i>&nbsp;user's home directory</i><br>
<a href="abs-guides.html#724">Homework assignment solver</a><br>
<a href="abs-guides.html#93">$HOSTNAME</a>, system<i>&nbsp;host name</i><br>
* * *<br>
<a href="abs-guides.html#535">$Id&nbsp;parameter, in</a><i>&nbsp;rcs</i>&nbsp;(Revision Control System)<br>
<a href="abs-guides.html#60">if [ condition ]; then ...<i>&nbsp;test</i></a>&nbsp;construct<br>
<a href="abs-guides.html#61">if-grep,</a><br>
•&nbsp;<br>
<i>&nbsp;if</i><a href="abs-guides.html#246">&nbsp;and grep in combination</a><br>
<a href="abs-guides.html#535">Fixup for</a><i>&nbsp;if-grep</i>&nbsp;test<br>
<a href="abs-guides.html#93">$IFS</a>,<i>&nbsp;Internal field separator</i>&nbsp;variable<br>
<a href="abs-guides.html#93">Defaults to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#93"><i>&nbsp;whitespace</i></a><br>
<a href="abs-guides.html#71">Integer comparison operators</a><br>
Appendix S. ASCII Table<br>
855<br>
<hr>
<A name=862></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#144">in,</a><i>&nbsp;keyword</i>&nbsp;preceding&nbsp;[list]&nbsp;in a<i>&nbsp;for</i>&nbsp;loop<br>
<a href="abs-guides.html#338">Initialization table,&nbsp;</a>/etc/inittab<br>
<a href="abs-guides.html#20">Inline group, i.e., code block</a><br>
<a href="abs-guides.html#503">Interactive script, test for</a><br>
<a href="abs-guides.html#374">I/O redirection</a><br>
<a href="abs-guides.html#456">Indirect referencing of variables</a><br>
<a href="abs-guides.html#459">New notation, introduced in version 2 of Bash ( example script)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#341">iptables, packet filtering and firewall utility</a><br>
<a href="abs-guides.html#338">Usage example</a><br>
•&nbsp;<br>
<a href="abs-guides.html#470">Example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#885">Iteration</a><br>
* * *<br>
<a href="abs-guides.html#219">Job IDs, table</a><br>
<a href="abs-guides.html#307">jot, Emit a sequence of integers. Equivalent to seq.</a><br>
<a href="abs-guides.html#309">Random sequence generation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#258">Just another Bash hacker!</a><br>
* * *<br>
<a href="abs-guides.html#187">Keywords</a><br>
<a href="abs-guides.html#217">kill, terminate a process by process ID</a><br>
<a href="abs-guides.html#218">Options (</a><br>
•&nbsp;<br>
-l,&nbsp;-9)<br>
<a href="abs-guides.html#218">killall, terminate a process</a><i>&nbsp;by name</i><br>
<a href="abs-guides.html#350"><i>killall script</i>&nbsp;in&nbsp;</a>/etc/rc.d/init.d<br>
* * *<br>
<a href="abs-guides.html#558">lastpipe shell option</a><br>
<a href="abs-guides.html#71">-le ,</a><i>&nbsp;less-than or equal</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
<a href="abs-guides.html#198">let, setting and carrying out arithmetic operations on variables</a><br>
Appendix S. ASCII Table<br>
856<br>
<hr>
<A name=863></a>Advanced Bash-Scripting Guide<br>
<i>C-style</i><br>
•&nbsp;<br>
<a href="abs-guides.html#198">&nbsp;increment and decrement operators</a><br>
<a href="abs-guides.html#360">Limit string, in a here document</a><br>
<a href="abs-guides.html#96">$LINENO</a>, variable indicating the<i>&nbsp;line number</i>&nbsp;where it appears in a script<br>
<a href="abs-guides.html#224">Link, file (using</a><i>&nbsp;ln</i>&nbsp;command)<br>
<a href="abs-guides.html#225">Invoking script with multiple names, using</a><br>
•&nbsp;<br>
<i>&nbsp;ln</i><br>
<a href="abs-guides.html#224"><i>symbolic</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#224">&nbsp;links,</a><i>&nbsp;ln -s</i><br>
<a href="abs-guides.html#424">List constructs</a><br>
<a href="abs-guides.html#424"><i>And</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#424">&nbsp;list</a><br>
<a href="abs-guides.html#425"><i>Or</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#425">&nbsp;list</a><br>
<a href="abs-guides.html#413">Local variables</a><br>
<a href="abs-guides.html#415">and recursion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#799">Localization</a><br>
<a href="abs-guides.html#82">Logical operators (</a>&amp;&amp;,&nbsp;||, etc.)<br>
<a href="abs-guides.html#793">Logout file, the&nbsp;</a>~/.bash_logout&nbsp;file<br>
<a href="abs-guides.html#342">Loopback device, mounting a file on a block device</a><br>
<a href="abs-guides.html#144">Loops</a><br>
<a href="abs-guides.html#158">break loop control command</a><br>
•&nbsp;<br>
<a href="abs-guides.html#158">continue loop control command</a><br>
•&nbsp;<br>
<i>C</i><br>
•&nbsp;&nbsp;<a href="abs-guides.html#86">-style loop within double parentheses</a><br>
<a href="abs-guides.html#151"><i>for</i>&nbsp;loop</a><br>
<a href="abs-guides.html#154"><i>while</i>&nbsp;loop<br></a><a href="abs-guides.html#144">do (keyword), begins execution of commands within a loop</a><br>
•&nbsp;<br>
<a href="abs-guides.html#144">done (keyword), terminates a loop</a><br>
•&nbsp;<br>
<a href="abs-guides.html#144"><i>for</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#144">&nbsp;loops</a><br>
<i>for&nbsp;</i>arg&nbsp;<i>in&nbsp;</i>[list];&nbsp;<i>do</i><br>
<a href="abs-guides.html#147"><i>Command substitution</i>&nbsp;to generate&nbsp;[list]</a><br>
<a href="abs-guides.html#146">Filename expansion in&nbsp;[list]</a><br>
<a href="abs-guides.html#145">Multiple parameters in each&nbsp;[list]&nbsp;element</a><br>
<a href="abs-guides.html#147">Omitting&nbsp;[list]</a><a href="abs-guides.html#104">, defaults to positional parameters</a><br>
Appendix S. ASCII Table<br>
857<br>
<hr>
<A name=864></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#145">Parameterizing&nbsp;[list]</a><br>
<a href="abs-guides.html#149">Redirection<br></a><a href="abs-guides.html#144">in, (keyword) preceding [list] in a</a><br>
•&nbsp;<br>
<i>&nbsp;for</i>&nbsp;loop<br>
<a href="abs-guides.html#157">Nested loops</a><br>
•&nbsp;<br>
<a href="abs-guides.html#25">Running a loop</a><br>
•&nbsp;<br>
<a href="abs-guides.html#25"><i>&nbsp;in the background</i>,</a><i>&nbsp;script example</i><br>
Semicolon required, when<br>
•&nbsp;<br>
<i>&nbsp;do</i>&nbsp;is on first line of loop<br>
<a href="abs-guides.html#144"><i>for</i>&nbsp;loop</a><br>
<a href="abs-guides.html#153"><i>while</i>&nbsp;loop<br></a><a href="abs-guides.html#156">until loop</a><br>
•&nbsp;<br>
<i>until [ condition-is-true ]; do<br></i><a href="abs-guides.html#153">while loop</a><br>
•&nbsp;<br>
<i>while [ condition ]; do</i><br>
<a href="abs-guides.html#155">Function call inside test brackets</a><br>
<a href="abs-guides.html#154">Multiple conditions</a><br>
<a href="abs-guides.html#156">Omitting<i>&nbsp;test brackets</i></a><br>
<a href="abs-guides.html#156">Redirection</a><br>
<a href="abs-guides.html#156"><i>while read</i>&nbsp;construct<br></a><a href="abs-guides.html#157">Which type of loop to use</a><br>
•&nbsp;<br>
Loopback devices<br>
<a href="abs-guides.html#460">In&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#460">/dev&nbsp;directory</a><br>
<a href="abs-guides.html#342">Mounting an ISO image</a><br>
•&nbsp;<br>
<a href="abs-guides.html#71">-lt ,</a><i>&nbsp;less-than</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
* * *<br>
<a href="abs-guides.html#319">m4, macro processing language</a><br>
<a href="abs-guides.html#96">$MACHTYPE</a>,<i>&nbsp;Machine type</i><br>
<a href="abs-guides.html#11">Magic number, marker at the head of a file indicating the file type</a><br>
<a href="abs-guides.html#280">Makefile, file containing the list of dependencies used by make command</a><br>
<a href="abs-guides.html#225">man,</a><i>&nbsp;manual page</i>&nbsp;(lookup)<br>
<a href="abs-guides.html#704"><i>Man page</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#704">&nbsp;editor (script)</a><br>
<a href="abs-guides.html#553">mapfile builtin, loads an array with a text file</a><br>
Appendix S. ASCII Table<br>
858<br>
<hr>
<A name=865></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#296">Math commands</a><br>
<a href="abs-guides.html#887">Meta-meaning</a><br>
<a href="abs-guides.html#751">Morse code training script</a><br>
<a href="abs-guides.html#78">Modulo, arithmetic</a><i>&nbsp;remainder</i>&nbsp;operator<br>
<a href="abs-guides.html#592">Application: Generating prime numbers</a><br>
•&nbsp;<br>
<a href="abs-guides.html#297">Mortgage calculations,</a><i>&nbsp;example script</i><br>
* * *<br>
<b>-n</b><a href="abs-guides.html#73">&nbsp;String not<i>&nbsp;null</i></a>&nbsp;test<br>
<a href="abs-guides.html#312">Named pipe, a temporary FIFO buffer</a><br>
<a href="abs-guides.html#591"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#329">nc,</a><i>&nbsp;netcat</i>, a network toolkit for TCP and UDP ports<br>
<a href="abs-guides.html#71">-ne,</a><i>&nbsp;not-equal-to</i><a href="abs-guides.html#71">&nbsp;integer comparison test</a><br>
<a href="abs-guides.html#18">Negation operator,</a><b>&nbsp;!</b><a href="abs-guides.html#60">, reverses the sense of a test</a><br>
<a href="abs-guides.html#340">netstat, Network statistics</a><br>
<a href="abs-guides.html#469">Network programming</a><br>
<a href="abs-guides.html#259">nl, a filter to number lines of text</a><br>
<a href="abs-guides.html#488"><i>Noclobber</i></a>,&nbsp;-C&nbsp;option to Bash to prevent overwriting of files<br>
<a href="abs-guides.html#82"><i>NOT</i>&nbsp;logical operator,</a><b>&nbsp;!</b><br>
<a href="abs-guides.html#43"><i>null</i>&nbsp;variable assignment, avoiding</a><br>
* * *<br>
<b>-o</b><a href="abs-guides.html#76">&nbsp;Logical OR compound comparison test</a><br>
Obfuscation<br>
<a href="abs-guides.html#18"><i>Colon</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#18">&nbsp;as function name</a><br>
<a href="abs-guides.html#724">Homework assignment</a><br>
•&nbsp;<br>
<a href="abs-guides.html#258">Just another Bash hacker!</a><br>
•&nbsp;<br>
<a href="abs-guides.html#50">octal, base-8 numbers</a><br>
<a href="abs-guides.html#317">od,</a><i>&nbsp;octal dump</i><br>
Appendix S. ASCII Table<br>
859<br>
<hr>
<A name=866></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#96">$OLDPWD</a>&nbsp;Previous working directory<br>
<a href="abs-guides.html#278">openssl encryption utility</a><br>
Operator<br>
<a href="abs-guides.html#882">Definition of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#87">Precedence</a><br>
•&nbsp;<br>
<a href="abs-guides.html#487">Options, passed to shell or script on command line or by set command</a><br>
<a href="abs-guides.html#425"><i>Or</i>&nbsp;list</a><br>
<a href="abs-guides.html#83"><i>Or</i>&nbsp;logical operator,</a><b>&nbsp;||</b><br>
* * *<br>
<a href="abs-guides.html#133">Parameter substitution</a><br>
<i>${parameter+alt_value}</i><br>
•&nbsp;<br>
<i>${parameter:+alt_value}</i><br>
<a href="abs-guides.html#135">Alternate value of parameter, if set<br></a><i>${parameter-default}</i><br>
•&nbsp;<br>
<i>${parameter:-default}</i><br>
<i>${parameter=default}</i><br>
<i>${parameter:=default}</i><br>
<a href="abs-guides.html#134">Default parameters<br></a><i>${!varprefix*}</i><br>
•&nbsp;<br>
<i>${!varprefix@}</i><br>
<a href="abs-guides.html#142">Parameter<i>&nbsp;name</i>&nbsp;match<br></a><i>${parameter?err_msg}</i><br>
•&nbsp;<br>
<a href="abs-guides.html#136">Parameter-unset message<br></a><i>${parameter}</i><br>
•&nbsp;<br>
<a href="abs-guides.html#133">Value of<i>&nbsp;parameter<br></i></a><a href="abs-guides.html#553"><i>Case modification</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#549">&nbsp;(version 4+ of Bash).</a><br>
<a href="abs-guides.html#591"><i>Script example</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#777"><b>Table</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#777">&nbsp;of</a><i>&nbsp;parameter substitution</i><br>
<a href="abs-guides.html#494">Parent / child process problem, a</a><i>&nbsp;child</i><a href="abs-guides.html#206">&nbsp;process cannot export variables to a parent process</a><br>
Parentheses<br>
Appendix S. ASCII Table<br>
860<br>
<hr>
<A name=867></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#19">Command group</a><br>
•&nbsp;<br>
<a href="abs-guides.html#356">Enclose group of</a><br>
•&nbsp;<br>
<i>&nbsp;Extended Regular Expressions</i><br>
<a href="abs-guides.html#86">Double parentheses, in arithmetic expansion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#96">$PATH</a>, the<i>&nbsp;path</i>&nbsp;(location of system binaries)<br>
Appending directories to&nbsp;<br>
•&nbsp;<br>
$PATH<a href="abs-guides.html#548">&nbsp;using the&nbsp;+=&nbsp;operator.</a><br>
<a href="abs-guides.html#507">Perl, programming language</a><br>
<a href="abs-guides.html#507">Combined in the same file with a</a><br>
•&nbsp;<br>
<i>&nbsp;Bash</i>&nbsp;script<br>
<a href="abs-guides.html#507">Embedded in a</a><br>
•&nbsp;<br>
<i>&nbsp;Bash</i>&nbsp;script<br>
<a href="abs-guides.html#709"><i>Perquackey</i>-type anagramming game (</a><i>Quackey</i>&nbsp;script)<br>
<a href="abs-guides.html#706"><i>Petals Around the Rose</i></a><br>
<a href="abs-guides.html#882">PID,</a><i>&nbsp;Process ID</i>, an identification number assigned to a running process.<br>
<a href="abs-guides.html#24">Pipe,</a><b>&nbsp;|</b>&nbsp;, a device for passing the output of a command to another command or to the shell<br>
<a href="abs-guides.html#524">Avoiding unnecessary commands in a</a><br>
•&nbsp;<br>
<i>&nbsp;pipe</i><br>
<a href="abs-guides.html#14"><i>Comments</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#14">&nbsp;embedded within</a><br>
<a href="abs-guides.html#58">Exit status of a pipe</a><br>
•&nbsp;<br>
<a href="abs-guides.html#547">Pipefail,</a><br>
•&nbsp;<br>
<i>&nbsp;set -o pipefail</i><a href="abs-guides.html#57">&nbsp;option to indicate exit status within a</a><i>&nbsp;pipe</i><br>
<a href="abs-guides.html#96">$PIPESTATUS</a><br>
•&nbsp;<br>
<a href="abs-guides.html#96">,</a><i>&nbsp;exit status</i>&nbsp;of last executed pipe<br>
<a href="abs-guides.html#25">Piping output of a command to a script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">Redirecting&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#221">stdin, rather than using cat in a</a><i>&nbsp;pipe</i><br>
<a href="abs-guides.html#490">Pitfalls</a><br>
<a href="abs-guides.html#493"><b>-</b></a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#493">&nbsp;(dash) is<i>&nbsp;not</i>&nbsp;redirection operator</a><br>
<a href="abs-guides.html#197"><b>//</b></a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#197">&nbsp;(double forward slash), behavior of cd command toward</a><br>
<a href="abs-guides.html#494">#!/bin/sh script header disables extended</a><br>
•&nbsp;<br>
<a href="abs-guides.html#538"><i>&nbsp;Bash</i>&nbsp;features</a><br>
<a href="abs-guides.html#524">Abuse of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#524"><i>&nbsp;cat</i></a><br>
<a href="abs-guides.html#497"><i>CGI</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#497">&nbsp;programming, using scripts for</a><br>
Closing<br>
•&nbsp;<br>
<i>&nbsp;limit string</i>&nbsp;in a<i>&nbsp;here document</i><a href="abs-guides.html#369">, indenting</a><br>
<a href="abs-guides.html#493">DOS-type newlines (\r\n) crash a script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#883"><i>Double-quoting</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#883">&nbsp;the<i>&nbsp;backslash</i>&nbsp;(<b>\</b>) character</a><br>
<a href="abs-guides.html#203">eval, risk of using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#493">Execute permission lacking for commands within a script</a><br>
•&nbsp;<br>
<i>Exit status</i><br>
•&nbsp;<br>
<a href="abs-guides.html#493">, anomalous</a><br>
<i>Exit status</i><br>
•&nbsp;<br>
<a href="abs-guides.html#493">&nbsp;of arithmetic expression<i>&nbsp;not</i>&nbsp;equivalent to an<i>&nbsp;error code</i></a><br>
<a href="abs-guides.html#494"><i>Export</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#494">&nbsp;problem,</a><i>&nbsp;child</i>&nbsp;process to<i>&nbsp;parent</i>&nbsp;process<br>
<a href="abs-guides.html#493">Extended</a><br>
•&nbsp;<br>
<a href="abs-guides.html#493"><i>&nbsp;Bash</i>&nbsp;features not available</a><br>
<a href="abs-guides.html#492">Failing to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#492"><i>&nbsp;quote</i>&nbsp;variables within</a><i>&nbsp;test</i>&nbsp;brackets<br>
<a href="abs-guides.html#498"><i>GNU</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#498">&nbsp;command set, in cross-platform scripts</a><br>
<i>let</i><br>
•&nbsp;<br>
<a href="abs-guides.html#492">&nbsp;misuse: attempting to set string variables</a><br>
<a href="abs-guides.html#494">Multiple echo statements in a function whose output is captured</a><br>
•&nbsp;<br>
<a href="abs-guides.html#43"><i>null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#43">&nbsp;variable assignment</a><br>
<a href="abs-guides.html#491">Numerical and string comparison operators</a><br>
•&nbsp;<br>
<a href="abs-guides.html#491"><i>&nbsp;not</i></a>&nbsp;equivalent<br>
Appendix S. ASCII Table<br>
861<br>
<hr>
<A name=868></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#491"><b>=</b>&nbsp;and<b>&nbsp;-eq</b></a><i>&nbsp;not</i>&nbsp;interchangeable<br><a href="abs-guides.html#491">Omitting terminal</a><br>
•&nbsp;<br>
<a href="abs-guides.html#491"><i>&nbsp;semicolon</i>, in a</a><i>&nbsp;curly-bracketed</i><a href="abs-guides.html#20">&nbsp;code block</a><br>
Piping<br>
•&nbsp;<br>
<a href="abs-guides.html#496"><i>echo</i>&nbsp;to a loop</a><br>
<a href="abs-guides.html#495"><i>echo</i>&nbsp;to<i>&nbsp;read</i>&nbsp;(however, this problem can be circumvented)</a><br>
<a href="abs-guides.html#497"><i>tail&nbsp;</i>-f&nbsp;to<i>&nbsp;grep<br></i></a>Preserving<br>
•&nbsp;<br>
<i>&nbsp;whitespace</i><a href="abs-guides.html#47">&nbsp;within a variable, unintended consequences</a><br>
<a href="abs-guides.html#497"><i>suid</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#497">&nbsp;commands inside a script</a><br>
<a href="abs-guides.html#493">Undocumented</a><br>
•&nbsp;<br>
<a href="abs-guides.html#493"><i>&nbsp;Bash</i>&nbsp;features, danger of</a><br>
<a href="abs-guides.html#491">Uninitialized variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#490">Variable names, inappropriate</a><br>
•&nbsp;<br>
<a href="abs-guides.html#494">Variables in a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#494"><i>&nbsp;subshell</i>,</a><i>&nbsp;scope</i>&nbsp;limited<br>
<a href="abs-guides.html#495">Subshell in</a><br>
•&nbsp;<br>
<a href="abs-guides.html#495"><i>&nbsp;while-read</i>&nbsp;loop</a><br>
<a href="abs-guides.html#490">Whitespace, misuse of</a><br>
•&nbsp;<br>
Pointers<br>
<a href="abs-guides.html#888">and file descriptors</a><br>
•&nbsp;<br>
<a href="abs-guides.html#405">and functions</a><br>
•&nbsp;<br>
<a href="abs-guides.html#457">and</a><br>
•&nbsp;<br>
<a href="abs-guides.html#457"><i>&nbsp;indirect references</i></a><br>
<a href="abs-guides.html#882">and</a><br>
•&nbsp;<br>
<a href="abs-guides.html#882"><i>&nbsp;variables</i></a><br>
<a href="abs-guides.html#538">Portability issues in shell scripting</a><br>
<a href="abs-guides.html#533">Setting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#533"><i>&nbsp;path</i>&nbsp;and<i>&nbsp;umask</i></a><br>
<a href="abs-guides.html#539">A</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#539"><i>&nbsp;test suite</i>&nbsp;script (Bash versus classic Bourne shell)</a><br>
<a href="abs-guides.html#534">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#534"><i>&nbsp;whatis</i></a><br>
<a href="abs-guides.html#42">Positional parameters</a><br>
<a href="abs-guides.html#104">$@</a><br>
•&nbsp;<br>
, as<i>&nbsp;separate</i>&nbsp;words<br>
<a href="abs-guides.html#104">$*</a><br>
•&nbsp;<br>
, as a<i>&nbsp;single</i>&nbsp;word<br>
<a href="abs-guides.html#403">in functions</a><br>
•&nbsp;<br>
<a href="abs-guides.html#881">POSIX,</a><i>&nbsp;Portable Operating System Interface / UNIX</i><br>
<a href="abs-guides.html#538">--posix</a><br>
•&nbsp;<br>
<a href="abs-guides.html#538">&nbsp;option</a><br>
<a href="abs-guides.html#538">1003.2 standard</a><br>
•&nbsp;<br>
<a href="abs-guides.html#357">Character classes</a><br>
•&nbsp;<br>
<a href="abs-guides.html#98">$PPID</a>,<i>&nbsp;process ID</i>&nbsp;of parent process<br>
<a href="abs-guides.html#87">Precedence, operator</a><br>
<a href="abs-guides.html#525"><i>Prepending</i></a>&nbsp;lines at head of a file,<i>&nbsp;script example</i><br>
Prime numbers<br>
Appendix S. ASCII Table<br>
862<br>
<hr>
<A name=869></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#296">Generating primes using the</a><br>
•&nbsp;<br>
<a href="abs-guides.html#296"><i>&nbsp;factor</i>&nbsp;command</a><br>
<a href="abs-guides.html#592">Generating primes using the</a><br>
•&nbsp;<br>
<a href="abs-guides.html#592"><i>&nbsp;modulo</i>&nbsp;operator</a><br>
<a href="abs-guides.html#446">Sieve of Eratosthenes, example script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#188">printf,</a><i>&nbsp;formatted print</i>&nbsp;command<br>
<a href="abs-guides.html#463">/proc</a>&nbsp;directory<br>
<a href="abs-guides.html#465">Running processes, files describing</a><br>
•&nbsp;<br>
<a href="abs-guides.html#468">Writing to files in&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#468">/proc</a>,<i>&nbsp;warning</i><br>
<a href="abs-guides.html#882">Process</a><br>
<a href="abs-guides.html#42">Child process</a><br>
•&nbsp;<br>
<a href="abs-guides.html#186">Parent process</a><br>
•&nbsp;<br>
<a href="abs-guides.html#882">Process ID (PID)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#394">Process substitution</a><br>
<a href="abs-guides.html#395">To compare contents of directories</a><br>
•&nbsp;<br>
<a href="abs-guides.html#395">To supply&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#395">stdin&nbsp;of a command</a><br>
<a href="abs-guides.html#394">Template</a><br>
•&nbsp;<br>
<a href="abs-guides.html#396"><i>while-read</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#396">&nbsp;loop without a<i>&nbsp;subshell</i></a><br>
<a href="abs-guides.html#796">Programmable completion (tab expansion)</a><br>
Prompt<br>
<a href="abs-guides.html#98">$PS1</a><br>
•&nbsp;<br>
,<i>&nbsp;Main prompt</i>, seen at command line<br>
<a href="abs-guides.html#98">$PS2</a><br>
•&nbsp;<br>
, Secondary prompt<br>
<a href="abs-guides.html#525">Pseudo-code, as problem-solving method</a><br>
<a href="abs-guides.html#98">$PWD</a>, Current working directory<br>
* * *<br>
<a href="abs-guides.html#709">Quackey, a</a><i>&nbsp;Perquackey</i>-type anagramming game (script)<br>
Question mark,<b>&nbsp;?</b><br>
<a href="abs-guides.html#356">Character match in an Extended</a><br>
•&nbsp;<br>
<i>&nbsp;Regular Expression</i><br>
<a href="abs-guides.html#19">Single-character</a><br>
•&nbsp;<br>
<a href="abs-guides.html#19"><i>&nbsp;wild card</i>, in globbing</a><br>
In a&nbsp;<br>
•&nbsp;<br>
<a href="abs-guides.html#19"><i>C</i>-style Trinary operator</a><br>
<a href="abs-guides.html#47">Quoting</a><br>
<a href="abs-guides.html#47">Character string</a><br>
•&nbsp;<br>
<a href="abs-guides.html#47">Variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#492">within<i>&nbsp;test</i>&nbsp;brackets</a><br>
Appendix S. ASCII Table<br>
863<br>
<hr>
<A name=870></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#47"><i>Whitespace</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#47">, using</a><i>&nbsp;quoting</i>&nbsp;to preserve<br>
* * *<br>
Random numbers<br>
<a href="abs-guides.html#123">/dev/urandom</a><br>
•&nbsp;<br>
<a href="abs-guides.html#123">rand()</a><br>
•&nbsp;<br>
<a href="abs-guides.html#123">, random function in awk</a><br>
<a href="abs-guides.html#112">$RANDOM</a><br>
•&nbsp;<br>
, Bash function that returns a pseudorandom integer<br>
<a href="abs-guides.html#237">Random sequence generation, using date command</a><br>
•&nbsp;<br>
<a href="abs-guides.html#309">Random sequence generation, using jot</a><br>
•&nbsp;<br>
<a href="abs-guides.html#127">Random string, generating</a><br>
•&nbsp;<br>
<a href="abs-guides.html#535">rcs</a><br>
<a href="abs-guides.html#190">read, set value of a variable from&nbsp;</a><a href="abs-guides.html#788">stdin</a><br>
<a href="abs-guides.html#192">Detecting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#192"><i>&nbsp;arrow</i>&nbsp;keys</a><br>
<a href="abs-guides.html#192">Options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#195">Piping output of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#195"><i>&nbsp;cat</i>&nbsp;to</a><i>&nbsp;read</i><br>
<a href="abs-guides.html#371">&quot;Prepending&quot; text</a><br>
•&nbsp;<br>
<a href="abs-guides.html#495">Problems piping</a><br>
•&nbsp;<br>
<a href="abs-guides.html#495"><i>&nbsp;echo</i>&nbsp;to</a><i>&nbsp;read</i><br>
<a href="abs-guides.html#194">Redirection from a file to</a><br>
•&nbsp;<br>
<i>&nbsp;read</i><br>
<a href="abs-guides.html#99">$REPLY</a><br>
•&nbsp;<br>
<a href="abs-guides.html#99">, default</a><i>&nbsp;read</i>&nbsp;variable<br>
<a href="abs-guides.html#194">Timed input</a><br>
•&nbsp;<br>
<a href="abs-guides.html#156"><i>while read</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#156">&nbsp;construct</a><br>
<a href="abs-guides.html#885">readline library</a><br>
<a href="abs-guides.html#415">Recursion</a><br>
<a href="abs-guides.html#415">Demonstration of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#416">Factorial</a><br>
•&nbsp;<br>
<a href="abs-guides.html#417">Fibonacci sequence</a><br>
•&nbsp;<br>
<a href="abs-guides.html#415">Local variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#509">Script calling itself recursively</a><br>
•&nbsp;<br>
<a href="abs-guides.html#418">Towers of Hanoi</a><br>
•&nbsp;<br>
Redirection<br>
<a href="abs-guides.html#380">Code blocks</a><br>
•&nbsp;<br>
<a href="abs-guides.html#377">exec &lt;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#377">filename,</a><br>
<a href="abs-guides.html#374">to reassign file descriptors<br></a><a href="abs-guides.html#788">Introductory-level explanation of</a><br>
•&nbsp;<br>
<i>&nbsp;I/O redirection</i><br>
<a href="abs-guides.html#375">Open a file for</a><br>
•&nbsp;<br>
<i>&nbsp;both</i>&nbsp;reading and writing<br>
&lt;&gt;filename<br><a href="abs-guides.html#194"><i>read</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#194">&nbsp;input redirected from a file</a><br>
<a href="abs-guides.html#375">stderr</a><br>
•&nbsp;<br>
<a href="abs-guides.html#375">&nbsp;to&nbsp;stdout</a><br>
Appendix S. ASCII Table<br>
864<br>
<hr>
<A name=871></a>Advanced Bash-Scripting Guide<br>
2&gt;&amp;1<br>
<a href="abs-guides.html#27">stdin</a><br>
•&nbsp;<br>
<a href="abs-guides.html#27">&nbsp;/&nbsp;stdout</a>, using<b>&nbsp;-</b><br>
<a href="abs-guides.html#412">stdin</a><br>
•&nbsp;<br>
<a href="abs-guides.html#412">of a<i>&nbsp;function</i></a><br>
<a href="abs-guides.html#374">stdout</a><br>
•&nbsp;<br>
<a href="abs-guides.html#374">&nbsp;to a file</a><br>
<i>&gt;</i>&nbsp;...&nbsp;<i>&gt;&gt;<br></i><a href="abs-guides.html#375">stdout</a><br>
•&nbsp;<br>
<a href="abs-guides.html#375">&nbsp;to<i>&nbsp;file descriptor j</i></a><br>
&gt;&amp;j<br><a href="abs-guides.html#375">file descriptor</a><br>
•&nbsp;<br>
<a href="abs-guides.html#375">i&nbsp;to<i>&nbsp;file descriptor j</i></a><br>
i&gt;&amp;j<br>
<a href="abs-guides.html#23">stdout</a><br>
•&nbsp;<br>
<a href="abs-guides.html#23">&nbsp;of a command to&nbsp;</a>stderr<br>
&gt;&amp;2<br>
<a href="abs-guides.html#23">stdout</a><br>
•&nbsp;<br>
<a href="abs-guides.html#23"><i>&nbsp;and&nbsp;</i>stderr&nbsp;of a command to a file</a><br>
&amp;&gt;<br><a href="abs-guides.html#312">tee, redirect to a file output of command(s) partway through a pipe</a><br>
•&nbsp;<br>
<a href="abs-guides.html#776">Reference Cards</a><br>
<a href="abs-guides.html#779">Miscellaneous constructs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#777">Parameter substitution/expansion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#776">Special shell variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#778">String operations</a><br>
•&nbsp;<br>
Test operators<br>
•&nbsp;<br>
<a href="abs-guides.html#776">Binary comparison</a><br>
<a href="abs-guides.html#777">Files</a><br>
<a href="abs-guides.html#354"><i>Regular Expressions</i></a><br>
<b>^</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#31">&nbsp;(caret) Beginning-of-line</a><br>
<b>$</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#354">&nbsp;(dollar sign)&nbsp;<i>Anchor</i></a><br>
<b>.</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#354">&nbsp;(dot) Match single character</a><br>
<b>*</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#18">&nbsp;(asterisk) Any number of characters</a><br>
<b>[ ]</b><br>
•&nbsp;<br>
<a href="abs-guides.html#355">&nbsp;(brackets) Enclose character set to match</a><br>
<b>\</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#355">&nbsp;(backslash) Escape, interpret following character literally</a><br>
<b>\&lt; ... \&gt;</b><br>
•&nbsp;<br>
&nbsp;(angle brackets,<i>&nbsp;escaped</i><a href="abs-guides.html#355">) Word boundary</a><br>
<a href="abs-guides.html#356">Extended REs</a><br>
•&nbsp;<br>
<b>+&nbsp;</b><a href="abs-guides.html#356"><i>Character match</i></a><br>
<b>\{ \}</b><a href="abs-guides.html#356">&nbsp;Escaped &quot;curly&quot; brackets</a><br>
<b>[: :]</b><a href="abs-guides.html#357">&nbsp;POSIX character classes</a><br>
<a href="abs-guides.html#99">$REPLY, Default value associated with read command</a><br>
Appendix S. ASCII Table<br>
865<br>
<hr>
<A name=872></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#392">Restricted shell, shell (or script) with certain commands disabled</a><br>
<a href="abs-guides.html#407">return, command that terminates a function</a><br>
<a href="abs-guides.html#310">run-parts</a><br>
<a href="abs-guides.html#535">Running scripts in sequence, without user intervention</a><br>
•&nbsp;<br>
* * *<br>
<a href="abs-guides.html#389">Scope of a variable, definition</a><br>
<a href="abs-guides.html#487">Script options, set at command line</a><br>
<a href="abs-guides.html#526">Scripting routines, library of useful definitions and functions</a><br>
<a href="abs-guides.html#98">Secondary prompt,&nbsp;</a><b>$PS2</b><br>
<a href="abs-guides.html#537">Security issues</a><br>
<a href="abs-guides.html#339">nmap,</a><br>
•&nbsp;<br>
<i>&nbsp;network mapper</i>&nbsp;/ port scanner<br>
<a href="abs-guides.html#323">sudo</a><br>
•&nbsp;<br>
<a href="abs-guides.html#497"><i>suid</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#497">&nbsp;commands inside a script</a><br>
<a href="abs-guides.html#537">Viruses, trojans, and worms in scripts</a><br>
•&nbsp;<br>
<a href="abs-guides.html#538">Writing secure scripts</a><br>
•&nbsp;<br>
<a href="abs-guides.html#781">sed, pattern-based programming language</a><br>
<a href="abs-guides.html#781"><b>Table</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#781">, basic operators</a><br>
<a href="abs-guides.html#782"><b>Table</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#782">, examples of operators</a><br>
<a href="abs-guides.html#167">select, construct for menu building</a><br>
<a href="abs-guides.html#168"><b>in&nbsp;</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#168"><i><b>list</b></i>&nbsp;omitted</a><br>
<a href="abs-guides.html#346">Semaphore</a><br>
<a href="abs-guides.html#144">Semicolon required, when do<i>&nbsp;keyword</i>&nbsp;is on first line of loop</a><br>
<a href="abs-guides.html#491">When terminating</a><br>
•&nbsp;<br>
<a href="abs-guides.html#491"><i>&nbsp;curly-bracketed</i>&nbsp;code block</a><br>
<a href="abs-guides.html#307">seq, Emit a sequence of integers. Equivalent to jot.</a><br>
<a href="abs-guides.html#203">set, Change value of internal script variables</a><br>
<a href="abs-guides.html#478">set -u, Abort script with error message if attempting to use an</a><br>
•&nbsp;<br>
<i>&nbsp;undeclared</i>&nbsp;variable.<br>
<a href="">Shell script, definition of</a><br>
<a href="abs-guides.html#503">Shell wrapper, script embedding a command or utility</a><br>
Appendix S. ASCII Table<br>
866<br>
<hr>
<A name=873></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#45">shift, reassigning</a><i>&nbsp;positional parameters</i><br>
<a href="abs-guides.html#100">$SHLVL,</a><i>&nbsp;shell level</i>, depth to which the shell (or script) is nested<br>
<a href="abs-guides.html#213">shopt, change</a><i>&nbsp;shell options</i><br>
<a href="abs-guides.html#479">Signal, a message sent to a process</a><br>
Simulations<br>
<a href="abs-guides.html#115">Brownian motion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#115">Galton board</a><br>
•&nbsp;<br>
<a href="abs-guides.html#517">Horserace</a><br>
•&nbsp;<br>
<a href="abs-guides.html#583"><i>Life</i></a><br>
•&nbsp;<br>
, game of<br>
<a href="abs-guides.html#302">PI, approximating by firing cannonballs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#449">Pushdown</a><br>
•&nbsp;<br>
<a href="abs-guides.html#449"><i>&nbsp;stack</i></a><br>
<a href="abs-guides.html#36">Single quotes (</a><b>' ... '</b>)<i>&nbsp;strong</i><a href="abs-guides.html#47">&nbsp;quoting</a><br>
<a href="abs-guides.html#461">Socket, a communication node associated with an I/O port</a><br>
Sorting<br>
<a href="abs-guides.html#442">Bubble sort</a><br>
•&nbsp;<br>
<a href="abs-guides.html#697">Insertion sort</a><br>
•&nbsp;<br>
<a href="abs-guides.html#210">source, execute a script or, within a script, import a file</a><br>
<a href="abs-guides.html#211">Passing positional parameters</a><br>
•&nbsp;<br>
<i>Spam</i>, dealing with<br>
<a href="abs-guides.html#281"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#282"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#626"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#662"><i>Example script</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#14">Special characters</a><br>
Stack<br>
<a href="abs-guides.html#884">Definition</a><br>
•&nbsp;<br>
Emulating a<br>
•&nbsp;<br>
<i>&nbsp;push-down stack</i><a href="abs-guides.html#449">, example script</a><br>
<a href="abs-guides.html#698">Standard Deviation, example script</a><br>
<a href="abs-guides.html#793">Startup files, Bash</a><br>
<a href="abs-guides.html#788">stdin&nbsp;and&nbsp;stdout</a><br>
<a href="abs-guides.html#721">Stopwatch, example script</a><br>
Appendix S. ASCII Table<br>
867<br>
<hr>
<A name=874></a>Advanced Bash-Scripting Guide<br>
Strings<br>
<b>=~</b><br>
•&nbsp;<br>
<a href="abs-guides.html#547">&nbsp;String match operator</a><br>
<a href="abs-guides.html#72">Comparison</a><br>
•&nbsp;<br>
<a href="abs-guides.html#137">Length</a><br>
•&nbsp;<br>
<i>${#string}<br></i><a href="abs-guides.html#125">Manipulation</a><br>
•&nbsp;<br>
<a href="abs-guides.html#132">Manipulation, using awk</a><br>
•&nbsp;<br>
<a href="abs-guides.html#73"><i>Null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#73">&nbsp;string, testing for</a><br>
<a href="abs-guides.html#622">Protecting strings from expansion and/or reinterpretation,</a><br>
•&nbsp;<br>
<i>&nbsp;script example</i><br>
<a href="abs-guides.html#624"><i>Unprotecting</i>&nbsp;strings,</a><i>&nbsp;script example<br>strchr()</i><br>
•&nbsp;<br>
<a href="abs-guides.html#126">, equivalent of</a><br>
<i>strlen()</i><br>
•&nbsp;<br>
<a href="abs-guides.html#125">, equivalent of</a><br>
<a href="abs-guides.html#270">strings command, find printable strings in a binary or data file</a><br>
•&nbsp;<br>
Substring extraction<br>
•&nbsp;<br>
<a href="abs-guides.html#126">${string:position}</a><br>
<a href="abs-guides.html#126">${string:position:length}</a><br>
<a href="abs-guides.html#233">Using<i>&nbsp;expr<br></i></a><a href="abs-guides.html#126">Substring</a><br>
•&nbsp;<br>
<a href="abs-guides.html#126"><i>&nbsp;index</i>&nbsp;(numerical position in string)</a><br>
<a href="abs-guides.html#128">Substring</a><br>
•&nbsp;<br>
<a href="abs-guides.html#128"><i>&nbsp;matching</i>, using expr</a><br>
<a href="abs-guides.html#137">Substring</a><br>
•&nbsp;<br>
<a href="abs-guides.html#137"><i>&nbsp;removal</i></a><br>
<a href="abs-guides.html#138">${var#Pattern}</a><br>
<a href="abs-guides.html#138">${var##Pattern}</a><br>
<a href="abs-guides.html#139">${var%Pattern}</a><br>
<a href="abs-guides.html#139">${var%%Pattern}<br></a>Substring replacement<br>
•&nbsp;<br>
<a href="abs-guides.html#132">${string/substring/replacement}</a><br>
<a href="abs-guides.html#132">${string//substring/replacement}</a><br>
<a href="abs-guides.html#132">${string/#substring/replacement}</a><br>
<a href="abs-guides.html#132">${string/%substring/replacement}</a><br>
<a href="abs-guides.html#577"><i>Script example<br></i></a><a href="abs-guides.html#778"><b>Table</b></a><br>
•&nbsp;<br>
<a href="abs-guides.html#778">&nbsp;of</a><i>&nbsp;string/substring</i>&nbsp;manipulation and extraction operators<br>
<a href="abs-guides.html#36"><i>Strong</i>&nbsp;quoting<b>&nbsp;' ... '</b></a><br>
<a href="abs-guides.html#499">Stylesheet for writing scripts</a><br>
Appendix S. ASCII Table<br>
868<br>
<hr>
<A name=875></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#387">Subshell</a><br>
<a href="abs-guides.html#387">Command list within parentheses</a><br>
•&nbsp;<br>
<a href="abs-guides.html#389">Variables,&nbsp;</a><br>
•&nbsp;<br>
$BASH_SUBSHELL&nbsp;and&nbsp;$SHLVL<br>
Variables in a<br>
•&nbsp;<br>
<i>&nbsp;subshell</i><br>
<a href="abs-guides.html#494"><i>scope</i>&nbsp;limited, but ...</a><br>
<a href="abs-guides.html#535">... can be accessed outside the subshell?</a><br>
<a href="abs-guides.html#323">su<i>&nbsp;Substitute user</i></a>, log on as a different user or as<i>&nbsp;root</i><br>
<a href="abs-guides.html#69">suid (</a><i>set user id</i>) file flag<br>
<a href="abs-guides.html#497"><i>suid</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#497">&nbsp;commands inside a script, not advisable</a><br>
<a href="abs-guides.html#224">Symbolic links</a><br>
<a href="abs-guides.html#473">Swapfiles</a><br>
* * *<br>
<a href="abs-guides.html#796">Tab completion</a><br>
<a href="abs-guides.html#542">Table lookup, script example</a><br>
<a href="abs-guides.html#245">tail,</a><i>&nbsp;echo</i>&nbsp;to&nbsp;stdout&nbsp;lines at the (tail) end of a text file<br>
<a href="abs-guides.html#262">tar, archiving utility</a><br>
<a href="abs-guides.html#312">tee, redirect to a file output of command(s) partway through a pipe</a><br>
<a href="abs-guides.html#324">Terminals</a><br>
<a href="abs-guides.html#327">setserial</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">setterm</a><br>
•&nbsp;<br>
<a href="abs-guides.html#325">stty</a><br>
•&nbsp;<br>
<a href="abs-guides.html#295">tput</a><br>
•&nbsp;<br>
<a href="abs-guides.html#327">wall</a><br>
•&nbsp;<br>
<i>test</i>&nbsp;command<br>
<a href="abs-guides.html#64">Bash</a><br>
•&nbsp;<br>
<a href="abs-guides.html#64"><i>&nbsp;builtin</i></a><br>
<a href="abs-guides.html#64">external command,&nbsp;</a><br>
•&nbsp;<br>
/usr/bin/test&nbsp;(equivalent to&nbsp;/usr/bin/[)<br>
<a href="abs-guides.html#60">Test constructs</a><br>
Test operators<br>
<b>-a</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#76">&nbsp;Logical AND compound comparison</a><br>
<b>-e</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#68">&nbsp;File exists</a><br>
Appendix S. ASCII Table<br>
869<br>
<hr>
<A name=876></a>Advanced Bash-Scripting Guide<br>
<b>-eq</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;is-equal-to (integer comparison)</a><br>
<b>-f</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#68">&nbsp;File is a<i>&nbsp;regular</i>&nbsp;file</a><br>
<b>-ge</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;greater-than or equal (integer comparison)</a><br>
<b>-gt</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;greater-than (integer comparison)</a><br>
<b>-le</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;less-than or equal (integer comparison)</a><br>
<b>-lt</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;less-than (integer comparison)</a><br>
<b>-n</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#73">&nbsp;not-zero-length (string comparison)</a><br>
<b>-ne</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;not-equal-to (integer comparison)</a><br>
<b>-o</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#76">&nbsp;Logical OR compound comparison</a><br>
<b>-u</b><br>
•&nbsp;<br>
<a href="abs-guides.html#69"><i>suid</i>&nbsp;flag set, file test</a><br>
<b>-z</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#73">&nbsp;is-zero-length (string comparison)</a><br>
<b>=</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#72">&nbsp;is-equal-to (string comparison)</a><br>
<b>==</b><a href="abs-guides.html#72">&nbsp;is-equal-to (string comparison)<br></a><b>&lt;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#72">&nbsp;less-than (string comparison)</a><br>
<b>&lt;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#71">&nbsp;less-than, (integer comparison, within double parentheses)</a><br>
<b>&lt;=</b><br>
•&nbsp;<br>
<a href="abs-guides.html#71">&nbsp;less-than-or-equal, (integer comparison, within</a><i>&nbsp;double parentheses</i>)<br>
<b>&gt;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#73">&nbsp;greater-than (string comparison)</a><br>
<b>&gt;</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#72">&nbsp;greater-than, (integer comparison, within</a><i>&nbsp;double parentheses</i>)<br>
<b>&gt;=</b><br>
•&nbsp;<br>
<a href="abs-guides.html#72">&nbsp;greater-than-or-equal, (integer comparison, within</a><i>&nbsp;double parentheses</i>)<br>
<b>||</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#83">&nbsp;Logical OR</a><br>
<b>&amp;&amp;</b><br>
•&nbsp;<br>
<a href="abs-guides.html#26">&nbsp;Logical AND</a><br>
<b>!</b><br>
•&nbsp;&nbsp;<a href="abs-guides.html#18">&nbsp;Negation operator, inverts exit status of a test</a><br>
<b>!=</b><a href="abs-guides.html#72">&nbsp;not-equal-to (string comparison)<br></a><b>Tables</b><br>
•&nbsp;<br>
&nbsp;of<i>&nbsp;test</i>&nbsp;operators<br>
<a href="abs-guides.html#776">Binary comparison</a><br>
<a href="abs-guides.html#777">File</a><br>
<a href="abs-guides.html#240">Text and text file processing</a><br>
<a href="abs-guides.html#236">Time / Date</a><br>
Timed input<br>
<a href="abs-guides.html#194">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#194"><i>&nbsp;read -t</i></a><br>
<a href="abs-guides.html#101">Using</a><br>
•&nbsp;<br>
<a href="abs-guides.html#101"><i>&nbsp;stty</i></a><br>
<a href="abs-guides.html#100">Using timing loop</a><br>
•&nbsp;<br>
<a href="abs-guides.html#100">Using&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#100">$TMOUT</a><br>
<a href="abs-guides.html#525">Tips and hints for Bash scripts</a><br>
<a href="abs-guides.html#532">Array, as</a><br>
•&nbsp;<br>
<a href="abs-guides.html#532"><i>&nbsp;return value</i>&nbsp;from a function</a><br>
<a href="abs-guides.html#410">Capturing the return value of a function, using</a><br>
•&nbsp;<br>
<i>&nbsp;echo</i><br>
<a href="abs-guides.html#469"><i>CGI</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#469">&nbsp;programming, using scripts for</a><br>
Comment blocks<br>
•&nbsp;<br>
<a href="abs-guides.html#367">Using&nbsp;<i>anonymous here documents</i></a><br>
Appendix S. ASCII Table<br>
870<br>
<hr>
<A name=877></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#529">Using&nbsp;<i>&nbsp;if-then</i>&nbsp;constructs<br></a><a href="abs-guides.html#528">Comment headers, special purpose</a><br>
•&nbsp;<br>
<a href="abs-guides.html#533"><i>C</i></a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#533">-style syntax , for manipulating variables</a><br>
<a href="abs-guides.html#783">Double-spacing a text file</a><br>
•&nbsp;<br>
<a href="abs-guides.html#222">Filenames prefixed with a dash, removing</a><br>
•&nbsp;<br>
<a href="abs-guides.html#533">Filter, feeding output back to</a><br>
•&nbsp;<br>
<i>&nbsp;same</i>&nbsp;filter<br>
<a href="abs-guides.html#530">Function</a><br>
•&nbsp;<br>
<a href="abs-guides.html#530"><i>&nbsp;return</i>&nbsp;value workarounds</a><br>
<a href="abs-guides.html#535"><i>if-grep</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#535">&nbsp;test fixup</a><br>
<a href="abs-guides.html#526">Library of useful definitions and</a><br>
•&nbsp;<br>
<i>&nbsp;functions</i><br>
<a href="abs-guides.html#43"><i>null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#43">&nbsp;variable assignment, avoiding</a><br>
<a href="abs-guides.html#531">Passing an</a><br>
•&nbsp;<br>
<a href="abs-guides.html#531"><i>&nbsp;array</i>&nbsp;to a function</a><br>
$PATH<br>
•&nbsp;<br>
<a href="abs-guides.html#548">, appending to, using the&nbsp;+=&nbsp;operator.</a><br>
<a href="abs-guides.html#525"><i>Prepending</i></a><br>
•&nbsp;<br>
&nbsp;lines at head of a file<br>
<a href="abs-guides.html#528">Progress bar template</a><br>
•&nbsp;<br>
<a href="abs-guides.html#525">Pseudo-code</a><br>
•&nbsp;<br>
<a href="abs-guides.html#535">rcs</a><br>
•&nbsp;<br>
<a href="abs-guides.html#23">Redirecting a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#23"><i>&nbsp;test</i>&nbsp;to&nbsp;/dev/null</a>&nbsp;to suppress output<br>
<a href="abs-guides.html#535">Running scripts in sequence without user intervention, using run-parts</a><br>
•&nbsp;<br>
<a href="abs-guides.html#526">Script as embedded command</a><br>
•&nbsp;<br>
Script<br>
•&nbsp;<br>
<i>&nbsp;portability</i><br>
<a href="abs-guides.html#533">Setting<i>&nbsp;path</i>&nbsp;and<i>&nbsp;umask</i></a><br>
<a href="abs-guides.html#534">Using<i>&nbsp;whatis<br></i></a><a href="abs-guides.html#526">Setting script variable to a block of embedded</a><br>
•&nbsp;<br>
<i>&nbsp;sed</i>&nbsp;or<i>&nbsp;awk</i>&nbsp;code<br>
<a href="abs-guides.html#535">Subshell variable, accessing outside the subshell</a><br>
•&nbsp;<br>
<a href="abs-guides.html#529">Testing a variable to see if it contains only digits</a><br>
•&nbsp;<br>
<a href="abs-guides.html#23">Testing whether a command exists, using type</a><br>
•&nbsp;<br>
<a href="abs-guides.html#525">Tracking script usage</a><br>
•&nbsp;<br>
<a href="abs-guides.html#396"><i>while-read</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#396">&nbsp;loop without a<i>&nbsp;subshell</i></a><br>
<a href="abs-guides.html#535">Widgets, invoking from a script</a><br>
•&nbsp;<br>
<a href="abs-guides.html#100">$TMOUT, Timeout interval</a><br>
<a href="abs-guides.html#883">Token, a symbol that may expand to a keyword or command</a><br>
<a href="abs-guides.html#295">tput, terminal-control command</a><br>
<a href="abs-guides.html#254">tr, character translation filter</a><br>
<a href="abs-guides.html#256">DOS to Unix text file conversion</a><br>
•&nbsp;<br>
<a href="abs-guides.html#255">Options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#580">Soundex,</a><br>
•&nbsp;<br>
<i>&nbsp;example script</i><br>
<a href="abs-guides.html#258">Variants</a><br>
•&nbsp;<br>
<a href="abs-guides.html#479"><i>Trap</i>, specifying an action upon receipt of a signal</a><br>
<i>Trinary</i>&nbsp;operator,<i>&nbsp;C</i>-style,&nbsp;<b>var&gt;10?88:99</b><br>
<a href="abs-guides.html#19">in</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#19"><i>&nbsp;double-parentheses</i>&nbsp;construct</a><br>
<a href="abs-guides.html#198">in</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#198"><i>&nbsp;let</i>&nbsp;construct</a><br>
Appendix S. ASCII Table<br>
871<br>
<hr>
<A name=878></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#214">true, returns</a><i>&nbsp;successful</i><a href="abs-guides.html#57">&nbsp;(0) exit status</a><br>
<a href="abs-guides.html#110">typeset builtin</a><br>
<a href="abs-guides.html#110">options</a><br>
•&nbsp;<br>
* * *<br>
<a href="abs-guides.html#103">$UID</a>, User ID number<br>
<a href="abs-guides.html#422">unalias, to remove an alias</a><br>
<a href="abs-guides.html#328">uname, output system information</a><br>
<a href="abs-guides.html#557">Unicode, encoding standard for representing letters and symbols</a><br>
<a href="abs-guides.html#491">Uninitialized variables</a><br>
<a href="abs-guides.html#240">uniq, filter to remove duplicate lines from a sorted file</a><br>
<a href="abs-guides.html#206">unset, delete a shell variable</a><br>
<a href="abs-guides.html#156">until loop</a><br>
<i>until [ condition-is-true ]; do</i><br>
* * *<br>
<i>Variables</i><br>
<a href="abs-guides.html#428">Array operations on</a><br>
•&nbsp;<br>
<a href="abs-guides.html#78">Assignment</a><br>
•&nbsp;<br>
<a href="abs-guides.html#39"><i>Script example</i></a><br>
<a href="abs-guides.html#39"><i>Script example</i></a><br>
<a href="abs-guides.html#36"><i>Script example<br></i></a><a href="abs-guides.html#91"><i>Bash</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#91">&nbsp;internal variables</a><br>
<a href="abs-guides.html#526">Block of</a><br>
•&nbsp;<br>
<a href="abs-guides.html#526"><i>&nbsp;sed</i>&nbsp;or<i>&nbsp;awk</i>&nbsp;code, setting a variable to</a><br>
<i>C-style</i><br>
•&nbsp;<br>
<a href="abs-guides.html#86">&nbsp; increment/decrement/trinary operations</a><br>
<a href="abs-guides.html#203">Change value of internal script variables using</a><br>
•&nbsp;<br>
<i>&nbsp;set</i><br>
<a href="abs-guides.html#110">declare, to modify the properties of variables</a><br>
•&nbsp;<br>
<a href="abs-guides.html#206">Deleting a shell variable using</a><br>
•&nbsp;<br>
<i>&nbsp;unset</i><br>
<a href="abs-guides.html#41">Environmental</a><br>
•&nbsp;<br>
<a href="abs-guides.html#140">Expansion / Substring replacement operators</a><br>
•&nbsp;<br>
<a href="abs-guides.html#456">Indirect referencing</a><br>
•&nbsp;<br>
<i>eval variable1=\$$variable2</i><br>
<a href="abs-guides.html#459">Newer notation</a><br>
Appendix S. ASCII Table<br>
872<br>
<hr>
<A name=879></a>Advanced Bash-Scripting Guide<br>
<i>${!variable}<br></i><a href="abs-guides.html#81">Integer</a><br>
•&nbsp;<br>
<a href="abs-guides.html#40">Integer / string (variables are untyped)</a><br>
•&nbsp;<br>
<a href="abs-guides.html#137">Length</a><br>
•&nbsp;<br>
<i>${#var}<br></i><a href="abs-guides.html#882">Lvalue</a><br>
•&nbsp;<br>
<a href="abs-guides.html#133">Manipulating and expanding</a><br>
•&nbsp;<br>
<a href="abs-guides.html#36"><i>Name</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#36">&nbsp;and<i>&nbsp;value</i>&nbsp;of a variable, distinguishing between</a><br>
<a href="abs-guides.html#73"><i>Null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#73">&nbsp;string, testing for</a><br>
<a href="abs-guides.html#43"><i>Null</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#43">&nbsp;variable assignment, avoiding</a><br>
<a href="abs-guides.html#47">Quoting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#492">within<i>&nbsp;test</i>&nbsp;brackets</a><br>
<a href="abs-guides.html#47">to preserve<i>&nbsp;whitespace<br></i></a><a href="abs-guides.html#882">rvalue</a><br>
•&nbsp;<br>
<a href="abs-guides.html#36">Setting to</a><br>
•&nbsp;<br>
<a href="abs-guides.html#36"><i>&nbsp;null</i>&nbsp;value</a><br>
<a href="abs-guides.html#388">In</a><br>
•&nbsp;&nbsp;<a href="abs-guides.html#388"><i>&nbsp;subshell</i>&nbsp;not visible to parent shell</a><br>
<a href="abs-guides.html#529">Testing a variable &nbsp;if it contains only digits</a><br>
•&nbsp;<br>
<a href="abs-guides.html#884">Typing, restricting the properties of a variable</a><br>
•&nbsp;<br>
<a href="abs-guides.html#478">Undeclared, error message</a><br>
•&nbsp;<br>
<a href="abs-guides.html#38">Uninitialized</a><br>
•&nbsp;<br>
<a href="abs-guides.html#47">Unquoted variable,</a><br>
•&nbsp;<br>
<i>&nbsp;splitting</i><br>
<a href="abs-guides.html#206">Unsetting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#40">Untyped</a><br>
•&nbsp;<br>
* * *<br>
<a href="abs-guides.html#216">wait, suspend script execution</a><br>
<a href="abs-guides.html#216">To remedy script hang</a><br>
•&nbsp;<br>
<a href="abs-guides.html#36"><i>Weak</i>&nbsp;quoting<b>&nbsp;&quot; ... &quot;</b></a><br>
<a href="abs-guides.html#153">while loop</a><br>
<i>while [ condition ]; do</i><br>
<a href="abs-guides.html#154">C-style syntax</a><br>
•&nbsp;<br>
<a href="abs-guides.html#155">Calling a</a><br>
•&nbsp;<br>
<a href="abs-guides.html#155"><i>&nbsp;function</i>&nbsp;within<i>&nbsp;test</i>&nbsp;brackets</a><br>
<a href="abs-guides.html#154">Multiple conditions</a><br>
•&nbsp;<br>
<a href="abs-guides.html#156">Omitting</a><br>
•&nbsp;<br>
<a href="abs-guides.html#156"><i>&nbsp;test</i>&nbsp;brackets</a><br>
<a href="abs-guides.html#156"><i>while read</i></a><br>
•&nbsp;<br>
<a href="abs-guides.html#156">&nbsp;construct</a><br>
<a href="abs-guides.html#396">Avoiding a<i>&nbsp;subshell</i></a><br>
<a href="abs-guides.html#34">Whitespace, spaces, tabs, and newline characters</a><br>
<a href="abs-guides.html#93">$IFS</a><br>
•&nbsp;<br>
<a href="abs-guides.html#93">&nbsp;defaults to</a><br>
<a href="abs-guides.html#490">Inappropriate use of</a><br>
•&nbsp;<br>
Appendix S. ASCII Table<br>
873<br>
<hr>
<A name=880></a>Advanced Bash-Scripting Guide<br>
<a href="abs-guides.html#369">Preceding closing</a><br>
•&nbsp;<br>
<a href="abs-guides.html#369"><i>&nbsp;limit string</i>&nbsp;in a</a><i>&nbsp;here document</i>, error<br>
<a href="abs-guides.html#14">Preceding script comments</a><br>
•&nbsp;<br>
<a href="abs-guides.html#47"><i>Quoting</i></a><br>
•&nbsp;<br>
, to preserve<i>&nbsp;whitespace</i>&nbsp;within strings or variables<br>
<a href="abs-guides.html#357">[:space:],</a><br>
•&nbsp;<br>
<i>&nbsp;POSIX</i>&nbsp;character class<br>
<a href="abs-guides.html#322">who, information about logged on users</a><br>
<a href="abs-guides.html#322">w</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">whoami</a><br>
•&nbsp;<br>
<a href="abs-guides.html#322">logname</a><br>
•&nbsp;<br>
<a href="abs-guides.html#535">Widgets</a><br>
<a href="abs-guides.html#887">Wild card characters</a><br>
<a href="abs-guides.html#18">Asterisk *</a><br>
•&nbsp;<br>
In &nbsp;<br>
•&nbsp;<br>
<a href="abs-guides.html#146"><i>[list]</i>&nbsp;constructs</a><br>
<a href="abs-guides.html#19">Question mark ?</a><br>
•&nbsp;<br>
<a href="abs-guides.html#358">Will not match&nbsp;</a><br>
•&nbsp;<br>
<a href="abs-guides.html#358">dot files</a><br>
Word splitting<br>
<a href="abs-guides.html#883">Definition</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170">Resulting from</a><br>
•&nbsp;<br>
<a href="abs-guides.html#170"><i>&nbsp;command substitution</i></a><br>
<a href="abs-guides.html#503">Wrapper, shell</a><br>
* * *<br>
<a href="abs-guides.html#228">xargs, Filter for grouping arguments</a><br>
<a href="abs-guides.html#230">Curly brackets</a><br>
•&nbsp;<br>
<a href="abs-guides.html#229">Limiting arguments passed</a><br>
•&nbsp;<br>
<a href="abs-guides.html#229">Options</a><br>
•&nbsp;<br>
<a href="abs-guides.html#229">Processes arguments one at a time</a><br>
•&nbsp;<br>
<a href="abs-guides.html#229">Whitespace, handling</a><br>
•&nbsp;<br>
* * *<br>
<a href="abs-guides.html#311">yes</a><br>
<a href="abs-guides.html#311">Emulation</a><br>
•&nbsp;<br>
* * *<br>
<b>-z</b><a href="abs-guides.html#73">&nbsp;String is<i>&nbsp;null</i></a><br>
<a href="abs-guides.html#218"><i>Zombie</i></a><a href="abs-guides.html#217">, a process that has terminated, but not yet been killed by its parent</a><br>
Appendix S. ASCII Table<br>
874<br>
<hr>
<A name=881></a>Advanced Bash-Scripting Guide<br>
<b>Notes</b><br>
[1]<br>
<a href="abs-guides.html#186">These are referred to as builtins, features internal to the shell.</a><br>
[2]<br>
<a href="abs-guides.html#415">Although recursion<i>&nbsp;is</i>&nbsp;possible in a shell script, it tends to be slow and its implementation is often an<br></a><a href="abs-guides.html#417">ugly kludge.</a><br>
[3]<br>
An<i>&nbsp;acronym</i>&nbsp;is a word formed by pasting together the initial letters of the words in a tongue-tripping<br>phrase. This is a harmful and subversive practice that surely deserves severe punishment.<br>
[4]<br>
Many of the features of<i>&nbsp;ksh88</i>, and even a few from the updated<i>&nbsp;ksh93</i>&nbsp;have been merged into Bash.<br>
[5]<br>
By convention, user-written shell scripts that are Bourne shell compliant generally take a name with a<br>.sh&nbsp;extension. System scripts, such as those found in&nbsp;/etc/rc.d, do not conform to this<br>nomenclature.<br>
[6]<br>
More commonly seen in the literature as<i>&nbsp;she-bang</i>&nbsp;or<i>&nbsp;sh-bang</i>. This derives from the concatenation of<br>the tokens<i>&nbsp;sharp</i>&nbsp;(#) and<i>&nbsp;bang</i>&nbsp;(!).<br>
[7]<br>
Some flavors of UNIX (those based on 4.2 BSD) allegedly take a four-byte magic number, requiring a<br>blank after the ! --&nbsp;<b>#! /bin/sh</b><a href="http://www.in-ulm.de/~mascheck/various/shebang/#details">. &nbsp;According to Sven Mascheck this is probably a myth.</a><br>
[8]<br>
The #! line in a shell script will be the first thing the command interpreter (<b>sh</b>&nbsp;or<b>&nbsp;bash</b>) sees. Since this<br>line begins with a #, it will be correctly interpreted as a comment when the command interpreter finally<br>executes the script. The line has already served its purpose - calling the command interpreter.<br>
If, in fact, the script includes an<i>&nbsp;extra</i>&nbsp;#! line, then<b>&nbsp;bash</b>&nbsp;will interpret it as a comment.<br>
#!/bin/bash<br>
echo &quot;Part 1 of script.&quot;<br>
a=1<br>
#!/bin/bash<br>
# This does *not* launch a new script.<br>
echo &quot;Part 2 of script.&quot;<br>
echo $a &nbsp;# Value of $a stays at 1.<br>
[9]<br>
This allows some cute tricks.<br>
#!/bin/rm<br>
# Self-deleting script.<br>
# Nothing much seems to happen when you run this... except that the file disappears.<br>
WHATEVER=85<br>
echo &quot;This line will never print (betcha!).&quot;<br>
exit $WHATEVER &nbsp;# Doesn't matter. The script will not exit here.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Try an echo $? after script termination.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # You'll get a 0, not a 85.<br>
Also, try starting a&nbsp;README&nbsp;file with a&nbsp;<b>#!/bin/more</b>, and making it executable. The result is a<br><a href="abs-guides.html#360">self-listing documentation file. (A here document using cat is possibly a better alternative -- see<br></a><a href="abs-guides.html#362">Example 19-3).</a><br>
[10]&nbsp;<b>P</b>ortable<b>&nbsp;O</b>perating<b>&nbsp;S</b>ystem<i>&nbsp;I</i>nterface, an attempt to standardize UNI<b>X</b>-like OSes. The POSIX<br>
<a href="http://www.opengroup.org/onlinepubs/007904975/toc.htm">specifications are listed on the Open Group site.</a><br>
[11]&nbsp;<a href="abs-guides.html#349">To avoid this possibility, a script may begin with a #!/bin/env bash</a><i>&nbsp;sha-bang</i>&nbsp;line. This may be useful<br>
on UNIX machines where<i>&nbsp;bash</i>&nbsp;is not located in&nbsp;/bin<br>
Appendix S. ASCII Table<br>
875<br>
<hr>
<A name=882></a>Advanced Bash-Scripting Guide<br>
[12]&nbsp;If<i>&nbsp;Bash</i>&nbsp;is your default shell, then the #! isn't necessary at the beginning of a script. However, if<br>
launching a script from a different shell, such as<i>&nbsp;tcsh</i>, then you<i>&nbsp;will</i>&nbsp;need the #!.<br>
[13]&nbsp;Caution: invoking a<i>&nbsp;Bash</i>&nbsp;script by&nbsp;<b>sh scriptname</b>&nbsp;turns off Bash-specific extensions, and the<br>
script may therefore fail to execute.<br>
[14]&nbsp;A script needs<i>&nbsp;read</i>, as well as execute permission for it to run, since the shell needs to be able to read<br>
it.<br>
[15]&nbsp;Why not simply invoke the script with&nbsp;<b>scriptname</b><a href="abs-guides.html#98">? If the directory you are in ($PWD) is where</a><br>
scriptname&nbsp;is located, why doesn't this work? This fails because, for security reasons, the current<br>directory (./<a href="abs-guides.html#96">) is not by default included in a user's $PATH. It is therefore necessary to explicitly<br></a>invoke the script in the current directory with a&nbsp;<b>./scriptname</b>.<br>
[16]&nbsp;An<i>&nbsp;operator</i>&nbsp;is an agent that carries out an<i>&nbsp;operation</i><a href="abs-guides.html#78">. Some examples are the common arithmetic</a><br>
<a href="abs-guides.html#78">operators,</a><b>&nbsp;+ - * /</b>. In Bash, there is some overlap between the concepts of<i>&nbsp;operator</i><a href="abs-guides.html#187">&nbsp;and keyword.</a><br>
[17]<br>
<b>A</b>merican<b>&nbsp;S</b>tandard<b>&nbsp;C</b>ode for<b>&nbsp;I</b>nformation<b>&nbsp;I</b>nterchange. This is a system for encoding text characters<br>(alphabetic, numeric, and a limited set of symbols) as 7-bit numbers that can be stored and manipulated<br>by computers. Many of the ASCII characters are represented on a standard keyboard.<br>
[18]<br>
A<i>&nbsp;PID</i>, or<i>&nbsp;process ID</i>, is a number assigned to a running process. The<i>&nbsp;PID</i>s of running processes may<br><a href="abs-guides.html#335">be viewed with a ps command.</a><br>
<b>Definition:</b>&nbsp;A<i>&nbsp;process</i>&nbsp;is a currently executing command (or program), sometimes referred to as a<br><i>job</i>.<br>
[19]&nbsp;The shell does the<i>&nbsp;brace expansion</i>. The command itself acts upon the<i>&nbsp;result</i>&nbsp;of the expansion.<br>
[20]&nbsp;Exception: a code block in braces as part of a pipe<i>&nbsp;may</i><a href="abs-guides.html#387">&nbsp;run as a subshell.</a><br>
ls | { read firstline; read secondline; }<br>
# &nbsp;Error. The code block in braces runs as a subshell,<br>
#+ so the output of &quot;ls&quot; cannot be passed to variables within the block.<br>
echo &quot;First line is $firstline; second line is $secondline&quot; &nbsp;# Won't work.<br>
# Thanks, S.C.<br>
[21]&nbsp;Even as in olden times a<i>&nbsp;philtre</i>&nbsp;denoted a potion alleged to have magical transformative powers, so<br>
does a UNIX<i>&nbsp;filter</i>&nbsp;transform its target in (roughly) analogous fashion. (The coder who comes up with a<br>&quot;love philtre&quot; that runs on a Linux machine will likely win accolades and honors.)<br>
[22]&nbsp;Bash stores a list of commands previously issued from the command-line in a<i>&nbsp;buffer</i>, or memory space,<br>
<a href="abs-guides.html#186">for recall with the builtin</a><i>&nbsp;history</i>&nbsp;commands.<br>
[23]&nbsp;A linefeed (<i>newline</i>) is also a whitespace character. This explains why a<i>&nbsp;blank line</i>, consisting only of a<br>
linefeed, is considered whitespace.<br>
[24]&nbsp;Technically, the<i>&nbsp;name</i>&nbsp;of a variable is called an<i>&nbsp;lvalue</i>, meaning that it appears on the<i>&nbsp;left</i>&nbsp;side of an<br>
assignment statment, as in&nbsp;<b>VARIABLE=23</b>. A variable's<i>&nbsp;value</i>&nbsp;is an<i>&nbsp;rvalue</i>, meaning that it appears on<br>the<i>&nbsp;right</i>&nbsp;side of an assignment statement, as in&nbsp;<b>VAR2=$VARIABLE</b>.<br>
A variable's<i>&nbsp;name</i>&nbsp;is, in fact, a<i>&nbsp;reference</i>, a<i>&nbsp;pointer</i>&nbsp;to the memory location(s) where the actual data<br>associated with that variable is kept.<br>
[25]&nbsp;Note that&nbsp;<a href="abs-guides.html#403"><i>functions</i>&nbsp;also take positional parameters.</a><br>
[26]&nbsp;The process calling the script sets the&nbsp;$0&nbsp;parameter. By convention, this parameter is the name of the<br>
<a href="abs-guides.html#225">script. See the manpage (manual page) for</a><b>&nbsp;execv</b>.<br>
Appendix S. ASCII Table<br>
876<br>
<hr>
<A name=883></a>Advanced Bash-Scripting Guide<br>
From the<i>&nbsp;command-line</i>, however,&nbsp;$0&nbsp;is the name of the shell.<br>
bash$&nbsp;<b>echo $0<br></b>bash<br>
tcsh%&nbsp;<b>echo $0<br></b>tcsh<br>
[27]&nbsp;<a href="abs-guides.html#210">If the the script is sourced or symlinked, then this will not work. It is safer to check $BASH_Source.</a><br>
[28]&nbsp;Unless there is a file named&nbsp;first&nbsp;in the current working directory. Yet another reason to<i>&nbsp;quote</i>.<br>
(Thank you, Harald Koenig, for pointing this out.<br>
[29]<br>
Encapsulating &quot;!&quot; within double quotes gives an error when used<i>&nbsp;from the command line</i>. This is<br><a href="abs-guides.html#803">interpreted as a history command. Within a script, though, this problem does not occur, since the Bash<br></a>history mechanism is disabled then.<br>
Of more concern is the<i>&nbsp;apparently</i>&nbsp;inconsistent behavior of&nbsp;<i>\</i>&nbsp;within double quotes, and especially<br>following an<b>&nbsp;echo -e</b>&nbsp;command.<br>
bash$&nbsp;<b>echo hello\!<br></b>hello!<br>
bash$&nbsp;<b>echo &quot;hello\!&quot;<br></b>hello\!<br>
bash$&nbsp;<b>echo \<br></b>&gt;<br>
bash$&nbsp;<b>echo &quot;\&quot;<br></b>&gt;<br>
bash$&nbsp;<b>echo \a<br></b>a<br>
bash$&nbsp;<b>echo &quot;\a&quot;<br></b>\a<br>
bash$&nbsp;<b>echo x\ty<br></b>xty<br>
bash$&nbsp;<b>echo &quot;x\ty&quot;<br></b>x\ty<br>
bash$&nbsp;<b>echo -e x\ty<br></b>xty<br>
bash$&nbsp;<b>echo -e &quot;x\ty&quot;<br></b>x &nbsp; &nbsp; &nbsp; y<br>
Double quotes following an<i>&nbsp;echo sometimes</i>&nbsp;escape&nbsp;<i>\</i>. Moreover, the&nbsp;-e&nbsp;option to<i>&nbsp;echo</i>&nbsp;causes the &quot;\t&quot;<br>to be interpreted as a<i>&nbsp;tab</i>.<br>
(Thank you, Wayne Pollock, for pointing this out, and Geoff Lee and Daniel Barclay for explaining it.)<br>
[30]&nbsp;&quot;Word splitting,&quot; in this context, means dividing a character string into separate and discrete<br>
arguments.<br>
[31]&nbsp;<a href="abs-guides.html#407">In those instances when there is no return terminating the function.</a><br>
[32]&nbsp;A<i>&nbsp;token</i><a href="abs-guides.html#887">&nbsp;is a symbol or short string with a special meaning attached to it (a meta-meaning). In Bash,</a><br>
certain tokens, such as<b>&nbsp;[</b><a href="abs-guides.html#15">&nbsp;and . (dot-command), may expand to</a><i>&nbsp;keywords</i>&nbsp;and commands.<br>
[33]&nbsp;Per the 1913 edition of<i>&nbsp;Webster's Dictionary</i>:<br>
Appendix S. ASCII Table<br>
877<br>
<hr>
<A name=884></a>Advanced Bash-Scripting Guide<br>
Deprecate<br>
...<br>
To pray against, as an evil;<br>
to seek to avert by prayer;<br>
to desire the removal of;<br>
to seek deliverance from;<br>
to express deep regret for;<br>
to disapprove of strongly.<br>
[34]&nbsp;Be aware that<i>&nbsp;suid</i>&nbsp;binaries may open security holes. The<i>&nbsp;suid</i>&nbsp;flag has no effect on shell scripts.<br>
[35]&nbsp;On Linux systems, the sticky bit is no longer used for files, only on directories.<br>
[36]&nbsp;As S.C. points out, in a compound test, even quoting the string variable might not suffice.&nbsp;<b>[ -n</b><br>
<b>&quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</b>&nbsp;may cause an error with some versions of Bash if&nbsp;$string&nbsp;is<br>empty. The safe way is to append an extra character to possibly empty variables,&nbsp;<b>[ &quot;x$string&quot; !=<br>x -o &quot;x$a&quot; = &quot;x$b&quot; ]</b>&nbsp;(the &quot;x's&quot; cancel out).<br>
[37]&nbsp;In a different context,<b>&nbsp;+=</b>&nbsp;can serve as a<i>&nbsp;string concatenation</i><a href="abs-guides.html#548">&nbsp;operator. This can be useful for modifying</a><br>
<a href="abs-guides.html#548"><i>environmental variables</i></a>.<br>
[38]&nbsp;<i>Side effects</i>&nbsp;are, of course, unintended -- and usually undesirable -- consequences.<br>
[39]&nbsp;<i>Precedence</i>, in this context, has approximately the same meaning as<i>&nbsp;priority</i><br>
[40]&nbsp;A<i>&nbsp;stack register</i>&nbsp;is a set of consecutive memory locations, such that the values stored (<i>pushed</i>) are<br>
retrieved (<i>popped</i>) in<i>&nbsp;reverse</i>&nbsp;order. The last value stored is the first retrieved. This is sometimes called<br>a&nbsp;<i>LIFO</i>&nbsp;(<i>last-in-first-out</i>) or<i>&nbsp;pushdown</i>&nbsp;stack.<br>
[41]&nbsp;The PID of the currently running script is&nbsp;$$, of course.<br>
[42]&nbsp;<a href="abs-guides.html#415">Somewhat analogous to recursion, in this context</a><i>&nbsp;nesting</i>&nbsp;refers to a pattern embedded within a larger<br>
pattern. One of the definitions of<i>&nbsp;nest</i>, according to the 1913 edition of<i>&nbsp;Webster's Dictionary</i>, illustrates<br>this beautifully: &quot;<i>A collection of boxes, cases, or the like, of graduated size, each put within the one<br>next larger.</i>&quot;<br>
[43]&nbsp;The words &quot;argument&quot; and &quot;parameter&quot; are often used interchangeably. In the context of this document,<br>
they have the same precise meaning:<i>&nbsp;a variable passed to a script or function.</i><br>
[44]&nbsp;Within a script, inside a subshell,&nbsp;$$<a href="abs-guides.html#91">&nbsp;returns the PID of the script, not the subshell.</a><br>
[45]&nbsp;In this context,<i>&nbsp;typing</i>&nbsp;a variable means to classify it and restrict its properties. For example, a variable<br>
<i>declared</i>&nbsp;or<i>&nbsp;typed</i><a href="abs-guides.html#778">&nbsp;as an integer is no longer available for string operations.</a><br>
declare -i intvar<br>
intvar=23<br>
echo &quot;$intvar&quot; &nbsp; # 23<br>
intvar=stringval<br>
echo &quot;$intvar&quot; &nbsp; # 0<br>
[46]&nbsp;True &quot;randomness,&quot; insofar as it exists at all, can only be found in certain incompletely understood<br>
natural phenomena, such as radioactive decay. Computers only<i>&nbsp;simulate</i>&nbsp;randomness, and<br>computer-generated sequences of &quot;random&quot; numbers are therefore referred to as<i>&nbsp;pseudorandom</i>.<br>
[47]&nbsp;The<i>&nbsp;seed</i>&nbsp;of a computer-generated pseudorandom number series can be considered an identification<br>
label. For example, think of the pseudorandom series with a seed of<i>&nbsp;23</i>&nbsp;as&nbsp;<i>Series #23</i>.<br>
A property of a pseurandom number series is the length of the cycle before it starts repeating itself. A<br>good pseurandom generator will produce series with very long cycles.<br>
[48]&nbsp;<a href="abs-guides.html#399">This applies to either command-line arguments or parameters passed to a function.</a><br>
[49]<br>
Appendix S. ASCII Table<br>
878<br>
<hr>
<A name=885></a>Advanced Bash-Scripting Guide<br>
Note that&nbsp;<i>$substring</i>&nbsp;and&nbsp;<i>$replacement</i>&nbsp;may refer to either<i>&nbsp;literal strings</i>&nbsp;or<i>&nbsp;variables</i>,<br>depending on context. See the first usage example.<br>
[50]&nbsp;<a href="abs-guides.html#787">If $parameter is null in a non-interactive script, it will terminate with a 127 exit status (the Bash error</a><br>
code for &quot;command not found&quot;).<br>
[51]&nbsp;<i>Iteration</i>: Repeated execution of a command or group of commands, usually -- but not always,<i>&nbsp;while</i>&nbsp;a<br>
given condition holds, or<i>&nbsp;until</i>&nbsp;a given condition is met.<br>
[52]&nbsp;<a href="abs-guides.html#186">These are shell builtins, whereas other loop commands, such as while and case, are keywords.</a><br>
[53]&nbsp;Pattern-match lines may also<i>&nbsp;start</i>&nbsp;with a<b>&nbsp;(</b>&nbsp;left paren to give the layout a more structured appearance.<br>
case $( arch ) in &nbsp; # $( arch ) returns machine architecture.<br>
&nbsp; ( i386 ) echo &quot;80386-based machine&quot;;;<br>
# ^ &nbsp; &nbsp; &nbsp;^<br>
&nbsp; ( i486 ) echo &quot;80486-based machine&quot;;;<br>
&nbsp; ( i586 ) echo &quot;Pentium-based machine&quot;;;<br>
&nbsp; ( i686 ) echo &quot;Pentium2+-based machine&quot;;;<br>
&nbsp; ( &nbsp; &nbsp;* ) echo &quot;Other type of machine&quot;;;<br>
esac<br>
[54]&nbsp;For purposes of<i>&nbsp;command substitution</i>, a<b>&nbsp;command</b>&nbsp;may be an external system command, an internal<br>
<a href="abs-guides.html#186">scripting builtin, or even a script function.</a><br>
[55]&nbsp;In a more technically correct sense,<i>&nbsp;command substitution</i>&nbsp;extracts the&nbsp;stdout&nbsp;of a command, then<br>
assigns it to a variable using the = operator.<br>
[56]&nbsp;In fact, nesting with backticks is also possible, but only by escaping the inner backticks, as John<br>
Default points out.<br>
word_count=` wc -w \`echo * | awk '{print $8}'\` `<br>
[57]&nbsp;As Nathan Coulter points out, &quot;while forking a process is a low-cost operation, executing a new<br>
program in the newly-forked child process adds more overhead.&quot;<br>
[58]&nbsp;<a href="abs-guides.html#238">An exception to this is the time command, listed in the official Bash documentation as a keyword</a><br>
(&quot;reserved word&quot;).<br>
[59]&nbsp;Note that<i>&nbsp;let</i><a href="abs-guides.html#492">&nbsp;cannot be used for setting<i>&nbsp;string</i>&nbsp;variables.</a><br>
[60]&nbsp;To<i>&nbsp;Export</i><a href="abs-guides.html#389">&nbsp;information is to make it available in a more general context. See also scope.</a><br>
[61]&nbsp;An<i>&nbsp;option</i>&nbsp;is an argument that acts as a flag, switching script behaviors on or off. The argument<br>
associated with a particular option indicates the behavior that the option (flag) switches on or off.<br>
[62]&nbsp;Technically, an<b>&nbsp;exit</b>&nbsp;only terminates the process (or shell) in which it is running,<i>&nbsp;not</i>&nbsp;the<i>&nbsp;parent process</i>.<br>
[63]&nbsp;Unless the<b>&nbsp;exec</b><a href="abs-guides.html#377">&nbsp;is used to reassign file descriptors.</a><br>
[64]<br>
<i>Hashing</i>&nbsp;is a method of creating lookup keys for data stored in a table. The<i>&nbsp;data items themselves</i>&nbsp;are<br>&quot;scrambled&quot; to create keys, using one of a number of simple mathematical<i>&nbsp;algorithms</i>&nbsp;(methods, or<br>recipes).<br>
An advantage of<i>&nbsp;hashing</i>&nbsp;is that it is fast. A disadvantage is that<i>&nbsp;collisions</i>&nbsp;-- where a single key maps to<br>more than one data item -- are possible.<br>
<a href="abs-guides.html#609">For examples of hashing see Example A-20 and Example A-21.</a><br>
[65]&nbsp;The<i>&nbsp;readline</i>&nbsp;library is what Bash uses for reading input in an interactive shell.<br>
[66]&nbsp;This only applies to<i>&nbsp;child processes</i>, of course.<br>
[67]&nbsp;The C source for a number of loadable builtins is typically found in the<br>
/usr/share/doc/bash-?.??/functions&nbsp;directory.<br>
Appendix S. ASCII Table<br>
879<br>
<hr>
<A name=886></a>Advanced Bash-Scripting Guide<br>
Note that the&nbsp;-f&nbsp;option to<b>&nbsp;enable</b><a href="abs-guides.html#538">&nbsp;is not portable to all systems.</a><br>
[68]&nbsp;The same effect as<b>&nbsp;autoload</b><a href="abs-guides.html#110">&nbsp;can be achieved with typeset -fu.</a><br>
[69]<br>
<i>Dotfiles</i>&nbsp;are files whose names begin with a<i>&nbsp;dot</i>, such as&nbsp;~/.Xdefaults. Such filenames do not<br>appear in a normal<b>&nbsp;ls</b>&nbsp;listing (although an<b>&nbsp;ls -a</b>&nbsp;will show them), and they cannot be deleted by an<br>accidental<b>&nbsp;rm -rf *</b>. Dotfiles are generally used as setup and configuration files in a user's home<br>directory.<br>
[70]&nbsp;This particular feature may not yet be implemented in the version of the ext2/ext3 filesystem installed<br>
on your system. Check the documentation for your Linux distro.<br>
[71]&nbsp;And even when<i>&nbsp;xargs</i>&nbsp;is not strictly necessary, it can speed up execution of a command involving<br>
<a href="abs-guides.html#239">batch-processing of multiple files.</a><br>
[72]&nbsp;This is only true of the GNU version of<b>&nbsp;tr</b>, not the generic version often found on commercial UNIX<br>
systems.<br>
[73]&nbsp;An<i>&nbsp;archive</i>, in the sense discussed here, is simply a set of related files stored in a single location.<br>
[74]&nbsp;A&nbsp;<i>tar czvf ArchiveName.tar.gz *&nbsp;will</i>&nbsp;include dotfiles in subdirectories<i>&nbsp;below</i>&nbsp;the current<br>
working directory. This is an undocumented GNU<b>&nbsp;tar</b>&nbsp;&quot;feature.&quot;<br>
[75]&nbsp;The checksum may be expressed as a<i>&nbsp;hexadecimal</i>&nbsp;number, or to some other base.<br>
[76]&nbsp;For even<i>&nbsp;better</i>&nbsp;security, use the<i>&nbsp;sha256sum</i>,<i>&nbsp;sha512</i>, and<i>&nbsp;sha1pass</i>&nbsp;commands.<br>
[77]&nbsp;This is a symmetric block cipher, used to encrypt files on a single system or local network, as opposed<br>
to the<i>&nbsp;public key</i>&nbsp;cipher class, of which<i>&nbsp;pgp</i>&nbsp;is a well-known example.<br>
[78]&nbsp;Creates a temporary<i>&nbsp;directory</i>&nbsp;when invoked with the&nbsp;-d&nbsp;option.<br>
[79]<br>
A<i>&nbsp;daemon</i>&nbsp;is a background process not attached to a terminal session. Daemons perform designated<br>services either at specified times or explicitly triggered by certain events.<br>
The word &quot;daemon&quot; means ghost in Greek, and there is certainly something mysterious, almost<br>supernatural, about the way UNIX daemons wander about behind the scenes, silently carrying out their<br>appointed tasks.<br>
[80]&nbsp;This is actually a script adapted from the Debian Linux distribution.<br>
[81]&nbsp;The<i>&nbsp;print queue</i>&nbsp;is the group of jobs &quot;waiting in line&quot; to be printed.<br>
[82]&nbsp;<a href="http://www2.linuxjournal.com/lj-issues/issue41/2156.html">For an excellent overview of this topic, see Andy Vaught's article, Introduction to Named Pipes, in the</a><br>
<a href="http://www.linuxjournal.com">September, 1997 issue of&nbsp;<i>Linux Journal</i></a>.<br>
[83]&nbsp;EBCDIC (pronounced &quot;ebb-sid-ick&quot;) is an acronym for Extended Binary Coded Decimal Interchange<br>
Code, an obsolete IBM data format. A bizarre application of the&nbsp;conv=ebcdic&nbsp;option of<b>&nbsp;dd</b>&nbsp;is as a<br>quick 'n easy, but not very secure text file encoder.<br>
cat $file | dd conv=swab,ebcdic &gt; $file_encrypted<br>
# Encode (looks like gibberish). &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
# Might as well switch bytes (swab), too, for a little extra obscurity.<br>
cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext<br>
# Decode.<br>
[84]&nbsp;A<i>&nbsp;macro</i>&nbsp;is a symbolic constant that expands into a command string or a set of operations on<br>
parameters. Simply put, it's a shortcut or abbreviation.<br>
[85]&nbsp;This is the case on a Linux machine or a UNIX system with disk quotas.<br>
[86]&nbsp;The<b>&nbsp;userdel</b>&nbsp;command will fail if the particular user being deleted is still logged on.<br>
[87]<br>
Appendix S. ASCII Table<br>
880<br>
<hr>
<A name=887></a>Advanced Bash-Scripting Guide<br>
<a href="http://www2.linuxjournal.com/lj-issues/issue66/3335.html">For more detail on burning CDRs, see Alex Withers' article, Creating CDs, in the October, 1999 issue<br></a><a href="http://www.linuxjournal.com">of&nbsp;<i>Linux Journal</i></a>.<br>
[88]&nbsp;The&nbsp;-c<a href="abs-guides.html#343">&nbsp;option to mke2fs also invokes a check for bad blocks.</a><br>
[89]&nbsp;Since only<i>&nbsp;root</i>&nbsp;has write permission in the&nbsp;/var/lock&nbsp;directory, a user script cannot set a lock file<br>
there.<br>
[90]&nbsp;Operators of single-user Linux systems generally prefer something simpler for backups, such as<b>&nbsp;tar</b>.<br>
[91]&nbsp;<a href="abs-guides.html#549">As of the version 4 update of Bash, the&nbsp;</a>-f&nbsp;and&nbsp;-c<a href="abs-guides.html#881">&nbsp;options take a block size of 512 when in POSIX</a><br>
mode. Additionally, there are two new options:&nbsp;-b<a href="abs-guides.html#461">&nbsp;for socket buffer size, and&nbsp;</a>-T&nbsp;for the limit on the<br>number of<i>&nbsp;threads</i>.<br>
[92]&nbsp;NAND is the logical<i>&nbsp;not-and</i>&nbsp;operator. Its effect is somewhat similar to subtraction.<br>
[93]&nbsp;In Bash and other Bourne shell derivatives, it is possible to set variables in a single command's<br>
environment.<br>
var1=value1 var2=value2 commandXXX<br>
# $var1 and $var2 set in the environment of 'commandXXX' only.<br>
[94]&nbsp;The<i>&nbsp;killall</i><a href="abs-guides.html#218">&nbsp;system script should not be confused with the killall command in&nbsp;</a>/usr/bin.<br>
[95]&nbsp;A<i>&nbsp;meta-meaning</i>&nbsp;is the meaning of a term or expression on a higher level of abstraction. For example,<br>
the<i>&nbsp;literal</i>&nbsp;meaning of<i>&nbsp;regular expression</i>&nbsp;is an ordinary expression that conforms to accepted usage.<br>The<i>&nbsp;meta-meaning</i>&nbsp;is drastically different, as discussed at length in this chapter.<br>
[96]&nbsp;<a href="abs-guides.html#781">Since sed, awk, and grep process single lines, there will usually not be a newline to match. In those</a><br>
cases where there is a newline in a multiple line expression, the dot will match the newline.<br>
#!/bin/bash<br>
sed -e 'N;s/.*/[&amp;]/' &lt;&lt; EOF &nbsp; # Here Document<br>
line1<br>
line2<br>
EOF<br>
# OUTPUT:<br>
# [line1<br>
# line2]<br>
echo<br>
awk '{ $0=$1 &quot;\n&quot; $2; if (/line.1/) {print}}' &lt;&lt; EOF<br>
line 1<br>
line 2<br>
EOF<br>
# OUTPUT:<br>
# line<br>
# 1<br>
# Thanks, S.C.<br>
exit 0<br>
[97]&nbsp;<i>Filename expansion</i>&nbsp;means expanding filename patterns or templates containing special characters. For<br>
example,&nbsp;example.???&nbsp;might expand to&nbsp;example.001&nbsp;and/or&nbsp;example.txt.<br>
[98]&nbsp;A<i>&nbsp;wild card</i>&nbsp;character, analogous to a wild card in poker, can represent (almost) any other character.<br>
[99]&nbsp;Filename expansion<i>&nbsp;can</i>&nbsp;match dotfiles, but only if the pattern explicitly includes the dot as a literal<br>
character.<br>
Appendix S. ASCII Table<br>
881<br>
<hr>
<A name=888></a>Advanced Bash-Scripting Guide<br>
~/[.]bashrc &nbsp; &nbsp;# &nbsp;Will not expand to ~/.bashrc<br>
~/?bashrc &nbsp; &nbsp; &nbsp;# &nbsp;Neither will this.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# &nbsp;Wild cards and metacharacters will NOT<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#+ expand to a dot in globbing.<br>
~/.[b]ashrc &nbsp; &nbsp;# &nbsp;Will expand to ~/.bashrc<br>
~/.ba?hrc &nbsp; &nbsp; &nbsp;# &nbsp;Likewise.<br>
~/.bashr* &nbsp; &nbsp; &nbsp;# &nbsp;Likewise.<br>
# Setting the &quot;dotglob&quot; option turns this off.<br>
# Thanks, S.C.<br>
[100]&nbsp;<a href="abs-guides.html#362">Except, as Dennis Benzinger points out, if using<b>&nbsp;&lt;&lt;-</b>&nbsp;to suppress tabs.</a><br>
[101]&nbsp;<a href="abs-guides.html#460">By convention in UNIX and Linux, data streams and peripherals (device files) are treated as files, in a</a><br>
fashion analogous to ordinary files.<br>
[102]&nbsp;A<i>&nbsp;file descriptor</i>&nbsp;is simply a number that the operating system assigns to an open file to keep track of it.<br>
Consider it a simplified type of file pointer. It is analogous to a<i>&nbsp;file handle</i>&nbsp;in<b>&nbsp;C</b>.<br>
[103]&nbsp;Using&nbsp;<i>file descriptor 5</i>&nbsp;might cause problems. When Bash creates a child process, as with<br>
<a href="abs-guides.html#212">exec, the child inherits fd 5 (see Chet Ramey's archived e-mail, &nbsp;SUBJECT: RE: File descriptor 5 is<br></a><a href="http://groups.google.com/group/gnu.bash.bug/browse_thread/thread/13955daafded3b5c/18c17050087f9f37">held open). Best leave this particular fd alone.</a><br>
[104]&nbsp;<a href="abs-guides.html#212">An external command invoked with an exec does</a><i>&nbsp;not</i>&nbsp;(usually) fork off a subprocess / subshell.<br>
[105]&nbsp;<a href="abs-guides.html#312">This has the same effect as a named pipe (temp file), and, in fact, named pipes were at one time used in</a><br>
process substitution.<br>
[106]&nbsp;The<b>&nbsp;return</b><a href="abs-guides.html#186">&nbsp;command is a Bash builtin.</a><br>
[107]&nbsp;However, as Thomas Braunberger points out, a local variable declared in a function<i>&nbsp;is also visible to</i><br>
<i>functions called by the parent function.</i><br>
#!/bin/bash<br>
function1 ()<br>
{<br>
&nbsp; local func1var=20<br>
&nbsp; echo &quot;Within function1, \$func1var = $func1var.&quot;<br>
&nbsp; function2<br>
}<br>
function2 ()<br>
{<br>
&nbsp; echo &quot;Within function2, \$func1var = $func1var.&quot;<br>
}<br>
function1<br>
exit 0<br>
# Output of the script:<br>
# Within function1, $func1var = 20.<br>
# Within function2, $func1var = 20.<br>
This is documented in the Bash manual:<br>
Appendix S. ASCII Table<br>
882<br>
<hr>
<A name=889></a>Advanced Bash-Scripting Guide<br>
&quot;Local can only be used within a function; it makes the variable name have a visible scope restricted to<br>that function<i>&nbsp;and its children</i>.&quot; [emphasis added]<i>&nbsp;The ABS Guide author considers this behavior to be a<br>bug.</i><br>
[108]&nbsp;Otherwise known as<i>&nbsp;redundancy</i>.<br>
[109]&nbsp;Otherwise known as<i>&nbsp;tautology</i>.<br>
[110]&nbsp;Otherwise known as a<i>&nbsp;metaphor</i>.<br>
[111]&nbsp;Otherwise known as a<i>&nbsp;recursive function</i>.<br>
[112]&nbsp;Too many levels of recursion may crash a script with a segfault.<br>
#!/bin/bash<br>
# &nbsp;Warning: Running this script could possibly lock up your system!<br>
# &nbsp;If you're lucky, it will segfault before using up all available memory.<br>
recursive_function () &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
{<br>
echo &quot;$1&quot; &nbsp; &nbsp; # Makes the function do something, and hastens the segfault.<br>
(( $1 &lt; $2 )) &amp;&amp; recursive_function $(( $1 + 1 )) $2;<br>
# &nbsp;As long as 1st parameter is less than 2nd,<br>
#+ increment 1st and recurse.<br>
}<br>
recursive_function 1 50000 &nbsp;# Recurse 50,000 levels!<br>
# &nbsp;Most likely segfaults (depending on stack size, set by ulimit -m).<br>
# &nbsp;Recursion this deep might cause even a C program to segfault,<br>
#+ by using up all the memory allotted to the stack.<br>
echo &quot;This will probably not print.&quot;<br>
exit 0 &nbsp;# This script will not exit normally.<br>
# &nbsp;Thanks, Stéphane Chazelas.<br>
[113]&nbsp;... as the first word of a command string. Obviously, an alias is only meaningful at the<i>&nbsp;beginning</i>&nbsp;of a<br>
command.<br>
[114]&nbsp;However, aliases do seem to expand positional parameters.<br>
[115]&nbsp;The entries in&nbsp;/dev&nbsp;provide mount points for physical and virtual devices. These entries use very little<br>
drive space.<br>
Some devices, such as&nbsp;/dev/null,&nbsp;/dev/zero, and&nbsp;/dev/urandom&nbsp;are virtual. They are not<br>actual physical devices and exist only in software.<br>
[116]&nbsp;A<i>&nbsp;block device</i>&nbsp;reads and/or writes data in chunks, or<i>&nbsp;blocks</i>, in contrast to a&nbsp;<i>character device</i>, which<br>
acesses data in<i>&nbsp;character</i>&nbsp;units. Examples of block devices are hard drives, CDROM drives, and flash<br>drives. Examples of character devices are keyboards, modems, sound cards.<br>
[117]&nbsp;Of course, the mount point&nbsp;/mnt/flashdrive&nbsp;must exist. If not, then, as<i>&nbsp;root</i>,<b>&nbsp;mkdir</b><br>
<b>/mnt/flashdrive</b>.<br>
To actually mount the drive, use the following command:<b>&nbsp;mount /mnt/flashdrive</b><br>
Newer Linux distros automount flash drives in the&nbsp;/media&nbsp;directory without user intervention.<br>
[118]&nbsp;<a href="abs-guides.html#331">Certain system commands, such as procinfo, free, vmstat, lsdev, and uptime do this as well.</a><br>
[119]&nbsp;By convention,&nbsp;<i>signal 0</i><a href="abs-guides.html#57">&nbsp;is assigned to exit.</a><br>
Appendix S. ASCII Table<br>
883<br>
<hr>
<A name=890></a>Advanced Bash-Scripting Guide<br>
[120]&nbsp;<a href="abs-guides.html#69">Setting the suid permission on the script itself has no effect in Linux and most other UNIX flavors.</a><br>
[121]&nbsp;<a href="abs-guides.html#11">In this context, &quot;magic numbers&quot; have an entirely different meaning than the magic numbers used to</a><br>
designate file types.<br>
[122]&nbsp;Quite a number of Linux utilities are, in fact, shell wrappers. Some examples are<br>
/usr/bin/pdf2ps,&nbsp;/usr/bin/batch, and&nbsp;/usr/bin/xmkmf.<br>
[123]&nbsp;ANSI is, of course, the acronym for the American National Standards Institute. This august body<br>
establishes and maintains various technical and industrial standards.<br>
[124]&nbsp;<a href="abs-guides.html#399">This usually means liberal use of functions.</a><br>
[125]&nbsp;<a href="http://www.virusbtn.com/magazine/archives/200204/malshell.xml">See Marius van Oers' article, Unix Shell Scripting Malware, and also the&nbsp;</a><a href="abs-guides.html#565"><i>Denning</i>&nbsp;reference in the</a><br>
<i>bibliography</i>.<br>
[126]&nbsp;<a href="abs-guides.html#349">Or, better yet, #!/bin/env sh.</a><br>
[127]&nbsp;To be more specific, Bash 4+ has<i>&nbsp;limited</i>&nbsp;support for associative arrays. It's a bare-bones<br>
implementation, and it lacks the much of the functionality of such arrays in other programming<br>languages.<br>
[128]&nbsp;Copyright 1995-2009 by Chester Ramey.<br>
[129]&nbsp;<a href="abs-guides.html#24">This only works with pipes and certain other</a><i>&nbsp;special</i>&nbsp;files.<br>
[130]&nbsp;<a href="abs-guides.html#885">But only in conjunction with readline, i.e., from the command-line.</a><br>
[131]&nbsp;<a href="abs-guides.html#195">And while you're at it, consider fixing the notorious piped read problem.</a><br>
[132]&nbsp;This is the notorious<i>&nbsp;flog it to death</i>&nbsp;technique that works so well with slow learners, eccentrics, odd<br>
ducks, fools and geniuses.<br>
[133]&nbsp;In fact, he is a school dropout with no formal credentials or professional experience whatsoever. None.<br>
Aside from the<i>&nbsp;ABS Guide</i>, his major claim to fame is a First Place in the sack race at the Colfax<br>Elementary School Field Day in June, 1958.<br>
[134]&nbsp;Those who can, do. Those who can't . . . get an MCSE.<br>
[135]&nbsp;Sometimes it seems as if he has spent his entire life flouting conventional wisdom and defying the<br>
sonorous Voice of Authority: &quot;<i>Hey, you can't do that!</i>&quot;<br>
[136]&nbsp;E-mails from certain spam-infested TLDs (61, 202, 211, 218, 220, etc.) will be trapped by spam filters<br>
and deleted unread.<br>
[137]&nbsp;Well, if you<i>&nbsp;absolutely</i><a href="abs-guides.html#724">&nbsp;insist, you can try modifying Example A-44 to suit your purposes.</a><br>
[138]&nbsp;It was hard to resist the obvious pun. No slight intended, since the book is a pretty decent introduction<br>
to the basic concepts of shell scripting.<br>
[139]&nbsp;<i>Sed</i>&nbsp;executes without user intervention.<br>
[140]&nbsp;If no address range is specified, the default is<i>&nbsp;all</i>&nbsp;lines.<br>
[141]&nbsp;Its name derives from the initials of its authors,<b>&nbsp;A</b>ho,<b>&nbsp;W</b>einberg, and<b>&nbsp;K</b>ernighan.<br>
[142]&nbsp;Out of range exit values can result in unexpected exit codes. An exit value greater than 255 returns an<br>
<a href="abs-guides.html#78">exit code modulo 256. For example,</a><i>&nbsp;exit 3809</i>&nbsp;gives an exit code of 225 (3809 % 256 = 225).<br>
[143]&nbsp;An update of&nbsp;/usr/include/sysexits.h&nbsp;allocates previously unused exit codes from 64 - 78. It<br>
may be anticipated that the range of unallotted exit codes will be further restricted in the future. The<br>author of this document will<i>&nbsp;not</i>&nbsp;do fixups on the scripting examples to conform to the changing<br>standard. This should not cause any problems, since there is no overlap or conflict in usage of exit<br>codes between compiled C/C++ binaries and shell scripts.<br>
[144]&nbsp;This does not apply to<b>&nbsp;csh</b>,<b>&nbsp;tcsh</b>, and other shells not related to or descended from the classic Bourne<br>
shell (<b>sh</b>).<br>
[145]&nbsp;In older versions of UNIX, passwords<i>&nbsp;were</i>&nbsp;stored in&nbsp;/etc/passwd, and that explains the name of<br>
the file.<br>
Appendix S. ASCII Table<br>
884<br>
<hr>
<A name=891></a>Advanced Bash-Scripting Guide<br>
[146]&nbsp;Some early UNIX systems had a fast, small-capacity fixed disk (containing&nbsp;/, the root partition), and a<br>
second drive which was larger, but slower (containing&nbsp;/usr&nbsp;and other partitions). The most frequently<br>used programs and utilities therefore resided on the small-but-fast drive, in&nbsp;/bin, and the others on the<br>slower drive, in&nbsp;/usr/bin.<br>
This likewise accounts for the split between&nbsp;/sbin&nbsp;and&nbsp;/usr/sbin,&nbsp;/lib&nbsp;and&nbsp;/usr/lib, etc.<br>
[147]&nbsp;This works only from the<i>&nbsp;command line</i>, of course, and not within a script.<br>
[148]&nbsp;Normally the default parameter completion files reside in either the&nbsp;/etc/profile.d&nbsp;directory or<br>
in&nbsp;/etc/bash_completion. These autoload on system startup. So, after writing a useful<br>completion script, you might wish to move it (as<i>&nbsp;root</i>, of course) to one of these directories.<br>
[149]&nbsp;It has been extensively documented that programmers are willing to put in long hours of effort in order<br>
to save ten minutes of &quot;unnecessary&quot; labor. This is known as<i>&nbsp;optimization</i>.<br>
[150]&nbsp;Various readers have suggested modifications of the above batch file to prettify it and make it more<br>
compact and efficient. In the opinion of the<i>&nbsp;ABS Guide</i>&nbsp;author, this is wasted effort. A Bash script can<br><a href="http://www.ntfs-3g.org">access a DOS filesystem, or even an NTFS partition (with the help of ntfs-3g) to do batch or scripted<br></a>operations.<br>
[151]&nbsp;For all you clever types who failed intermediate algebra, a<i>&nbsp;determinant</i>&nbsp;is a numerical value associated<br>
with a multidimensional<i>&nbsp;matrix</i><a href="abs-guides.html#427">&nbsp;(array of numbers).</a><br>
For the simple case of a 2 x 2 determinant:<br>
&nbsp; |a &nbsp;b|<br>
&nbsp; |b &nbsp;a|<br>
The solution is a*a - b*b, where &quot;a&quot; and &quot;b&quot; represent numbers.<br>
[152]&nbsp;The author intends that this book be released into the Public Domain after a period of 14 years from<br>
initial publication, that is, in 2014. In the early years of the American republic this was the duration<br>statutorily granted to a copyrighted work.<br>
Appendix S. ASCII Table<br>
885<br>
<hr>
<A name="outline"></a><h1>Document Outline</h1>
<ul><li><A href="abs-guides.html#2">Table of Contents</A>
<li><A href="abs-guides.html#7">Chapter 1. Shell Programming!</A>
<li><A href="abs-guides.html#9">Chapter 2. Starting Off With a Sha-Bang</A>
<ul><li><A href="abs-guides.html#12">2.1. Invoking the script</A>
<li><A href="abs-guides.html#12">2.2. Preliminary Exercises</A>
</ul><li><A href="abs-guides.html#13">Part 2. Basics</A>
<li><A href="abs-guides.html#14">Chapter 3. Special Characters</A>
<li><A href="abs-guides.html#36">Chapter 4. Introduction to Variables and Parameters</A>
<ul><li><A href="abs-guides.html#36">4.1. Variable Substitution</A>
<li><A href="abs-guides.html#39">4.2. Variable Assignment</A>
<li><A href="abs-guides.html#40">4.3. Bash Variables Are Untyped</A>
<li><A href="abs-guides.html#41">4.4. Special Variable Types</A>
</ul><li><A href="abs-guides.html#47">Chapter 5. Quoting</A>
<ul><li><A href="abs-guides.html#47">5.1. Quoting Variables</A>
<li><A href="abs-guides.html#49">5.2. Escaping</A>
</ul><li><A href="abs-guides.html#57">Chapter 6. Exit and Exit Status</A>
<li><A href="abs-guides.html#60">Chapter 7. Tests</A>
<ul><li><A href="abs-guides.html#60">7.1. Test Constructs</A>
<li><A href="abs-guides.html#68">7.2. File test operators</A>
<li><A href="abs-guides.html#71">7.3. Other Comparison Operators</A>
<li><A href="abs-guides.html#76">7.4. Nested if/then Condition Tests</A>
<li><A href="abs-guides.html#77">7.5. Testing Your Knowledge of Tests</A>
</ul><li><A href="abs-guides.html#78">Chapter 8. Operations and Related Topics</A>
<ul><li><A href="abs-guides.html#78">8.1. Operators</A>
<li><A href="abs-guides.html#84">8.2. Numerical Constants</A>
<li><A href="abs-guides.html#86">8.3. The Double-Parentheses Construct</A>
<li><A href="abs-guides.html#87">8.4. Operator Precedence</A>
</ul><li><A href="abs-guides.html#90">Part 3. Beyond the Basics</A>
<li><A href="abs-guides.html#91">Chapter 9. Another Look at Variables</A>
<ul><li><A href="abs-guides.html#91">9.1. Internal Variables</A>
<li><A href="abs-guides.html#110">9.2. Typing variables: declare or typeset</A>
<ul><li><A href="abs-guides.html#112">9.2.1. Another use for declare</A>
</ul><li><A href="abs-guides.html#112">9.3. $RANDOM: generate random integer</A>
</ul><li><A href="abs-guides.html#125">Chapter 10. Manipulating Variables</A>
<ul><li><A href="abs-guides.html#125">10.1. Manipulating Strings</A>
<ul><li><A href="abs-guides.html#132">10.1.1. Manipulating strings using awk</A>
<li><A href="abs-guides.html#133">10.1.2. Further Reference</A>
</ul><li><A href="abs-guides.html#133">10.2. Parameter Substitution</A>
</ul><li><A href="abs-guides.html#144">Chapter 11. Loops and Branches</A>
<ul><li><A href="abs-guides.html#144">11.1. Loops</A>
<li><A href="abs-guides.html#157">11.2. Nested Loops</A>
<li><A href="abs-guides.html#158">11.3. Loop Control</A>
<li><A href="abs-guides.html#162">11.4. Testing and Branching</A>
</ul><li><A href="abs-guides.html#170">Chapter 12. Command Substitution</A>
<li><A href="abs-guides.html#176">Chapter 13. Arithmetic Expansion</A>
<li><A href="abs-guides.html#177">Chapter 14. Recess Time</A>
<li><A href="abs-guides.html#178">Part 4. Commands</A>
<li><A href="abs-guides.html#186">Chapter 15. Internal Commands and Builtins</A>
<ul><li><A href="abs-guides.html#215">15.1. Job Control Commands</A>
</ul><li><A href="abs-guides.html#220">Chapter 16. External Filters, Programs and Commands</A>
<ul><li><A href="abs-guides.html#220">16.1. Basic Commands</A>
<li><A href="abs-guides.html#225">16.2. Complex Commands</A>
<li><A href="abs-guides.html#236">16.3. Time / Date Commands</A>
<li><A href="abs-guides.html#240">16.4. Text Processing Commands</A>
<li><A href="abs-guides.html#262">16.5. File and Archiving Commands</A>
<li><A href="abs-guides.html#280">16.6. Communications Commands</A>
<li><A href="abs-guides.html#295">16.7. Terminal Control Commands</A>
<li><A href="abs-guides.html#296">16.8. Math Commands</A>
<li><A href="abs-guides.html#307">16.9. Miscellaneous Commands</A>
</ul><li><A href="abs-guides.html#321">Chapter 17. System and Administrative Commands</A>
<ul><li><A href="abs-guides.html#350">17.1. Analyzing a System Script</A>
</ul><li><A href="abs-guides.html#352">Part 5. Advanced Topics</A>
<li><A href="abs-guides.html#354">Chapter 18. Regular Expressions</A>
<ul><li><A href="abs-guides.html#354">18.1. A Brief Introduction to Regular Expressions</A>
<li><A href="abs-guides.html#358">18.2. Globbing</A>
</ul><li><A href="abs-guides.html#360">Chapter 19. Here Documents</A>
<ul><li><A href="abs-guides.html#370">19.1. Here Strings</A>
</ul><li><A href="abs-guides.html#374">Chapter 20. I/O Redirection</A>
<ul><li><A href="abs-guides.html#377">20.1. Using exec</A>
<li><A href="abs-guides.html#380">20.2. Redirecting Code Blocks</A>
<li><A href="abs-guides.html#385">20.3. Applications</A>
</ul><li><A href="abs-guides.html#387">Chapter 21. Subshells</A>
<li><A href="abs-guides.html#392">Chapter 22. Restricted Shells</A>
<li><A href="abs-guides.html#394">Chapter 23. Process Substitution</A>
<li><A href="abs-guides.html#399">Chapter 24. Functions</A>
<ul><li><A href="abs-guides.html#403">24.1. Complex Functions and Function Complexities</A>
<li><A href="abs-guides.html#413">24.2. Local Variables</A>
<ul><li><A href="abs-guides.html#415">24.2.1. Local variables and recursion.</A>
</ul><li><A href="abs-guides.html#417">24.3. Recursion Without Local Variables</A>
</ul><li><A href="abs-guides.html#421">Chapter 25. Aliases</A>
<li><A href="abs-guides.html#424">Chapter 26. List Constructs</A>
<li><A href="abs-guides.html#427">Chapter 27. Arrays</A>
<li><A href="abs-guides.html#456">Chapter 28. Indirect References</A>
<li><A href="abs-guides.html#460">Chapter 29. /dev and /proc</A>
<ul><li><A href="abs-guides.html#460">29.1. /dev</A>
<li><A href="abs-guides.html#463">29.2. /proc</A>
</ul><li><A href="abs-guides.html#469">Chapter 30. Network Programming</A>
<li><A href="abs-guides.html#472">Chapter 31. Of Zeros and Nulls</A>
<li><A href="abs-guides.html#476">Chapter 32. Debugging</A>
<li><A href="abs-guides.html#487">Chapter 33. Options</A>
<li><A href="abs-guides.html#490">Chapter 34. Gotchas</A>
<li><A href="abs-guides.html#499">Chapter 35. Scripting With Style</A>
<ul><li><A href="abs-guides.html#499">35.1. Unofficial Shell Scripting Stylesheet</A>
</ul><li><A href="abs-guides.html#502">Chapter 36. Miscellany</A>
<ul><li><A href="abs-guides.html#502">36.1. Interactive and non-interactive shells and scripts</A>
<li><A href="abs-guides.html#503">36.2. Shell Wrappers</A>
<li><A href="abs-guides.html#508">36.3. Tests and Comparisons: Alternatives</A>
<li><A href="abs-guides.html#509">36.4. Recursion: a script calling itself</A>
<li><A href="abs-guides.html#511">36.5. "Colorizing" Scripts</A>
<li><A href="abs-guides.html#524">36.6. Optimizations</A>
<li><A href="abs-guides.html#525">36.7. Assorted Tips</A>
<ul><li><A href="abs-guides.html#525">36.7.1. Ideas for more powerful scripts</A>
<li><A href="abs-guides.html#535">36.7.2. Widgets</A>
</ul><li><A href="abs-guides.html#537">36.8. Security Issues</A>
<ul><li><A href="abs-guides.html#537">36.8.1. Infected Shell Scripts</A>
<li><A href="abs-guides.html#537">36.8.2. Hiding Shell Script Source</A>
<li><A href="abs-guides.html#538">36.8.3. Writing Secure Shell Scripts</A>
</ul><li><A href="abs-guides.html#538">36.9. Portability Issues</A>
<ul><li><A href="abs-guides.html#539">36.9.1. A Test Suite</A>
</ul><li><A href="abs-guides.html#540">36.10. Shell Scripting Under Windows</A>
</ul><li><A href="abs-guides.html#541">Chapter 37. Bash, versions 2, 3, and 4</A>
<ul><li><A href="abs-guides.html#541">37.1. Bash, version 2</A>
<li><A href="abs-guides.html#545">37.2. Bash, version 3</A>
<ul><li><A href="abs-guides.html#548">37.2.1. Bash, version 3.1</A>
<li><A href="abs-guides.html#548">37.2.2. Bash, version 3.2</A>
</ul><li><A href="abs-guides.html#549">37.3. Bash, version 4</A>
<ul><li><A href="abs-guides.html#556">37.3.1. Bash, version 4.1</A>
<li><A href="abs-guides.html#557">37.3.2. Bash, version 4.2</A>
</ul></ul><li><A href="abs-guides.html#561">Chapter 38. Endnotes</A>
<ul><li><A href="abs-guides.html#561">38.1. Author's Note</A>
<li><A href="abs-guides.html#561">38.2. About the Author</A>
<li><A href="abs-guides.html#561">38.3. Where to Go For Help</A>
<li><A href="abs-guides.html#562">38.4. Tools Used to Produce This Book</A>
<ul><li><A href="abs-guides.html#562">38.4.1. Hardware</A>
<li><A href="abs-guides.html#562">38.4.2. Software and Printware</A>
</ul><li><A href="abs-guides.html#562">38.5. Credits</A>
<li><A href="abs-guides.html#564">38.6. Disclaimer</A>
</ul><li><A href="abs-guides.html#565">Bibliography</A>
<li><A href="abs-guides.html#572">Appendix A. Contributed Scripts</A>
<li><A href="abs-guides.html#776">Appendix B. Reference Cards</A>
<li><A href="abs-guides.html#781">Appendix C. A Sed and Awk Micro-Primer</A>
<ul><li><A href="abs-guides.html#781">C.1. Sed</A>
<li><A href="abs-guides.html#784">C.2. Awk</A>
</ul><li><A href="abs-guides.html#787">Appendix D. Exit Codes With Special Meanings</A>
<li><A href="abs-guides.html#788">Appendix E. A Detailed Introduction to I/O and I/O Redirection</A>
<li><A href="abs-guides.html#790">Appendix F. Command-Line Options</A>
<ul><li><A href="abs-guides.html#790">F.1. Standard Command-Line Options</A>
<li><A href="abs-guides.html#791">F.2. Bash Command-Line Options</A>
</ul><li><A href="abs-guides.html#793">Appendix G. Important Files</A>
<li><A href="abs-guides.html#794">Appendix H. Important System Directories</A>
<li><A href="abs-guides.html#796">Appendix I. An Introduction to Programmable Completion</A>
<li><A href="abs-guides.html#799">Appendix J. Localization</A>
<li><A href="abs-guides.html#803">Appendix K. History Commands</A>
<li><A href="abs-guides.html#804">Appendix L. Sample .bashrc and .bash_profile Files</A>
<li><A href="abs-guides.html#819">Appendix M. Converting DOS Batch Files to Shell Scripts</A>
<li><A href="abs-guides.html#823">Appendix N. Exercises</A>
<ul><li><A href="abs-guides.html#823">N.1. Analyzing Scripts</A>
<li><A href="abs-guides.html#825">N.2. Writing Scripts</A>
</ul><li><A href="abs-guides.html#835">Appendix O. Revision History</A>
<li><A href="abs-guides.html#838">Appendix P. Download and Mirror Sites</A>
<li><A href="abs-guides.html#839">Appendix Q. To Do List</A>
<li><A href="abs-guides.html#840">Appendix R. Copyright</A>
<li><A href="abs-guides.html#843">Appendix S. ASCII Table</A>
<ul><li><A href="abs-guides.html#844">Index</A>
<ul><li><A href="abs-guides.html#881">Notes</A>
</ul></ul></ul><hr>
</BODY>
</HTML>
