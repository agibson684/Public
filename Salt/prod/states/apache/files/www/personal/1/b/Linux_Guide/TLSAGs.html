<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><b>The Linux System Administrator's Guide</b><br>
<b>Version 0.8</b><br>
<b>Lars Wirzenius</b><br>
<a href="mailto:liw@iki.fi">&lt;liw@iki.fi&gt;</a><br>
<b>Joanna Oja</b><br>
<a href="mailto:viu@iki.fi">&lt;viu@iki.fi&gt;</a><br>
<b>Stephen Stafford</b><br>
<a href="mailto:stephen@clothcat.demon.co.uk">&lt;stephen@clothcat.demon.co.uk&gt;</a><br>
<b>Alex Weeks</b><br>
<a href="mailto:weeks_alex@yahoo.com.NOSPAM">&lt;weeks_alex@yahoo.com.NOSPAM&gt;</a><br>
2003−12−03<br>
An introduction to system administration of a Linux system for novices.<br>
Copyright 1993−−1998 Lars Wirzenius.<br>
Copyright 1998−−2001 Joanna Oja.<br>
Copyright 2001−−2003 Stephen Stafford.<br>
Copyright 2003−−Present Stephen Stafford &amp; Alex Weeks.<br>
Trademarks are owned by their owners.<br>
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free<br>Documentation License, Version 1.1; with no Invariant Sections, with no Front−Cover Texts, and with no<br>Back−Cover Texts. A copy of the license is included in the section entitled &quot;GNU Free Documentation<br>License&quot;.<br>
<hr>
<A name=2></a><hr>
<A name=3></a>The Linux System Administrator's Guide<br>
<b>Table of Contents</b><br>
<a href="TLSAGs.html#7"><b>Source&nbsp;and&nbsp;pre−formatted&nbsp;versions&nbsp;available..................................................................................................1</b></a><br>
<a href="TLSAGs.html#8"><b>Chapter&nbsp;1.&nbsp;Introduction......................................................................................................................................2</b></a><br>
<a href="TLSAGs.html#10"><b>Chapter&nbsp;2.&nbsp;About&nbsp;This&nbsp;Book..............................................................................................................................4</b></a><br>
<a href="TLSAGs.html#10">2.1.&nbsp;Acknowledgments.............................................................................................................................4</a><br>
<a href="TLSAGs.html#10">2.1.1.&nbsp;Joanna's&nbsp;acknowledgments......................................................................................................4<br>2.1.2.&nbsp;Stephen's&nbsp;acknowledgments....................................................................................................4<br></a><a href="TLSAGs.html#11">2.1.3.&nbsp;Alex's&nbsp;Acknowledgments........................................................................................................5</a><br>
<a href="TLSAGs.html#11">2.2.&nbsp;Typographical&nbsp;Conventions..............................................................................................................5</a><br>
<a href="TLSAGs.html#12"><b>Chapter&nbsp;3.&nbsp;Overview&nbsp;of&nbsp;a&nbsp;Linux&nbsp;System...........................................................................................................6</b></a><br>
<a href="TLSAGs.html#12">3.1.&nbsp;Various&nbsp;parts&nbsp;of&nbsp;an&nbsp;operating&nbsp;system................................................................................................6<br>3.2.&nbsp;Important&nbsp;parts&nbsp;of&nbsp;the&nbsp;kernel.............................................................................................................6<br></a><a href="TLSAGs.html#13">3.3.&nbsp;Major&nbsp;services&nbsp;in&nbsp;a&nbsp;UNIX&nbsp;system.....................................................................................................7</a><br>
<a href="TLSAGs.html#14">3.3.1.&nbsp;init............................................................................................................................................8<br>3.3.2.&nbsp;Logins&nbsp;from&nbsp;terminals.............................................................................................................8<br>3.3.3.&nbsp;Syslog......................................................................................................................................8<br>3.3.4.&nbsp;Periodic&nbsp;command&nbsp;execution:&nbsp;cron&nbsp;and&nbsp;at..............................................................................8<br></a><a href="TLSAGs.html#15">3.3.5.&nbsp;Graphical&nbsp;user&nbsp;interface...........................................................................................................9<br>3.3.6.&nbsp;Networking..............................................................................................................................9<br>3.3.7.&nbsp;Network&nbsp;logins........................................................................................................................9<br></a><a href="TLSAGs.html#16">3.3.8.&nbsp;Network&nbsp;file&nbsp;systems.............................................................................................................10<br>3.3.9.&nbsp;Mail</a>.......................................................................................................................................10<br><a href="TLSAGs.html#16">3.3.10.&nbsp;Printing................................................................................................................................10<br>3.3.11.&nbsp;The&nbsp;filesystem&nbsp;layout..........................................................................................................10</a><br>
<a href="TLSAGs.html#18"><b>Chapter&nbsp;4.&nbsp;Overview&nbsp;of&nbsp;the&nbsp;Directory&nbsp;Tree....................................................................................................12</b></a><br>
<a href="TLSAGs.html#18">4.1.&nbsp;Background.....................................................................................................................................12<br></a><a href="TLSAGs.html#19">4.2.&nbsp;The&nbsp;root&nbsp;filesystem.........................................................................................................................13<br></a><a href="TLSAGs.html#20">4.3.&nbsp;The&nbsp;/etc&nbsp;directory............................................................................................................................14<br></a><a href="TLSAGs.html#22">4.4.&nbsp;The&nbsp;/dev&nbsp;directory...........................................................................................................................16<br>4.5.&nbsp;The&nbsp;/usr&nbsp;filesystem..........................................................................................................................16<br>4.6.&nbsp;The&nbsp;/var&nbsp;filesystem..........................................................................................................................16<br></a><a href="TLSAGs.html#23">4.7.&nbsp;The&nbsp;/proc&nbsp;filesystem........................................................................................................................17</a><br>
<a href="TLSAGs.html#25"><b>Chapter&nbsp;5.&nbsp;Device&nbsp;Files.....................................................................................................................................19</b></a><br>
<a href="TLSAGs.html#25">5.1.&nbsp;The&nbsp;MAKEDEV&nbsp;Script...................................................................................................................19<br>5.2.&nbsp;The&nbsp;mknod&nbsp;command.....................................................................................................................19<br></a><a href="TLSAGs.html#26">5.3.&nbsp;Device&nbsp;List......................................................................................................................................20</a><br>
<a href="TLSAGs.html#28"><b>Chapter&nbsp;6.&nbsp;Using&nbsp;Disks&nbsp;and&nbsp;Other&nbsp;Storage&nbsp;Media.........................................................................................22</b></a><br>
<a href="TLSAGs.html#28">6.1.&nbsp;Two&nbsp;kinds&nbsp;of&nbsp;devices......................................................................................................................22<br></a><a href="TLSAGs.html#29">6.2.&nbsp;Hard&nbsp;disks.......................................................................................................................................23<br></a><a href="TLSAGs.html#31">6.3.&nbsp;Floppies...........................................................................................................................................25<br></a><a href="TLSAGs.html#32">6.4.&nbsp;CD−ROMs......................................................................................................................................26<br>6.5.&nbsp;Tapes...............................................................................................................................................26<br></a><a href="TLSAGs.html#33">6.6.&nbsp;Formatting.......................................................................................................................................27</a><br>
i<br>
<hr>
<A name=4></a>The Linux System Administrator's Guide<br>
<b>Table of Contents</b><br>
<a href="TLSAGs.html#28"><b>Chapter&nbsp;6.&nbsp;Using&nbsp;Disks&nbsp;and&nbsp;Other&nbsp;Storage&nbsp;Media</b></a><br>
<a href="TLSAGs.html#34">6.7.&nbsp;Partitions.........................................................................................................................................28</a><br>
<a href="TLSAGs.html#35">6.7.1.&nbsp;The&nbsp;MBR,&nbsp;boot&nbsp;sectors&nbsp;and&nbsp;partition&nbsp;table............................................................................29<br>6.7.2.&nbsp;Extended&nbsp;and&nbsp;logical&nbsp;partitions.............................................................................................29<br></a><a href="TLSAGs.html#36">6.7.3.&nbsp;Partition&nbsp;types........................................................................................................................30<br></a><a href="TLSAGs.html#37">6.7.4.&nbsp;Partitioning&nbsp;a&nbsp;hard&nbsp;disk..........................................................................................................31<br>6.7.5.&nbsp;Device&nbsp;files&nbsp;and&nbsp;partitions.....................................................................................................31</a><br>
<a href="TLSAGs.html#38">6.8.&nbsp;Filesystems......................................................................................................................................32</a><br>
<a href="TLSAGs.html#38">6.8.1.&nbsp;What&nbsp;are&nbsp;filesystems?............................................................................................................32<br>6.8.2.&nbsp;Filesystems&nbsp;galore.................................................................................................................32<br></a><a href="TLSAGs.html#40">6.8.3.&nbsp;Which&nbsp;filesystem&nbsp;should&nbsp;be&nbsp;used?........................................................................................34<br></a><a href="TLSAGs.html#41">6.8.4.&nbsp;Creating&nbsp;a&nbsp;filesystem.............................................................................................................35<br></a><a href="TLSAGs.html#42">6.8.5.&nbsp;Mounting&nbsp;and&nbsp;unmounting....................................................................................................36<br></a><a href="TLSAGs.html#45">6.8.6.&nbsp;Checking&nbsp;filesystem&nbsp;integrity&nbsp;with&nbsp;fsck................................................................................39<br>6.8.7.&nbsp;Checking&nbsp;for&nbsp;disk&nbsp;errors&nbsp;with&nbsp;badblocks...............................................................................39<br></a><a href="TLSAGs.html#46">6.8.8.&nbsp;Fighting&nbsp;fragmentation..........................................................................................................40<br>6.8.9.&nbsp;Other&nbsp;tools&nbsp;for&nbsp;all&nbsp;filesystems...............................................................................................40<br></a><a href="TLSAGs.html#47">6.8.10.&nbsp;Other&nbsp;tools&nbsp;for&nbsp;the&nbsp;ext2/ext3&nbsp;filesystem..............................................................................41</a><br>
<a href="TLSAGs.html#48">6.9.&nbsp;Disks&nbsp;without&nbsp;filesystems...............................................................................................................42<br></a><a href="TLSAGs.html#49">6.10.&nbsp;Allocating&nbsp;disk&nbsp;space....................................................................................................................43</a><br>
<a href="TLSAGs.html#49">6.10.1.&nbsp;Partitioning&nbsp;schemes............................................................................................................43<br>6.10.2.&nbsp;Space&nbsp;requirements..............................................................................................................43<br></a><a href="TLSAGs.html#50">6.10.3.&nbsp;Examples&nbsp;of&nbsp;hard&nbsp;disk&nbsp;allocation........................................................................................44<br>6.10.4.&nbsp;Adding&nbsp;more&nbsp;disk&nbsp;space&nbsp;for&nbsp;Linux......................................................................................44<br>6.10.5.&nbsp;Tips&nbsp;for&nbsp;saving&nbsp;disk&nbsp;space...................................................................................................44</a><br>
<a href="TLSAGs.html#52"><b>Chapter&nbsp;7.&nbsp;Memory&nbsp;Management...................................................................................................................46</b></a><br>
<a href="TLSAGs.html#52">7.1.&nbsp;What&nbsp;is&nbsp;virtual&nbsp;memory?.................................................................................................................46<br>7.2.&nbsp;Creating&nbsp;a&nbsp;swap&nbsp;space.....................................................................................................................46<br></a><a href="TLSAGs.html#53">7.3.&nbsp;Using&nbsp;a&nbsp;swap&nbsp;space.........................................................................................................................47<br></a><a href="TLSAGs.html#55">7.4.&nbsp;Sharing&nbsp;swap&nbsp;spaces&nbsp;with&nbsp;other&nbsp;operating&nbsp;systems........................................................................49<br>7.5.&nbsp;Allocating&nbsp;swap&nbsp;space.....................................................................................................................49<br></a><a href="TLSAGs.html#56">7.6.&nbsp;The&nbsp;buffer&nbsp;cache.............................................................................................................................50</a><br>
<a href="TLSAGs.html#58"><b>Chapter&nbsp;8.&nbsp;Boots&nbsp;And&nbsp;Shutdowns....................................................................................................................52</b></a><br>
<a href="TLSAGs.html#58">8.1.&nbsp;An&nbsp;overview&nbsp;of&nbsp;boots&nbsp;and&nbsp;shutdowns.............................................................................................52<br>8.2.&nbsp;The&nbsp;boot&nbsp;process&nbsp;in&nbsp;closer&nbsp;look......................................................................................................52<br></a><a href="TLSAGs.html#60">8.3.&nbsp;More&nbsp;about&nbsp;shutdowns....................................................................................................................54<br></a><a href="TLSAGs.html#61">8.4.&nbsp;Rebooting........................................................................................................................................55<br></a><a href="TLSAGs.html#62">8.5.&nbsp;Single&nbsp;user&nbsp;mode.............................................................................................................................56<br>8.6.&nbsp;Emergency&nbsp;boot&nbsp;floppies................................................................................................................56</a><br>
<a href="TLSAGs.html#63"><b>Chapter&nbsp;9.&nbsp;init....................................................................................................................................................57</b></a><br>
<a href="TLSAGs.html#63">9.1.&nbsp;init&nbsp;comes&nbsp;first</a>................................................................................................................................57<br><a href="TLSAGs.html#63">9.2.&nbsp;Configuring&nbsp;init&nbsp;to&nbsp;start&nbsp;getty:&nbsp;the&nbsp;/etc/inittab&nbsp;file..........................................................................57<br></a><a href="TLSAGs.html#64">9.3.&nbsp;Run&nbsp;levels.......................................................................................................................................58<br></a><a href="TLSAGs.html#65">9.4.&nbsp;Special&nbsp;configuration&nbsp;in&nbsp;/etc/inittab................................................................................................59<br></a><a href="TLSAGs.html#66">9.5.&nbsp;Booting&nbsp;in&nbsp;single&nbsp;user&nbsp;mode...........................................................................................................60</a><br>
ii<br>
<hr>
<A name=5></a>The Linux System Administrator's Guide<br>
<b>Table of Contents</b><br>
<a href="TLSAGs.html#67"><b>Chapter&nbsp;10.&nbsp;Logging&nbsp;In&nbsp;And&nbsp;Out.....................................................................................................................61</b></a><br>
<a href="TLSAGs.html#67">10.1.&nbsp;Logins&nbsp;via&nbsp;terminals......................................................................................................................61<br></a><a href="TLSAGs.html#68">10.2.&nbsp;Logins&nbsp;via&nbsp;the&nbsp;network..................................................................................................................62<br></a><a href="TLSAGs.html#69">10.3.&nbsp;What&nbsp;login&nbsp;does............................................................................................................................63<br></a><a href="TLSAGs.html#70">10.4.&nbsp;X&nbsp;and&nbsp;xdm.....................................................................................................................................64<br>10.5.&nbsp;Access&nbsp;control...............................................................................................................................64<br>10.6.&nbsp;Shell&nbsp;startup..................................................................................................................................64</a><br>
<a href="TLSAGs.html#71"><b>Chapter&nbsp;11.&nbsp;Managing&nbsp;user&nbsp;accounts..............................................................................................................65</b></a><br>
<a href="TLSAGs.html#71">11.1.&nbsp;What's&nbsp;an&nbsp;account?........................................................................................................................65<br>11.2.&nbsp;Creating&nbsp;a&nbsp;user..............................................................................................................................65</a><br>
<a href="TLSAGs.html#71">11.2.1.&nbsp;/etc/passwd&nbsp;and&nbsp;other&nbsp;informative&nbsp;files...............................................................................65<br></a><a href="TLSAGs.html#72">11.2.2.&nbsp;Picking&nbsp;numeric&nbsp;user&nbsp;and&nbsp;group&nbsp;ids....................................................................................66<br>11.2.3.&nbsp;Initial&nbsp;environment:&nbsp;/etc/skel...............................................................................................66<br></a><a href="TLSAGs.html#73">11.2.4.&nbsp;Creating&nbsp;a&nbsp;user&nbsp;by&nbsp;hand.......................................................................................................67</a><br>
<a href="TLSAGs.html#73">11.3.&nbsp;Changing&nbsp;user&nbsp;properties..............................................................................................................67<br></a><a href="TLSAGs.html#74">11.4.&nbsp;Removing&nbsp;a&nbsp;user</a>...........................................................................................................................68<br><a href="TLSAGs.html#74">11.5.&nbsp;Disabling&nbsp;a&nbsp;user&nbsp;temporarily.........................................................................................................68</a><br>
<a href="TLSAGs.html#76"><b>Chapter&nbsp;12.&nbsp;Backups.........................................................................................................................................70</b></a><br>
<a href="TLSAGs.html#76">12.1.&nbsp;On&nbsp;the&nbsp;importance&nbsp;of&nbsp;being&nbsp;backed&nbsp;up.........................................................................................70<br>12.2.&nbsp;Selecting&nbsp;the&nbsp;backup&nbsp;medium.......................................................................................................70<br></a><a href="TLSAGs.html#77">12.3.&nbsp;Selecting&nbsp;the&nbsp;backup&nbsp;tool..............................................................................................................71<br></a><a href="TLSAGs.html#78">12.4.&nbsp;Simple&nbsp;backups.............................................................................................................................72</a><br>
<a href="TLSAGs.html#78">12.4.1.&nbsp;Making&nbsp;backups&nbsp;with&nbsp;tar.....................................................................................................72<br></a><a href="TLSAGs.html#79">12.4.2.&nbsp;Restoring&nbsp;files&nbsp;with&nbsp;tar........................................................................................................73</a><br>
<a href="TLSAGs.html#80">12.5.&nbsp;Multilevel&nbsp;backups........................................................................................................................74<br></a><a href="TLSAGs.html#81">12.6.&nbsp;What&nbsp;to&nbsp;back&nbsp;up............................................................................................................................75<br></a><a href="TLSAGs.html#82">12.7.&nbsp;Compressed&nbsp;backups.....................................................................................................................76</a><br>
<a href="TLSAGs.html#83"><b>Chapter&nbsp;13.&nbsp;Keeping&nbsp;Time...............................................................................................................................77</b></a><br>
<a href="TLSAGs.html#83">13.1.&nbsp;The&nbsp;concept&nbsp;of&nbsp;localtime...............................................................................................................77<br></a><a href="TLSAGs.html#84">13.2.&nbsp;The&nbsp;hardware&nbsp;and&nbsp;software&nbsp;clocks................................................................................................78<br>13.3.&nbsp;Showing&nbsp;and&nbsp;setting&nbsp;time..............................................................................................................78<br></a><a href="TLSAGs.html#85">13.4.&nbsp;When&nbsp;the&nbsp;clock&nbsp;is&nbsp;wrong...............................................................................................................79<br>13.5.&nbsp;NTP&nbsp;−&nbsp;Network&nbsp;Time&nbsp;Protocol.....................................................................................................79<br></a><a href="TLSAGs.html#86">13.6.&nbsp;Basic&nbsp;NTP&nbsp;configuration...............................................................................................................80<br></a><a href="TLSAGs.html#87">13.7.&nbsp;NTP&nbsp;Toolkit..................................................................................................................................81<br></a><a href="TLSAGs.html#89">13.8.&nbsp;Some&nbsp;known&nbsp;NTP&nbsp;servers.............................................................................................................83<br>13.9.&nbsp;NTP&nbsp;Links.....................................................................................................................................83</a><br>
<a href="TLSAGs.html#90"><b>Chapter&nbsp;14.&nbsp;Finding&nbsp;Help.................................................................................................................................84</b></a><br>
<a href="TLSAGs.html#90">14.1.&nbsp;Newsgroups&nbsp;and&nbsp;Mailing&nbsp;Lists.....................................................................................................84</a><br>
<a href="TLSAGs.html#90">14.1.1.&nbsp;Finding&nbsp;The&nbsp;Right&nbsp;Forum....................................................................................................84<br>14.1.2.&nbsp;Before&nbsp;You&nbsp;Post..................................................................................................................84<br>14.1.3.&nbsp;Writing&nbsp;Your&nbsp;Post</a>...............................................................................................................84<br><a href="TLSAGs.html#91">14.1.4.&nbsp;Formatting&nbsp;Your&nbsp;Post..........................................................................................................85<br>14.1.5.&nbsp;Follow&nbsp;Up............................................................................................................................85</a><br>
iii<br>
<hr>
<A name=6></a>The Linux System Administrator's Guide<br>
<b>Table of Contents</b><br>
<a href="TLSAGs.html#90"><b>Chapter&nbsp;14.&nbsp;Finding&nbsp;Help</b></a><br>
<a href="TLSAGs.html#91">14.1.6.&nbsp;More&nbsp;Information................................................................................................................85</a><br>
<a href="TLSAGs.html#91">14.2.&nbsp;IRC................................................................................................................................................85</a><br>
<a href="TLSAGs.html#92">14.2.1.&nbsp;Colours................................................................................................................................86<br>14.2.2.&nbsp;Be&nbsp;Polite..............................................................................................................................86<br>14.2.3.&nbsp;Type&nbsp;Properly,&nbsp;in&nbsp;English....................................................................................................86<br>14.2.4.&nbsp;Port&nbsp;scanning.......................................................................................................................86<br>14.2.5.&nbsp;Keep&nbsp;it&nbsp;in&nbsp;the&nbsp;Channel.........................................................................................................86<br></a><a href="TLSAGs.html#93">14.2.6.&nbsp;Stay&nbsp;On&nbsp;Topic......................................................................................................................87<br>14.2.7.&nbsp;CTCPs.................................................................................................................................87<br>14.2.8.&nbsp;Hacking,&nbsp;Cracking,&nbsp;Phreaking,&nbsp;Warezing...........................................................................87<br>14.2.9.&nbsp;Round&nbsp;Up............................................................................................................................87<br>14.2.10.&nbsp;Further&nbsp;Reading.................................................................................................................87</a><br>
<a href="TLSAGs.html#94"><b>Appendix&nbsp;A.&nbsp;GNU&nbsp;Free&nbsp;Documentation&nbsp;License...........................................................................................88</b></a><br>
<a href="TLSAGs.html#94">0.&nbsp;PREAMBLE......................................................................................................................................88<br>1.&nbsp;APPLICABILITY&nbsp;AND&nbsp;DEFINITIONS..........................................................................................88<br></a><a href="TLSAGs.html#95">2.&nbsp;VERBATIM&nbsp;COPYING....................................................................................................................89<br>3.&nbsp;COPYING&nbsp;IN&nbsp;QUANTITY...............................................................................................................89<br></a><a href="TLSAGs.html#96">4.&nbsp;MODIFICATIONS............................................................................................................................90<br></a><a href="TLSAGs.html#97">5.&nbsp;COMBINING&nbsp;DOCUMENTS...........................................................................................................91<br>6.&nbsp;COLLECTIONS&nbsp;OF&nbsp;DOCUMENTS................................................................................................91<br></a><a href="TLSAGs.html#98">7.&nbsp;AGGREGATION&nbsp;WITH&nbsp;INDEPENDENT&nbsp;WORKS.......................................................................92<br>8.&nbsp;TRANSLATION................................................................................................................................92<br>9.&nbsp;TERMINATION................................................................................................................................92<br>10.&nbsp;FUTURE&nbsp;REVISIONS&nbsp;OF&nbsp;THIS&nbsp;LICENSE...................................................................................92<br></a><a href="TLSAGs.html#99">How&nbsp;to&nbsp;use&nbsp;this&nbsp;License&nbsp;for&nbsp;your&nbsp;documents.........................................................................................93</a><br>
<a href="TLSAGs.html#100"><b>Glossary&nbsp;(DRAFT,&nbsp;but&nbsp;not&nbsp;for&nbsp;long&nbsp;hopefully)..............................................................................................94</b></a><br>
iv<br>
<hr>
<A name=7></a><b>Source and pre−formatted versions available</b><br>
The source code and other machine readable formats of this book can be found on the Internet via anonymous<br><a href="http://www.tldp.org/">FTP at the Linux Documentation Project home page http://www.tldp.org/, or at the home page of this book at<br></a><a href="http://www.taylexson.org/sag//">http://www.taylexson.org/sag/. Available are at least HTML and PDF formats.</a><br>
Source and pre−formatted versions available<br>
1<br>
<hr>
<A name=8></a><b>Chapter 1. Introduction</b><br>
&quot;In the beginning, the file was without form, and void; and emptiness was upon the face of<br>the bits. And the Fingers of the Author moved upon the face of the keyboard. And the Author<br>said, Let there be words, and there were words.&quot;<br>
The Linux System Administrator's Guide, describes the system administration aspects of using Linux. It is<br>intended for people who know next to nothing about system administration (those saying &quot;what is it?&quot;), but<br>who have already mastered at least the basics of normal usage. This manual doesn't tell you how to install<br>Linux; that is described in the Installation and Getting Started document. See below for more information<br>about Linux manuals.<br>
System administration covers all the things that you have to do to keep a computer system in usable order. It<br>includes things like backing up files (and restoring them if necessary), installing new programs, creating<br>accounts for users (and deleting them when no longer needed), making certain that the filesystem is not<br>corrupted, and so on. If a computer were, say, a house, system administration would be called maintenance,<br>and would include cleaning, fixing broken windows, and other such things.<br>
The structure of this manual is such that many of the chapters should be usable independently, so if you need<br>information about backups, for example, you can read just that chapter. However, this manual is first and<br>foremost a tutorial and can be read sequentially or as a whole.<br>
This manual is not intended to be used completely independently. Plenty of the rest of the Linux<br>documentation is also important for system administrators. After all, a system administrator is just a user with<br>special privileges and duties. Very useful resources are the manual pages, which should always be consulted<br>when you are not familiar with a command. If you do not know which command you need, then the<b>&nbsp;apropos<br></b>command can be used. Consult its manual page for more details.<br>
While this manual is targeted at Linux, a general principle has been that it should be useful with other UNIX<br>based operating systems as well. Unfortunately, since there is so much variance between different versions of<br>UNIX in general, and in system administration in particular, there is little hope to cover all variants. Even<br>covering all possibilities for Linux is difficult, due to the nature of its development.<br>
There is no one official Linux distribution, so different people have different setups and many people have a<br>setup they have built up themselves. This book is not targeted at any one distribution. Distributions can and do<br>vary considerably. When possible, differences have been noted and alternatives given.<br>
In trying to describe how things work, rather than just listing &quot;five easy steps&quot; for each task, there is much<br>information here that is not necessary for everyone, but those parts are marked as such and can be skipped if<br>you use a preconfigured system. Reading everything will, naturally, increase your understanding of the system<br>and should make using and administering it more productive.&nbsp;[1]<br>
Like all other Linux related development, the work to write this manual was done on a volunteer basis: I did it<br>because I thought it might be fun and because I felt it should be done. However, like all volunteer work, there<br>is a limit to how much time, knowledge and experience people have. This means that the manual is not<br>necessarily as good as it would be if a wizard had been paid handsomely to write it and had spent millennia to<br>perfect it. Be warned.<br>
Chapter 1. Introduction<br>
2<br>
<hr>
<A name=9></a>The Linux System Administrator's Guide<br>
One particular point where corners have been cut is that many things that are already well documented in<br>other freely available manuals are not always covered here. This applies especially to program specific<br>documentation, such as all the details of using<b>&nbsp;mkfs</b>. Only the purpose of the program and as much of its<br>usage as is necessary for the purposes of this manual is described. For further information, consult these other<br>manuals. Usually, all of the referred to documentation is part of the full Linux documentation set.<br>
Chapter 1. Introduction<br>
3<br>
<hr>
<A name=10></a><b>Chapter 2. About This Book</b><br>
<b>2.1. Acknowledgments</b><br>
<b>2.1.1. Joanna's acknowledgments</b><br>
Lars has tried to make this manual as good as possible and I would like, as a current maintainer, to keep up the<br>good work. I would really like to hear from you if you have any ideas on how to make it better. Bad language,<br>factual errors, ideas for new areas to cover, rewritten sections, information about how various UNIX versions<br>do things, I am interested in all of it. My contact information is available via the World Wide Web at<br><a href="http://www.iki.fi/viu/">http://www.iki.fi/viu/.</a><br>
Many people have helped me with this book, directly or indirectly. I would like to especially thank Matt<br>Welsh for inspiration and LDP leadership, Andy Oram for getting me to work again with much−valued<br>feedback, Olaf Kirch for showing me that it can be done, and Adam Richter at Yggdrasil and others for<br>showing me that other people can find it interesting as well.<br>
Stephen Tweedie, H. Peter Anvin, Remy Card, Theodore Ts'o, and Stephen Tweedie have let me borrow their<br>work (and thus make the book look thicker and much more impressive): a comparison between the xia and<br>ext2 filesystems, the device list and a description of the ext2 filesystem. These aren't part of the book any<br>more. I am most grateful for this, and very apologetic for the earlier versions that sometimes lacked proper<br>attribution.<br>
In addition, I would like to thank Mark Komarinski for sending his material in 1993 and the many system<br>administration columns in Linux Journal. They are quite informative and inspirational.<br>
Many useful comments have been sent by a large number of people. My miniature black hole of an archive<br>doesn't let me find all their names, but some of them are, in alphabetical order: Paul Caprioli, Ales Cepek,<br>Marie−France Declerfayt, Dave Dobson, Olaf Flebbe, Helmut Geyer, Larry Greenfield and his father, Stephen<br>Harris, Jyrki Havia, Jim Haynes, York Lam, Timothy Andrew Lister, Jim Lynch, Michael J. Micek, Jacob<br>Navia, Dan Poirier, Daniel Quinlan, Jouni K Seppänen, Philippe Steindl, G.B. Stotte. My apologies to anyone<br>I have forgotten.<br>
<b>2.1.2. Stephen's acknowledgments</b><br>
I would like to thank Lars and Joanna for their hard work on the guide.<br>
In a guide like this one there are likely to be at least some minor inaccuracies. And there are almost certainly<br>going to be sections that become out of date from time to time. If you notice any of this then please let me<br>know by sending me an email to:&nbsp;<a href="mailto:bagpuss@debian.org">&lt;bagpuss@debian.org&gt;</a>. I will take virtually any form of input (diffs,<br>just plain text, html, whatever), I am in no way above allowing others to help me maintain such a large text as<br>this :)<br>
Many thanks to Helen Topping Shaw for getting the red pen out and making the text far better than it would<br>otherwise have been. Also thanks are due just for being wonderful.<br>
<a href="http://people.debian.org/~bagpuss">The current web home of the guide is http://people.debian.org/~bagpuss</a><br>
Chapter 2. About This Book<br>
4<br>
<hr>
<A name=11></a>The Linux System Administrator's Guide<br>
<b>2.1.3. Alex's Acknowledgments</b><br>
I would like to thank Lars, Joanna, and Stephen for all the great work that they have done on this document<br>over the years. I only hope that my contribution will be worthy of continuing the work they started.<br>
There have been many people who have helped me on my journey through the &quot;Windows−Free&quot; world, the<br>person I feel I need to thank the most is my first true UN*X mentor, Mike Velasco. Back in a time before<br>SCO became a &quot;dirty word&quot;, Mike helped me on the path of tar's, cpio's, and many, many man pages. Thanks<br>Mike! You are the 'Sofa King'.<br>
<b>2.2. Typographical Conventions</b><br>
Throughout this book, I have tried to use uniform typographical conventions. Hopefully they aid readability.<br>If you can suggest any improvements please contact me.<br>
Filenames are expressed as:&nbsp;/usr/share/doc/foo.<br>
Command names are expressed as:<b>&nbsp;fsck</b><br>
Email addresses are expressed as:&nbsp;<a href="mailto:stephen@clothcat.demon.co.uk">&lt;stephen@clothcat.demon.co.uk&gt;</a><br>
<a href="http://www.tldp.org">URLs are expressed as: http://www.tldp.org</a><br>
I will add to this section as things come up whilst editing. If you notice anything that should be added then<br>please let me know.<br>
Chapter 2. About This Book<br>
5<br>
<hr>
<A name=12></a><b>Chapter 3. Overview of a Linux System</b><br>
&quot;God saw everything that he had made, and saw that it was very good. &quot; −− Bible King James<br>Version. Genesis 1:31<br>
This chapter gives an overview of a Linux system. First, the major services provided by the operating system<br>are described. Then, the programs that implement these services are described with a considerable lack of<br>detail. The purpose of this chapter is to give an understanding of the system as a whole, so that each part is<br>described in detail elsewhere.<br>
<b>3.1. Various parts of an operating system</b><br>
A UNIX operating system consists of a<i>&nbsp;kernel</i>&nbsp;and some<i>&nbsp;system programs</i>. There are also some<i>&nbsp;application<br>programs</i>&nbsp;for doing work. The kernel is the heart of the operating system.&nbsp;[2] It keeps track of files on the<br>disk, starts programs and runs them concurrently, assigns memory and other resources to various processes,<br>receives packets from and sends packets to the network, and so on. The kernel does very little by itself, but it<br>provides tools with which all services can be built. It also prevents anyone from accessing the hardware<br>directly, forcing everyone to use the tools it provides.&nbsp;[3] This way the kernel provides some protection for<br>users from each other. The tools provided by the kernel are used via<i>&nbsp;system calls</i>. See manual page section 2<br>for more information on these.<br>
The system programs use the tools provided by the kernel to implement the various services required from an<br>operating system. System programs, and all other programs, run `on top of the kernel', in what is called the<br><i>user mode</i>. The difference between system and application programs is one of intent: applications are intended<br>for getting useful things done (or for playing, if it happens to be a game), whereas system programs are<br>needed to get the system working. A word processor is an application;<b>&nbsp;mount</b>&nbsp;is a system program. The<br>difference is often somewhat blurry, however, and is important only to compulsive categorizers.<br>
An operating system can also contain compilers and their corresponding libraries (GCC and the C library in<br>particular under Linux), although not all programming languages need be part of the operating system.<br>Documentation, and sometimes even games, can also be part of it. Traditionally, the operating system has<br>been defined by the contents of the installation tape or disks; with Linux it is not as clear since it is spread all<br>over the FTP sites of the world.<br>
<b>3.2. Important parts of the kernel</b><br>
The Linux kernel consists of several important parts: process management, memory management, hardware<br><a href="TLSAGs.html#12">device drivers, filesystem drivers, network management, and various other bits and pieces. Figure 3−1 shows<br></a>some of them.<br>
<b>Figure 3−1. Some of the more important parts of the Linux kernel</b><br>
Chapter 3. Overview of a Linux System<br>
6<br>
<hr>
<A name=13></a><IMG src="TLSAG-13_1.png"><br>
The Linux System Administrator's Guide<br>
Probably the most important parts of the kernel (nothing else works without them) are memory management<br>and process management. Memory management takes care of assigning memory areas and swap space areas<br>to processes, parts of the kernel, and for the buffer cache. Process management creates processes, and<br>implements multitasking by switching the active process on the processor.<br>
At the lowest level, the kernel contains a hardware device driver for each kind of hardware it supports. Since<br>the world is full of different kinds of hardware, the number of hardware device drivers is large. There are<br>often many otherwise similar pieces of hardware that differ in how they are controlled by software. The<br>similarities make it possible to have general classes of drivers that support similar operations; each member of<br>the class has the same interface to the rest of the kernel but differs in what it needs to do to implement them.<br>For example, all disk drivers look alike to the rest of the kernel, i.e., they all have operations like `initialize the<br>drive', `read sector N', and `write sector N'.<br>
Some software services provided by the kernel itself have similar properties, and can therefore be abstracted<br>into classes. For example, the various network protocols have been abstracted into one programming<br>interface, the BSD socket library. Another example is the<i>&nbsp;virtual filesystem</i>&nbsp;(VFS) layer that abstracts the<br>filesystem operations away from their implementation. Each filesystem type provides an implementation of<br>each filesystem operation. When some entity tries to use a filesystem, the request goes via the VFS, which<br>routes the request to the proper filesystem driver.<br>
<b>3.3. Major services in a UNIX system</b><br>
This section describes some of the more important UNIX services, but without much detail. They are<br>described more thoroughly in later chapters.<br>
Chapter 3. Overview of a Linux System<br>
7<br>
<hr>
<A name=14></a>The Linux System Administrator's Guide<br>
<b>3.3.1. init</b><br>
The single most important service in a UNIX system is provided by<b>&nbsp;init</b>.<b>&nbsp;init</b>&nbsp;is started as the first process of<br>every UNIX system, as the last thing the kernel does when it boots. When<b>&nbsp;init</b>&nbsp;starts, it continues the boot<br>process by doing various startup chores (checking and mounting filesystems, starting daemons, etc).<br>
The exact list of things that<b>&nbsp;init</b>&nbsp;does depends on which flavor it is; there are several to choose from.<b>&nbsp;init<br></b>usually provides the concept of<i>&nbsp;single user mode</i>, in which no one can log in and root uses a shell at the<br>console; the usual mode is called<i>&nbsp;multiuser mode</i>. Some flavors generalize this as<i>&nbsp;run levels</i>; single and<br>multiuser modes are considered to be two run levels, and there can be additional ones as well, for example, to<br>run X on the console.<br>
Linux allows for up to 10<i>&nbsp;runlevels</i>, 0−9, but usually only some of these are defined by default. Runlevel 0 is<br>defined as &quot;system halt&quot;. Runlevel 1 is defined as &quot;single user mode&quot;. Runlevel 6 is defined as &quot;system<br>reboot&quot;. Other runlevels are dependent on how your particular distribution has defined them, and they vary<br>significantly between distributions. Looking at the contents of&nbsp;/etc/inittab&nbsp;usually will give some hint<br>what the predefined runlevels are and what they have been defined as.<br>
In normal operation,<b>&nbsp;init</b>&nbsp;makes sure<b>&nbsp;getty</b>&nbsp;is working (to allow users to log in), and to adopt orphan processes<br>(processes whose parent has died; in UNIX<i>&nbsp;all</i>&nbsp;processes<i>&nbsp;must</i>&nbsp;be in a single tree, so orphans must be<br>adopted).<br>
When the system is shut down, it is<b>&nbsp;init</b>&nbsp;that is in charge of killing all other processes, unmounting all<br>filesystems and stopping the processor, along with anything else it has been configured to do.<br>
<b>3.3.2. Logins from terminals</b><br>
Logins from terminals (via serial lines) and the console (when not running X) are provided by the<b>&nbsp;getty<br></b>program.<b>&nbsp;init</b>&nbsp;starts a separate instance of<b>&nbsp;getty</b>&nbsp;for each terminal upon which logins are to be allowed.<b>&nbsp;getty<br></b>reads the username and runs the<b>&nbsp;login</b>&nbsp;program, which reads the password. If the username and password are<br>correct,<b>&nbsp;login</b>&nbsp;runs the shell. When the shell terminates, i.e., the user logs out, or when<b>&nbsp;login</b>&nbsp;terminated<br>because the username and password didn't match,<b>&nbsp;init</b>&nbsp;notices this and starts a new instance of<b>&nbsp;getty</b>. The<br>kernel has no notion of logins, this is all handled by the<i>&nbsp;system programs</i>.<br>
<b>3.3.3. Syslog</b><br>
The kernel and many<i>&nbsp;system programs</i>&nbsp;produce error, warning, and other messages. It is often important that<br>these messages can be viewed later, even much later, so they should be written to a file. The program doing<br>this is<b>&nbsp;syslog</b>. It can be configured to sort the messages to different files according to writer or degree of<br>importance. For example, kernel messages are often directed to a separate file from the others, since kernel<br>messages are often more important and need to be read regularly to spot problems.<br>
<b>3.3.4. Periodic command execution: cron and at</b><br>
Both users and system administrators often need to run commands periodically. For example, the system<br>administrator might want to run a command to clean the directories with temporary files (/tmp&nbsp;and<br>/var/tmp) from old files, to keep the disks from filling up, since not all programs clean up after themselves<br>correctly.<br>
Chapter 3. Overview of a Linux System<br>
8<br>
<hr>
<A name=15></a>The Linux System Administrator's Guide<br>
The<b>&nbsp;cron</b>&nbsp;service is set up to do this. Each user can have a&nbsp;crontab&nbsp;file, where she lists the commands she<br>wishes to execute and the times they should be executed. The<b>&nbsp;cron</b>&nbsp;daemon takes care of starting the<br>commands when specified.<br>
The<b>&nbsp;at</b>&nbsp;service is similar to<b>&nbsp;cron</b>, but it is once only: the command is executed at the given time, but it is not<br>repeated.<br>
See the manual pages cron(1), crontab(1), crontab(5), at(1) and atd(8) for more in depth information.<br>
<b>3.3.5. Graphical user interface</b><br>
UNIX and Linux don't incorporate the user interface into the kernel; instead, they let it be implemented by<br>user level programs. This applies for both text mode and graphical environments.<br>
This arrangement makes the system more flexible, but has the disadvantage that it is simple to implement a<br>different user interface for each program, making the system harder to learn.<br>
The graphical environment primarily used with Linux is called the X Window System (X for short). X also<br>does not implement a user interface; it only implements a window system, i.e., tools with which a graphical<br>user interface can be implemented. Some popular window managers are: fvwm, icewm, blackbox and<br>windowmaker. There are also two popular desktop managers, KDE and Gnome.<br>
<b>3.3.6. Networking</b><br>
Networking is the act of connecting two or more computers so that they can communicate with each other.<br>The actual methods of connecting and communicating are slightly complicated, but the end result is very<br>useful.<br>
UNIX operating systems have many networking features. Most basic services (filesystems, printing, backups,<br>etc) can be done over the network. This can make system administration easier, since it allows centralized<br>administration, while still reaping in the benefits of microcomputing and distributed computing, such as lower<br>costs and better fault tolerance.<br>
However, this book merely glances at networking; see the<i>&nbsp;Linux Network Administrators' Guide<br></i><a href="http://www.tldp.org/LDP/nag2/index.html">http://www.tldp.org/LDP/nag2/index.html for more information, including a basic description of how<br></a>networks operate.<br>
<b>3.3.7. Network logins</b><br>
Network logins work a little differently than normal logins. There is a separate physical serial line for each<br>terminal via which it is possible to log in. For each person logging in via the network, there is a separate<br>virtual network connection, and there can be any number of these.&nbsp;[4] It is therefore not possible to run a<br>separate<b>&nbsp;getty</b>&nbsp;for each possible virtual connection. There are also several different ways to log in via a<br>network,<b>&nbsp;telnet</b>&nbsp;and<b>&nbsp;rlogin</b>&nbsp;being the major ones in TCP/IP networks.&nbsp;[5]<br>
Network logins have, instead of a herd of<b>&nbsp;getty</b>s, a single daemon per way of logging in (<b>telnet</b>&nbsp;and<b>&nbsp;rlogin<br></b>have separate daemons) that listens for all incoming login attempts. When it notices one, it starts a new<br>instance of itself to handle that single attempt; the original instance continues to listen for other attempts. The<br>new instance works similarly to<b>&nbsp;getty</b>.<br>
Chapter 3. Overview of a Linux System<br>
9<br>
<hr>
<A name=16></a>The Linux System Administrator's Guide<br>
<b>3.3.8. Network file systems</b><br>
One of the more useful things that can be done with networking services is sharing files via a<i>&nbsp;network file<br>system</i>. The one usually used is called the Network File System, or NFS, developed by Sun.<br>
With a network file system any file operations done by a program on one machine are sent over the network to<br>another computer. This fools the program to think that all the files on the other computer are actually on the<br>computer the program is running on. This makes information sharing extremely simple, since it requires no<br>modifications to programs.<br>
<a href="http://www.samba.org">Another popular way of sharing files is Samba http://www.samba.org. This protocol allows the sharing of<br></a>files with MS Windows machines (via Network Neighbourhood). It also allows the sharing of printers across<br>machines.<br>
<b>3.3.9. Mail</b><br>
Electronic mail is the most popularly used method for communicating via computer. An electronic letter is<br>stored in a file using a special format, and special mail programs are used to send and read the letters.<br>
Each user has an<i>&nbsp;incoming mailbox</i>&nbsp;(a file in the special format), where all new mail is stored. When someone<br>sends mail, the mail program locates the receiver's mailbox and appends the letter to the mailbox file. If the<br>receiver's mailbox is in another machine, the letter is sent to the other machine, which delivers it to the<br>mailbox as it best sees fit.<br>
The mail system consists of many programs. The delivery of mail to local or remote mailboxes is done by one<br>program (the<i>&nbsp;mail transfer agent</i>&nbsp;(MTA), e.g.,<b>&nbsp;sendmail</b>&nbsp;or<b>&nbsp;smail</b>), while the programs users use are many and<br>varied (<i>mail user agent</i>&nbsp;(MUA), e.g.,<b>&nbsp;pine</b>,<b>&nbsp;mutt</b>&nbsp;or<b>&nbsp;elm</b>). The mailboxes are usually stored in<br>/var/spool/mail.<br>
<b>3.3.10. Printing</b><br>
Only one person can use a printer at one time, but it is uneconomical not to share printers between users. The<br>printer is therefore managed by software that implements a<i>&nbsp;print queue</i>: all print jobs are put into a queue and<br>whenever the printer is done with one job, the next one is sent to it automatically. This relieves the users from<br>organizing the print queue and fighting over control of the printer.&nbsp;[6]<br>
The print queue software also<i>&nbsp;spools</i>&nbsp;the printouts on disk, i.e., the text is kept in a file while the job is in the<br>queue. This allows an application program to spit out the print jobs quickly to the print queue software; the<br>application does not have to wait until the job is actually printed to continue. This is really convenient, since it<br>allows one to print out one version, and not have to wait for it to be printed before one can make a completely<br>revised new version.<br>
<b>3.3.11. The filesystem layout</b><br>
The filesystem is divided into many parts; usually along the lines of a root filesystem with&nbsp;/bin,&nbsp;/lib,<br>/etc,&nbsp;/dev, and a few others; a&nbsp;/usr&nbsp;filesystem with programs and unchanging data; a&nbsp;/var&nbsp;filesystem<br>with changing data (such as log files); and a&nbsp;/home&nbsp;filesystem for everyone's personal files. Depending on<br>the hardware configuration and the decisions of the system administrator, the division can be different; it can<br>
Chapter 3. Overview of a Linux System<br>
10<br>
<hr>
<A name=17></a>The Linux System Administrator's Guide<br>
even be all in one filesystem.<br>
<a href="TLSAGs.html#18">Chapter 4 describes the filesystem layout in some little detail; the Filesystem Hierarchy Standard covers it in<br></a>somewhat more detail.&nbsp;[7]<br>
Chapter 3. Overview of a Linux System<br>
11<br>
<hr>
<A name=18></a><IMG src="TLSAG-18_1.png"><br>
<b>Chapter 4. Overview of the Directory Tree</b><br>
&quot; Two days later, there was Pooh, sitting on his branch, dangling his legs, and there, beside<br>him, were four pots of honey...&quot; (A.A. Milne)<br>
This chapter describes the important parts of a standard Linux directory tree, based on the Filesystem<br>Hierarchy Standard. It outlines the normal way of breaking the directory tree into separate filesystems with<br>different purposes and gives the motivation behind this particular split. Not all Linux distributions follow this<br>standard slavishly, but it is generic enough to give you an overview.<br>
<b>4.1. Background</b><br>
This chapter is loosely based on the<i>&nbsp;Filesystems Hierarchy Standard</i>&nbsp;(FHS)&nbsp;[8] version 2.1, which attempts to<br>set a standard for how the directory tree in a Linux&nbsp;[9] system is organized. Such a standard has the advantage<br>that it will be easier to write or port software for Linux, and to administer Linux machines, since everything<br>should be in standardized places. There is no authority behind the standard that forces anyone to comply with<br>it, but it has gained the support of many Linux distributions. It is not a good idea to break with the FHS<br>without very compelling reasons. The FHS attempts to follow Unix tradition and current trends, making Linux<br>systems familiar to those with experience with other Unix systems, and vice versa.<br>
This chapter is not as detailed as the FHS. A system administrator should also read the full FHS for a<br>complete understanding.<br>
This chapter does not explain all files in detail. The intention is not to describe every file, but to give an<br>overview of the system from a filesystem point of view. Further information on each file is available<br>elsewhere in this manual or in the Linux manual pages.<br>
The full directory tree is intended to be breakable into smaller parts, each capable of being on its own disk or<br>partition, to accommodate to disk size limits and to ease backup and other system administration tasks. The<br>major parts are the root (/),&nbsp;/usr,&nbsp;/var, and&nbsp;/home<a href="TLSAGs.html#18">&nbsp;filesystems (see Figure 4−1). Each part has a different<br></a>purpose. The directory tree has been designed so that it works well in a network of Linux machines which<br>may share some parts of the filesystems over a read−only device (e.g., a CD−ROM), or over the network with<br>NFS.<br>
<b>Figure 4−1. Parts of a Unix directory tree. Dashed lines indicate partition limits.</b><br>
The roles of the different parts of the directory tree are described below.<br>
Chapter 4. Overview of the Directory Tree<br>
12<br>
<hr>
<A name=19></a>The Linux System Administrator's Guide<br>
The root filesystem is specific for each machine (it is generally stored on a local disk, although it<br>
•&nbsp;<br>
could be a ramdisk or network drive as well) and contains the files that are necessary for booting the<br>system up, and to bring it up to such a state that the other filesystems may be mounted. The contents<br>of the root filesystem will therefore be sufficient for the single user state. It will also contain tools for<br>fixing a broken system, and for recovering lost files from backups.<br>The&nbsp;<br>
•&nbsp;<br>
/usr&nbsp;filesystem contains all commands, libraries, manual pages, and other unchanging files<br>
needed during normal operation. No files in&nbsp;/usr&nbsp;should be specific for any given machine, nor<br>should they be modified during normal use. This allows the files to be shared over the network, which<br>can be cost−effective since it saves disk space (there can easily be hundreds of megabytes,<br>increasingly multiple gigabytes in&nbsp;/usr). It can make administration easier (only the master&nbsp;/usr<br>needs to be changed when updating an application, not each machine separately) to have /usr network<br>mounted. Even if the filesystem is on a local disk, it could be mounted read−only, to lessen the chance<br>of filesystem corruption during a crash.<br>The&nbsp;<br>
•&nbsp;<br>
/var&nbsp;filesystem contains files that change, such as spool directories (for mail, news, printers,<br>
etc), log files, formatted manual pages, and temporary files. Traditionally everything in&nbsp;/var&nbsp;has<br>been somewhere below&nbsp;/usr, but that made it impossible to mount&nbsp;/usr&nbsp;read−only.<br>The&nbsp;<br>
•&nbsp;<br>
/home&nbsp;filesystem contains the users' home directories, i.e., all the real data on the system.<br>
Separating home directories to their own directory tree or filesystem makes backups easier; the other<br>parts often do not have to be backed up, or at least not as often as they seldom change. A big&nbsp;/home<br>might have to be broken across several filesystems, which requires adding an extra naming level<br>below&nbsp;/home, for example&nbsp;/home/students&nbsp;and&nbsp;/home/staff.<br>
Although the different parts have been called filesystems above, there is no requirement that they actually be<br>on separate filesystems. They could easily be kept in a single one if the system is a small single−user system<br>and the user wants to keep things simple. The directory tree might also be divided into filesystems differently,<br>depending on how large the disks are, and how space is allocated for various purposes. The important part,<br>though, is that all the standard<i>&nbsp;names</i>&nbsp;work; even if, say,&nbsp;/var&nbsp;and&nbsp;/usr&nbsp;are actually on the same partition,<br>the names&nbsp;/usr/lib/libc.a&nbsp;and&nbsp;/var/log/messages&nbsp;must work, for example by moving files<br>below&nbsp;/var&nbsp;into&nbsp;/usr/var, and making&nbsp;/var&nbsp;a symlink to&nbsp;/usr/var.<br>
The Unix filesystem structure groups files according to purpose, i.e., all commands are in one place, all data<br>files in another, documentation in a third, and so on. An alternative would be to group files files according to<br>the program they belong to, i.e., all Emacs files would be in one directory, all TeX in another, and so on. The<br>problem with the latter approach is that it makes it difficult to share files (the program directory often contains<br>both static and sharable and changing and non−sharable files), and sometimes to even find the files (e.g.,<br>manual pages in a huge number of places, and making the manual page programs find all of them is a<br>maintenance nightmare).<br>
<b>4.2. The root filesystem</b><br>
The root filesystem should generally be small, since it contains very critical files and a small, infrequently<br>modified filesystem has a better chance of not getting corrupted. A corrupted root filesystem will generally<br>mean that the system becomes unbootable except with special measures (e.g., from a floppy), so you don't<br>want to risk it.<br>
The root directory generally doesn't contain any files, except perhaps the standard boot image for the system,<br>usually called&nbsp;/vmlinuz. All other files are in subdirectories in the root filesystems:<br>
<i><b>/bin</b></i><br>
Commands needed during bootup that might be used by normal users (probably after bootup).<br>
Chapter 4. Overview of the Directory Tree<br>
13<br>
<hr>
<A name=20></a>The Linux System Administrator's Guide<br>
<i><b>/sbin</b></i><br>
Like&nbsp;/bin, but the commands are not intended for normal users, although they may use them if<br>necessary and allowed.&nbsp;/sbin&nbsp;is not usually in the default path of normal users, but will be in root's<br>default path.<br>
<i><b>/etc</b></i><br>
Configuration files specific to the machine.<br>
<i><b>/root</b></i><br>
The home directory for user root. This is usually not accessible to other users on the system<br>
<i><b>/lib</b></i><br>
Shared libraries needed by the programs on the root filesystem.<br>
<i><b>/lib/modules</b></i><br>
Loadable kernel modules, especially those that are needed to boot the system when recovering from<br>disasters (e.g., network and filesystem drivers).<br>
<i><b>/dev</b></i><br>
<a href="TLSAGs.html#25">Device files. Some of the more commonly used device files are examined in Chapter 5</a><br>
<i><b>/tmp</b></i><br>
Temporary files. Programs running after bootup should use&nbsp;/var/tmp, not&nbsp;/tmp, since the former<br>is probably on a disk with more space. Often /tmp will be a symbolic link to /var/tmp.<br>
<i><b>/boot</b></i><br>
Files used by the bootstrap loader, e.g., LILO. Kernel images are often kept here instead of in the root<br>directory. If there are many kernel images, the directory can easily grow rather big, and it might be<br>better to keep it in a separate filesystem. Another reason would be to make sure the kernel images are<br>within the first 1024 cylinders of an IDE disk.&nbsp;[10]<br>
<i><b>/mnt</b></i><br>
Mount point for temporary mounts by the system administrator. Programs aren't supposed to mount<br>on&nbsp;/mnt&nbsp;automatically.&nbsp;/mnt&nbsp;might be divided into subdirectories (e.g.,&nbsp;/mnt/dosa&nbsp;might be the<br>floppy drive using an MS−DOS filesystem, and&nbsp;/mnt/exta&nbsp;might be the same with an ext2<br>filesystem).<br>
<i><b>/proc,&nbsp;/usr,&nbsp;/var,&nbsp;/home</b></i><br>
Mount points for the other filesystems.&nbsp;[11]<br>
<b>4.3. The&nbsp;/etc&nbsp;directory</b><br>
The&nbsp;/etc&nbsp;directory contains a lot of files. Some of them are described below. For others, you should<br>determine which program they belong to and read the manual page for that program. Many networking<br>configuration files are in&nbsp;/etc&nbsp;as well, and are described in the<i>&nbsp;Networking Administrators' Guide</i>.<br>
<i><b>/etc/rc&nbsp;or&nbsp;/etc/rc.d&nbsp;or&nbsp;/etc/rc?.d</b></i><br>
<a href="TLSAGs.html#63">Scripts or directories of scripts to run at startup or when changing the run level. See Chapter 9 for<br></a>further information.<br>
<i><b>/etc/passwd</b></i><br>
The user database, with fields giving the username, real name, home directory, encrypted password,<br>and other information about each user. The format is documented in the<b>&nbsp;passwd</b>&nbsp;manual page. The<br>encrypted passwords are much more commonly found in the&nbsp;/etc/shadow&nbsp;these days. This means<br>that almost everything about the user<i>&nbsp;except</i>&nbsp;the password is stored in the&nbsp;passwd&nbsp;file. History and<br>convention make a name change undesirable.<br>
<i><b>/etc/fdprm</b></i><br>
Floppy disk parameter table. Describes what different floppy disk formats look like. Used by<br><b>setfdprm</b>. See the<b>&nbsp;setfdprm</b>&nbsp;manual page for more information.<br>
<i><b>/etc/fstab</b></i><br>
Chapter 4. Overview of the Directory Tree<br>
14<br>
<hr>
<A name=21></a>The Linux System Administrator's Guide<br>
Lists the filesystems mounted automatically at startup by the<b>&nbsp;mount −a</b>&nbsp;command (in&nbsp;/etc/rc&nbsp;or<br>equivalent startup file). Under Linux, also contains information about swap areas used automatically<br>by<b>&nbsp;swapon −a</b><a href="TLSAGs.html#42">. See Section 6.8.5 and the</a><b>&nbsp;mount</b>&nbsp;manual page for more information. Also&nbsp;fstab<br>usually has its own manual page in section 5.<br>
<i><b>/etc/group</b></i><br>
Similar to&nbsp;/etc/passwd, but describes groups instead of users. See the&nbsp;group&nbsp;manual page in<br>section 5 for more information.<br>
<i><b>/etc/inittab</b></i><br>
Configuration file for<b>&nbsp;init</b>.<br>
<i><b>/etc/issue</b></i><br>
Output by<b>&nbsp;getty</b>&nbsp;before the login prompt. Usually contains a short description or welcoming message<br>to the system. The contents are up to the system administrator.<br>
<i><b>/etc/magic</b></i><br>
The configuration file for<b>&nbsp;file</b>. Contains the descriptions of various file formats based on which<b>&nbsp;file<br></b>guesses the type of the file. See the&nbsp;magic&nbsp;and<b>&nbsp;file</b>&nbsp;manual pages for more information.<br>
<i><b>/etc/motd</b></i><br>
The message of the day, automatically output after a successful login. Contents are up to the system<br>administrator. Often used for getting information to every user, such as warnings about planned<br>downtimes.<br>
<i><b>/etc/mtab</b></i><br>
List of currently mounted filesystems. Initially set up by the bootup scripts, and updated automatically<br>by the<b>&nbsp;mount</b>&nbsp;command. Used when a list of mounted filesystems is needed, e.g., by the<b>&nbsp;df</b>&nbsp;command.<br>
<i><b>/etc/shadow</b></i><br>
Shadow password file on systems with shadow password software installed. Shadow passwords move<br>the encrypted password from&nbsp;/etc/passwd&nbsp;into&nbsp;/etc/shadow; the latter is not readable by<br>anyone except root. This makes it harder to crack passwords. If your distribution gives you a choice<br>(many do) of whether or not to use shadow passwords then you are highly recommended to do so.<br>
<i><b>/etc/login.defs</b></i><br>
Configuration file for the<b>&nbsp;login</b>&nbsp;command. The&nbsp;login.defs&nbsp;file usually has a manual page in<br>section 5.<br>
<i><b>/etc/printcap</b></i><br>
Like&nbsp;/etc/termcap, but intended for printers. However it uses different syntax. The&nbsp;printcap<br>has a manual page in section 5.<br>
<i><b>/etc/profile,&nbsp;/etc/csh.login,&nbsp;/etc/csh.cshrc</b></i><br>
Files executed at login or startup time by the Bourne or C shells. These allow the system administrator<br>to set global defaults for all users. See the manual pages for the respective shells.<br>
<i><b>/etc/securetty</b></i><br>
Identifies secure terminals, i.e., the terminals from which root is allowed to log in. Typically only the<br>virtual consoles are listed, so that it becomes impossible (or at least harder) to gain superuser<br>privileges by breaking into a system over a modem or a network. Do not allow root logins over a<br>network. Prefer to log in as an unprivileged user and use<b>&nbsp;su</b>&nbsp;or<b>&nbsp;sudo</b>&nbsp;to gain root privileges.<br>
<i><b>/etc/shells</b></i><br>
Lists trusted shells. The<b>&nbsp;chsh</b>&nbsp;command allows users to change their login shell only to shells listed in<br>this file.<b>&nbsp;ftpd</b>, the server process that provides FTP services for a machine, will check that the user's<br>shell is listed in&nbsp;/etc/shells&nbsp;and will not let people log in unless the shell is listed there.<br>
<i><b>/etc/termcap</b></i><br>
The terminal capability database. Describes by what &quot;escape sequences&quot; various terminals can be<br>controlled. Programs are written so that instead of directly outputting an escape sequence that only<br>works on a particular brand of terminal, they look up the correct sequence to do whatever it is they<br>want to do in&nbsp;/etc/termcap. As a result most programs work with most kinds of terminals. See<br>the&nbsp;termcap, curs_termcap, and&nbsp;terminfo&nbsp;manual pages for more information.<br>
Chapter 4. Overview of the Directory Tree<br>
15<br>
<hr>
<A name=22></a>The Linux System Administrator's Guide<br>
<b>4.4. The&nbsp;/dev&nbsp;directory</b><br>
The&nbsp;/dev&nbsp;directory contains the special device files for all the devices. The device files are named using<br><a href="TLSAGs.html#25">special conventions; these are described in Chapter 5. The device files are created during installation, and later<br></a>with the<b>&nbsp;/dev/MAKEDEV</b>&nbsp;script. The<b>&nbsp;/dev/MAKEDEV.local</b>&nbsp;is a script written by the system administrator<br>that creates local−only device files or links (i.e. those that are not part of the standard<b>&nbsp;MAKEDEV</b>, such as<br>device files for some non−standard device driver).<br>
<b>4.5. The&nbsp;/usr&nbsp;filesystem</b><br>
The&nbsp;/usr&nbsp;filesystem is often large, since all programs are installed there. All files in&nbsp;/usr&nbsp;usually come<br>from a Linux distribution; locally installed programs and other stuff goes below&nbsp;/usr/local. This makes it<br>possible to update the system from a new version of the distribution, or even a completely new distribution,<br>without having to install all programs again. Some of the subdirectories of&nbsp;/usr&nbsp;are listed below (some of the<br>less important directories have been dropped; see the FSSTND for more information).<br>
<i><b>/usr/X11R6</b></i><br>
The X Window System, all files. To simplify the development and installation of X, the X files have<br>not been integrated into the rest of the system. There is a directory tree below&nbsp;/usr/X11R6&nbsp;similar<br>to that below&nbsp;/usr&nbsp;itself.<br>
<i><b>/usr/bin</b></i><br>
Almost all user commands. Some commands are in&nbsp;/bin&nbsp;or in&nbsp;/usr/local/bin.<br>
<i><b>/usr/sbin</b></i><br>
System administration commands that are not needed on the root filesystem, e.g., most server<br>programs.<br>
<i><b>/usr/share/man,&nbsp;/usr/share/info,&nbsp;/usr/share/doc</b></i><br>
Manual pages, GNU Info documents, and miscellaneous other documentation files, respectively.<br>
<i><b>/usr/include</b></i><br>
Header files for the C programming language. This should actually be below&nbsp;/usr/lib&nbsp;for<br>consistency, but the tradition is overwhelmingly in support for this name.<br>
<i><b>/usr/lib</b></i><br>
Unchanging data files for programs and subsystems, including some site−wide configuration files.<br>The name&nbsp;lib&nbsp;comes from library; originally libraries of programming subroutines were stored in<br>/usr/lib.<br>
<i><b>/usr/local</b></i><br>
The place for locally installed software and other files. Distributions may not install anything in here.<br>It is reserved solely for the use of the local administrator. This way he can be absolutely certain that<br>no updates or upgrades to his distribution will overwrite any extra software he has installed locally.<br>
<b>4.6. The&nbsp;/var&nbsp;filesystem</b><br>
The&nbsp;/var&nbsp;contains data that is changed when the system is running normally. It is specific for each system,<br>i.e., not shared over the network with other computers.<br>
<i><b>/var/cache/man</b></i><br>
A cache for man pages that are formatted on demand. The source for manual pages is usually stored<br>in&nbsp;/usr/share/man/man?/&nbsp;(where ? is the manual section. See the manual page for<b>&nbsp;man</b>&nbsp;in<br>section 7); some manual pages might come with a pre−formatted version, which might be stored in<br>
Chapter 4. Overview of the Directory Tree<br>
16<br>
<hr>
<A name=23></a>The Linux System Administrator's Guide<br>
/usr/share/man/cat*. Other manual pages need to be formatted when they are first viewed;<br>the formatted version is then stored in&nbsp;/var/cache/man&nbsp;so that the next person to view the same<br>page won't have to wait for it to be formatted.<br>
<i><b>/var/games</b></i><br>
Any variable data belonging to games in&nbsp;/usr&nbsp;should be placed here. This is in case /usr is mounted<br>read only.<br>
<i><b>/var/lib</b></i><br>
Files that change while the system is running normally.<br>
<i><b>/var/local</b></i><br>
Variable data for programs that are installed in&nbsp;/usr/local&nbsp;(i.e., programs that have been installed<br>by the system administrator). Note that even locally installed programs should use the other&nbsp;/var<br>directories if they are appropriate, e.g.,&nbsp;/var/lock.<br>
<i><b>/var/lock</b></i><br>
Lock files. Many programs follow a convention to create a lock file in&nbsp;/var/lock&nbsp;to indicate that<br>they are using a particular device or file. Other programs will notice the lock file and won't attempt to<br>use the device or file.<br>
<i><b>/var/log</b></i><br>
Log files from various programs, especially<b>&nbsp;login</b>&nbsp;(/var/log/wtmp, which logs all logins and<br>logouts into the system) and<b>&nbsp;syslog</b>&nbsp;(/var/log/messages, where all kernel and system program<br>message are usually stored). Files in&nbsp;/var/log&nbsp;can often grow indefinitely, and may require<br>cleaning at regular intervals.<br>
<i><b>/var/mail</b></i><br>
This is the FHS approved location for user mailbox files. Depending on how far your distribution has<br>gone towards FHS compliance, these files may still be held in&nbsp;/var/spool/mail.<br>
<i><b>/var/run</b></i><br>
Files that contain information about the system that is valid until the system is next booted. For<br>example,&nbsp;/var/run/utmp&nbsp;contains information about people currently logged in.<br>
<i><b>/var/spool</b></i><br>
Directories for news, printer queues, and other queued work. Each different spool has its own<br>subdirectory below&nbsp;/var/spool, e.g., the news spool is in&nbsp;/var/spool/news. Note that some<br>installations which are not fully compliant with the latest version of the FHS may have user mailboxes<br>under&nbsp;/var/spool/mail.<br>
<i><b>/var/tmp</b></i><br>
Temporary files that are large or that need to exist for a longer time than what is allowed for&nbsp;/tmp.<br>(Although the system administrator might not allow very old files in&nbsp;/var/tmp&nbsp;either.)<br>
<b>4.7. The&nbsp;/proc&nbsp;filesystem</b><br>
The&nbsp;/proc&nbsp;filesystem contains a illusionary filesystem. It does not exist on a disk. Instead, the kernel creates<br>it in memory. It is used to provide information about the system (originally about processes, hence the name).<br>Some of the more important files and directories are explained below. The&nbsp;/proc&nbsp;filesystem is described in<br>more detail in the&nbsp;proc&nbsp;manual page.<br>
<i><b>/proc/1</b></i><br>
A directory with information about process number 1. Each process has a directory below&nbsp;/proc<br>with the name being its process identification number.<br>
<i><b>/proc/cpuinfo</b></i><br>
Information about the processor, such as its type, make, model, and performance.<br>
<i><b>/proc/devices</b></i><br>
List of device drivers configured into the currently running kernel.<br>
Chapter 4. Overview of the Directory Tree<br>
17<br>
<hr>
<A name=24></a>The Linux System Administrator's Guide<br>
<i><b>/proc/dma</b></i><br>
Shows which DMA channels are being used at the moment.<br>
<i><b>/proc/filesystems</b></i><br>
Filesystems configured into the kernel.<br>
<i><b>/proc/interrupts</b></i><br>
Shows which interrupts are in use, and how many of each there have been.<br>
<i><b>/proc/ioports</b></i><br>
Which I/O ports are in use at the moment.<br>
<i><b>/proc/kcore</b></i><br>
An image of the physical memory of the system. This is exactly the same size as your physical<br>memory, but does not really take up that much memory; it is generated on the fly as programs access<br>it. (Remember: unless you copy it elsewhere, nothing under&nbsp;/proc&nbsp;takes up any disk space at all.)<br>
<i><b>/proc/kmsg</b></i><br>
Messages output by the kernel. These are also routed to<b>&nbsp;syslog</b>.<br>
<i><b>/proc/ksyms</b></i><br>
Symbol table for the kernel.<br>
<i><b>/proc/loadavg</b></i><br>
The `load average' of the system; three meaningless indicators of how much work the system has to<br>do at the moment.<br>
<i><b>/proc/meminfo</b></i><br>
Information about memory usage, both physical and swap.<br>
<i><b>/proc/modules</b></i><br>
Which kernel modules are loaded at the moment.<br>
<i><b>/proc/net</b></i><br>
Status information about network protocols.<br>
<i><b>/proc/self</b></i><br>
A symbolic link to the process directory of the program that is looking at&nbsp;/proc. When two<br>processes look at&nbsp;/proc, they get different links. This is mainly a convenience to make it easier for<br>programs to get at their process directory.<br>
<i><b>/proc/stat</b></i><br>
Various statistics about the system, such as the number of page faults since the system was booted.<br>
<i><b>/proc/uptime</b></i><br>
The time the system has been up.<br>
<i><b>/proc/version</b></i><br>
The kernel version.<br>
Note that while the above files tend to be easily readable text files, they can sometimes be formatted in a way<br>that is not easily digestible. There are many commands that do little more than read the above files and format<br>them for easier understanding. For example, the<b>&nbsp;free</b>&nbsp;program reads&nbsp;/proc/meminfo&nbsp;and converts the<br>amounts given in bytes to kilobytes (and adds a little more information, as well).<br>
Chapter 4. Overview of the Directory Tree<br>
18<br>
<hr>
<A name=25></a><b>Chapter 5. Device Files</b><br>
This chapter gives an overview of what a device file is, and how to create one. It also lists some of the more<br>common device files. The canonical list of device files is<br>/usr/src/linux/Documentation/devices.txt&nbsp;if you have the Linux kernel source code installed<br>on your system. The devices listed here are correct as of kernel version 2.2.17.<br>
<b>5.1. The MAKEDEV Script</b><br>
Most device files will already be created and will be there ready to use after you install your Linux system. If<br>by some chance you need to create one which is not provided then you should first try to use the<b>&nbsp;MAKEDEV<br></b>script. This script is usually located in&nbsp;/dev/MAKEDEV&nbsp;but might also have a copy (or a symbolic link) in<br>/sbin/MAKEDEV. If it turns out not to be in your path then you will need to specify the path to it explicitly.<br>
In general the command is used as:<br>
#&nbsp;<b>/dev/MAKEDEV −v ttyS0</b><br>
create ttyS0 &nbsp; c 4 64 root:dialout 0660<br>
This will create the device file&nbsp;/dev/ttyS0&nbsp;with major node 4 and minor node 64 as a character device<br>with access permissions 0660 with owner root and group dialout.<br>
ttyS0&nbsp;is a serial port. The major and minor node numbers are numbers understood by the kernel. The kernel<br>refers to hardware devices as numbers, this would be very difficult for us to remember, so we use filenames.<br>Access permissions of 0660 means read and write permission for the owner (root in this case) and read and<br>write permission for members of the group (dialout in this case) with no access for anyone else.<br>
<b>5.2. The mknod command</b><br>
<b>MAKEDEV</b>&nbsp;is the preferred way of creating device files which are not present. However sometimes the<br><b>MAKEDEV</b>&nbsp;script will not know about the device file you wish to create. This is where the<b>&nbsp;mknod</b>&nbsp;command<br>comes in. In order to use<b>&nbsp;mknod</b>&nbsp;you need to know the major and minor node numbers for the device you<br>wish to create. The&nbsp;devices.txt&nbsp;file in the kernel source documentation is the canonical source of this<br>information.<br>
To take an example, let us suppose that our version of the<b>&nbsp;MAKEDEV</b>&nbsp;script does not know how to create the<br>/dev/ttyS0&nbsp;device file. We need to use<b>&nbsp;mknod</b>&nbsp;to create it. We know from looking at the&nbsp;devices.txt<br>file that it should be a character device with major number 4 and minor number 64. So we now know all we<br>need to create the file.<br>
#&nbsp;<b>mknod /dev/ttyS0 c 4 64</b><br>
#&nbsp;<b>chown root.dialout /dev/ttyS0</b><br>
#&nbsp;<b>chmod 0644 /dev/ttyS0</b><br>
#&nbsp;<b>ls −l /dev/ttyS0</b><br>
crw−rw−−−− &nbsp; 1 root dialout &nbsp; &nbsp;4, &nbsp; 64 Oct 23 18:23 /dev/ttyS0<br>
As you can see, many more steps are required to create the file. In this example you can see the process<br>required however. It is unlikely in the extreme that the ttyS0 file would not be provided by the<b>&nbsp;MAKEDEV</b><br>
Chapter 5. Device Files<br>
19<br>
<hr>
<A name=26></a>The Linux System Administrator's Guide<br>
script, but it suffices to illustrate the point.<br>
<b>5.3. Device List</b><br>
This list which follows is by no means exhaustive or as detailed as it could be. Many of these device files will<br>need support compiled into your kernel for the hardware. Read the kernel documentation to find details of any<br>particular device.<br>
If you think there are other devices which should be included here but aren't then let me know. I will try to<br>include them in the next revision.<br>
<i><b>/dev/dsp</b></i><br>
Digital Signal Processor. Basically this forms the interface between software which produces sound<br>and your soundcard. It is a character device on major node 14 and minor 3.<br>
<i><b>/dev/fd0</b></i><br>
The first floppy drive. If you are lucky enough to have several drives then they will be numbered<br>sequentially. It is a character device on major node 2 and minor 0.<br>
<i><b>/dev/fb0</b></i><br>
The first framebuffer device. A framebuffer is an abstraction layer between software and graphics<br>hardware. This means that applications do not need to know about what kind of hardware you have<br>but merely how to communicate with the framebuffer driver's API (Application Programming<br>Interface) which is well defined and standardised. The framebuffer is a character device and is on<br>major node 29 and minor 0.<br>
<i><b>/dev/hda</b></i><br>
/dev/hda&nbsp;is the master IDE drive on the primary IDE controller.&nbsp;/dev/hdb&nbsp;is the slave drive on<br>the primary controller.&nbsp;/dev/hdc&nbsp;and&nbsp;/dev/hdd&nbsp;are the master and slave devices on the secondary<br>controller respectively. Each disk is divided into partitions. Partitions 1−4 are primary partitions and<br>partitions 5 and above are logical partitions inside extended partitions. Therefore the device file which<br>references each partition is made up of several parts. For example&nbsp;/dev/hdc9&nbsp;references partition 9<br>(a logical partition inside an extended partition type) on the master IDE drive on the secondary IDE<br>controller. The major and minor node numbers are somewhat complex. For the first IDE controller all<br>partitions are block devices on major node 3. The master drive&nbsp;hda&nbsp;is at minor 0 and the slave drive<br>hdb&nbsp;is at minor 64. For each partition inside the drive add the partition number to the minor node<br>number for the drive. For example&nbsp;/dev/hdb5&nbsp;is major 3, minor 69 (64 + 5 = 69). Drives on the<br>secondary interface are handled the same way, but with major node 22.<br>
<i><b>/dev/ht0</b></i><br>
The first IDE tape drive. Subsequent drives are numbered&nbsp;ht1&nbsp;etc. They are character devices on<br>major node 37 and start at minor node 0 for&nbsp;ht0&nbsp;1 for&nbsp;ht1&nbsp;etc.<br>
<i><b>/dev/js0</b></i><br>
The first analogue joystick. Subsequent joysticks are numbered&nbsp;js1,&nbsp;js2&nbsp;etc. Digital joysticks are<br>called&nbsp;djs0,&nbsp;djs1&nbsp;and so on. They are character devices on major node 15. The analogue joysticks<br>start at minor node 0 and go up to 127 (more than enough for even the most fanatic gamer). Digital<br>joysticks start at minor node 128.<br>
<i><b>/dev/lp0</b></i><br>
The first parallel printer device. Subsequent printers are numbered&nbsp;lp1,&nbsp;lp2&nbsp;etc. They are character<br>devices on major mode 6 and minor nodes starting at 0 and numbered sequentially.<br>
<i><b>/dev/loop0</b></i><br>
The first loopback device. Loopback devices are used for mounting filesystems which are not located<br>on other block devices such as disks. For example if you wish to mount an iso9660 CD ROM image<br>without burning it to CD then you need to use a loopback device to do so. This is usually transparent<br>
Chapter 5. Device Files<br>
20<br>
<hr>
<A name=27></a>The Linux System Administrator's Guide<br>
to the user and is handled by the<b>&nbsp;mount</b>&nbsp;command. Refer to the manual pages for<b>&nbsp;mount</b>&nbsp;and<b>&nbsp;losetup</b>.<br>The loopback devices are block devices on major node 7 and with minor nodes starting at 0 and<br>numbered sequentially.<br>
<i><b>/dev/md0</b></i><br>
First metadisk group. Metadisks are related to RAID (Redundant Array of Independent Disks)<br>devices. Please refer to the various RAID HOWTOs at the LDP for more details. Metadisk devices<br>are block devices on major node 9 with minor nodes starting at 0 and numbered sequentially.<br>
<i><b>/dev/mixer</b></i><br>
This is part of the OSS (Open Sound System) driver. Refer to the OSS documentation at<br><a href="http://www.opensound.com">http://www.opensound.com for more details. It is a character device on major node 14, minor node 0.</a><br>
<i><b>/dev/null</b></i><br>
The bit bucket. A black hole where you can send data for it never to be seen again. Anything sent to<br>/dev/null&nbsp;will disappear. This can be useful if, for example, you wish to run a command but not<br>have any feedback appear on the terminal. It is a character device on major node 1 and minor node 3.<br>
<i><b>/dev/psaux</b></i><br>
The PS/2 mouse port. This is a character device on major node 10, minor node 1.<br>
<i><b>/dev/pda</b></i><br>
Parallel port IDE disks. These are named similarly to disks on the internal IDE controllers<br>(/dev/hd*). They are block devices on major node 45. Minor nodes need slightly more explanation<br>here. The first device is&nbsp;/dev/pda&nbsp;and it is on minor node 0. Partitions on this device are found by<br>adding the partition number to the minor number for the device. Each device is limited to 15 partitions<br>each rather than 63 (the limit for internal IDE disks).&nbsp;/dev/pdb&nbsp;minor nodes start at 16,&nbsp;/dev/pdc<br>at 32 and&nbsp;/dev/pdd&nbsp;at 48. So for example the minor node number for&nbsp;/dev/pdc6&nbsp;would be 38<br>(32 + 6 = 38). This scheme limits you to 4 parallel disks of 15 partitions each.<br>
<i><b>/dev/pcd0</b></i><br>
Parallel port CD ROM drives. These are numbered from 0 onwards. All are block devices on major<br>node 46.&nbsp;/dev/pcd0&nbsp;is on minor node 0 with subsequent drives being on minor nodes 1, 2, 3 etc.<br>
<i><b>/dev/pt0</b></i><br>
Parallel port tape devices. Tapes do not have partitions so these are just numbered sequentially. They<br>are character devices on major node 96. The minor node numbers start from 0 for&nbsp;/dev/pt0, 1 for<br>/dev/pt1, and so on.<br>
<i><b>/dev/parport0</b></i><br>
The raw parallel ports. Most devices which are attached to parallel ports have their own drivers. This<br>is a device to access the port directly. It is a character device on major node 99 with minor node 0.<br>Subsequent devices after the first are numbered sequentially incrementing the minor node.<br>
<i><b>/dev/random&nbsp;or&nbsp;/dev/urandom</b></i><br>
These are kernel random number generators.&nbsp;/dev/random&nbsp;is a non−deterministic generator which<br>means that the value of the next number cannot be guessed from the preceding ones. It uses the<br>entropy of the system hardware to generate numbers. When it has no more entropy to use then it must<br>wait until it has collected more before it will allow any more numbers to be read from it.<br>/dev/urandom&nbsp;works similarly. Initially it also uses the entropy of the system hardware, but when<br>there is no more entropy to use it will continue to return numbers using a pseudo random number<br>generating formula. This is considered to be less secure for vital purposes such as cryptographic key<br>pair generation. If security is your overriding concern then use&nbsp;/dev/random, if speed is more<br>important then&nbsp;/dev/urandom&nbsp;works fine. They are character devices on major node 1 with minor<br>nodes 8 for&nbsp;/dev/random&nbsp;and 9 for&nbsp;/dev/urandom.<br>
<i><b>/dev/zero</b></i><br>
This is a simple way of getting many 0s. Every time you read from this device it will return 0. This<br>can be useful sometimes, for example when you want a file of fixed length but don't really care what<br>it contains. It is a character device on major node 1 and minor node 5.<br>
Chapter 5. Device Files<br>
21<br>
<hr>
<A name=28></a><b>Chapter 6. Using Disks and Other Storage Media</b><br>
&quot;On a clear disk you can seek forever. &quot;<br>
When you install or upgrade your system, you need to do a fair amount of work on your disks. You have to<br>make filesystems on your disks so that files can be stored on them and reserve space for the different parts of<br>your system.<br>
This chapter explains all these initial activities. Usually, once you get your system set up, you won't have to<br>go through the work again, except for using floppies. You'll need to come back to this chapter if you add a<br>new disk or want to fine−tune your disk usage.<br>
The basic tasks in administering disks are:<br>
Format your disk. This does various things to prepare it for use, such as checking for bad sectors.<br>
•&nbsp;<br>
(Formatting is nowadays not necessary for most hard disks.)<br>Partition a hard disk, if you want to use it for several activities that aren't supposed to interfere with<br>
•&nbsp;<br>
one another. One reason for partitioning is to store different operating systems on the same disk.<br>Another reason is to keep user files separate from system files, which simplifies back−ups and helps<br>protect the system files from corruption.<br>Make a filesystem (of a suitable type) on each disk or partition. The disk means nothing to Linux until<br>
•&nbsp;<br>
you make a filesystem; then files can be created and accessed on it.<br>Mount different filesystems to form a single tree structure, either automatically, or manually as<br>
•&nbsp;<br>
needed. (Manually mounted filesystems usually need to be unmounted manually as well.)<br>
<a href="TLSAGs.html#52">Chapter 7 contains information about virtual memory and disk caching, of which you also need to be aware<br></a>when using disks.<br>
<b>6.1. Two kinds of devices</b><br>
UNIX, and therefore Linux, recognizes two different kinds of device: random−access block devices (such as<br>disks), and character devices (such as tapes and serial lines), some of which may be serial, and some<br>random−access. Each supported device is represented in the filesystem as a<i>&nbsp;device file</i>. When you read or<br>write a device file, the data comes from or goes to the device it represents. This way no special programs (and<br>no special application programming methodology, such as catching interrupts or polling a serial port) are<br>necessary to access devices; for example, to send a file to the printer, one could just say<br>
$&nbsp;<b>cat filename &gt; /dev/lp1</b><br>
$<br>
and the contents of the file are printed (the file must, of course, be in a form that the printer understands).<br>However, since it is not a good idea to have several people cat their files to the printer at the same time, one<br>usually uses a special program to send the files to be printed (usually<b>&nbsp;lpr</b>). This program makes sure that only<br>one file is being printed at a time, and will automatically send files to the printer as soon as it finishes with the<br>previous file. Something similar is needed for most devices. In fact, one seldom needs to worry about device<br>files at all.<br>
Since devices show up as files in the filesystem (in the&nbsp;/dev&nbsp;directory), it is easy to see just what device files<br>
Chapter 6. Using Disks and Other Storage Media<br>
22<br>
<hr>
<A name=29></a>The Linux System Administrator's Guide<br>
exist, using<b>&nbsp;ls</b>&nbsp;or another suitable command. In the output of<b>&nbsp;ls −l</b>, the first column contains the type of the file<br>and its permissions. For example, inspecting a serial device might give<br>
$&nbsp;<b>ls −l /dev/ttyS0</b><br>
crw−rw−r−− &nbsp; &nbsp;1 root &nbsp; &nbsp; dialout &nbsp; &nbsp;4, &nbsp;64 Aug 19 18:56 /dev/ttyS0<br>
$<br>
The first character in the first column, i.e., `c' in&nbsp;crw−rw−rw−&nbsp;above, tells an informed user the type of the<br>file, in this case a character device. For ordinary files, the first character is `−', for directories it is `d', and for<br>block devices `b'; see the<b>&nbsp;ls</b>&nbsp;man page for further information.<br>
Note that usually all device files exist even though the device itself might be not be installed. So just because<br>you have a file&nbsp;/dev/sda, it doesn't mean that you really do have an SCSI hard disk. Having all the device<br>files makes the installation programs simpler, and makes it easier to add new hardware (there is no need to<br>find out the correct parameters for and create the device files for the new device).<br>
<b>6.2. Hard disks</b><br>
This subsection introduces terminology related to hard disks. If you already know the terms and concepts, you<br>can skip this subsection.<br>
<a href="TLSAGs.html#29">See Figure 6−1 for a schematic picture of the important parts in a hard disk. A hard disk consists of one or<br></a>more circular<i>&nbsp;platters</i>,&nbsp;[12] of which either or both<i>&nbsp;surfaces</i>&nbsp;are coated with a magnetic substance used for<br>recording the data. For each surface, there is a<i>&nbsp;read−write head</i>&nbsp;that examines or alters the recorded data. The<br>platters rotate on a common axis; typical rotation speed is 5400 or 7200 rotations per minute, although<br>high−performance hard disks have higher speeds and older disks may have lower speeds. The heads move<br>along the radius of the platters; this movement combined with the rotation of the platters allows the head to<br>access all parts of the surfaces.<br>
The processor (CPU) and the actual disk communicate through a<i>&nbsp;disk controller</i>. This relieves the rest of the<br>computer from knowing how to use the drive, since the controllers for different types of disks can be made to<br>use the same interface towards the rest of the computer. Therefore, the computer can say just &quot;hey disk, give<br>me what I want&quot;, instead of a long and complex series of electric signals to move the head to the proper<br>location and waiting for the correct position to come under the head and doing all the other unpleasant stuff<br>necessary. (In reality, the interface to the controller is still complex, but much less so than it would otherwise<br>be.) The controller may also do other things, such as caching, or automatic bad sector replacement.<br>
The above is usually all one needs to understand about the hardware. There are also other things, such as the<br>motor that rotates the platters and moves the heads, and the electronics that control the operation of the<br>mechanical parts, but they are mostly not relevant for understanding the working principles of a hard disk.<br>
The surfaces are usually divided into concentric rings, called<i>&nbsp;tracks</i>, and these in turn are divided into<i>&nbsp;sectors</i>.<br>This division is used to specify locations on the hard disk and to allocate disk space to files. To find a given<br>place on the hard disk, one might say &quot;surface 3, track 5, sector 7&quot;. Usually the number of sectors is the same<br>for all tracks, but some hard disks put more sectors in outer tracks (all sectors are of the same physical size, so<br>more of them fit in the longer outer tracks). Typically, a sector will hold 512 bytes of data. The disk itself<br>can't handle smaller amounts of data than one sector.<br>
<b>Figure 6−1. A schematic picture of a hard disk.</b><br>
Chapter 6. Using Disks and Other Storage Media<br>
23<br>
<hr>
<A name=30></a><IMG src="TLSAG-30_1.png"><br>
The Linux System Administrator's Guide<br>
Each surface is divided into tracks (and sectors) in the same way. This means that when the head for one<br>surface is on a track, the heads for the other surfaces are also on the corresponding tracks. All the<br>corresponding tracks taken together are called a<i>&nbsp;cylinder</i>. It takes time to move the heads from one track<br>(cylinder) to another, so by placing the data that is often accessed together (say, a file) so that it is within one<br>cylinder, it is not necessary to move the heads to read all of it. This improves performance. It is not always<br>possible to place files like this; files that are stored in several places on the disk are called<i>&nbsp;fragmented</i>.<br>
The number of surfaces (or heads, which is the same thing), cylinders, and sectors vary a lot; the specification<br>of the number of each is called the<i>&nbsp;geometry</i>&nbsp;of a hard disk. The geometry is usually stored in a special,<br>battery−powered memory location called the<i>&nbsp;CMOS RAM</i>, from where the operating system can fetch it<br>during bootup or driver initialization.<br>
Unfortunately, the BIOS&nbsp;[13] has a design limitation, which makes it impossible to specify a track number<br>that is larger than 1024 in the CMOS RAM, which is too little for a large hard disk. To overcome this, the<br>hard disk controller lies about the geometry, and<i>&nbsp;translates the addresses</i>&nbsp;given by the computer into<br>something that fits reality. For example, a hard disk might have 8 heads, 2048 tracks, and 35 sectors per track.<br><a href="TLSAGs.html#104">[14] Its controller could lie to the computer and claim that it has 16 heads, 1024 tracks, and 35 sectors per<br></a>track, thus not exceeding the limit on tracks, and translates the address that the computer gives it by halving<br>the head number, and doubling the track number. The mathematics can be more complicated in reality,<br>
Chapter 6. Using Disks and Other Storage Media<br>
24<br>
<hr>
<A name=31></a>The Linux System Administrator's Guide<br>
because the numbers are not as nice as here (but again, the details are not relevant for understanding the<br>principle). This translation distorts the operating system's view of how the disk is organized, thus making it<br>impractical to use the all−data−on−one−cylinder trick to boost performance.<br>
The translation is only a problem for IDE disks. SCSI disks use a sequential sector number (i.e., the controller<br>translates a sequential sector number to a head, cylinder, and sector triplet), and a completely different method<br>for the CPU to talk with the controller, so they are insulated from the problem. Note, however, that the<br>computer might not know the real geometry of an SCSI disk either.<br>
Since Linux often will not know the real geometry of a disk, its filesystems don't even try to keep files within<br>a single cylinder. Instead, it tries to assign sequentially numbered sectors to files, which almost always gives<br>similar performance. The issue is further complicated by on−controller caches, and automatic prefetches done<br>by the controller.<br>
Each hard disk is represented by a separate device file. There can (usually) be only two or four IDE hard<br>disks. These are known as&nbsp;/dev/hda,&nbsp;/dev/hdb,&nbsp;/dev/hdc, and&nbsp;/dev/hdd, respectively. SCSI hard<br>disks are known as&nbsp;/dev/sda,&nbsp;/dev/sdb, and so on. Similar naming conventions exist for other hard disk<br><a href="TLSAGs.html#25">types; see Chapter 5 for more information. Note that the device files for the hard disks give access to the<br></a>entire disk, with no regard to partitions (which will be discussed below), and it's easy to mess up the partitions<br>or the data in them if you aren't careful. The disks' device files are usually used only to get access to the<br>master boot record (which will also be discussed below).<br>
<b>6.3. Floppies</b><br>
A floppy disk consists of a flexible membrane covered on one or both sides with similar magnetic substance<br>as a hard disk. The floppy disk itself doesn't have a read−write head, that is included in the drive. A floppy<br>corresponds to one platter in a hard disk, but is removable and one drive can be used to access different<br>floppies, and the same floppy can be read by many drives, whereas the hard disk is one indivisible unit.<br>
Like a hard disk, a floppy is divided into tracks and sectors (and the two corresponding tracks on either side of<br>a floppy form a cylinder), but there are many fewer of them than on a hard disk.<br>
A floppy drive can usually use several different types of disks; for example, a 3.5 inch drive can use both 720<br>kB and 1.44 MB disks. Since the drive has to operate a bit differently and the operating system must know<br>how big the disk is, there are many device files for floppy drives, one per combination of drive and disk type.<br>Therefore,&nbsp;/dev/fd0H1440&nbsp;is the first floppy drive (fd0), which must be a 3.5 inch drive, using a 3.5 inch,<br>high density disk (H) of size 1440 kB (1440), i.e., a normal 3.5 inch HD floppy.<br>
The names for floppy drives are complex, however, and Linux therefore has a special floppy device type that<br>automatically detects the type of the disk in the drive. It works by trying to read the first sector of a newly<br>inserted floppy using different floppy types until it finds the correct one. This naturally requires that the<br>floppy is formatted first. The automatic devices are called&nbsp;/dev/fd0,&nbsp;/dev/fd1, and so on.<br>
The parameters the automatic device uses to access a disk can also be set using the program<b>&nbsp;setfdprm</b>. This<br>can be useful if you need to use disks that do not follow any usual floppy sizes, e.g., if they have an unusual<br>number of sectors, or if the autodetecting for some reason fails and the proper device file is missing.<br>
Linux can handle many nonstandard floppy disk formats in addition to all the standard ones. Some of these<br>require using special formatting programs. We'll skip these disk types for now, but in the mean time you can<br>examine the&nbsp;/etc/fdprm&nbsp;file. It specifies the settings that<b>&nbsp;setfdprm</b>&nbsp;recognizes.<br>
Chapter 6. Using Disks and Other Storage Media<br>
25<br>
<hr>
<A name=32></a>The Linux System Administrator's Guide<br>
The operating system must know when a disk has been changed in a floppy drive, for example, in order to<br>avoid using cached data from the previous disk. Unfortunately, the signal line that is used for this is<br>sometimes broken, and worse, this won't always be noticeable when using the drive from within MS−DOS. If<br>you are experiencing weird problems using floppies, this might be the reason. The only way to correct it is to<br>repair the floppy drive.<br>
<b>6.4. CD−ROMs</b><br>
A CD−ROM drive uses an optically read, plastic coated disk. The information is recorded on the surface of<br>the disk&nbsp;[15] in small `holes' aligned along a spiral from the center to the edge. The drive directs a laser beam<br>along the spiral to read the disk. When the laser hits a hole, the laser is reflected in one way; when it hits<br>smooth surface, it is reflected in another way. This makes it easy to code bits, and therefore information. The<br>rest is easy, mere mechanics.<br>
CD−ROM drives are slow compared to hard disks. Whereas a typical hard disk will have an average seek time<br>less than 15 milliseconds, a fast CD−ROM drive can use tenths of a second for seeks. The actual data transfer<br>rate is fairly high at hundreds of kilobytes per second. The slowness means that CD−ROM drives are not as<br>pleasant to use as hard disks (some Linux distributions provide `live' filesystems on CD−ROMs, making it<br>unnecessary to copy the files to the hard disk, making installation easier and saving a lot of hard disk space),<br>although it is still possible. For installing new software, CD−ROMs are very good, since maximum speed is<br>not essential during installation.<br>
There are several ways to arrange data on a CD−ROM. The most popular one is specified by the international<br>standard ISO 9660. This standard specifies a very minimal filesystem, which is even more crude than the one<br>MS−DOS uses. On the other hand, it is so minimal that every operating system should be able to map it to its<br>native system.<br>
For normal UNIX use, the ISO 9660 filesystem is not usable, so an extension to the standard has been<br>developed, called the Rock Ridge extension. Rock Ridge allows longer filenames, symbolic links, and a lot of<br>other goodies, making a CD−ROM look more or less like any contemporary UNIX filesystem. Even better, a<br>Rock Ridge filesystem is still a valid ISO 9660 filesystem, making it usable by non−UNIX systems as well.<br>Linux supports both ISO 9660 and the Rock Ridge extensions; the extensions are recognized and used<br>automatically.<br>
The filesystem is only half the battle, however. Most CD−ROMs contain data that requires a special program<br>to access, and most of these programs do not run under Linux (except, possibly, under dosemu, the Linux<br>MS−DOS emulator, or wine, the Windows emulator.&nbsp;[16] There is also VMWare, a commercial product<br>which emulates an entire x86 machine in software&nbsp;[17]) .<br>
A CD−ROM drive is accessed via the corresponding device file. There are several ways to connect a<br>CD−ROM drive to the computer: via SCSI, via a sound card, or via EIDE. The hardware hacking needed to<br>do this is outside the scope of this book, but the type of connection decides the device file.<br>
<b>6.5. Tapes</b><br>
A tape drive uses a tape, similar&nbsp;[18] to cassettes used for music. A tape is serial in nature, which means that<br>in order to get to any given part of it, you first have to go through all the parts in between. A disk can be<br>accessed randomly, i.e., you can jump directly to any place on the disk. The serial access of tapes makes them<br>slow.<br>
Chapter 6. Using Disks and Other Storage Media<br>
26<br>
<hr>
<A name=33></a>The Linux System Administrator's Guide<br>
On the other hand, tapes are relatively cheap to make, since they do not need to be fast. They can also easily<br>be made quite long, and can therefore contain a large amount of data. This makes tapes very suitable for<br>things like archiving and backups, which do not require large speeds, but benefit from low costs and large<br>storage capacities.<br>
<b>6.6. Formatting</b><br>
<i>Formatting</i>&nbsp;is the process of writing marks on the magnetic media that are used to mark tracks and sectors.<br>Before a disk is formatted, its magnetic surface is a complete mess of magnetic signals. When it is formatted,<br>some order is brought into the chaos by essentially drawing lines where the tracks go, and where they are<br>divided into sectors. The actual details are not quite exactly like this, but that is irrelevant. What is important<br>is that a disk cannot be used unless it has been formatted.<br>
The terminology is a bit confusing here: in MS−DOS and MS Windows, the word formatting is used to cover<br>also the process of creating a filesystem (which will be discussed below). There, the two processes are often<br>combined, especially for floppies. When the distinction needs to be made, the real formatting is called<br><i>low−level formatting</i>, while making the filesystem is called<i>&nbsp;high−level formatting</i>. In UNIX circles, the two<br>are called formatting and making a filesystem, so that's what is used in this book as well.<br>
For IDE and some SCSI disks the formatting is actually done at the factory and doesn't need to be repeated;<br>hence most people rarely need to worry about it. In fact, formatting a hard disk can cause it to work less well,<br>for example because a disk might need to be formatted in some very special way to allow automatic bad<br>sector replacement to work.<br>
Disks that need to be or can be formatted often require a special program anyway, because the interface to the<br>formatting logic inside the drive is different from drive to drive. The formatting program is often either on the<br>controller BIOS, or is supplied as an MS−DOS program; neither of these can easily be used from within<br>Linux.<br>
During formatting one might encounter bad spots on the disk, called<i>&nbsp;bad blocks</i>&nbsp;or<i>&nbsp;bad sectors</i>. These are<br>sometimes handled by the drive itself, but even then, if more of them develop, something needs to be done to<br>avoid using those parts of the disk. The logic to do this is built into the filesystem; how to add the information<br>into the filesystem is described below. Alternatively, one might create a small partition that covers just the bad<br>part of the disk; this approach might be a good idea if the bad spot is very large, since filesystems can<br>sometimes have trouble with very large bad areas.<br>
Floppies are formatted with<b>&nbsp;fdformat</b>. The floppy device file to use is given as the parameter. For example,<br>the following command would format a high density, 3.5 inch floppy in the first floppy drive:<br>
$&nbsp;<b>fdformat /dev/fd0H1440</b><br>
Double−sided, 80 tracks, 18 sec/track. Total capacity&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1440 kB.<br>
Formatting ... done<br>
Verifying ... done<br>
$<br>
Note that if you want to use an autodetecting device (e.g.,&nbsp;/dev/fd0), you<i>&nbsp;must</i>&nbsp;set the parameters of the<br>device with<b>&nbsp;setfdprm</b>&nbsp;first. To achieve the same effect as above, one would have to do the following:<br>
$&nbsp;<b>setfdprm /dev/fd0 1440/1440</b><br>
Chapter 6. Using Disks and Other Storage Media<br>
27<br>
<hr>
<A name=34></a>The Linux System Administrator's Guide<br>
$&nbsp;<b>fdformat /dev/fd0</b><br>
Double−sided, 80 tracks, 18 sec/track. Total capacity&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1440 kB.<br>
Formatting ... done<br>
Verifying ... done<br>
$<br>
It is usually more convenient to choose the correct device file that matches the type of the floppy. Note that it<br>is unwise to format floppies to contain more information than what they are designed for.<br>
<b>fdformat</b>&nbsp;will also validate the floppy, i.e., check it for bad blocks. It will try a bad block several times (you<br>can usually hear this, the drive noise changes dramatically). If the floppy is only marginally bad (due to dirt<br>on the read/write head, some errors are false signals),<b>&nbsp;fdformat</b>&nbsp;won't complain, but a real error will abort the<br>validation process. The kernel will print log messages for each I/O error it finds; these will go to the console<br>or, if<b>&nbsp;syslog</b>&nbsp;is being used, to the file&nbsp;/usr/log/messages.<b>&nbsp;fdformat</b>&nbsp;itself won't tell where the error is<br>(one usually doesn't care, floppies are cheap enough that a bad one is automatically thrown away).<br>
$&nbsp;<b>fdformat /dev/fd0H1440</b><br>
Double−sided, 80 tracks, 18 sec/track. Total capacity&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1440 kB.<br>
Formatting ... done<br>
Verifying ... read: Unknown error<br>
$<br>
The<b>&nbsp;badblocks</b>&nbsp;command can be used to search any disk or partition for bad blocks (including a floppy). It<br>does not format the disk, so it can be used to check even existing filesystems. The example below checks a 3.5<br>inch floppy with two bad blocks.<br>
$&nbsp;<b>badblocks /dev/fd0H1440 1440</b><br>
718<br>
719<br>
$<br>
<b>badblocks</b>&nbsp;outputs the block numbers of the bad blocks it finds. Most filesystems can avoid such bad blocks.<br>They maintain a list of known bad blocks, which is initialised when the filesystem is made, and can be<br>modified later. The initial search for bad blocks can be done by the<b>&nbsp;mkfs</b>&nbsp;command (which initializes the<br>filesystem), but later checks should be done with<b>&nbsp;badblocks</b>&nbsp;and the new blocks should be added with<b>&nbsp;fsck</b>.<br>We'll describe<b>&nbsp;mkfs</b>&nbsp;and<b>&nbsp;fsck</b>&nbsp;later.<br>
Many modern disks automatically notice bad blocks, and attempt to fix them by using a special, reserved good<br>block instead. This is invisible to the operating system. This feature should be documented in the disk's<br>manual, if you're curious if it is happening. Even such disks can fail, if the number of bad blocks grows too<br>large, although chances are that by then the disk will be so rotten as to be unusable.<br>
<b>6.7. Partitions</b><br>
A hard disk can be divided into several<i>&nbsp;partitions</i>. Each partition functions as if it were a separate hard disk.<br>The idea is that if you have one hard disk, and want to have, say, two operating systems on it, you can divide<br>the disk into two partitions. Each operating system uses its partition as it wishes and doesn't touch the other<br>ones. This way the two operating systems can co−exist peacefully on the same hard disk. Without partitions<br>one would have to buy a hard disk for each operating system.<br>
Chapter 6. Using Disks and Other Storage Media<br>
28<br>
<hr>
<A name=35></a>The Linux System Administrator's Guide<br>
Floppies are not usually partitioned. There is no technical reason against this, but since they're so small,<br>partitions would be useful only very rarely. CD−ROMs are usually also not partitioned, since it's easier to use<br>them as one big disk, and there is seldom a need to have several operating systems on one.<br>
<b>6.7.1. The MBR, boot sectors and partition table</b><br>
The information about how a hard disk has been partitioned is stored in its first sector (that is, the first sector<br>of the first track on the first disk surface). The first sector is the<i>&nbsp;master boot record</i>&nbsp;(MBR) of the disk; this is<br>the sector that the BIOS reads in and starts when the machine is first booted. The master boot record contains<br>a small program that reads the partition table, checks which partition is active (that is, marked bootable), and<br>reads the first sector of that partition, the partition's<i>&nbsp;boot sector</i>&nbsp;(the MBR is also a boot sector, but it has a<br>special status and therefore a special name). This boot sector contains another small program that reads the<br>first part of the operating system stored on that partition (assuming it is bootable), and then starts it.<br>
The partitioning scheme is not built into the hardware, or even into the BIOS. It is only a convention that<br>many operating systems follow. Not all operating systems do follow it, but they are the exceptions. Some<br>operating systems support partitions, but they occupy one partition on the hard disk, and use their internal<br>partitioning method within that partition. The latter type exists peacefully with other operating systems<br>(including Linux), and does not require any special measures, but an operating system that doesn't support<br>partitions cannot co−exist on the same disk with any other operating system.<br>
As a safety precaution, it is a good idea to write down the partition table on a piece of paper, so that if it ever<br>corrupts you don't have to lose all your files. (A bad partition table can be fixed with<b>&nbsp;fdisk</b>). The relevant<br>information is given by the<b>&nbsp;fdisk −l</b>&nbsp;command:<br>
$&nbsp;<b>fdisk −l /dev/hda</b><br>
Disk /dev/hda: 15 heads, 57 sectors, 790 cylinders<br>
Units = cylinders of 855 * 512 bytes<br>
&nbsp; Device Boot &nbsp;Begin &nbsp; Start &nbsp; &nbsp; End &nbsp;Blocks &nbsp; Id &nbsp;System<br>
/dev/hda1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp;24 &nbsp; 10231+ &nbsp;82 &nbsp;Linux swap<br>
/dev/hda2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;25 &nbsp; &nbsp; &nbsp;25 &nbsp; &nbsp; &nbsp;48 &nbsp; 10260 &nbsp; 83 &nbsp;Linux native<br>
/dev/hda3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;49 &nbsp; &nbsp; &nbsp;49 &nbsp; &nbsp; 408 &nbsp;153900 &nbsp; 83 &nbsp;Linux native<br>
/dev/hda4 &nbsp; &nbsp; &nbsp; &nbsp; 409 &nbsp; &nbsp; 409 &nbsp; &nbsp; 790 &nbsp;163305 &nbsp; &nbsp;5 &nbsp;Extended<br>
/dev/hda5 &nbsp; &nbsp; &nbsp; &nbsp; 409 &nbsp; &nbsp; 409 &nbsp; &nbsp; 744 &nbsp;143611+ &nbsp;83 &nbsp;Linux native<br>
/dev/hda6 &nbsp; &nbsp; &nbsp; &nbsp; 745 &nbsp; &nbsp; 745 &nbsp; &nbsp; 790 &nbsp; 19636+ &nbsp;83 &nbsp;Linux native<br>
$<br>
<b>6.7.2. Extended and logical partitions</b><br>
The original partitioning scheme for PC hard disks allowed only four partitions. This quickly turned out to be<br>too little in real life, partly because some people want more than four operating systems (Linux, MS−DOS,<br>OS/2, Minix, FreeBSD, NetBSD, or Windows/NT, to name a few), but primarily because sometimes it is a<br>good idea to have several partitions for one operating system. For example, swap space is usually best put in<br>its own partition for Linux instead of in the main Linux partition for reasons of speed (see below).<br>
To overcome this design problem,<i>&nbsp;extended partitions</i>&nbsp;were invented. This trick allows partitioning a<i>&nbsp;primary<br>partition</i>&nbsp;into sub−partitions. The primary partition thus subdivided is the<i>&nbsp;extended partition</i>; the<br>sub−partitions are<i>&nbsp;logical partitions</i>. They behave like primary partitions, but are created differently. There is<br>no speed difference between them.<br>
Chapter 6. Using Disks and Other Storage Media<br>
29<br>
<hr>
<A name=36></a><IMG src="TLSAG-36_1.png"><br>
The Linux System Administrator's Guide<br>
<a href="TLSAGs.html#36">The partition structure of a hard disk might look like that in Figure 6−2. The disk is divided into three primary<br></a>partitions, the second of which is divided into two logical partitions. Part of the disk is not partitioned at all.<br>The disk as a whole and each primary partition has a boot sector.<br>
<b>Figure 6−2. A sample hard disk partitioning.</b><br>
<b>6.7.3. Partition types</b><br>
The partition tables (the one in the MBR, and the ones for extended partitions) contain one byte per partition<br>that identifies the type of that partition. This attempts to identify the operating system that uses the partition,<br>or what it uses it for. The purpose is to make it possible to avoid having two operating systems accidentally<br>using the same partition. However, in reality, operating systems do not really care about the partition type<br>byte; e.g., Linux doesn't care at all what it is. Worse, some of them use it incorrectly; e.g., at least some<br>versions of DR−DOS ignore the most significant bit of the byte, while others don't.<br>
There is no standardization agency to specify what each byte value means, but some commonly accepted ones<br><a href="TLSAGs.html#36">are included in in Table 6−1. A more complete list is available in the Linux</a><b>&nbsp;fdisk</b>&nbsp;program.<br>
<b>Table 6−1. Partition types (from the Linux fdisk program).</b><br>
0&nbsp;Empty<br>
40&nbsp;Venix 80286&nbsp;94&nbsp;Amoeba BBT<br>
1&nbsp;DOS 12−bit FAT<br>
51&nbsp;Novell?<br>
a5&nbsp;BSD/386<br>
2&nbsp;XENIX root<br>
52&nbsp;Microport<br>
b7&nbsp;BSDI fs<br>
3&nbsp;XENIX usr<br>
63&nbsp;GNU HURD&nbsp;b8&nbsp;BSDI swap<br>
4&nbsp;DOS 16−bit FAT &lt;32M&nbsp;64&nbsp;Novell<br>
c7&nbsp;Syrinx<br>
5&nbsp;Extended<br>
75&nbsp;PC/IX<br>
db&nbsp;CP/M<br>
6&nbsp;DOS 16−bit &gt;=32M<br>
80&nbsp;Old MINIX<br>
e1&nbsp;DOS access<br>
7&nbsp;OS/2 HPFS<br>
81&nbsp;Linux/MINIX&nbsp;e3&nbsp;DOS R/O<br>
8&nbsp;AIX<br>
82&nbsp;Linux swap<br>
f2&nbsp;DOS secondary<br>
9&nbsp;AIX bootable<br>
83&nbsp;Linux native<br>
ff&nbsp;BBT<br>
a&nbsp;OS/2 Boot Manager<br>
93&nbsp;Amoeba<br>
Chapter 6. Using Disks and Other Storage Media<br>
30<br>
<hr>
<A name=37></a>The Linux System Administrator's Guide<br>
<b>6.7.4. Partitioning a hard disk</b><br>
There are many programs for creating and removing partitions. Most operating systems have their own, and it<br>can be a good idea to use each operating system's own, just in case it does something unusual that the others<br>can't. Many of the programs are called<b>&nbsp;fdisk</b>, including the Linux one, or variations thereof. Details on using<br>the Linux<b>&nbsp;fdisk</b>&nbsp;are given on its man page. The<b>&nbsp;cfdisk</b>&nbsp;command is similar to<b>&nbsp;fdisk</b>, but has a nicer (full<br>screen) user interface.<br>
When using IDE disks, the boot partition (the partition with the bootable kernel image files) must be<br>completely within the first 1024 cylinders. This is because the disk is used via the BIOS during boot (before<br>the system goes into protected mode), and BIOS can't handle more than 1024 cylinders. It is sometimes<br>possible to use a boot partition that is only partly within the first 1024 cylinders. This works as long as all the<br>files that are read with the BIOS are within the first 1024 cylinders. Since this is difficult to arrange, it is<i>&nbsp;a<br>very bad idea</i>&nbsp;to do it; you never know when a kernel update or disk defragmentation will result in an<br>unbootable system. Therefore, make sure your boot partition is completely within the first 1024 cylinders&nbsp;[19]<br>.<br>
Some newer versions of the BIOS and IDE disks can, in fact, handle disks with more than 1024 cylinders. If<br>you have such a system, you can forget about the problem; if you aren't quite sure of it, put it within the first<br>1024 cylinders.<br>
Each partition should have an even number of sectors, since the Linux filesystems use a 1 kilobyte block size,<br>i.e., two sectors. An odd number of sectors will result in the last sector being unused. This won't result in any<br>problems, but it is ugly, and some versions of<b>&nbsp;fdisk</b>&nbsp;will warn about it.<br>
Changing a partition's size usually requires first backing up everything you want to save from that partition<br>(preferably the whole disk, just in case), deleting the partition, creating new partition, then restoring<br>everything to the new partition. If the partition is growing, you may need to adjust the sizes (and backup and<br>restore) of the adjoining partitions as well.<br>
Since changing partition sizes is painful, it is preferable to get the partitions right the first time, or have an<br>effective and easy to use backup system. If you're installing from a media that does not require much human<br>intervention (say, from CD−ROM, as opposed to floppies), it is often easy to play with different configuration<br>at first. Since you don't already have data to back up, it is not so painful to modify partition sizes several<br>times.<br>
There is a program for MS−DOS, called<b>&nbsp;fips</b>&nbsp;[20] , which resizes an MS−DOS partition without requiring the<br>backup and restore, but for other filesystems it is still necessary.<br>
<b>6.7.5. Device files and partitions</b><br>
Each partition and extended partition has its own device file. The naming convention for these files is that a<br>partition's number is appended after the name of the whole disk, with the convention that 1−4 are primary<br>partitions (regardless of how many primary partitions there are) and number greater than 5 are logical<br>partitions (regardless of within which primary partition they reside). For example,&nbsp;/dev/hda1&nbsp;is the first<br>primary partition on the first IDE hard disk, and&nbsp;/dev/sdb7&nbsp;is the third extended partition on the second<br>SCSI hard disk.<br>
Chapter 6. Using Disks and Other Storage Media<br>
31<br>
<hr>
<A name=38></a>The Linux System Administrator's Guide<br>
<b>6.8. Filesystems</b><br>
<b>6.8.1. What are filesystems?</b><br>
A<i>&nbsp;filesystem</i>&nbsp;is the methods and data structures that an operating system uses to keep track of files on a disk or<br>partition; that is, the way the files are organized on the disk. The word is also used to refer to a partition or<br>disk that is used to store the files or the type of the filesystem. Thus, one might say &quot;I have two filesystems&quot;<br>meaning one has two partitions on which one stores files, or that one is using the &quot;extended filesystem&quot;,<br>meaning the type of the filesystem.<br>
The difference between a disk or partition and the filesystem it contains is important. A few programs<br>(including, reasonably enough, programs that create filesystems) operate directly on the raw sectors of a disk<br>or partition; if there is an existing file system there it will be destroyed or seriously corrupted. Most programs<br>operate on a filesystem, and therefore won't work on a partition that doesn't contain one (or that contains one<br>of the wrong type).<br>
Before a partition or disk can be used as a filesystem, it needs to be initialized, and the bookkeeping data<br>structures need to be written to the disk. This process is called<i>&nbsp;making a filesystem</i>.<br>
Most UNIX filesystem types have a similar general structure, although the exact details vary quite a bit. The<br>central concepts are<i>&nbsp;superblock</i>,<i>&nbsp;inode</i>,<i>&nbsp;data block</i>,<i>&nbsp;directory block</i>, and<i>&nbsp;indirection block</i>. The superblock<br>contains information about the filesystem as a whole, such as its size (the exact information here depends on<br>the filesystem). An inode contains all information about a file, except its name. The name is stored in the<br>directory, together with the number of the inode. A directory entry consists of a filename and the number of<br>the inode which represents the file. The inode contains the numbers of several data blocks, which are used to<br>store the data in the file. There is space only for a few data block numbers in the inode, however, and if more<br>are needed, more space for pointers to the data blocks is allocated dynamically. These dynamically allocated<br>blocks are indirect blocks; the name indicates that in order to find the data block, one has to find its number in<br>the indirect block first.<br>
UNIX filesystems usually allow one to create a<i>&nbsp;hole</i>&nbsp;in a file (this is done with the&nbsp;lseek()&nbsp;system call;<br>check the manual page), which means that the filesystem just pretends that at a particular place in the file<br>there is just zero bytes, but no actual disk sectors are reserved for that place in the file (this means that the file<br>will use a bit less disk space). This happens especially often for small binaries, Linux shared libraries, some<br>databases, and a few other special cases. (Holes are implemented by storing a special value as the address of<br>the data block in the indirect block or inode. This special address means that no data block is allocated for that<br>part of the file, ergo, there is a hole in the file.)<br>
<b>6.8.2. Filesystems galore</b><br>
Linux supports several types of filesystems. As of this writing the most important ones are:<br>
<i><b>minix</b></i><br>
The oldest, presumed to be the most reliable, but quite limited in features (some time stamps are<br>missing, at most 30 character filenames) and restricted in capabilities (at most 64 MB per filesystem).<br>
<i><b>xia</b></i><br>
A modified version of the minix filesystem that lifts the limits on the filenames and filesystem sizes,<br>but does not otherwise introduce new features. It is not very popular, but is reported to work very<br>well.<br>
Chapter 6. Using Disks and Other Storage Media<br>
32<br>
<hr>
<A name=39></a>The Linux System Administrator's Guide<br>
<i><b>ext3</b></i><br>
The ext3 filesystem has all the features of the ext2 filesystem. The difference is, journaling has been<br>added. This improves performance and recovery time in case of a system crash. This has become<br>more popular than ext2.<br>
<i><b>ext2</b></i><br>
The most featureful of the native Linux filesystems. It is designed to be easily upwards compatible, so<br>that new versions of the filesystem code do not require re−making the existing filesystems.<br>
<i><b>ext</b></i><br>
An older version of ext2 that wasn't upwards compatible. It is hardly ever used in new installations<br>any more, and most people have converted to ext2.<br>
<i><b>reiserfs</b></i><br>
A more robust filesystem. Journalling is used which makes data loss less likely. Journalling is a<br>mechanism whereby a record is kept of transaction which are to be performed, or which have been<br>performed. This allows the filesystem to reconstruct itself fairly easily after damage caused by, for<br>example, improper shutdowns.<br>
In addition, support for several foreign filesystems exists, to make it easier to exchange files with other<br>operating systems. These foreign filesystems work just like native ones, except that they may be lacking in<br>some usual UNIX features, or have curious limitations, or other oddities.<br>
<i><b>msdos</b></i><br>
Compatibility with MS−DOS (and OS/2 and Windows NT) FAT filesystems.<br>
<i><b>umsdos</b></i><br>
Extends the msdos filesystem driver under Linux to get long filenames, owners, permissions, links,<br>and device files. This allows a normal msdos filesystem to be used as if it were a Linux one, thus<br>removing the need for a separate partition for Linux.<br>
<i><b>vfat</b></i><br>
This is an extension of the FAT filesystem known as FAT32. It supports larger disk sizes than FAT.<br>Most MS Windows disks are vfat.<br>
<i><b>iso9660</b></i><br>
The standard CD−ROM filesystem; the popular Rock Ridge extension to the CD−ROM standard that<br>allows longer file names is supported automatically.<br>
<i><b>nfs</b></i><br>
A networked filesystem that allows sharing a filesystem between many computers to allow easy<br>access to the files from all of them.<br>
<i><b>smbfs</b></i><br>
A networks filesystem which allows sharing of a filesystem with an MS Windows computer. It is<br>compatible with the Windows file sharing protocols.<br>
<i><b>hpfs</b></i><br>
The OS/2 filesystem.<br>
<i><b>sysv</b></i><br>
SystemV/386, Coherent, and Xenix filesystems.<br>
The choice of filesystem to use depends on the situation. If compatibility or other reasons make one of the<br>non−native filesystems necessary, then that one must be used. If one can choose freely, then it is probably<br>wisest to use ext3, since it has all the features of ext2, and is a journaled filesystem.<br>
There is also the proc filesystem, usually accessible as the&nbsp;/proc&nbsp;directory, which is not really a filesystem at<br>all, even though it looks like one. The proc filesystem makes it easy to access certain kernel data structures,<br>such as the process list (hence the name). It makes these data structures look like a filesystem, and that<br>filesystem can be manipulated with all the usual file tools. For example, to get a listing of all processes one<br>
Chapter 6. Using Disks and Other Storage Media<br>
33<br>
<hr>
<A name=40></a>The Linux System Administrator's Guide<br>
might use the command<br>
$&nbsp;<b>ls −l /proc</b><br>
total 0<br>
dr−xr−xr−x &nbsp; 4 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 1<br>
dr−xr−xr−x &nbsp; 4 liw &nbsp; &nbsp; &nbsp;users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 31 20:37 63<br>
dr−xr−xr−x &nbsp; 4 liw &nbsp; &nbsp; &nbsp;users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 31 20:37 94<br>
dr−xr−xr−x &nbsp; 4 liw &nbsp; &nbsp; &nbsp;users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 31 20:37 95<br>
dr−xr−xr−x &nbsp; 4 root &nbsp; &nbsp; users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 31 20:37 98<br>
dr−xr−xr−x &nbsp; 4 liw &nbsp; &nbsp; &nbsp;users &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 Jan 31 20:37 99<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 devices<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 dma<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 filesystems<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 interrupts<br>
−r−−−−−−−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp;8654848 Jan 31 20:37 kcore<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 11:50 kmsg<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 ksyms<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 11:51 loadavg<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 meminfo<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 modules<br>
dr−xr−xr−x &nbsp; 2 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 net<br>
dr−xr−xr−x &nbsp; 4 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 self<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 stat<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37 uptime<br>
−r−−r−−r−− &nbsp; 1 root &nbsp; &nbsp; root &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 Jan 31 20:37&nbsp;<br>
version<br>
$<br>
(There will be a few extra files that don't correspond to processes, though. The above example has been<br>shortened.)<br>
Note that even though it is called a filesystem, no part of the proc filesystem touches any disk. It exists only in<br>the kernel's imagination. Whenever anyone tries to look at any part of the proc filesystem, the kernel makes it<br>look as if the part existed somewhere, even though it doesn't. So, even though there is a multi−megabyte<br>/proc/kcore&nbsp;file, it doesn't take any disk space.<br>
<b>6.8.3. Which filesystem should be used?</b><br>
There is usually little point in using many different filesystems. Currently, ext3 is the most popular filesystem,<br>because it is a journaled filesystem. Currently it is probably the wisest choice. Reiserfs is another popular<br>choice because it to is journaled. Depending on the overhead for bookkeeping structures, speed, (perceived)<br>reliability, compatibility, and various other reasons, it may be advisable to use another file system. This needs<br>to be decided on a case−by−case basis.<br>
A filesystem that uses journaling is also called a journaled filesystem. A journaled filesystem maintains a log,<br>or journal, of what has happened on a filesystem. In the event of a system crash, or if your 2 year old son hits<br>the power button like mine loves to do, a journaled filesystem is designed to use the filesystem's logs to<br>recreate unsaved and lost data. This makes data loss much less likely and will likely become a standard<br>feature in Linux filesystems. However, do not get a false sense of security from this. Like everything else,<br>errors can arise. Always make sure to back up your data in the event of an emergency.<br>
Chapter 6. Using Disks and Other Storage Media<br>
34<br>
<hr>
<A name=41></a>The Linux System Administrator's Guide<br>
<b>6.8.4. Creating a filesystem</b><br>
Filesystems are created, i.e., initialized, with the<b>&nbsp;mkfs</b>&nbsp;command. There is actually a separate program for<br>each filesystem type.<b>&nbsp;mkfs</b>&nbsp;is just a front end that runs the appropriate program depending on the desired<br>filesystem type. The type is selected with the&nbsp;−t fstype&nbsp;option.<br>
The programs called by<b>&nbsp;mkfs</b>&nbsp;have slightly different command line interfaces. The common and most<br>important options are summarized below; see the manual pages for more.<br>
<i><b>−t fstype</b></i><br>
Select the type of the filesystem.<br>
<i><b>−c</b></i><br>
Search for bad blocks and initialize the bad block list accordingly.<br>
<i><b>−l filename</b></i><br>
Read the initial bad block list from the name file.<br>
To create an ext2 filesystem on a floppy, one would give the following commands:<br>
$&nbsp;<b>fdformat −n /dev/fd0H1440</b><br>
Double−sided, 80 tracks, 18 sec/track. Total capacity&nbsp;<br>
1440 kB.<br>
Formatting ... done<br>
$&nbsp;<b>badblocks /dev/fd0H1440 1440 $&gt;$&nbsp;</b><br>
<b>bad−blocks</b><br>
$&nbsp;<b>mkfs −t ext2 −l bad−blocks&nbsp;</b><br>
<b>/dev/fd0H1440</b><br>
mke2fs 0.5a, 5−Apr−94 for EXT2 FS 0.5, 94/03/10<br>
360 inodes, 1440 blocks<br>
72 blocks (5.00%) reserved for the super user<br>
First data block=1<br>
Block size=1024 (log=0)<br>
Fragment size=1024 (log=0)<br>
1 block group<br>
8192 blocks per group, 8192 fragments per group<br>
360 inodes per group<br>
Writing inode tables: done<br>
Writing superblocks and filesystem accounting information:&nbsp;<br>
done<br>
$<br>
First, the floppy was formatted (the&nbsp;−n&nbsp;option prevents validation, i.e., bad block checking). Then bad blocks<br>were searched with<b>&nbsp;badblocks</b>, with the output redirected to a file,&nbsp;bad−blocks. Finally, the filesystem was<br>created, with the bad block list initialized by whatever<b>&nbsp;badblocks</b>&nbsp;found.<br>
The&nbsp;−c&nbsp;option could have been used with<b>&nbsp;mkfs</b>&nbsp;instead of<b>&nbsp;badblocks</b>&nbsp;and a separate file. The example below<br>does that.<br>
$&nbsp;<b>mkfs −t ext2 −c&nbsp;</b><br>
<b>/dev/fd0H1440</b><br>
mke2fs 0.5a, 5−Apr−94 for EXT2 FS 0.5, 94/03/10<br>
360 inodes, 1440 blocks<br>
72 blocks (5.00%) reserved for the super user<br>
First data block=1<br>
Block size=1024 (log=0)<br>
Fragment size=1024 (log=0)<br>
Chapter 6. Using Disks and Other Storage Media<br>
35<br>
<hr>
<A name=42></a><IMG src="TLSAG-42_1.png"><br>
<IMG src="TLSAG-42_2.png"><br>
The Linux System Administrator's Guide<br>
1 block group<br>
8192 blocks per group, 8192 fragments per group<br>
360 inodes per group<br>
Checking for bad blocks (read−only test): done<br>
Writing inode tables: done<br>
Writing superblocks and filesystem accounting information:&nbsp;<br>
done<br>
$<br>
The&nbsp;−c&nbsp;option is more convenient than a separate use of<b>&nbsp;badblocks</b>, but<b>&nbsp;badblocks</b>&nbsp;is necessary for checking<br>after the filesystem has been created.<br>
The process to prepare filesystems on hard disks or partitions is the same as for floppies, except that the<br>formatting isn't needed.<br>
<b>6.8.5. Mounting and unmounting</b><br>
Before one can use a filesystem, it has to be<i>&nbsp;mounted</i>. The operating system then does various bookkeeping<br>things to make sure that everything works. Since all files in UNIX are in a single directory tree, the mount<br>operation will make it look like the contents of the new filesystem are the contents of an existing subdirectory<br>in some already mounted filesystem.<br>
<a href="TLSAGs.html#42">For example, Figure 6−3 shows three separate filesystems, each with their own root directory. When the last<br></a>two filesystems are mounted below&nbsp;/home&nbsp;and&nbsp;/usr, respectively, on the first filesystem, we can get a<br><a href="TLSAGs.html#42">single directory tree, as in Figure 6−4.</a><br>
<b>Figure 6−3. Three separate filesystems.</b><br>
<b>Figure 6−4.&nbsp;/home&nbsp;and&nbsp;/usr&nbsp;have been mounted.</b><br>
The mounts could be done as in the following example:<br>
$&nbsp;<b>mount /dev/hda2 /home</b><br>
$&nbsp;<b>mount /dev/hda3 /usr</b><br>
$<br>
Chapter 6. Using Disks and Other Storage Media<br>
36<br>
<hr>
<A name=43></a>The Linux System Administrator's Guide<br>
The<b>&nbsp;mount</b>&nbsp;command takes two arguments. The first one is the device file corresponding to the disk or<br>partition containing the filesystem. The second one is the directory below which it will be mounted. After<br>these commands the contents of the two filesystems look just like the contents of the&nbsp;/home&nbsp;and&nbsp;/usr<br>directories, respectively. One would then say that &quot;/dev/hda2<i>&nbsp;is mounted on&nbsp;</i>/home&quot;, and similarly for<br>/usr. To look at either filesystem, one would look at the contents of the directory on which it has been<br>mounted, just as if it were any other directory. Note the difference between the device file,&nbsp;/dev/hda2, and<br>the mounted−on directory,&nbsp;/home. The device file gives access to the raw contents of the disk, the<br>mounted−on directory gives access to the files on the disk. The mounted−on directory is called the<i>&nbsp;mount<br>point</i>.<br>
Linux supports many filesystem types.<b>&nbsp;mount</b>&nbsp;tries to guess the type of the filesystem. You can also use the<br>−t fstype&nbsp;option to specify the type directly; this is sometimes necessary, since the heuristics<b>&nbsp;mount</b>&nbsp;uses<br>do not always work. For example, to mount an MS−DOS floppy, you could use the following command:<br>
$&nbsp;<b>mount −t msdos /dev/fd0&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; /floppy</b><br>
$<br>
The mounted−on directory need not be empty, although it must exist. Any files in it, however, will be<br>inaccessible by name while the filesystem is mounted. (Any files that have already been opened will still be<br>accessible. Files that have hard links from other directories can be accessed using those names.) There is no<br>harm done with this, and it can even be useful. For instance, some people like to have&nbsp;/tmp&nbsp;and&nbsp;/var/tmp<br>synonymous, and make&nbsp;/tmp&nbsp;be a symbolic link to&nbsp;/var/tmp. When the system is booted, before the&nbsp;/var<br>filesystem is mounted, a&nbsp;/var/tmp&nbsp;directory residing on the root filesystem is used instead. When&nbsp;/var&nbsp;is<br>mounted, it will make the&nbsp;/var/tmp&nbsp;directory on the root filesystem inaccessible. If&nbsp;/var/tmp&nbsp;didn't exist<br>on the root filesystem, it would be impossible to use temporary files before mounting&nbsp;/var.<br>
If you don't intend to write anything to the filesystem, use the&nbsp;−r&nbsp;switch for<b>&nbsp;mount</b>&nbsp;to do a<i>&nbsp;read−only mount</i>.<br>This will make the kernel stop any attempts at writing to the filesystem, and will also stop the kernel from<br>updating file access times in the inodes. Read−only mounts are necessary for unwritable media, e.g.,<br>CD−ROMs.<br>
The alert reader has already noticed a slight logistical problem. How is the first filesystem (called the<i>&nbsp;root<br>filesystem</i>, because it contains the root directory) mounted, since it obviously can't be mounted on another<br>filesystem? Well, the answer is that it is done by magic.&nbsp;[21] The root filesystem is magically mounted at boot<br>time, and one can rely on it to always be mounted. If the root filesystem can't be mounted, the system does not<br>boot. The name of the filesystem that is magically mounted as root is either compiled into the kernel, or set<br>using LILO or<b>&nbsp;rdev</b>.<br>
The root filesystem is usually first mounted read−only. The startup scripts will then run<b>&nbsp;fsck</b>&nbsp;to verify its<br>validity, and if there are no problems, they will<i>&nbsp;re−mount</i>&nbsp;it so that writes will also be allowed.<b>&nbsp;fsck</b>&nbsp;must not<br>be run on a mounted filesystem, since any changes to the filesystem while<b>&nbsp;fsck</b>&nbsp;is running<i>&nbsp;will</i>&nbsp;cause trouble.<br>Since the root filesystem is mounted read−only while it is being checked,<b>&nbsp;fsck</b>&nbsp;can fix any problems without<br>worry, since the remount operation will flush any metadata that the filesystem keeps in memory.<br>
On many systems there are other filesystems that should also be mounted automatically at boot time. These<br>are specified in the&nbsp;/etc/fstab&nbsp;file; see the fstab man page for details on the format. The details of exactly<br>when the extra filesystems are mounted depend on many factors, and can be configured by each administrator<br><a href="TLSAGs.html#58">if need be; see Chapter 8.</a><br>
Chapter 6. Using Disks and Other Storage Media<br>
37<br>
<hr>
<A name=44></a>The Linux System Administrator's Guide<br>
When a filesystem no longer needs to be mounted, it can be unmounted with<b>&nbsp;umount</b>.&nbsp;[22]<b>&nbsp;umount</b>&nbsp;takes one<br>argument: either the device file or the mount point. For example, to unmount the directories of the previous<br>example, one could use the commands<br>
$&nbsp;<b>umount /dev/hda2</b><br>
$&nbsp;<b>umount /usr</b><br>
$<br>
See the man page for further instructions on how to use the command. It is imperative that you always<br>unmount a mounted floppy.<i>&nbsp;Don't just pop the floppy out of the drive!</i>&nbsp;Because of disk caching, the data is not<br>necessarily written to the floppy until you unmount it, so removing the floppy from the drive too early might<br>cause the contents to become garbled. If you only read from the floppy, this is not very likely, but if you write,<br>even accidentally, the result may be catastrophic.<br>
Mounting and unmounting requires super user privileges, i.e., only root can do it. The reason for this is that if<br>any user can mount a floppy on any directory, then it is rather easy to create a floppy with, say, a Trojan horse<br>disguised as&nbsp;/bin/sh, or any other often used program. However, it is often necessary to allow users to use<br>floppies, and there are several ways to do this:<br>
Give the users the root password. This is obviously bad security, but is the easiest solution. It works<br>
•&nbsp;<br>
well if there is no need for security anyway, which is the case on many non−networked, personal<br>systems.<br>Use a program such as<br>
•&nbsp;<br>
<b>&nbsp;sudo</b>&nbsp;to allow users to use mount. This is still bad security, but doesn't directly<br>
give super user privileges to everyone.&nbsp;[23]<br>Make the users use<br>
•&nbsp;<br>
<b>&nbsp;mtools</b>, a package for manipulating MS−DOS filesystems, without mounting<br>
them. This works well if MS−DOS floppies are all that is needed, but is rather awkward otherwise.<br>List the floppy devices and their allowable mount points together with the suitable options in<br>
•&nbsp;<br>
/etc/fstab.<br>
The last alternative can be implemented by adding a line like the following to the&nbsp;/etc/fstab&nbsp;file:<br>
&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/floppy &nbsp; &nbsp; &nbsp;msdos &nbsp; user,noauto &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 0<br>
The columns are: device file to mount, directory to mount on, filesystem type, options, backup frequency<br>(used by<b>&nbsp;dump</b>), and<b>&nbsp;fsck</b>&nbsp;pass number (to specify the order in which filesystems should be checked upon<br>boot; 0 means no check).<br>
The&nbsp;noauto&nbsp;option stops this mount to be done automatically when the system is started (i.e., it stops<b>&nbsp;mount<br>−a</b>&nbsp;from mounting it). The&nbsp;user&nbsp;option allows any user to mount the filesystem, and, because of security<br>reasons, disallows execution of programs (normal or setuid) and interpretation of device files from the<br>mounted filesystem. After this, any user can mount a floppy with an msdos filesystem with the following<br>command:<br>
$&nbsp;<b>mount /floppy</b><br>
$<br>
The floppy can (and needs to, of course) be unmounted with the corresponding<b>&nbsp;umount</b>&nbsp;command.<br>
If you want to provide access to several types of floppies, you need to give several mount points. The settings<br>can be different for each mount point. For example, to give access to both MS−DOS and ext2 floppies, you<br>could have the following to lines in&nbsp;/etc/fstab:<br>
Chapter 6. Using Disks and Other Storage Media<br>
38<br>
<hr>
<A name=45></a>The Linux System Administrator's Guide<br>
&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0 &nbsp; &nbsp;/dosfloppy &nbsp; &nbsp;msdos &nbsp; user,noauto &nbsp;0 &nbsp;0<br>
&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0 &nbsp; &nbsp;/ext2floppy &nbsp; ext2 &nbsp; &nbsp;user,noauto &nbsp;0 &nbsp;0<br>
For MS−DOS filesystems (not just floppies), you probably want to restrict access to it by using the&nbsp;uid,&nbsp;gid,<br>and&nbsp;umask&nbsp;filesystem options, described in detail on the<b>&nbsp;mount</b>&nbsp;manual page. If you aren't careful, mounting<br>an MS−DOS filesystem gives everyone at least read access to the files in it, which is not a good idea.<br>
<b>6.8.6. Checking filesystem integrity with fsck</b><br>
Filesystems are complex creatures, and as such, they tend to be somewhat error−prone. A filesystem's<br>correctness and validity can be checked using the<b>&nbsp;fsck</b>&nbsp;command. It can be instructed to repair any minor<br>problems it finds, and to alert the user if there any unrepairable problems. Fortunately, the code to implement<br>filesystems is debugged quite effectively, so there are seldom any problems at all, and they are usually caused<br>by power failures, failing hardware, or operator errors; for example, by not shutting down the system properly.<br>
Most systems are setup to run<b>&nbsp;fsck</b>&nbsp;automatically at boot time, so that any errors are detected (and hopefully<br>corrected) before the system is used. Use of a corrupted filesystem tends to make things worse: if the data<br>structures are messed up, using the filesystem will probably mess them up even more, resulting in more data<br>loss. However,<b>&nbsp;fsck</b>&nbsp;can take a while to run on big filesystems, and since errors almost never occur if the<br>system has been shut down properly, a couple of tricks are used to avoid doing the checks in such cases. The<br>first is that if the file&nbsp;/etc/fastboot&nbsp;exists, no checks are made. The second is that the ext2 filesystem has<br>a special marker in its superblock that tells whether the filesystem was unmounted properly after the previous<br>mount. This allows<b>&nbsp;e2fsck</b>&nbsp;(the version of<b>&nbsp;fsck</b>&nbsp;for the ext2 filesystem) to avoid checking the filesystem if the<br>flag indicates that the unmount was done (the assumption being that a proper unmount indicates no problems).<br>Whether the&nbsp;/etc/fastboot&nbsp;trick works on your system depends on your startup scripts, but the ext2 trick<br>works every time you use<b>&nbsp;e2fsck</b>. It has to be explicitly bypassed with an option to<b>&nbsp;e2fsck</b>&nbsp;to be avoided. (See<br>the<b>&nbsp;e2fsck</b>&nbsp;man page for details on how.)<br>
The automatic checking only works for the filesystems that are mounted automatically at boot time. Use<b>&nbsp;fsck<br></b>manually to check other filesystems, e.g., floppies.<br>
If<b>&nbsp;fsck</b>&nbsp;finds unrepairable problems, you need either in−depth knowledge of how filesystems work in general,<br>and the type of the corrupt filesystem in particular, or good backups. The latter is easy (although sometimes<br>tedious) to arrange, the former can sometimes be arranged via a friend, the Linux newsgroups and mailing<br>lists, or some other source of support, if you don't have the know−how yourself. I'd like to tell you more about<br>it, but my lack of education and experience in this regard hinders me. The<b>&nbsp;debugfs</b>&nbsp;program by Theodore Ts'o<br>should be useful.<br>
<b>fsck</b>&nbsp;must only be run on unmounted filesystems, never on mounted filesystems (with the exception of the<br>read−only root during startup). This is because it accesses the raw disk, and can therefore modify the<br>filesystem without the operating system realizing it. There<i>&nbsp;will</i>&nbsp;be trouble, if the operating system is confused.<br>
<b>6.8.7. Checking for disk errors with badblocks</b><br>
It can be a good idea to periodically check for bad blocks. This is done with the<b>&nbsp;badblocks</b>&nbsp;command. It<br>outputs a list of the numbers of all bad blocks it can find. This list can be fed to<b>&nbsp;fsck</b>&nbsp;to be recorded in the<br>filesystem data structures so that the operating system won't try to use the bad blocks for storing data. The<br>following example will show how this could be done.<br>
Chapter 6. Using Disks and Other Storage Media<br>
39<br>
<hr>
<A name=46></a>The Linux System Administrator's Guide<br>
$&nbsp;<b>badblocks /dev/fd0H1440 1440 &gt;&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; bad−blocks</b><br>
$&nbsp;<b>fsck −t ext2 −l bad−blocks&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0H1440</b><br>
Parallelizing fsck version 0.5a (5−Apr−94)<br>
&nbsp; &nbsp; &nbsp; &nbsp; e2fsck 0.5a, 5−Apr−94 for EXT2 FS 0.5, 94/03/10<br>
&nbsp; &nbsp; &nbsp; &nbsp; Pass 1: Checking inodes, blocks, and sizes<br>
&nbsp; &nbsp; &nbsp; &nbsp; Pass 2: Checking directory structure<br>
&nbsp; &nbsp; &nbsp; &nbsp; Pass 3: Checking directory connectivity<br>
&nbsp; &nbsp; &nbsp; &nbsp; Pass 4: Check reference counts.<br>
&nbsp; &nbsp; &nbsp; &nbsp; Pass 5: Checking group summary information.<br>
&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****<br>
&nbsp; &nbsp; &nbsp; &nbsp; /dev/fd0H1440: 11/360 files, 63/1440 blocks<br>
$<br>
If badblocks reports a block that was already used,<b>&nbsp;e2fsck</b>&nbsp;will try to move the block to another place. If the<br>block was really bad, not just marginal, the contents of the file may be corrupted.<br>
<b>6.8.8. Fighting fragmentation</b><br>
When a file is written to disk, it can't always be written in consecutive blocks. A file that is not stored in<br>consecutive blocks is<i>&nbsp;fragmented</i>. It takes longer to read a fragmented file, since the disk's read−write head<br>will have to move more. It is desirable to avoid fragmentation, although it is less of a problem in a system<br>with a good buffer cache with read−ahead.<br>
The ext2 filesystem attempts to keep fragmentation at a minimum, by keeping all blocks in a file close<br>together, even if they can't be stored in consecutive sectors. Ext2 effectively always allocates the free block<br>that is nearest to other blocks in a file. For ext2, it is therefore seldom necessary to worry about fragmentation.<br>There is a program for defragmenting an ext2 filesystem called, strangely enough,<b>&nbsp;defrag</b>&nbsp;[24] .<br>
There are many MS−DOS defragmentation programs that move blocks around in the filesystem to remove<br>fragmentation. For other filesystems, defragmentation must be done by backing up the filesystem, re−creating<br>it, and restoring the files from backups. Backing up a filesystem before defragmenting is a good idea for all<br>filesystems, since many things can go wrong during the defragmentation.<br>
<b>6.8.9. Other tools for all filesystems</b><br>
Some other tools are also useful for managing filesystems.<b>&nbsp;df</b>&nbsp;shows the free disk space on one or more<br>filesystems;<b>&nbsp;du</b>&nbsp;shows how much disk space a directory and all its files contain. These can be used to hunt<br>down disk space wasters. Both have manual pages which detail the (many) options which can be used.<br>
<b>sync</b><a href="TLSAGs.html#56">&nbsp;forces all unwritten blocks in the buffer cache (see Section 7.6) to be written to disk. It is seldom<br></a>necessary to do this by hand; the daemon process<b>&nbsp;update</b>&nbsp;does this automatically. It can be useful in<br>catastrophes, for example if<b>&nbsp;update</b>&nbsp;or its helper process<b>&nbsp;bdflush</b>&nbsp;dies, or if you must turn off power<i>&nbsp;now</i>&nbsp;and<br>can't wait for<b>&nbsp;update</b>&nbsp;to run. Again, there are manual pages. The<b>&nbsp;man</b>&nbsp;is your very best friend in linux. Its<br>cousin<b>&nbsp;apropos</b>&nbsp;is also very useful when you don't know what the name of the command you want is.<br>
Chapter 6. Using Disks and Other Storage Media<br>
40<br>
<hr>
<A name=47></a>The Linux System Administrator's Guide<br>
<b>6.8.10. Other tools for the ext2/ext3 filesystem</b><br>
In addition to the filesystem creator (<b>mke2fs</b>) and checker (<b>e2fsck</b>) accessible directly or via the filesystem<br>type independent front ends, the ext2 filesystem has some additional tools that can be useful.<br>
<b>tune2fs</b>&nbsp;adjusts filesystem parameters. Some of the more interesting parameters are:<br>
A maximal mount count.<br>
•&nbsp;<br>
<b>&nbsp;e2fsck</b>&nbsp;enforces a check when filesystem has been mounted too many times,<br>
even if the clean flag is set. For a system that is used for developing or testing the system, it might be<br>a good idea to reduce this limit.<br>A maximal time between checks.<br>
•&nbsp;<br>
<b>&nbsp;e2fsck</b>&nbsp;can also enforce a maximal time between two checks, even if<br>
the clean flag is set, and the filesystem hasn't been mounted very often. This can be disabled,<br>however.<br>Number of blocks reserved for root. Ext2 reserves some blocks for root so that if the filesystem fills<br>
•&nbsp;<br>
up, it is still possible to do system administration without having to delete anything. The reserved<br>amount is by default 5 percent, which on most disks isn't enough to be wasteful. However, for<br>floppies there is no point in reserving any blocks.<br>
See the<b>&nbsp;tune2fs</b>&nbsp;manual page for more information.<br>
<b>dumpe2fs</b><a href="TLSAGs.html#47">&nbsp;shows information about an ext2 filesystem, mostly from the superblock. Figure 6−5 shows a<br></a>sample output. Some of the information in the output is technical and requires understanding of how the<br>filesystem works (see appendix XXX ext2fspaper), but much of it is readily understandable even for<br>layadmins.<br>
<b>Figure 6−5. Sample output from dumpe2fs</b><br>
dumpe2fs 0.5b, 11−Mar−95 for EXT2 FS 0.5a, 94/10/23<br>Filesystem magic number: &nbsp;0xEF53<br>Filesystem state: &nbsp; &nbsp; &nbsp; &nbsp; clean<br>Errors behavior: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Continue<br>Inode count: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;360<br>Block count: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1440<br>Reserved block count: &nbsp; &nbsp; 72<br>Free blocks: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1133<br>Free inodes: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;326<br>First block: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br>Block size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1024<br>Fragment size: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1024<br>Blocks per group: &nbsp; &nbsp; &nbsp; &nbsp; 8192<br>Fragments per group: &nbsp; &nbsp; &nbsp;8192<br>Inodes per group: &nbsp; &nbsp; &nbsp; &nbsp; 360<br>Last mount time: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Tue Aug &nbsp;8 01:52:52 1995<br>Last write time: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Tue Aug &nbsp;8 01:53:28 1995<br>Mount count: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3<br>Maximum mount count: &nbsp; &nbsp; &nbsp;20<br>Last checked: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tue Aug &nbsp;8 01:06:31 1995<br>Check interval: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br>
Chapter 6. Using Disks and Other Storage Media<br>
41<br>
<hr>
<A name=48></a>The Linux System Administrator's Guide<br>
Reserved blocks uid: &nbsp; &nbsp; &nbsp;0 (user root)<br>Reserved blocks gid: &nbsp; &nbsp; &nbsp;0 (group root)<br>
Group 0:<br>&nbsp; Block bitmap at 3, Inode bitmap at 4, Inode table at 5<br>&nbsp; 1133 free blocks, 326 free inodes, 2 directories<br>&nbsp; Free blocks: 307−1439<br>&nbsp; Free inodes: 35−360<br>
<b>debugfs</b>&nbsp;is a filesystem debugger. It allows direct access to the filesystem data structures stored on disk and<br>can thus be used to repair a disk that is so broken that<b>&nbsp;fsck</b>&nbsp;can't fix it automatically. It has also been known to<br>be used to recover deleted files. However,<b>&nbsp;debugfs</b>&nbsp;very much requires that you understand what you're doing;<br>a failure to understand can destroy all your data.<br>
<b>dump</b>&nbsp;and<b>&nbsp;restore</b>&nbsp;can be used to back up an ext2 filesystem. They are ext2 specific versions of the traditional<br><a href="TLSAGs.html#76">UNIX backup tools. See Chapter 12 for more information on backups.</a><br>
<b>6.9. Disks without filesystems</b><br>
Not all disks or partitions are used as filesystems. A swap partition, for example, will not have a filesystem on<br>it. Many floppies are used in a tape−drive emulating fashion, so that a<b>&nbsp;tar</b>&nbsp;(tape archive) or other file is written<br>directly on the raw disk, without a filesystem. Linux boot floppies don't contain a filesystem, only the raw<br>kernel.<br>
Avoiding a filesystem has the advantage of making more of the disk usable, since a filesystem always has<br>some bookkeeping overhead. It also makes the disks more easily compatible with other systems: for example,<br>the<b>&nbsp;tar</b>&nbsp;file format is the same on all systems, while filesystems are different on most systems. You will<br>quickly get used to disks without filesystems if you need them. Bootable Linux floppies also do not<br>necessarily have a filesystem, although they may.<br>
One reason to use raw disks is to make image copies of them. For instance, if the disk contains a partially<br>damaged filesystem, it is a good idea to make an exact copy of it before trying to fix it, since then you can<br>start again if your fixing breaks things even more. One way to do this is to use<b>&nbsp;dd</b>:<br>
$&nbsp;<b>dd if=/dev/fd0H1440&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; of=floppy−image</b><br>
2880+0 records in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2880+0 records out<br>
$&nbsp;<b>dd if=floppy−image&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; of=/dev/fd0H1440</b><br>
2880+0 records in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 2880+0 records out<br>
$<br>
The first<b>&nbsp;dd</b>&nbsp;makes an exact image of the floppy to the file&nbsp;floppy−image, the second one writes the image<br>to the floppy. (The user has presumably switched the floppy before the second command. Otherwise the<br>command pair is of doubtful usefulness.)<br>
Chapter 6. Using Disks and Other Storage Media<br>
42<br>
<hr>
<A name=49></a>The Linux System Administrator's Guide<br>
<b>6.10. Allocating disk space</b><br>
<b>6.10.1. Partitioning schemes</b><br>
It is not easy to partition a disk in the best possible way. Worse, there is no universally correct way to do it;<br>there are too many factors involved.<br>
The traditional way is to have a (relatively) small root filesystem, which contains&nbsp;/bin,&nbsp;/etc,&nbsp;/dev,&nbsp;/lib,<br>/tmp, and other stuff that is needed to get the system up and running. This way, the root filesystem (in its<br>own partition or on its own disk) is all that is needed to bring up the system. The reasoning is that if the root<br>filesystem is small and is not heavily used, it is less likely to become corrupt when the system crashes, and<br>you will therefore find it easier to fix any problems caused by the crash. Then you create separate partitions or<br>use separate disks for the directory tree below&nbsp;/usr, the users' home directories (often under&nbsp;/home), and<br>the swap space. Separating the home directories (with the users' files) in their own partition makes backups<br>easier, since it is usually not necessary to backup programs (which reside below&nbsp;/usr). In a networked<br>environment it is also possible to share&nbsp;/usr&nbsp;among several machines (e.g., by using NFS), thereby reducing<br>the total disk space required by several tens or hundreds of megabytes times the number of machines.<br>
The problem with having many partitions is that it splits the total amount of free disk space into many small<br>pieces. Nowadays, when disks and (hopefully) operating systems are more reliable, many people prefer to<br>have just one partition that holds all their files. On the other hand, it can be less painful to back up (and<br>restore) a small partition.<br>
For a small hard disk (assuming you don't do kernel development), the best way to go is probably to have just<br>one partition. For large hard disks, it is probably better to have a few large partitions, just in case something<br>does go wrong. (Note that `small' and `large' are used in a relative sense here; your needs for disk space decide<br>what the threshold is.)<br>
If you have several disks, you might wish to have the root filesystem (including&nbsp;/usr) on one, and the users'<br>home directories on another.<br>
It is a good idea to be prepared to experiment a bit with different partitioning schemes (over time, not just<br>while first installing the system). This is a bit of work, since it essentially requires you to install the system<br>from scratch several times&nbsp;[25] , but it is the only way to be sure you do it right.<br>
<b>6.10.2. Space requirements</b><br>
The Linux distribution you install will give some indication of how much disk space you need for various<br>configurations. Programs installed separately may also do the same. This will help you plan your disk space<br>usage, but you should prepare for the future and reserve some extra space for things you will notice later that<br>you need.<br>
The amount you need for user files depends on what your users wish to do. Most people seem to need as much<br>space for their files as possible, but the amount they will live happily with varies a lot. Some people do only<br>light text processing and will survive nicely with a few megabytes, others do heavy image processing and will<br>need gigabytes.<br>
By the way, when comparing file sizes given in kilobytes or megabytes and disk space given in megabytes, it<br>can be important to know that the two units can be different. Some disk manufacturers like to pretend that a<br>
Chapter 6. Using Disks and Other Storage Media<br>
43<br>
<hr>
<A name=50></a>The Linux System Administrator's Guide<br>
kilobyte is 1000 bytes and a megabyte is 1000 kilobytes, while all the rest of the computing world uses 1024<br>for both factors. Therefore, my 345 MB hard disk was really a 330 MB hard disk.<br>
<a href="TLSAGs.html#55">Swap space allocation is discussed in Section 7.5.</a><br>
<b>6.10.3. Examples of hard disk allocation</b><br>
I used to have a 109 MB hard disk. Now I am using a 330 MB hard disk. I'll explain how and why I<br>partitioned those disks.<br>
The 109 MB disk I partitioned in a lot of ways, when my needs and the operating systems I used changed; I'll<br>explain two typical scenarios. First, I used to run MS−DOS together with Linux. For that, I needed about 20<br>MB of hard disk, or just enough to have MS−DOS, a C compiler, an editor, a few other utilities, the program I<br>was working on, and enough free disk space to not feel claustrophobic. For Linux, I had a 10 MB swap<br>partition, and the rest, or 79 MB, was a single partition with all the files I had under Linux. I experimented<br>with having separate root,&nbsp;/usr, and&nbsp;/home&nbsp;partitions, but there was never enough free disk space in one<br>piece to do much interesting.<br>
When I didn't need MS−DOS anymore, I repartitioned the disk so that I had a 12 MB swap partition, and<br>again had the rest as a single filesystem.<br>
The 330 MB disk is partitioned into several partitions, like this:<br>
5 MB<br>
root filesystem<br>
10 MB<br>
swap partition<br>
180 MB&nbsp;/usr&nbsp;filesystem<br>
120 MB&nbsp;/home&nbsp;filesystem<br>
15 MB<br>
scratch partition<br>
The scratch partition is for playing around with things that require their own partition, e.g., trying different<br>Linux distributions, or comparing speeds of filesystems. When not needed for anything else, it is used as swap<br>space (I like to have a lot of open windows).&nbsp;[26]<br>
<b>6.10.4. Adding more disk space for Linux</b><br>
Adding more disk space for Linux is easy, at least after the hardware has been properly installed (the<br>hardware installation is outside the scope of this book). You format it if necessary, then create the partitions<br>and filesystem as described above, and add the proper lines to&nbsp;/etc/fstab&nbsp;so that it is mounted<br>automatically.<br>
<b>6.10.5. Tips for saving disk space</b><br>
The best tip for saving disk space is to avoid installing unnecessary programs. Most Linux distributions have<br>an option to install only part of the packages they contain, and by analyzing your needs you might notice that<br>you don't need most of them. This will help save a lot of disk space, since many programs are quite large.<br>Even if you do need a particular package or program, you might not need all of it. For example, some on−line<br>documentation might be unnecessary, as might some of the Elisp files for GNU Emacs, some of the fonts for<br>
Chapter 6. Using Disks and Other Storage Media<br>
44<br>
<hr>
<A name=51></a>The Linux System Administrator's Guide<br>
X11, or some of the libraries for programming.<br>
If you cannot uninstall packages, you might look into compression. Compression programs such as<b>&nbsp;gzip</b>&nbsp;or<br><b>zip</b>&nbsp;will compress (and uncompress) individual files or groups of files. The<b>&nbsp;gzexe</b>&nbsp;system will compress and<br>uncompress programs invisibly to the user (unused programs are compressed, then uncompressed as they are<br>used). The experimental DouBle system will compress all files in a filesystem, invisibly to the programs that<br>use them. (If you are familiar with products such as Stacker for MS−DOS or DriveSpace for Windows, the<br>principle is the same.)<br>
Chapter 6. Using Disks and Other Storage Media<br>
45<br>
<hr>
<A name=52></a><b>Chapter 7. Memory Management</b><br>
&quot;Minnet, jag har tappat mitt minne, är jag svensk eller finne, kommer inte ihåg...&quot; (Bosse<br>österberg)<br>
A Swedish drinking song, (rough) translation: &quot;Memory, I have lost my memory. Am I<br>Swedish or Finnish? I can't remember&quot;<br>
This section describes the Linux memory management features, i.e., virtual memory and the disk buffer cache.<br>The purpose and workings and the things the system administrator needs to take into consideration are<br>described.<br>
<b>7.1. What is virtual memory?</b><br>
Linux supports<i>&nbsp;virtual memory</i>, that is, using a disk as an extension of RAM so that the effective size of<br>usable memory grows correspondingly. The kernel will write the contents of a currently unused block of<br>memory to the hard disk so that the memory can be used for another purpose. When the original contents are<br>needed again, they are read back into memory. This is all made completely transparent to the user; programs<br>running under Linux only see the larger amount of memory available and don't notice that parts of them reside<br>on the disk from time to time. Of course, reading and writing the hard disk is slower (on the order of a<br>thousand times slower) than using real memory, so the programs don't run as fast. The part of the hard disk<br>that is used as virtual memory is called the<i>&nbsp;swap space</i>.<br>
Linux can use either a normal file in the filesystem or a separate partition for swap space. A swap partition is<br>faster, but it is easier to change the size of a swap file (there's no need to repartition the whole hard disk, and<br>possibly install everything from scratch). When you know how much swap space you need, you should go for<br>a swap partition, but if you are uncertain, you can use a swap file first, use the system for a while so that you<br>can get a feel for how much swap you need, and then make a swap partition when you're confident about its<br>size.<br>
You should also know that Linux allows one to use several swap partitions and/or swap files at the same time.<br>This means that if you only occasionally need an unusual amount of swap space, you can set up an extra swap<br>file at such times, instead of keeping the whole amount allocated all the time.<br>
A note on operating system terminology: computer science usually distinguishes between swapping (writing<br>the whole process out to swap space) and paging (writing only fixed size parts, usually a few kilobytes, at a<br>time). Paging is usually more efficient, and that's what Linux does, but traditional Linux terminology talks<br>about swapping anyway.&nbsp;[27]<br>
<b>7.2. Creating a swap space</b><br>
A swap file is an ordinary file; it is in no way special to the kernel. The only thing that matters to the kernel is<br>that it has no holes, and that it is prepared for use with<b>&nbsp;mkswap</b>. It must reside on a local disk, however; it<br>can't reside in a filesystem that has been mounted over NFS due to implementation reasons.<br>
The bit about holes is important. The swap file reserves the disk space so that the kernel can quickly swap out<br>a page without having to go through all the things that are necessary when allocating a disk sector to a file.<br>
Chapter 7. Memory Management<br>
46<br>
<hr>
<A name=53></a>The Linux System Administrator's Guide<br>
The kernel merely uses any sectors that have already been allocated to the file. Because a hole in a file means<br>that there are no disk sectors allocated (for that place in the file), it is not good for the kernel to try to use<br>them.<br>
One good way to create the swap file without holes is through the following command:<br>
$&nbsp;<b>dd if=/dev/zero of=/extra−swap bs=1024&nbsp;</b><br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; count=1024</b><br>
1024+0 records in<br>
&nbsp; &nbsp; &nbsp; &nbsp; 1024+0 records out<br>
$<br>
where&nbsp;/extra−swap&nbsp;is the name of the swap file and the size of is given after the&nbsp;count=. It is best for the<br>size to be a multiple of 4, because the kernel writes out<i>&nbsp;memory pages</i>, which are 4 kilobytes in size. If the<br>size is not a multiple of 4, the last couple of kilobytes may be unused.<br>
A swap partition is also not special in any way. You create it just like any other partition; the only difference<br>is that it is used as a raw partition, that is, it will not contain any filesystem at all. It is a good idea to mark<br>swap partitions as type 82 (Linux swap); this will the make partition listings clearer, even though it is not<br>strictly necessary to the kernel.<br>
After you have created a swap file or a swap partition, you need to write a signature to its beginning; this<br>contains some administrative information and is used by the kernel. The command to do this is<b>&nbsp;mkswap</b>, used<br>like this:<br>
$&nbsp;<b>mkswap /extra−swap 1024</b><br>
Setting up swapspace, size = 1044480&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; bytes<br>
$<br>
Note that the swap space is still not in use yet: it exists, but the kernel does not use it to provide virtual<br>memory.<br>
You should be very careful when using<b>&nbsp;mkswap</b>, since it does not check that the file or partition isn't used for<br>anything else.<i>&nbsp;You can easily overwrite important files and partitions with<b>&nbsp;mkswap</b>!</i>&nbsp;Fortunately, you should<br>only need to use<b>&nbsp;mkswap</b>&nbsp;when you install your system.<br>
The Linux memory manager limits the size of each swap space to about 127 MB (for various technical<br>reasons, the actual limit is (4096−10) * 8 * 4096 = 133890048$ bytes, or 127.6875 megabytes). You can,<br>however, use up to 8 swap spaces simultaneously, for a total of almost 1 GB.&nbsp;[28]<br>
This is actually no longer true, this section is slated for a rewrite Real Soon Now (tm). With newer kernels and<br>versions of the<b>&nbsp;mkswap</b>&nbsp;command the actual limit depends on architecture. For i386 and compatibles it is<br>2Gigabytes, other architectures vary. Consult the mkswap(8) manual page for more details.<br>
<b>7.3. Using a swap space</b><br>
An initialized swap space is taken into use with<b>&nbsp;swapon</b>. This command tells the kernel that the swap space<br>can be used. The path to the swap space is given as the argument, so to start swapping on a temporary swap<br>file one might use the following command.<br>
Chapter 7. Memory Management<br>
47<br>
<hr>
<A name=54></a>The Linux System Administrator's Guide<br>
$&nbsp;<b>swapon /extra−swap</b><br>
$<br>
Swap spaces can be used automatically by listing them in the&nbsp;/etc/fstab&nbsp;file.<br>
/dev/hda8 &nbsp; &nbsp; &nbsp; &nbsp;none &nbsp; &nbsp; &nbsp; &nbsp;swap &nbsp; &nbsp; &nbsp; &nbsp;sw &nbsp; &nbsp; 0 &nbsp; &nbsp; 0<br>
/swapfile &nbsp; &nbsp; &nbsp; &nbsp;none &nbsp; &nbsp; &nbsp; &nbsp;swap &nbsp; &nbsp; &nbsp; &nbsp;sw &nbsp; &nbsp; 0 &nbsp; &nbsp; 0<br>
The startup scripts will run the command<b>&nbsp;swapon −a</b>, which will start swapping on all the swap spaces listed<br>in<b>&nbsp;/etc/fstab</b>. Therefore, the<b>&nbsp;swapon</b>&nbsp;command is usually used only when extra swap is needed.<br>
You can monitor the use of swap spaces with<b>&nbsp;free</b>. It will tell the total amount of swap space used.<br>
$&nbsp;<b>free</b><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total &nbsp; &nbsp; &nbsp; used &nbsp; &nbsp; &nbsp; free &nbsp; &nbsp; shared &nbsp;&nbsp;<br>
&nbsp;buffers<br>
Mem: &nbsp; &nbsp; &nbsp; &nbsp; 15152 &nbsp; &nbsp; &nbsp;14896 &nbsp; &nbsp; &nbsp; &nbsp;256 &nbsp; &nbsp; &nbsp;12404 &nbsp; &nbsp; &nbsp; 2528<br>
−/+ buffers: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12368 &nbsp; &nbsp; &nbsp; 2784<br>
Swap: &nbsp; &nbsp; &nbsp; &nbsp;32452 &nbsp; &nbsp; &nbsp; 6684 &nbsp; &nbsp; &nbsp;25768<br>
$<br>
The first line of output (Mem:) shows the physical memory. The total column does not show the physical<br>memory used by the kernel, which is usually about a megabyte. The used column shows the amount of<br>memory used (the second line does not count buffers). The free column shows completely unused memory.<br>The shared column shows the amount of memory shared by several processes; the more, the merrier. The<br>buffers column shows the current size of the disk buffer cache.<br>
That last line (Swap:) shows similar information for the swap spaces. If this line is all zeroes, your swap<br>space is not activated.<br>
The same information is available via<b>&nbsp;top</b>, or using the proc filesystem in file&nbsp;/proc/meminfo. It is<br>currently difficult to get information on the use of a specific swap space.<br>
A swap space can be removed from use with<b>&nbsp;swapoff</b>. It is usually not necessary to do it, except for temporary<br>swap spaces. Any pages in use in the swap space are swapped in first; if there is not sufficient physical<br>memory to hold them, they will then be swapped out (to some other swap space). If there is not enough virtual<br>memory to hold all of the pages Linux will start to thrash; after a long while it should recover, but meanwhile<br>the system is unusable. You should check (e.g., with<b>&nbsp;free</b>) that there is enough free memory before removing<br>a swap space from use.<br>
All the swap spaces that are used automatically with<b>&nbsp;swapon −a</b>&nbsp;can be removed from use with<b>&nbsp;swapoff −a</b>; it<br>looks at the file&nbsp;/etc/fstab&nbsp;to find what to remove. Any manually used swap spaces will remain in use.<br>
Sometimes a lot of swap space can be in use even though there is a lot of free physical memory. This can<br>happen for instance if at one point there is need to swap, but later a big process that occupied much of the<br>physical memory terminates and frees the memory. The swapped−out data is not automatically swapped in<br>until it is needed, so the physical memory may remain free for a long time. There is no need to worry about<br>this, but it can be comforting to know what is happening.<br>
Chapter 7. Memory Management<br>
48<br>
<hr>
<A name=55></a>The Linux System Administrator's Guide<br>
<b>7.4. Sharing swap spaces with other operating systems</b><br>
Virtual memory is built into many operating systems. Since they each need it only when they are running, i.e.,<br>never at the same time, the swap spaces of all but the currently running one are being wasted. It would be<br>more efficient for them to share a single swap space. This is possible, but can require a bit of hacking. The<br>Tips−HOWTO contains some advice on how to implement this.<br>
<b>7.5. Allocating swap space</b><br>
Some people will tell you that you should allocate twice as much swap space as you have physical memory,<br>but this is a bogus rule. Here's how to do it properly:<br>
Estimate your total memory needs. This is the largest amount of memory you'll probably need at a<br>
•&nbsp;<br>
time, that is the sum of the memory requirements of all the programs you want to run at the same<br>time. This can be done by running at the same time all the programs you are likely to ever be running<br>at the same time.<br>
For instance, if you want to run X, you should allocate about 8 MB for it, gcc wants several<br>megabytes (some files need an unusually large amount, up to tens of megabytes, but usually about<br>four should do), and so on. The kernel will use about a megabyte by itself, and the usual shells and<br>other small utilities perhaps a few hundred kilobytes (say a megabyte together). There is no need to<br>try to be exact, rough estimates are fine, but you might want to be on the pessimistic side.<br>
Remember that if there are going to be several people using the system at the same time, they are all<br>going to consume memory. However, if two people run the same program at the same time, the total<br>memory consumption is usually not double, since code pages and shared libraries exist only once.<br>
The<b>&nbsp;free</b>&nbsp;and<b>&nbsp;ps</b>&nbsp;commands are useful for estimating the memory needs.<br>Add some security to the estimate in step 1. This is because estimates of program sizes will probably<br>
•&nbsp;<br>
be wrong, because you'll probably forget some programs you want to run, and to make certain that<br>you have some extra space just in case. A couple of megabytes should be fine. (It is better to allocate<br>too much than too little swap space, but there's no need to over−do it and allocate the whole disk,<br>since unused swap space is wasted space; see later about adding more swap.) Also, since it is nicer to<br>deal with even numbers, you can round the value up to the next full megabyte.<br>Based on the computations above, you know how much memory you'll be needing in total. So, in<br>
•&nbsp;<br>
order to allocate swap space, you just need to subtract the size of your physical memory from the total<br>memory needed, and you know how much swap space you need. (On some versions of UNIX, you<br>need to allocate space for an image of the physical memory as well, so the amount computed in step 2<br>is what you need and you shouldn't do the subtraction.)<br>If your calculated swap space is very much larger than your physical memory (more than a couple<br>
•&nbsp;<br>
times larger), you should probably invest in more physical memory, otherwise performance will be<br>too low.<br>
It's a good idea to have at least some swap space, even if your calculations indicate that you need none. Linux<br>uses swap space somewhat aggressively, so that as much physical memory as possible can be kept free. Linux<br>will swap out memory pages that have not been used, even if the memory is not yet needed for anything. This<br>avoids waiting for swapping when it is needed: the swapping can be done earlier, when the disk is otherwise<br>idle.<br>
Chapter 7. Memory Management<br>
49<br>
<hr>
<A name=56></a>The Linux System Administrator's Guide<br>
Swap space can be divided among several disks. This can sometimes improve performance, depending on the<br>relative speeds of the disks and the access patterns of the disks. You might want to experiment with a few<br>schemes, but be aware that doing the experiments properly is quite difficult. You should not believe claims<br>that any one scheme is superior to any other, since it won't always be true.<br>
<b>7.6. The buffer cache</b><br>
Reading from a disk&nbsp;[29] is very slow compared to accessing (real) memory. In addition, it is common to read<br>the same part of a disk several times during relatively short periods of time. For example, one might first read<br>an e−mail message, then read the letter into an editor when replying to it, then make the mail program read it<br>again when copying it to a folder. Or, consider how often the command<b>&nbsp;ls</b>&nbsp;might be run on a system with<br>many users. By reading the information from disk only once and then keeping it in memory until no longer<br>needed, one can speed up all but the first read. This is called<i>&nbsp;disk buffering</i>, and the memory used for the<br>purpose is called the<i>&nbsp;buffer cache</i>.<br>
Since memory is, unfortunately, a finite, nay, scarce resource, the buffer cache usually cannot be big enough<br>(it can't hold all the data one ever wants to use). When the cache fills up, the data that has been unused for the<br>longest time is discarded and the memory thus freed is used for the new data.<br>
Disk buffering works for writes as well. On the one hand, data that is written is often soon read again (e.g., a<br>source code file is saved to a file, then read by the compiler), so putting data that is written in the cache is a<br>good idea. On the other hand, by only putting the data into the cache, not writing it to disk at once, the<br>program that writes runs quicker. The writes can then be done in the background, without slowing down the<br>other programs.<br>
Most operating systems have buffer caches (although they might be called something else), but not all of them<br>work according to the above principles. Some are<i>&nbsp;write−through</i>: the data is written to disk at once (it is kept<br>in the cache as well, of course). The cache is called<i>&nbsp;write−back</i>&nbsp;if the writes are done at a later time.<br>Write−back is more efficient than write−through, but also a bit more prone to errors: if the machine crashes,<br>or the power is cut at a bad moment, or the floppy is removed from the disk drive before the data in the cache<br>waiting to be written gets written, the changes in the cache are usually lost. This might even mean that the<br>filesystem (if there is one) is not in full working order, perhaps because the unwritten data held important<br>changes to the bookkeeping information.<br>
<a href="TLSAGs.html#58">Because of this, you should never turn off the power without using a proper shutdown procedure (see Chapter<br>8), or remove a floppy from the disk drive until it has been unmounted (if it was mounted) or after whatever<br></a>program is using it has signaled that it is finished and the floppy drive light doesn't shine anymore. The<b>&nbsp;sync<br></b>command<i>&nbsp;flushes</i>&nbsp;the buffer, i.e., forces all unwritten data to be written to disk, and can be used when one<br>wants to be sure that everything is safely written. In traditional UNIX systems, there is a program called<br><b>update</b>&nbsp;running in the background which does a<b>&nbsp;sync</b>&nbsp;every 30 seconds, so it is usually not necessary to use<br><b>sync</b>. Linux has an additional daemon,<b>&nbsp;bdflush</b>, which does a more imperfect sync more frequently to avoid<br>the sudden freeze due to heavy disk I/O that<b>&nbsp;sync</b>&nbsp;sometimes causes.<br>
Under Linux,<b>&nbsp;bdflush</b>&nbsp;is started by<b>&nbsp;update</b>. There is usually no reason to worry about it, but if<b>&nbsp;bdflush<br></b>happens to die for some reason, the kernel will warn about this, and you should start it by hand<br>(<b>/sbin/update</b>).<br>
The cache does not actually buffer files, but blocks, which are the smallest units of disk I/O (under Linux,<br>they are usually 1 kB). This way, also directories, super blocks, other filesystem bookkeeping data, and<br>non−filesystem disks are cached.<br>
Chapter 7. Memory Management<br>
50<br>
<hr>
<A name=57></a>The Linux System Administrator's Guide<br>
The effectiveness of a cache is primarily decided by its size. A small cache is next to useless: it will hold so<br>little data that all cached data is flushed from the cache before it is reused. The critical size depends on how<br>much data is read and written, and how often the same data is accessed. The only way to know is to<br>experiment.<br>
If the cache is of a fixed size, it is not very good to have it too big, either, because that might make the free<br>memory too small and cause swapping (which is also slow). To make the most efficient use of real memory,<br>Linux automatically uses all free RAM for buffer cache, but also automatically makes the cache smaller when<br>programs need more memory.<br>
Under Linux, you do not need to do anything to make use of the cache, it happens completely automatically.<br>Except for following the proper procedures for shutdown and removing floppies, you do not need to worry<br>about it.<br>
Chapter 7. Memory Management<br>
51<br>
<hr>
<A name=58></a><b>Chapter 8. Boots And Shutdowns</b><br>
Start me up<br>Ah... you've got to... you've got to<br>Never, never never stop<br>Start it up<br>Ah... start it up, never, never, never<br>&nbsp;You make a grown man cry,<br>&nbsp; you make a grown man cry<br>(Rolling Stones)<br>
This section explains what goes on when a Linux system is brought up and taken down, and how it should be<br>done properly. If proper procedures are not followed, files might be corrupted or lost.<br>
<b>8.1. An overview of boots and shutdowns</b><br>
The act of turning on a computer system and causing its operating system to be loaded&nbsp;[30] is called<i>&nbsp;booting</i>.<br>The name comes from an image of the computer pulling itself up from its bootstraps, but the act itself slightly<br>more realistic.<br>
During bootstrapping, the computer first loads a small piece of code called the<i>&nbsp;bootstrap loader</i>, which in turn<br>loads and starts the operating system. The bootstrap loader is usually stored in a fixed location on a hard disk<br>or a floppy. The reason for this two step process is that the operating system is big and complicated, but the<br>first piece of code that the computer loads must be very small (a few hundred bytes), to avoid making the<br>firmware unnecessarily complicated.<br>
Different computers do the bootstrapping differently. For PCs, the computer (its BIOS) reads in the first sector<br>(called the<i>&nbsp;boot sector</i>) of a floppy or hard disk. The bootstrap loader is contained within this sector. It loads<br>the operating system from elsewhere on the disk (or from some other place).<br>
After Linux has been loaded, it initializes the hardware and device drivers, and then runs<b>&nbsp;init</b>.<b>&nbsp;init</b>&nbsp;starts other<br>processes to allow users to log in, and do things. The details of this part will be discussed below.<br>
In order to shut down a Linux system, first all processes are told to terminate (this makes them close any files<br>and do other necessary things to keep things tidy), then filesystems and swap areas are unmounted, and finally<br>a message is printed to the console that the power can be turned off. If the proper procedure is not followed,<br>terrible things can and will happen; most importantly, the filesystem buffer cache might not be flushed, which<br>means that all data in it is lost and the filesystem on disk is inconsistent, and therefore possibly unusable.<br>
<b>8.2. The boot process in closer look</b><br>
You can boot Linux either from a floppy or from the hard disk. The installation section in the Installation and<br>Getting Started guide (XXX citation) tells you how to install Linux so you can boot it the way you want to.<br>
When a PC is booted, the BIOS will do various tests to check that everything looks all right,&nbsp;[31] and will<br>then start the actual booting. It will choose a disk drive (typically the first floppy drive, if there is a floppy<br>
Chapter 8. Boots And Shutdowns<br>
52<br>
<hr>
<A name=59></a>The Linux System Administrator's Guide<br>
inserted, otherwise the first hard disk, if one is installed in the computer; the order might be configurable,<br>however) and will then read its very first sector. This is called the<i>&nbsp;boot sector</i>; for a hard disk, it is also called<br>the<i>&nbsp;master boot record</i>, since a hard disk can contain several partitions, each with their own boot sectors.<br>
The boot sector contains a small program (small enough to fit into one sector) whose responsibility is to read<br>the actual operating system from the disk and start it. When booting Linux from a floppy disk, the boot sector<br>contains code that just reads the first few hundred blocks (depending on the actual kernel size, of course) to a<br>predetermined place in memory. On a Linux boot floppy, there is no filesystem, the kernel is just stored in<br>consecutive sectors, since this simplifies the boot process. It is possible, however, to boot from a floppy with a<br>filesystem, by using LILO, the LInux LOader.<br>
When booting from the hard disk, the code in the master boot record will examine the partition table (also in<br>the master boot record), identify the active partition (the partition that is marked to be bootable), read the boot<br>sector from that partition, and then start the code in that boot sector. The code in the partition's boot sector<br>does what a floppy disk's boot sector does: it will read in the kernel from the partition and start it. The details<br>vary, however, since it is generally not useful to have a separate partition for just the kernel image, so the code<br>in the partition's boot sector can't just read the disk in sequential order, it has to find the sectors wherever the<br>filesystem has put them. There are several ways around this problem, but the most common way is to use<br>LILO. (The details about how to do this are irrelevant for this discussion, however; see the LILO<br>documentation for more information; it is most thorough.)<br>
When booting with LILO, it will normally go right ahead and read in and boot the default kernel. It is also<br>possible to configure LILO to be able to boot one of several kernels, or even other operating systems than<br>Linux, and it is possible for the user to choose which kernel or operating system is to be booted at boot time.<br>LILO can be configured so that if one holds down the<b>&nbsp;alt</b>,<b>&nbsp;shift</b>, or<b>&nbsp;ctrl</b>&nbsp;key at boot time (when LILO is<br>loaded), LILO will ask what is to be booted and not boot the default right away. Alternatively, LILO can be<br>configured so that it will always ask, with an optional timeout that will cause the default kernel to be booted.<br>
With LILO, it is also possible to give a<i>&nbsp;kernel command line argument</i>, after the name of the kernel or<br>operating system.<br>
Booting from floppy and from hard disk have both their advantages, but generally booting from the hard disk<br>is nicer, since it avoids the hassle of playing around with floppies. It is also faster. However, it can be more<br>troublesome to install the system to boot from the hard disk, so many people will first boot from floppy, then,<br>when the system is otherwise installed and working well, will install LILO and start booting from the hard<br>disk.<br>
After the Linux kernel has been read into the memory, by whatever means, and is started for real, roughly the<br>following things happen:<br>
The Linux kernel is installed compressed, so it will first uncompress itself. The beginning of the<br>
•&nbsp;<br>
kernel image contains a small program that does this.<br>If you have a super−VGA card that Linux recognizes and that has some special text modes (such as<br>
•&nbsp;<br>
100 columns by 40 rows), Linux asks you which mode you want to use. During the kernel<br>compilation, it is possible to preset a video mode, so that this is never asked. This can also be done<br>with LILO or<b>&nbsp;rdev</b>.<br>After this, the kernel checks what other hardware there is (hard disks, floppies, network adapters, etc),<br>
•&nbsp;<br>
and configures some of its device drivers appropriately; while it does this, it outputs messages about<br>its findings. For example, when I boot, I it looks like this:<br>
LILO boot:<br>
Loading linux.<br>
Chapter 8. Boots And Shutdowns<br>
53<br>
<hr>
<A name=60></a>The Linux System Administrator's Guide<br>
Console: colour EGA+ 80x25, 8 virtual consoles<br>
Serial driver version 3.94 with no serial options enabled<br>
tty00 at 0x03f8 (irq = 4) is a 16450<br>
tty01 at 0x02f8 (irq = 3) is a 16450<br>
lp_init: lp1 exists (0), using polling driver<br>
Memory: 7332k/8192k available (300k kernel code, 384k reserved, 176k&nbsp;<br>
data)<br>
Floppy drive(s): fd0 is 1.44M, fd1 is 1.2M<br>
Loopback device init<br>
Warning WD8013 board not found at i/o = 280.<br>
Math coprocessor using irq13 error reporting.<br>
Partition check:<br>
&nbsp; hda: hda1 hda2 hda3<br>
VFS: Mounted root (ext filesystem).<br>
Linux version 0.99.pl9−1 (root@haven) 05/01/93 14:12:20<br>
The exact texts are different on different systems, depending on the hardware, the version of Linux<br>being used, and how it has been configured.<br>Then the kernel will try to mount the root filesystem. The place is configurable at compilation time, or<br>
•&nbsp;<br>
any time with<b>&nbsp;rdev</b>&nbsp;or LILO. The filesystem type is detected automatically. If the mounting of the<br>root filesystem fails, for example because you didn't remember to include the corresponding<br>filesystem driver in the kernel, the kernel panics and halts the system (there isn't much it can do,<br>anyway).<br>
The root filesystem is usually mounted read−only (this can be set in the same way as the place). This<br>makes it possible to check the filesystem while it is mounted; it is not a good idea to check a<br>filesystem that is mounted read−write.<br>After this, the kernel starts the program<br>
•&nbsp;<br>
<b>&nbsp;init</b>&nbsp;(located in&nbsp;/sbin/init) in the background (this will<br>
always become process number 1).<b>&nbsp;init</b>&nbsp;does various startup chores. The exact things it does depends<br><a href="TLSAGs.html#63">on how it is configured; see Chapter 9 for more information (not yet written). It will at least start some<br></a>essential background daemons.<br><b>init</b><br>
•&nbsp;<br>
&nbsp;then switches to multi−user mode, and starts a<b>&nbsp;getty</b>&nbsp;for virtual consoles and serial lines.<b>&nbsp;getty</b>&nbsp;is<br>
the program which lets people log in via virtual consoles and serial terminals.<b>&nbsp;init</b>&nbsp;may also start some<br>other programs, depending on how it is configured.<br>After this, the boot is complete, and the system is up and running normally.<br>
•&nbsp;<br>
<b>8.3. More about shutdowns</b><br>
It is important to follow the correct procedures when you shut down a Linux system. If you fail do so, your<br>filesystems probably will become trashed and the files probably will become scrambled. This is because<br>Linux has a disk cache that won't write things to disk at once, but only at intervals. This greatly improves<br>performance but also means that if you just turn off the power at a whim the cache may hold a lot of data and<br>that what is on the disk may not be a fully working filesystem (because only some things have been written to<br>the disk).<br>
Another reason against just flipping the power switch is that in a multi−tasking system there can be lots of<br>things going on in the background, and shutting the power can be quite disastrous. By using the proper<br>shutdown sequence, you ensure that all background processes can save their data.<br>
The command for properly shutting down a Linux system is<b>&nbsp;shutdown</b>. It is usually used in one of two ways.<br>
If you are running a system where you are the only user, the usual way of using<b>&nbsp;shutdown</b>&nbsp;is to quit all<br>running programs, log out on all virtual consoles, log in as root on one of them (or stay logged in as root if<br>
Chapter 8. Boots And Shutdowns<br>
54<br>
<hr>
<A name=61></a>The Linux System Administrator's Guide<br>
you already are, but you should change to root's home directory or the root directory, to avoid problems with<br>unmounting), then give the command<b>&nbsp;shutdown −h now</b>&nbsp;(substitute&nbsp;now&nbsp;with a plus sign and a number in<br>minutes if you want a delay, though you usually don't on a single user system).<br>
Alternatively, if your system has many users, use the command<b>&nbsp;shutdown −h +time message</b>, where&nbsp;time&nbsp;is<br>the time in minutes until the system is halted, and&nbsp;message&nbsp;is a short explanation of why the system is<br>shutting down.<br>
#&nbsp;<b>shutdown −h +10 'We will install a new&nbsp;</b><br>
<b>disk. &nbsp;System should</b><br>
<b>&gt; be back on−line in three hours.'</b><br>
#<br>
This will warn everybody that the system will shut down in ten minutes, and that they'd better get lost or lose<br>data. The warning is printed to every terminal on which someone is logged in, including all<b>&nbsp;xterm</b>s:<br>
Broadcast message from root (ttyp0) Wed Aug &nbsp;2 01:03:25 1995...<br>
We will install a new disk. &nbsp;System should<br>
be back on−line in three hours.<br>
The system is going DOWN for system halt in 10 minutes !!<br>
The warning is automatically repeated a few times before the boot, with shorter and shorter intervals as the<br>time runs out.<br>
When the real shutting down starts after any delays, all filesystems (except the root one) are unmounted, user<br>processes (if anybody is still logged in) are killed, daemons are shut down, all filesystem are unmounted, and<br>generally everything settles down. When that is done,<b>&nbsp;init</b>&nbsp;prints out a message that you can power down the<br>machine. Then, and only then, should you move your fingers towards the power switch.<br>
Sometimes, although rarely on any good system, it is impossible to shut down properly. For instance, if the<br>kernel panics and crashes and burns and generally misbehaves, it might be completely impossible to give any<br>new commands, hence shutting down properly is somewhat difficult, and just about everything you can do is<br>hope that nothing has been too severely damaged and turn off the power. If the troubles are a bit less severe<br>(say, somebody hit your keyboard with an axe), and the kernel and the<b>&nbsp;update</b>&nbsp;program still run normally, it is<br>probably a good idea to wait a couple of minutes to give<b>&nbsp;update</b>&nbsp;a chance to flush the buffer cache, and only<br>cut the power after that.<br>
Some people like to shut down using the command<b>&nbsp;sync</b>&nbsp;[32] three times, waiting for the disk I/O to stop, then<br>turn off the power. If there are no running programs, this is about equivalent to using<b>&nbsp;shutdown</b>. However, it<br>does not unmount any filesystems and this can lead to problems with the ext2fs &quot;clean filesystem&quot; flag. The<br>triple−sync method is<i>&nbsp;not recommended</i>.<br>
(In case you're wondering: the reason for three syncs is that in the early days of UNIX, when the commands<br>were typed separately, that usually gave sufficient time for most disk I/O to be finished.)<br>
<b>8.4. Rebooting</b><br>
Rebooting means booting the system again. This can be accomplished by first shutting it down completely,<br>turning power off, and then turning it back on. A simpler way is to ask<b>&nbsp;shutdown</b>&nbsp;to reboot the system,<br>instead of merely halting it. This is accomplished by using the&nbsp;−r&nbsp;option to<b>&nbsp;shutdown</b>, for example, by giving<br>
Chapter 8. Boots And Shutdowns<br>
55<br>
<hr>
<A name=62></a>The Linux System Administrator's Guide<br>
the command<b>&nbsp;shutdown −r now</b>.<br>
Most Linux systems run<b>&nbsp;shutdown −r now</b>&nbsp;when ctrl−alt−del is pressed on the keyboard. This reboots the<br>system. The action on ctrl−alt−del is configurable, however, and it might be better to allow for some delay<br>before the reboot on a multiuser machine. Systems that are physically accessible to anyone might even be<br>configured to do nothing when ctrl−alt−del is pressed.<br>
<b>8.5. Single user mode</b><br>
The<b>&nbsp;shutdown</b>&nbsp;command can also be used to bring the system down to single user mode, in which no one can<br>log in, but root can use the console. This is useful for system administration tasks that can't be done while the<br>system is running normally.<br>
<b>8.6. Emergency boot floppies</b><br>
It is not always possible to boot a computer from the hard disk. For example, if you make a mistake in<br>configuring LILO, you might make your system unbootable. For these situations, you need an alternative way<br>of booting that will always work (as long as the hardware works). For typical PCs, this means booting from<br>the floppy drive.<br>
Most Linux distributions allow one to create an<i>&nbsp;emergency boot floppy</i>&nbsp;during installation. It is a good idea to<br>do this. However, some such boot disks contain only the kernel, and assume you will be using the programs<br>on the distribution's installation disks to fix whatever problem you have. Sometimes those programs aren't<br>enough; for example, you might have to restore some files from backups made with software not on the<br>installation disks.<br>
Thus, it might be necessary to create a custom root floppy as well. The<i>&nbsp;Bootdisk HOWTO</i>&nbsp;by Graham<br>Chapman (XXX citation) contains instructions for doing this. You must, of course, remember to keep your<br>emergency boot and root floppies up to date.<br>
You can't use the floppy drive you use to mount the root floppy for anything else. This can be inconvenient if<br>you only have one floppy drive. However, if you have enough memory, you can configure your boot floppy to<br>load the root disk to a ramdisk (the boot floppy's kernel needs to be specially configured for this). Once the<br>root floppy has been loaded into the ramdisk, the floppy drive is free to mount other disks.<br>
Chapter 8. Boots And Shutdowns<br>
56<br>
<hr>
<A name=63></a><b>Chapter 9. init</b><br>
&quot;Uuno on numero yksi&quot; (Slogan for a series of Finnish movies.)<br>
This chapter describes the<b>&nbsp;init</b>&nbsp;process, which is the first user level process started by the kernel.<b>&nbsp;init</b>&nbsp;has<br>many important duties, such as starting<b>&nbsp;getty</b>&nbsp;(so that users can log in), implementing run levels, and taking<br>care of orphaned processes. This chapter explains how<b>&nbsp;init</b>&nbsp;is configured and how you can make use of the<br>different run levels.<br>
<b>9.1. init comes first</b><br>
<b>init</b>&nbsp;is one of those programs that are absolutely essential to the operation of a Linux system, but that you still<br>can mostly ignore. A good Linux distribution will come with a configuration for<b>&nbsp;init</b>&nbsp;that will work for most<br>systems, and on these systems there is nothing you need to do about<b>&nbsp;init</b>. Usually, you only need to worry<br>about<b>&nbsp;init</b>&nbsp;if you hook up serial terminals, dial−in (not dial−out) modems, or if you want to change the default<br>run level.<br>
When the kernel has started itself (has been loaded into memory, has started running, and has initialized all<br>device drivers and data structures and such), it finishes its own part of the boot process by starting a user level<br>program,<b>&nbsp;init</b>. Thus,<b>&nbsp;init</b>&nbsp;is always the first process (its process number is always 1).<br>
The kernel looks for<b>&nbsp;init</b>&nbsp;in a few locations that have been historically used for it, but the proper location for it<br>(on a Linux system) is&nbsp;/sbin/init. If the kernel can't find<b>&nbsp;init</b>, it tries to run&nbsp;/bin/sh, and if that also<br>fails, the startup of the system fails.<br>
When<b>&nbsp;init</b>&nbsp;starts, it finishes the boot process by doing a number of administrative tasks, such as checking<br>filesystems, cleaning up&nbsp;/tmp, starting various services, and starting a<b>&nbsp;getty</b>&nbsp;for each terminal and virtual<br><a href="TLSAGs.html#67">console where users should be able to log in (see Chapter 10).</a><br>
After the system is properly up,<b>&nbsp;init</b>&nbsp;restarts<b>&nbsp;getty</b>&nbsp;for each terminal after a user has logged out (so that the<br>next user can log in).<b>&nbsp;init</b>&nbsp;also adopts orphan processes: when a process starts a child process and dies before<br>its child, the child immediately becomes a child of<b>&nbsp;init</b>. This is important for various technical reasons, but it<br>is good to know it, since it makes it easier to understand process lists and process tree graphs.&nbsp;[33] There are a<br>few variants of<b>&nbsp;init</b>&nbsp;available. Most Linux distributions use<b>&nbsp;sysvinit</b>&nbsp;(written by Miquel van Smoorenburg),<br>which is based on the System V<b>&nbsp;init</b>&nbsp;design. The BSD versions of Unix have a different<b>&nbsp;init</b>. The primary<br>difference is run levels: System V has them, BSD does not (at least traditionally). This difference is not<br>essential. We'll look at<b>&nbsp;sysvinit</b>&nbsp;only.<br>
<b>9.2. Configuring init to start getty: the&nbsp;/etc/inittab&nbsp;file</b><br>
When it starts up,<b>&nbsp;init</b>&nbsp;reads the&nbsp;/etc/inittab&nbsp;configuration file. While the system is running, it will<br>re−read it, if sent the HUP signal;&nbsp;[34] this feature makes it unnecessary to boot the system to make changes<br>to the<b>&nbsp;init</b>&nbsp;configuration take effect.<br>
The&nbsp;/etc/inittab&nbsp;file is a bit complicated. We'll start with the simple case of configuring<b>&nbsp;getty</b>&nbsp;lines.<br>Lines in&nbsp;/etc/inittab&nbsp;consist of four colon−delimited fields:<br>
Chapter 9. init<br>
57<br>
<hr>
<A name=64></a>The Linux System Administrator's Guide<br>
id:runlevels:action:process<br>
The fields are described below. In addition,&nbsp;/etc/inittab&nbsp;can contain empty lines, and lines that begin<br>with a number sign (`#'); these are both ignored.<br>
<i><b>id</b></i><br>
This identifies the line in the file. For<b>&nbsp;getty</b>&nbsp;lines, it specifies the terminal it runs on (the characters<br>after&nbsp;/dev/tty&nbsp;in the device file name). For other lines, it doesn't matter (except for length<br>restrictions), but it should be unique.<br>
<i><b>runlevels</b></i><br>
The run levels the line should be considered for. The run levels are given as single digits, without<br>delimiters. (Run levels are described in the next section.)<br>
<i><b>action</b></i><br>
What action should be taken by the line, e.g.,&nbsp;respawn&nbsp;to run the command in the next field again,<br>when it exits, or&nbsp;once&nbsp;to run it just once.<br>
<i><b>process</b></i><br>
The command to run.<br>
To start a<b>&nbsp;getty</b>&nbsp;on the first virtual terminal (/dev/tty1), in all the normal multi−user run levels (2−5), one<br>would write the following line:<br>
1:2345:respawn:/sbin/getty 9600 tty1<br>
The first field says that this is the line for&nbsp;/dev/tty1. The second field says that it applies to run levels 2, 3,<br>4, and 5. The third field means that the command should be run again, after it exits (so that one can log in, log<br>out, and then log in again). The last field is the command that runs<b>&nbsp;getty</b>&nbsp;on the first virtual terminal.&nbsp;[35]<br>
If you wanted to add terminals or dial−in modem lines to a system, you'd add more lines to&nbsp;/etc/inittab,<br>one for each terminal or dial−in line. For more details, see the manual pages<b>&nbsp;init</b>,&nbsp;inittab, and<b>&nbsp;getty</b>.<br>
If a command fails when it starts, and<b>&nbsp;init</b>&nbsp;is configured to&nbsp;restart&nbsp;it, it will use a lot of system resources:<br><b>init</b>&nbsp;starts it, it fails,<b>&nbsp;init</b>&nbsp;starts it, it fails,<b>&nbsp;init</b>&nbsp;starts it, it fails, and so on, ad infinitum. To prevent this,<b>&nbsp;init</b>&nbsp;will<br>keep track of how often it restarts a command, and if the frequency grows to high, it will delay for five<br>minutes before restarting again.<br>
<b>9.3. Run levels</b><br>
A<i>&nbsp;run level</i>&nbsp;is a state of<b>&nbsp;init</b>&nbsp;and the whole system that defines what system services are operating. Run levels<br><a href="TLSAGs.html#64">are identified by numbers, see Table 9−1. There is no consensus of how to use the user defined run levels (2<br></a>through 5). Some system administrators use run levels to define which subsystems are working, e.g., whether<br>X is running, whether the network is operational, and so on. Others have all subsystems always running or<br>start and stop them individually, without changing run levels, since run levels are too coarse for controlling<br>their systems. You need to decide for yourself, but it might be easiest to follow the way your Linux<br>distribution does things.<br>
<b>Table 9−1. Run level numbers</b><br>
0<br>
Halt the system.<br>
1<br>
Single−user mode (for special administration).<br>
Chapter 9. init<br>
58<br>
<hr>
<A name=65></a>The Linux System Administrator's Guide<br>
2−5&nbsp;Normal operation (user defined).<br>
6<br>
Reboot.<br>
Run levels are configured in&nbsp;/etc/inittab&nbsp;by lines like the following:<br>
l2:2:wait:/etc/init.d/rc 2<br>
The first field is an arbitrary label, the second one means that this applies for run level 2. The third field<br>means that<b>&nbsp;init</b>&nbsp;should run the command in the fourth field once, when the run level is entered, and that<b>&nbsp;init<br></b>should wait for it to complete. The&nbsp;/etc/init.d/rc&nbsp;command runs whatever commands are necessary to<br>start and stop services to enter run level 2.<br>
The command in the fourth field does all the hard work of setting up a run level. It starts services that aren't<br>already running, and stops services that shouldn't be running in the new run level any more. Exactly what the<br>command is, and how run levels are configured, depends on the Linux distribution.<br>
When<b>&nbsp;init</b>&nbsp;starts, it looks for a line in&nbsp;/etc/inittab&nbsp;that specifies the default run level:<br>
id:2:initdefault:<br>
You can ask<b>&nbsp;init</b>&nbsp;to go to a non−default run level at startup by giving the kernel a command line argument of<br>single&nbsp;or&nbsp;emergency. Kernel command line arguments can be given via LILO, for example. This allows<br>you to choose the single user mode (run level 1).<br>
While the system is running, the<b>&nbsp;telinit</b>&nbsp;command can change the run level. When the run level is changed,<br><b>init</b>&nbsp;runs the relevant command from&nbsp;/etc/inittab.<br>
<b>9.4. Special configuration in&nbsp;/etc/inittab</b><br>
The&nbsp;/etc/inittab&nbsp;has some special features that allow<b>&nbsp;init</b>&nbsp;to react to special circumstances. These<br>special features are marked by special keywords in the third field. Some examples:<br>
<i><b>powerwait</b></i><br>
Allows<b>&nbsp;init</b>&nbsp;to shut the system down, when the power fails. This assumes the use of a UPS, and<br>software that watches the UPS and informs<b>&nbsp;init</b>&nbsp;that the power is off.<br>
<i><b>ctrlaltdel</b></i><br>
Allows<b>&nbsp;init</b>&nbsp;to reboot the system, when the user presses ctrl−alt−del on the console keyboard. Note<br>that the system administrator can configure the reaction to ctrl−alt−del to be something else instead,<br>e.g., to be ignored, if the system is in a public location. (Or to start<b>&nbsp;nethack</b>.)<br>
<i><b>sysinit</b></i><br>
Command to be run when the system is booted. This command usually cleans up&nbsp;/tmp, for example.<br>
The list above is not exhaustive. See your&nbsp;inittab&nbsp;manual page for all possibilities, and for details on how<br>to use the above ones.<br>
Chapter 9. init<br>
59<br>
<hr>
<A name=66></a>The Linux System Administrator's Guide<br>
<b>9.5. Booting in single user mode</b><br>
An important run level is<i>&nbsp;single user mode</i>&nbsp;(run level 1), in which only the system administrator is using the<br>machine and as few system services, including logins, as possible are running. Single user mode is necessary<br>for a few administrative tasks,&nbsp;[36] such as running<b>&nbsp;fsck</b>&nbsp;on a&nbsp;/usr&nbsp;partition, since this requires that the<br>partition be unmounted, and that can't happen, unless just about all system services are killed.<br>
A running system can be taken to single user mode by using<b>&nbsp;telinit</b>&nbsp;to request run level 1. At bootup, it can be<br>entered by giving the word&nbsp;single&nbsp;or&nbsp;emergency&nbsp;on the kernel command line: the kernel gives the<br>command line to<b>&nbsp;init</b>&nbsp;as well, and<b>&nbsp;init</b>&nbsp;understands from that word that it shouldn't use the default run level.<br>(The kernel command line is entered in a way that depends on how you boot the system.)<br>
Booting into single user mode is sometimes necessary so that one can run<b>&nbsp;fsck</b>&nbsp;by hand, before anything<br>mounts or otherwise touches a broken&nbsp;/usr&nbsp;partition (any activity on a broken filesystem is likely to break it<br>more, so<b>&nbsp;fsck</b>&nbsp;should be run as soon as possible).<br>
The bootup scripts<b>&nbsp;init</b>&nbsp;runs will automatically enter single user mode, if the automatic<b>&nbsp;fsck</b>&nbsp;at bootup fails.<br>This is an attempt to prevent the system from using a filesystem that is so broken that<b>&nbsp;fsck</b>&nbsp;can't fix it<br>automatically. Such breakage is relatively rare, and usually involves a broken hard disk or an experimental<br>kernel release, but it's good to be prepared.<br>
As a security measure, a properly configured system will ask for the root password before starting the shell in<br>single user mode. Otherwise, it would be simple to just enter a suitable line to LILO to get in as root. (This<br>will break if&nbsp;/etc/passwd&nbsp;has been broken by filesystem problems, of course, and in that case you'd better<br>have a boot floppy handy.)<br>
Chapter 9. init<br>
60<br>
<hr>
<A name=67></a><b>Chapter 10. Logging In And Out</b><br>
&quot;I don't care to belong to a club that accepts people like me as a member.&quot; (Groucho Marx)<br>
This section describes what happens when a user logs in or out. The various interactions of background<br>processes, log files, configuration files, and so on are described in some detail.<br>
<b>10.1. Logins via terminals</b><br>
<a href="TLSAGs.html#67">Figure 10−1 shows how logins happen via terminals. First,</a><b>&nbsp;init</b>&nbsp;makes sure there is a<b>&nbsp;getty</b>&nbsp;program for the<br>terminal connection (or console).<b>&nbsp;getty</b>&nbsp;listens at the terminal and waits for the user to notify that he is ready<br>to login in (this usually means that the user must type something). When it notices a user,<b>&nbsp;getty</b>&nbsp;outputs a<br>welcome message (stored in&nbsp;/etc/issue), and prompts for the username, and finally runs the<b>&nbsp;login<br></b>program.<b>&nbsp;login</b>&nbsp;gets the username as a parameter, and prompts the user for the password. If these match,<b>&nbsp;login<br></b>starts the shell configured for the user; else it just exits and terminates the process (perhaps after giving the<br>user another chance at entering the username and password).<b>&nbsp;init</b>&nbsp;notices that the process terminated, and<br>starts a new<b>&nbsp;getty</b>&nbsp;for the terminal.<br>
<b>Figure 10−1. Logins via terminals: the interaction of init, getty, login, and the shell.</b><br>
Chapter 10. Logging In And Out<br>
61<br>
<hr>
<A name=68></a><IMG src="TLSAG-68_1.png"><br>
The Linux System Administrator's Guide<br>
Note that the only new process is the one created by<b>&nbsp;init</b>&nbsp;(using the&nbsp;fork&nbsp;system call);<b>&nbsp;getty</b>&nbsp;and<b>&nbsp;login</b>&nbsp;only<br>replace the program running in the process (using the&nbsp;exec&nbsp;system call).<br>
A separate program, for noticing the user, is needed for serial lines, since it can be (and traditionally was)<br>complicated to notice when a terminal becomes active.<b>&nbsp;getty</b>&nbsp;also adapts to the speed and other settings of the<br>connection, which is important especially for dial−in connections, where these parameters may change from<br>call to call.<br>
There are several versions of<b>&nbsp;getty</b>&nbsp;and<b>&nbsp;init</b>&nbsp;in use, all with their good and bad points. It is a good idea to learn<br>about the versions on your system, and also about the other versions (you could use the Linux Software Map<br>to search them). If you don't have dial−ins, you probably don't have to worry about<b>&nbsp;getty</b>, but<b>&nbsp;init</b>&nbsp;is still<br>important.<br>
<b>10.2. Logins via the network</b><br>
Two computers in the same network are usually linked via a single physical cable. When they communicate<br>over the network, the programs in each computer that take part in the communication are linked via a<i>&nbsp;virtual<br>connection</i>, a sort of imaginary cable. As far as the programs at either end of the virtual connection are<br>concerned, they have a monopoly on their own cable. However, since the cable is not real, only imaginary, the<br>operating systems of both computers can have several virtual connections share the same physical cable. This<br>way, using just a single cable, several programs can communicate without having to know of or care about the<br>
Chapter 10. Logging In And Out<br>
62<br>
<hr>
<A name=69></a>The Linux System Administrator's Guide<br>
other communications. It is even possible to have several computers use the same cable; the virtual<br>connections exist between two computers, and the other computers ignore those connections that they don't<br>take part in.<br>
That's a complicated and over−abstracted description of the reality. It might, however, be good enough to<br>understand the important reason why network logins are somewhat different from normal logins. The virtual<br>connections are established when there are two programs on different computers that wish to communicate.<br>Since it is in principle possible to login from any computer in a network to any other computer, there is a huge<br>number of potential virtual communications. Because of this, it is not practical to start a<b>&nbsp;getty</b>&nbsp;for each<br>potential login.<br>
There is a single process inetd (corresponding to<b>&nbsp;getty</b>) that handles all network logins. When it notices an<br>incoming network login (i.e., it notices that it gets a new virtual connection to some other computer), it starts a<br>new process to handle that single login. The original process remains and continues to listen for new logins.<br>
To make things a bit more complicated, there is more than one communication protocol for network logins.<br>The two most important ones are<b>&nbsp;telnet</b>&nbsp;and<b>&nbsp;rlogin</b>. In addition to logins, there are many other virtual<br>connections that may be made (for FTP, Gopher, HTTP, and other network services). It would be ineffective<br>to have a separate process listening for a particular type of connection, so instead there is only one listener that<br>can recognize the type of the connection and can start the correct type of program to provide the service. This<br>single listener is called<b>&nbsp;inetd</b>; see the<i>&nbsp;Linux Network Administrators' Guide</i>&nbsp;for more information.<br>
<b>10.3. What login does</b><br>
The<b>&nbsp;login</b>&nbsp;program takes care of authenticating the user (making sure that the username and password match),<br>and of setting up an initial environment for the user by setting permissions for the serial line and starting the<br>shell.<br>
Part of the initial setup is outputting the contents of the file&nbsp;/etc/motd&nbsp;(short for message of the day) and<br>checking for electronic mail. These can be disabled by creating a file called&nbsp;.hushlogin&nbsp;in the user's home<br>directory.<br>
If the file&nbsp;/etc/nologin&nbsp;exists, logins are disabled. That file is typically created by<b>&nbsp;shutdown</b>&nbsp;and<br>relatives.<b>&nbsp;login</b>&nbsp;checks for this file, and will refuse to accept a login if it exists. If it does exist,<b>&nbsp;login</b>&nbsp;outputs<br>its contents to the terminal before it quits.<br>
<b>login</b>&nbsp;logs all failed login attempts in a system log file (via<b>&nbsp;syslog</b>). It also logs all logins by root. Both of<br>these can be useful when tracking down intruders.<br>
Currently logged in people are listed in&nbsp;/var/run/utmp. This file is valid only until the system is next<br>rebooted or shut down; it is cleared when the system is booted. It lists each user and the terminal (or network<br>connection) he is using, along with some other useful information. The<b>&nbsp;who</b>,<b>&nbsp;w</b>, and other similar commands<br>look in&nbsp;utmp&nbsp;to see who are logged in.<br>
All successful logins are recorded into&nbsp;/var/log/wtmp. This file will grow without limit, so it must be<br>cleaned regularly, for example by having a weekly<b>&nbsp;cron</b>&nbsp;job to clear it.&nbsp;[37] The<b>&nbsp;last</b>&nbsp;command browses<br>wtmp.<br>
Both&nbsp;utmp&nbsp;and&nbsp;wtmp&nbsp;are in a binary format (see the&nbsp;utmp&nbsp;manual page); it is unfortunately not convenient<br>to examine them without special programs.<br>
Chapter 10. Logging In And Out<br>
63<br>
<hr>
<A name=70></a>The Linux System Administrator's Guide<br>
<b>10.4. X and xdm</b><br>
XXX X implements logins via xdm; also: xterm −ls<br>
<b>10.5. Access control</b><br>
The user database is traditionally contained in the&nbsp;/etc/passwd&nbsp;file. Some systems use<i>&nbsp;shadow passwords</i>,<br>and have moved the passwords to<b>&nbsp;/etc/shadow</b>. Sites with many computers that share the accounts use NIS or<br>some other method to store the user database; they might also automatically copy the database from one<br>central location to all other computers.<br>
The user database contains not only the passwords, but also some additional information about the users, such<br>as their real names, home directories, and login shells. This other information needs to be public, so that<br>anyone can read it. Therefore the password is stored encrypted. This does have the drawback that anyone with<br>access to the encrypted password can use various cryptographic methods to guess it, without trying to actually<br>log into the computer. Shadow passwords try to avoid this by moving the password into another file, which<br>only root can read (the password is still stored encrypted). However, installing shadow passwords later onto a<br>system that did not support them can be difficult.<br>
With or without passwords, it is important to make sure that all passwords in a system are good, i.e., not easily<br>guessed. The<b>&nbsp;crack</b>&nbsp;program can be used to crack passwords; any password it can find is by definition not a<br>good one. While<b>&nbsp;crack</b>&nbsp;can be run by intruders, it can also be run by the system administrator to avoid bad<br>passwords. Good passwords can also be enforced by the<b>&nbsp;passwd</b>&nbsp;program; this is in fact more effective in<br>CPU cycles, since cracking passwords requires quite a lot of computation.<br>
The user group database is kept in&nbsp;/etc/group; for systems with shadow passwords, there can be a<br>/etc/shadow.group.<br>
root usually can't login via most terminals or the network, only via terminals listed in the&nbsp;/etc/securetty<br>file. This makes it necessary to get physical access to one of these terminals. It is, however, possible to log in<br>via any terminal as any other user, and use the<b>&nbsp;su</b>&nbsp;command to become root.<br>
<b>10.6. Shell startup</b><br>
When an interactive login shell starts, it automatically executes one or more pre−defined files. Different shells<br>execute different files; see the documentation of each shell for further information.<br>
Most shells first run some global file, for example, the Bourne shell (<b>/bin/sh</b>) and its derivatives execute<br>/etc/profile; in addition, they execute&nbsp;.profile&nbsp;in the user's home directory.&nbsp;/etc/profile<br>allows the system administrator to have set up a common user environment, especially by setting the&nbsp;PATH&nbsp;to<br>include local command directories in addition to the normal ones. On the other hand,&nbsp;.profile&nbsp;allows the<br>user to customize the environment to his own tastes by overriding, if necessary, the default environment.<br>
Chapter 10. Logging In And Out<br>
64<br>
<hr>
<A name=71></a><b>Chapter 11. Managing user accounts</b><br>
&quot;The similarities of sysadmins and drug dealers: both measure stuff in Ks, and both have<br>users.&quot; (Old, tired computer joke.)<br>
This chapter explains how to create new user accounts, how to modify the properties of those accounts, and<br>how to remove the accounts. Different Linux systems have different tools for doing this.<br>
<b>11.1. What's an account?</b><br>
When a computer is used by many people it is usually necessary to differentiate between the users, for<br>example, so that their private files can be kept private. This is important even if the computer can only be used<br>by a single person at a time, as with most microcomputers.&nbsp;[38] Thus, each user is given a unique username,<br>and that name is used to log in.<br>
There's more to a user than just a name, however. An<i>&nbsp;account</i>&nbsp;is all the files, resources, and information<br>belonging to one user. The term hints at banks, and in a commercial system each account usually has some<br>money attached to it, and that money vanishes at different speeds depending on how much the user stresses<br>the system. For example, disk space might have a price per megabyte and day, and processing time might<br>have a price per second.<br>
<b>11.2. Creating a user</b><br>
The Linux kernel itself treats users are mere numbers. Each user is identified by a unique integer, the<i>&nbsp;user id<br></i>or<i>&nbsp;uid</i>, because numbers are faster and easier for a computer to process than textual names. A separate<br>database outside the kernel assigns a textual name, the<i>&nbsp;username</i>, to each user id. The database contains<br>additional information as well.<br>
To create a user, you need to add information about the user to the user database, and create a home directory<br>for him. It may also be necessary to educate the user, and set up a suitable initial environment for him.<br>
Most Linux distributions come with a program for creating accounts. There are several such programs<br>available. Two command line alternatives are<b>&nbsp;adduser</b>&nbsp;and<b>&nbsp;useradd</b>; there may be a GUI tool as well.<br>Whatever the program, the result is that there is little if any manual work to be done. Even if the details are<br><a href="TLSAGs.html#73">many and intricate, these programs make everything seem trivial. However, Section 11.2.4 describes how to<br></a>do it by hand.<br>
<b>11.2.1.&nbsp;/etc/passwd&nbsp;and other informative files</b><br>
The basic user database in a Unix system is the text file,&nbsp;/etc/passwd&nbsp;(called the<i>&nbsp;password file</i>), which<br>lists all valid usernames and their associated information. The file has one line per username, and is divided<br>into seven colon−delimited fields:<br>
Username.<br>
•&nbsp;<br>
Password, in an encrypted form.<br>
•&nbsp;<br>
Numeric user id.<br>
•&nbsp;<br>
Numeric group id.<br>
•&nbsp;<br>
Chapter 11. Managing user accounts<br>
65<br>
<hr>
<A name=72></a>The Linux System Administrator's Guide<br>
Full name or other description of account.<br>
•&nbsp;<br>
Home directory.<br>
•&nbsp;<br>
Login shell (program to run at login).<br>
•&nbsp;<br>
The format is explained in more detail on the&nbsp;passwd&nbsp;manual page.<br>
Any user on the system may read the password file, so that they can, for example, learn the name of another<br>user. This means that the password (the second field) is also available to everyone. The password file encrypts<br>the password, so in theory there is no problem. However, the encryption is breakable, especially if the<br>password is weak (e.g., it is short or it can be found in a dictionary). Therefore it is not a good idea to have the<br>password in the password file.<br>
Many Linux systems have<i>&nbsp;shadow passwords</i>. This is an alternative way of storing the password: the<br>encrypted password is stored in a separate file,&nbsp;/etc/shadow, which only root can read. The<br>/etc/passwd&nbsp;file only contains a special marker in the second field. Any program that needs to verify a<br>user is setuid, and can therefore access the shadow password file. Normal programs, which only use the other<br>fields in the password file, can't get at the password.&nbsp;[39]<br>
<b>11.2.2. Picking numeric user and group ids</b><br>
On most systems it doesn't matter what the numeric user and group ids are, but if you use the Network<br>filesystem (NFS), you need to have the same uid and gid on all systems. This is because NFS also identifies<br>users with the numeric uids. If you aren't using NFS, you can let your account creation tool pick them<br>automatically.<br>
If you are using NFS, you'll have to be invent a mechanism for synchronizing account information. One<br>alternative is to the NIS system (see XXX network−admin−guide).<br>
However, you should try to avoid re−using numeric uids (and textual usernames), because the new owner of<br>the uid (or username) may get access to the old owner's files (or mail, or whatever).<br>
<b>11.2.3. Initial environment:&nbsp;/etc/skel</b><br>
When the home directory for a new user is created, it is initialized with files from the&nbsp;/etc/skel&nbsp;directory.<br>The system administrator can create files in&nbsp;/etc/skel&nbsp;that will provide a nice default environment for<br>users. For example, he might create a&nbsp;/etc/skel/.profile&nbsp;that sets the EDITOR environment variable<br>to some editor that is friendly towards new users.<br>
However, it is usually best to try to keep&nbsp;/etc/skel&nbsp;as small as possible, since it will be next to impossible<br>to update existing users' files. For example, if the name of the friendly editor changes, all existing users would<br>have to edit their&nbsp;.profile. The system administrator could try to do it automatically, with a script, but that<br>is almost certain going to break someone's file.<br>
Whenever possible, it is better to put global configuration into global files, such as&nbsp;/etc/profile. This<br>way it is possible to update it without breaking users' own setups.<br>
Chapter 11. Managing user accounts<br>
66<br>
<hr>
<A name=73></a>The Linux System Administrator's Guide<br>
<b>11.2.4. Creating a user by hand</b><br>
To create a new account manually, follow these steps:<br>
Edit&nbsp;<br>
•&nbsp;<br>
/etc/passwd&nbsp;with<b>&nbsp;vipw</b>&nbsp;and add a new line for the new account. Be careful with the syntax.<br>
<i>Do not edit directly with an editor!</i><b>&nbsp;vipw</b>&nbsp;locks the file, so that other commands won't try to update it<br>at the same time. You should make the password field be `*', so that it is impossible to log in.<br>Similarly, edit&nbsp;<br>
•&nbsp;<br>
/etc/group&nbsp;with<b>&nbsp;vigr</b>, if you need to create a new group as well.<br>
Create the home directory of the user with<br>
•&nbsp;<br>
<b>&nbsp;mkdir</b>.<br>
Copy the files from&nbsp;<br>
•&nbsp;<br>
/etc/skel&nbsp;to the new home directory.<br>
Fix ownerships and permissions with<br>
•&nbsp;<br>
<b>&nbsp;chown</b>&nbsp;and<b>&nbsp;chmod</b>. The&nbsp;−R&nbsp;option is most useful. The correct<br>
permissions vary a little from one site to another, but usually the following commands do the right<br>thing:<br>
<b>cd /home/newusername</b><br>
<b>chown −R username.group .</b><br>
<b>chmod −R go=u,go−w .</b><br>
<b>chmod go= .</b><br>
Set the password with<br>
•&nbsp;<br>
<b>&nbsp;passwd</b>.<br>
After you set the password in the last step, the account will work. You shouldn't set it until everything else has<br>been done, otherwise the user may inadvertently log in while you're still copying the files.<br>
It is sometimes necessary to create dummy accounts&nbsp;[40] that are not used by people. For example, to set up<br>an anonymous FTP server (so that anyone can download files from it, without having to get an account first),<br>you need to create an account called ftp. In such cases, it is usually not necessary to set the password (last step<br>above). Indeed, it is better not to, so that no−one can use the account, unless they first become root, since root<br>can become any user.<br>
<b>11.3. Changing user properties</b><br>
There are a few commands for changing various properties of an account (i.e., the relevant field in<br>/etc/passwd):<br>
<i><b>chfn</b></i><br>
Change the full name field.<br>
<i><b>chsh</b></i><br>
Change the login shell.<br>
<i><b>passwd</b></i><br>
Change the password.<br>
The super−user may use these commands to change the properties of any account. Normal users can only<br>change the properties of their own account. It may sometimes be necessary to disable these commands (with<br><b>chmod</b>) for normal users, for example in an environment with many novice users.<br>
Other tasks need to be done by hand. For example, to change the username, you need to edit&nbsp;/etc/passwd<br>directly (with<b>&nbsp;vipw</b>, remember). Likewise, to add or remove the user to more groups, you need to edit<br>/etc/group&nbsp;(with<b>&nbsp;vigr</b>). Such tasks tend to be rare, however, and should be done with caution: for<br>example, if you change the username, e−mail will no longer reach the user, unless you also create a mail alias.<br><a href="TLSAGs.html#105">[41]</a><br>
Chapter 11. Managing user accounts<br>
67<br>
<hr>
<A name=74></a>The Linux System Administrator's Guide<br>
<b>11.4. Removing a user</b><br>
To remove a user, you first remove all his files, mailboxes, mail aliases, print jobs,<b>&nbsp;cron</b>&nbsp;and<b>&nbsp;at</b>&nbsp;jobs, and all<br>other references to the user. Then you remove the relevant lines from&nbsp;/etc/passwd&nbsp;and&nbsp;/etc/group<br>(remember to remove the username from all groups it's been added to). It may be a good idea to first disable<br>the account (see below), before you start removing stuff, to prevent the user from using the account while it is<br>being removed.<br>
Remember that users may have files outside their home directory. The<b>&nbsp;find</b>&nbsp;command can find them:<br>
find / −user username<br>
However, note that the above command will take a<i>&nbsp;long</i>&nbsp;time, if you have large disks. If you mount network<br>disks, you need to be careful so that you won't trash the network or the server.<br>
Some Linux distributions come with special commands to do this; look for<b>&nbsp;deluser</b>&nbsp;or<b>&nbsp;userdel</b>. However, it is<br>easy to do it by hand as well, and the commands might not do everything.<br>
<b>11.5. Disabling a user temporarily</b><br>
It is sometimes necessary to temporarily disable an account, without removing it. For example, the user might<br>not have paid his fees, or the system administrator may suspect that a cracker has got the password of that<br>account.<br>
The best way to disable an account is to change its shell into a special program that just prints a message. This<br>way, whoever tries to log into the account, will fail, and will know why. The message can tell the user to<br>contact the system administrator so that any problems may be dealt with.<br>
It would also be possible to change the username or password to something else, but then the user won't know<br>what is going on. Confused users mean more work.&nbsp;[42]<br>
A simple way to create the special programs is to write `tail scripts':<br>
#!/usr/bin/tail +2<br>
This account has been closed due to a security breach.<br>
Please call 555−1234 and wait for the men in black to arrive.<br>
The first two characters (`#!') tell the kernel that the rest of the line is a command that needs to be run to<br>interpret this file. The<b>&nbsp;tail</b>&nbsp;command in this case outputs everything except the first line to the standard output.<br>
If user billg is suspected of a security breach, the system administrator would do something like this:<br>
#&nbsp;<b>chsh −s&nbsp;</b><br>
<b>/usr/local/lib/no−login/security billg</b><br>
#&nbsp;<b>su − tester</b><br>
This account has been closed due to a security breach.<br>
Please call 555−1234 and wait for the men in black to arrive.<br>
#<br>
The purpose of the<b>&nbsp;su</b>&nbsp;is to test that the change worked, of course.<br>
Chapter 11. Managing user accounts<br>
68<br>
<hr>
<A name=75></a>The Linux System Administrator's Guide<br>
Tail scripts should be kept in a separate directory, so that their names don't interfere with normal user<br>commands.<br>
Chapter 11. Managing user accounts<br>
69<br>
<hr>
<A name=76></a><b>Chapter 12. Backups</b><br>
Hardware is indeterministically reliable.&nbsp;<br>Software is deterministically unreliable.<br>People are indeterministically unreliable.<br>Nature is deterministically reliable.<br>
This chapter explains about why, how, and when to make backups, and how to restore things from backups.<br>
<b>12.1. On the importance of being backed up</b><br>
Your data is valuable. It will cost you time and effort re−create it, and that costs money or at least personal<br>grief and tears; sometimes it can't even be re−created, e.g., if it is the results of some experiments. Since it is<br>an investment, you should protect it and take steps to avoid losing it.<br>
There are basically four reasons why you might lose data: hardware failures, software bugs, human action, or<br>natural disasters.&nbsp;[43] Although modern hardware tends to be quite reliable, it can still break seemingly<br>spontaneously. The most critical piece of hardware for storing data is the hard disk, which relies on tiny<br>magnetic fields remaining intact in a world filled with electromagnetic noise. Modern software doesn't even<br>tend to be reliable; a rock solid program is an exception, not a rule. Humans are quite unreliable, they will<br>either make a mistake, or they will be malicious and destroy data on purpose. Nature might not be evil, but it<br>can wreak havoc even when being good. All in all, it is a small miracle that anything works at all.<br>
Backups are a way to protect the investment in data. By having several copies of the data, it does not matter as<br>much if one is destroyed (the cost is only that of the restoration of the lost data from the backup).<br>
It is important to do backups properly. Like everything else that is related to the physical world, backups will<br>fail sooner or later. Part of doing backups well is to make sure they work; you don't want to notice that your<br>backups didn't work.&nbsp;[44] Adding insult to injury, you might have a bad crash just as you're making the<br>backup; if you have only one backup medium, it might destroyed as well, leaving you with the smoking ashes<br>of hard work.&nbsp;[45] Or you might notice, when trying to restore, that you forgot to back up something<br>important, like the user database on a 15000 user site. Best of all, all your backups might be working<br>perfectly, but the last known tape drive reading the kind of tapes you used was the one that now has a<br>bucketful of water in it.<br>
When it comes to backups, paranoia is in the job description.<br>
<b>12.2. Selecting the backup medium</b><br>
The most important decision regarding backups is the choice of backup medium. You need to consider cost,<br>reliability, speed, availability, and usability.<br>
Cost is important, since you should preferably have several times more backup storage than what you need for<br>the data. A cheap medium is usually a must.<br>
Reliability is extremely important, since a broken backup can make a grown man cry. A backup medium must<br>
Chapter 12. Backups<br>
70<br>
<hr>
<A name=77></a>The Linux System Administrator's Guide<br>
be able to hold data without corruption for years. The way you use the medium affects it reliability as a<br>backup medium. A hard disk is typically very reliable, but as a backup medium it is not very reliable, if it is in<br>the same computer as the disk you are backing up.<br>
Speed is usually not very important, if backups can be done without interaction. It doesn't matter if a backup<br>takes two hours, as long as it needs no supervision. On the other hand, if the backup can't be done when the<br>computer would otherwise be idle, then speed is an issue.<br>
Availability is obviously necessary, since you can't use a backup medium if it doesn't exist. Less obvious is<br>the need for the medium to be available even in the future, and on computers other than your own. Otherwise<br>you may not be able to restore your backups after a disaster.<br>
Usability is a large factor in how often backups are made. The easier it is to make backups, the better. A<br>backup medium mustn't be hard or boring to use.<br>
The typical alternatives are floppies and tapes. Floppies are very cheap, fairly reliable, not very fast, very<br>available, but not very usable for large amounts of data. Tapes are cheap to somewhat expensive, fairly<br>reliable, fairly fast, quite available, and, depending on the size of the tape, quite comfortable.<br>
There are other alternatives. They are usually not very good on availability, but if that is not a problem, they<br>can be better in other ways. For example, magneto−optical disks can have good sides of both floppies (they're<br>random access, making restoration of a single file quick) and tapes (contain a lot of data).<br>
<b>12.3. Selecting the backup tool</b><br>
There are many tools that can be used to make backups. The traditional UNIX tools used for backups are<b>&nbsp;tar</b>,<br><b>cpio</b>, and<b>&nbsp;dump</b>. In addition, there are large number of third party packages (both freeware and commercial)<br>that can be used. The choice of backup medium can affect the choice of tool.<br>
<b>tar</b>&nbsp;and<b>&nbsp;cpio</b>&nbsp;are similar, and mostly equivalent from a backup point of view. Both are capable of storing files<br>on tapes, and retrieving files from them. Both are capable of using almost any media, since the kernel device<br>drivers take care of the low level device handling and the devices all tend to look alike to user level programs.<br>Some UNIX versions of<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;cpio</b>&nbsp;may have problems with unusual files (symbolic links, device files, files<br>with very long pathnames, and so on), but the Linux versions should handle all files correctly.<br>
<b>dump</b>&nbsp;is different in that it reads the filesystem directly and not via the filesystem. It is also written<br>specifically for backups;<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;cpio</b>&nbsp;are really for archiving files, although they work for backups as well.<br>
Reading the filesystem directly has some advantages. It makes it possible to back files up without affecting<br>their time stamps; for<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;cpio</b>, you would have to mount the filesystem read−only first. Directly reading<br>the filesystem is also more effective, if everything needs to be backed up, since it can be done with much less<br>disk head movement. The major disadvantage is that it makes the backup program specific to one filesystem<br>type; the Linux<b>&nbsp;dump</b>&nbsp;program understands the ext2 filesystem only.<br>
<b>dump</b>&nbsp;also directly supports backup levels (which we'll be discussing below); with<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;cpio</b>&nbsp;this has to be<br>implemented with other tools.<br>
A comparison of the third party backup tools is beyond the scope of this book. The Linux Software Map lists<br>many of the freeware ones.<br>
Chapter 12. Backups<br>
71<br>
<hr>
<A name=78></a>The Linux System Administrator's Guide<br>
<b>12.4. Simple backups</b><br>
A simple backup scheme is to back up everything once, then back up everything that has been modified since<br>the previous backup. The first backup is called a<i>&nbsp;full backup</i>, the subsequent ones are<i>&nbsp;incremental backups</i>. A<br>full backup is often more laborious than incremental ones, since there is more data to write to the tape and a<br>full backup might not fit onto one tape (or floppy). Restoring from incremental backups can be many times<br>more work than from a full one. Restoration can be optimized so that you always back up everything since the<br>previous full backup; this way, backups are a bit more work, but there should never be a need to restore more<br>than a full backup and an incremental backup.<br>
If you want to make backups every day and have six tapes, you could use tape 1 for the first full backup (say,<br>on a Friday), and tapes 2 to 5 for the incremental backups (Monday through Thursday). Then you make a new<br>full backup on tape 6 (second Friday), and start doing incremental ones with tapes 2 to 5 again. You don't<br>want to overwrite tape 1 until you've got a new full backup, lest something happens while you're making the<br>full backup. After you've made a full backup to tape 6, you want to keep tape 1 somewhere else, so that when<br>your other backup tapes are destroyed in the fire, you still have at least something left. When you need to<br>make the next full backup, you fetch tape 1 and leave tape 6 in its place.<br>
If you have more than six tapes, you can use the extra ones for full backups. Each time you make a full<br>backup, you use the oldest tape. This way you can have full backups from several previous weeks, which is<br>good if you want to find an old, now deleted file, or an old version of a file.<br>
<b>12.4.1. Making backups with tar</b><br>
A full backup can easily be made with<b>&nbsp;tar</b>:<br>
#&nbsp;<b>tar −−create −−file /dev/ftape&nbsp;</b><br>
<b>/usr/src</b><br>
tar: Removing leading / from absolute path names in&nbsp;<br>
the archive<br>
#<br>
The example above uses the GNU version of<b>&nbsp;tar</b>&nbsp;and its long option names. The traditional version of<b>&nbsp;tar</b>&nbsp;only<br>understands single character options. The GNU version can also handle backups that don't fit on one tape or<br>floppy, and also very long paths; not all traditional versions can do these things. (Linux only uses GNU<b>&nbsp;tar</b>.)<br>
If your backup doesn't fit on one tape, you need to use the&nbsp;−−multi−volume&nbsp;(−M) option:<br>
#&nbsp;<b>tar −cMf /dev/fd0H1440&nbsp;</b><br>
<b>/usr/src</b><br>
tar: Removing leading / from absolute path names in&nbsp;<br>
the archive<br>
Prepare volume #2 for /dev/fd0H1440 and hit return:<br>
#<br>
Note that you should format the floppies before you begin the backup, or else use another window or virtual<br>terminal and do it when<b>&nbsp;tar</b>&nbsp;asks for a new floppy.<br>
After you've made a backup, you should check that it is OK, using the&nbsp;−−compare&nbsp;(−d) option:<br>
#&nbsp;<b>tar −−compare −−verbose −f&nbsp;</b><br>
<b>/dev/ftape</b><br>
Chapter 12. Backups<br>
72<br>
<hr>
<A name=79></a>The Linux System Administrator's Guide<br>
usr/src/<br>
usr/src/linux<br>
usr/src/linux−1.2.10−includes/<br>
....<br>
#<br>
Failing to check a backup means that you will not notice that your backups aren't working until after you've<br>lost the original data.<br>
An incremental backup can be done with<b>&nbsp;tar</b>&nbsp;using the&nbsp;−−newer&nbsp;(−N) option:<br>
#&nbsp;<b>tar −−create −−newer '8 Sep 1995'&nbsp;</b><br>
<b>−−file /dev/ftape /usr/src&nbsp;</b><br>
<b>−−verbose</b><br>
tar: Removing leading / from absolute path names in&nbsp;<br>
the archive<br>
usr/src/<br>
usr/src/linux−1.2.10−includes/<br>
usr/src/linux−1.2.10−includes/include/<br>
usr/src/linux−1.2.10−includes/include/linux/<br>
usr/src/linux−1.2.10−includes/include/linux/modules/<br>
usr/src/linux−1.2.10−includes/include/asm−generic/<br>
usr/src/linux−1.2.10−includes/include/asm−i386/<br>
usr/src/linux−1.2.10−includes/include/asm−mips/<br>
usr/src/linux−1.2.10−includes/include/asm−alpha/<br>
usr/src/linux−1.2.10−includes/include/asm−m68k/<br>
usr/src/linux−1.2.10−includes/include/asm−sparc/<br>
usr/src/patch−1.2.11.gz<br>
#<br>
Unfortunately,<b>&nbsp;tar</b>&nbsp;can't notice when a file's inode information has changed, for example, that its permission<br>bits have been changed, or when its name has been changed. This can be worked around using<b>&nbsp;find</b>&nbsp;and<br>comparing current filesystem state with lists of files that have been previously backed up. Scripts and<br>programs for doing this can be found on Linux ftp sites.<br>
<b>12.4.2. Restoring files with tar</b><br>
The&nbsp;−−extract&nbsp;(−x) option for<b>&nbsp;tar</b>&nbsp;extracts files:<br>
#&nbsp;<b>tar −−extract −−same−permissions&nbsp;</b><br>
<b>−−verbose −−file&nbsp;</b><br>
<b>/dev/fd0H1440</b><br>
usr/src/<br>
usr/src/linux<br>
usr/src/linux−1.2.10−includes/<br>
usr/src/linux−1.2.10−includes/include/<br>
usr/src/linux−1.2.10−includes/include/linux/<br>
usr/src/linux−1.2.10−includes/include/linux/hdreg.h<br>
usr/src/linux−1.2.10−includes/include/linux/kernel.h<br>
...<br>
#<br>
You also extract only specific files or directories (which includes all their files and subdirectories) by naming<br>on the command line:<br>
#&nbsp;<b>tar xpvf /dev/fd0H1440&nbsp;</b><br>
Chapter 12. Backups<br>
73<br>
<hr>
<A name=80></a>The Linux System Administrator's Guide<br>
<b>usr/src/linux−1.2.10−includes/include/linux/hdreg.h</b><br>
usr/src/linux−1.2.10−includes/include/linux/hdreg.h<br>
#<br>
Use the&nbsp;−−list&nbsp;(−t) option, if you just want to see what files are on a backup volume:<br>
#&nbsp;<b>tar −−list −−file&nbsp;</b><br>
<b>/dev/fd0H1440</b><br>
usr/src/<br>
usr/src/linux<br>
usr/src/linux−1.2.10−includes/<br>
usr/src/linux−1.2.10−includes/include/<br>
usr/src/linux−1.2.10−includes/include/linux/<br>
usr/src/linux−1.2.10−includes/include/linux/hdreg.h<br>
usr/src/linux−1.2.10−includes/include/linux/kernel.h<br>
...<br>
#<br>
Note that<b>&nbsp;tar</b>&nbsp;always reads the backup volume sequentially, so for large volumes it is rather slow. It is not<br>possible, however, to use random access database techniques when using a tape drive or some other sequential<br>medium.<br>
<b>tar</b>&nbsp;doesn't handle deleted files properly. If you need to restore a filesystem from a full and an incremental<br>backup, and you have deleted a file between the two backups, it will exist again after you have done the<br>restore. This can be a big problem, if the file has sensitive data that should no longer be available.<br>
<b>12.5. Multilevel backups</b><br>
The simple backup method outlined in the previous section is often quite adequate for personal use or small<br>sites. For more heavy duty use, multilevel backups are more appropriate.<br>
The simple method has two backup levels: full and incremental backups. This can be generalized to any<br>number of levels. A full backup would be level 0, and the different levels of incremental backups levels 1, 2,<br>3, etc. At each incremental backup level you back up everything that has changed since the previous backup at<br>the same or a previous level.<br>
The purpose for doing this is that it allows a longer<i>&nbsp;backup history</i>&nbsp;cheaply. In the example in the previous<br>section, the backup history went back to the previous full backup. This could be extended by having more<br>tapes, but only a week per new tape, which might be too expensive. A longer backup history is useful, since<br>deleted or corrupted files are often not noticed for a long time. Even a version of a file that is not very up to<br>date is better than no file at all.<br>
With multiple levels the backup history can be extended more cheaply. For example, if we buy ten tapes, we<br>could use tapes 1 and 2 for monthly backups (first Friday each month), tapes 3 to 6 for weekly backups (other<br>Fridays; note that there can be five Fridays in one month, so we need four more tapes), and tapes 7 to 10 for<br>daily backups (Monday to Thursday). With only four more tapes, we've been able to extend the backup<br>history from two weeks (after all daily tapes have been used) to two months. It is true that we can't restore<br>every version of each file during those two months, but what we can restore is often good enough.<br>
<a href="TLSAGs.html#80">Figure 12−1 shows which backup level is used each day, and which backups can be restored from at the end<br></a>of the month.<br>
<b>Figure 12−1. A sample multilevel backup schedule.</b><br>
Chapter 12. Backups<br>
74<br>
<hr>
<A name=81></a><IMG src="TLSAG-81_1.png"><br>
The Linux System Administrator's Guide<br>
Backup levels can also be used to keep filesystem restoration time to a minimum. If you have many<br>incremental backups with monotonously growing level numbers, you need to restore all of them if you need to<br>rebuild the whole filesystem. Instead you can use level numbers that aren't monotonous, and keep down the<br>number of backups to restore.<br>
To minimize the number of tapes needed to restore, you could use a smaller level for each incremental tape.<br>However, then the time to make the backups increases (each backup copies everything since the previous full<br>backup). A better scheme is suggested by the<b>&nbsp;dump</b>&nbsp;manual page and described by the table XX<br>(efficient−backup−levels). Use the following succession of backup levels: 3, 2, 5, 4, 7, 6, 9, 8, 9, etc. This<br>keeps both the backup and restore times low. The most you have to backup is two day's worth of work. The<br>number of tapes for a restore depends on how long you keep between full backups, but it is less than in the<br>simple schemes.<br>
<b>Table 12−1. Efficient backup scheme using many backup levels</b><br>
<b>Tape&nbsp;Level&nbsp;Backup (days)&nbsp;Restore tapes</b><br>
1<br>
0<br>
n/a<br>
1<br>
2<br>
3<br>
1<br>
1, 2<br>
3<br>
2<br>
2<br>
1, 3<br>
4<br>
5<br>
1<br>
1, 2, 4<br>
5<br>
4<br>
2<br>
1, 2, 5<br>
6<br>
7<br>
1<br>
1, 2, 5, 6<br>
7<br>
6<br>
2<br>
1, 2, 5, 7<br>
8<br>
9<br>
1<br>
1, 2, 5, 7, 8<br>
9<br>
8<br>
2<br>
1, 2, 5, 7, 9<br>
10<br>
9<br>
1<br>
1, 2, 5, 7, 9, 10<br>
11<br>
9<br>
1<br>
1, 2, 5, 7, 9, 10, 11<br>
...<br>
9<br>
1<br>
1, 2, 5, 7, 9, 10, 11, ...<br>
A fancy scheme can reduce the amount of labor needed, but it does mean there are more things to keep track<br>of. You must decide if it is worth it.<br>
<b>dump</b>&nbsp;has built−in support for backup levels. For<b>&nbsp;tar</b>&nbsp;and<b>&nbsp;cpio</b>&nbsp;it must be implemented with shell scripts.<br>
<b>12.6. What to back up</b><br>
You want to back up as much as possible. The major exception is software that can be easily reinstalled,&nbsp;[46]<br>but even they may have configuration files that it is important to back up, lest you need to do all the work to<br>configure them all over again. Another major exception is the&nbsp;/proc&nbsp;filesystem; since that only contains data<br>that the kernel always generates automatically, it is never a good idea to back it up. Especially the<br>/proc/kcore&nbsp;file is unnecessary, since it is just an image of your current physical memory; it's pretty large<br>
Chapter 12. Backups<br>
75<br>
<hr>
<A name=82></a>The Linux System Administrator's Guide<br>
as well.<br>
Gray areas include the news spool, log files, and many other things in&nbsp;/var. You must decide what you<br>consider important.<br>
The obvious things to back up are user files (/home) and system configuration files (/etc, but possibly<br>other things scattered all over the filesystem).<br>
<b>12.7. Compressed backups</b><br>
Backups take a lot of space, which can cost quite a lot of money. To reduce the space needed, the backups can<br>be compressed. There are several ways of doing this. Some programs have support for for compression built<br>in; for example, the&nbsp;−−gzip&nbsp;(−z) option for GNU<b>&nbsp;tar</b>&nbsp;pipes the whole backup through the<b>&nbsp;gzip</b>&nbsp;compression<br>program, before writing it to the backup medium.<br>
Unfortunately, compressed backups can cause trouble. Due to the nature of how compression works, if a<br>single bit is wrong, all the rest of the compressed data will be unusable. Some backup programs have some<br>built in error correction, but no method can handle a large number of errors. This means that if the backup is<br>compressed the way GNU<b>&nbsp;tar</b>&nbsp;does it, with the whole output compressed as a unit, a single error makes all the<br>rest of the backup lost. Backups must be reliable, and this method of compression is not a good idea.<br>
An alternative way is to compress each file separately. This still means that the one file is lost, but all other<br>files are unharmed. The lost file would have been corrupted anyway, so this situation is not much worse than<br>not using compression at all. The<b>&nbsp;afio</b>&nbsp;program (a variant of<b>&nbsp;cpio</b>) can do this.<br>
Compression takes some time, which may make the backup program unable to write data fast enough for a<br>tape drive.&nbsp;[47] This can be avoided by buffering the output (either internally, if the backup program if smart<br>enough, or by using another program), but even that might not work well enough. This should only be a<br>problem on slow computers.<br>
Chapter 12. Backups<br>
76<br>
<hr>
<A name=83></a><b>Chapter 13. Keeping Time</b><br>
&quot;Time is an illusion. Lunchtime double so.&quot; (Douglas Adams.)<br>
This chapter explains how a Linux system keeps time, and what you need to do to avoid causing trouble.<br>Usually, you don't need to do anything about time, but it is good to understand it.<br>
<b>13.1. The concept of localtime</b><br>
Time measurement is based on mostly regular natural phenomena, such as alternating light and dark periods<br>caused by the rotation of the planet. The total time taken by two successive periods is constant, but the lengths<br>of the light and dark period vary. One simple constant is noon.<br>
Noon is the time of the day when the Sun is at its highest position. Since the Earth is round,&nbsp;[48] noon<br>happens at different times in different places. This leads to the concept of<i>&nbsp;local time</i>. Humans measure time in<br>many units, most of which are tied to natural phenomena like noon. As long as you stay in the same place, it<br>doesn't matter that local times differ.<br>
As soon as you need to communicate with distant places, you'll notice the need for a common time. In modern<br>times, most of the places in the world communicate with most other places in the world, so a global standard<br>for measuring time has been defined. This time is called<i>&nbsp;universal time</i>&nbsp;(UT or UTC, formerly known as<br>Greenwich Mean Time or GMT, since it used to be local time in Greenwich, England). When people with<br>different local times need to communicate, they can express times in universal time, so that there is no<br>confusion about when things should happen.<br>
Each local time is called a time zone. While geography would allow all places that have noon at the same time<br>have the same time zone, politics makes it difficult. For various reasons, many countries use<i>&nbsp;daylight savings<br>time</i>, that is, they move their clocks to have more natural light while they work, and then move the clocks<br>back during winter. Other countries do not do this. Those that do, do not agree when the clocks should be<br>moved, and they change the rules from year to year. This makes time zone conversions definitely non−trivial.<br>
Time zones are best named by the location or by telling the difference between local and universal time. In the<br>US and some other countries, the local time zones have a name and a three letter abbreviation. The<br>abbreviations are not unique, however, and should not be used unless the country is also named. It is better to<br>talk about the local time in, say, Helsinki, than about East European time, since not all countries in Eastern<br>Europe follow the same rules.<br>
Linux has a time zone package that knows about all existing time zones, and that can easily be updated when<br>the rules change. All the system administrator needs to do is to select the appropriate time zone. Also, each<br>user can set his own time zone; this is important since many people work with computers in different<br>countries over the Internet. When the rules for daylight savings time change in your local time zone, make<br>sure you'll upgrade at least that part of your Linux system. Other than setting the system time zone and<br>upgrading the time zone data files, there is little need to bother about time.<br>
Chapter 13. Keeping Time<br>
77<br>
<hr>
<A name=84></a>The Linux System Administrator's Guide<br>
<b>13.2. The hardware and software clocks</b><br>
A personal computer has a battery driven hardware clock. The battery ensures that the clock will work even if<br>the rest of the computer is without electricity. The hardware clock can be set from the BIOS setup screen or<br>from whatever operating system is running.<br>
The Linux kernel keeps track of time independently from the hardware clock. During the boot, Linux sets its<br>own clock to the same time as the hardware clock. After this, both clocks run independently. Linux maintains<br>its own clock because looking at the hardware is slow and complicated.<br>
The kernel clock always shows universal time. This way, the kernel does not need to know about time zones<br>at all. The simplicity results in higher reliability and makes it easier to update the time zone information. Each<br>process handles time zone conversions itself (using standard tools that are part of the time zone package).<br>
The hardware clock can be in local time or in universal time. It is usually better to have it in universal time,<br>because then you don't need to change the hardware clock when daylight savings time begins or ends (UTC<br>does not have DST). Unfortunately, some PC operating systems, including MS−DOS, Windows, and OS/2,<br>assume the hardware clock shows local time. Linux can handle either, but if the hardware clock shows local<br>time, then it must be modified when daylight savings time begins or ends (otherwise it wouldn't show local<br>time).<br>
<b>13.3. Showing and setting time</b><br>
In Linux, the system time zone is determined by the symbolic link&nbsp;/etc/localtime. This link points to a<br>time zone data file that describes the local time zone. The time zone data files are located at either<br>/usr/lib/zoneinfo&nbsp;or&nbsp;/usr/share/zoneinfo&nbsp;depending on what distribution of Linux you use.<br>
For example, on a SuSE system located in New Jersey the&nbsp;/etc/localtime&nbsp;link would point to<br>/usr/share/zoneinfo/US/Eastern. On a Debian system the&nbsp;/etc/localtime&nbsp;link would point<br>to&nbsp;/usr/lib/zoneinfo/US/Eastern.<br>
If you fail to find the&nbsp;zoneinfo&nbsp;directory in either the&nbsp;/usr/lib&nbsp;or&nbsp;/usr/share&nbsp;directories, either do a<br><b>find /usr −print | grep zoneinfo</b>&nbsp;or consult your distribution's documentation.<br>
What happens when you have a users located in a different timezone? A user can change his private time zone<br>by setting the TZ environment variable. If it is unset, the system time zone is assumed. The syntax of the TZ<br>variable is described in the&nbsp;tzset&nbsp;manual page.<br>
The<b>&nbsp;date</b>&nbsp;command shows the current date and time.&nbsp;[49] For example:<br>
$&nbsp;<b>date</b><br>
Sun Jul 14 21:53:41 EET DST 1996<br>
$<br>
That time is Sunday, 14th of July, 1996, at about ten before ten at the evening, in the time zone called &quot;EET<br>DST&quot; (which might be East European Daylight Savings Time).<b>&nbsp;date</b>&nbsp;can also show the universal time:<br>
$&nbsp;<b>date −u</b><br>
Sun Jul 14 18:53:42 UTC 1996<br>
$<br>
Chapter 13. Keeping Time<br>
78<br>
<hr>
<A name=85></a>The Linux System Administrator's Guide<br>
<b>date</b>&nbsp;is also used to set the kernel's software clock:<br>
#&nbsp;<b>date 07142157</b><br>
Sun Jul 14 21:57:00 EET DST 1996<br>
#&nbsp;<b>date</b><br>
Sun Jul 14 21:57:02 EET DST 1996<br>
#<br>
See the<b>&nbsp;date</b>&nbsp;manual page for more details; the syntax is a bit arcane. Only root can set the time. While each<br>user can have his own time zone, the clock is the same for everyone.<br>
<b>date</b>&nbsp;only shows or sets the software clock. The<b>&nbsp;clock</b>&nbsp;commands synchronizes the hardware and software<br>clocks. It is used when the system boots, to read the hardware clock and set the software clock. If you need to<br>set both clocks, you first set the software clock with<b>&nbsp;date</b>, and then the hardware clock with<b>&nbsp;clock −w</b>.<br>
The&nbsp;−u&nbsp;option to<b>&nbsp;clock</b>&nbsp;tells it that the hardware clock is in universal time. You<i>&nbsp;must</i>&nbsp;use the&nbsp;−u&nbsp;option<br>correctly. If you don't, your computer will be quite confused about what the time is.<br>
The clocks should be changed with care. Many parts of a Unix system require the clocks to work correctly.<br>For example, the<b>&nbsp;cron</b>&nbsp;daemon runs commands periodically. If you change the clock, it can be confused of<br>whether it needs to run the commands or not. On one early Unix system, someone set the clock twenty years<br>into the future, and<b>&nbsp;cron</b>&nbsp;wanted to run all the periodic commands for twenty years all at once. Current<br>versions of<b>&nbsp;cron</b>&nbsp;can handle this correctly, but you should still be careful. Big jumps or backward jumps are<br>more dangerous than smaller or forward ones.<br>
<b>13.4. When the clock is wrong</b><br>
The Linux software clock is not always accurate. It is kept running by a periodic<i>&nbsp;timer interrupt</i>&nbsp;generated by<br>PC hardware. If the system has too many processes running, it may take too long to service the timer interrupt,<br>and the software clock starts slipping behind. The hardware clock runs independently and is usually more<br>accurate. If you boot your computer often (as is the case for most systems that aren't servers), it will usually<br>keep fairly accurate time.<br>
If you need to adjust the hardware clock, it is usually simplest to reboot, go into the BIOS setup screen, and<br>do it from there. This avoids all trouble that changing system time might cause. If doing it via BIOS is not an<br>option, set the new time with<b>&nbsp;date</b>&nbsp;and<b>&nbsp;clock</b>&nbsp;(in that order), but be prepared to reboot, if some part of the<br>system starts acting funny.<br>
Another method would be to use either<b>&nbsp;hwclock −w</b>&nbsp;or<b>&nbsp;hwclock −−systohc</b>&nbsp;to sync the hardware clock to the<br>software clock. If you want to sync your software clock to your hardware clock then you would use<b>&nbsp;hwclock<br>−s</b>&nbsp;or<b>&nbsp;hwclock −−hctosys</b>. For more information on this command read<b>&nbsp;man hwclock</b>.<br>
<b>13.5. NTP − Network Time Protocol</b><br>
A networked computer (even if just over a modem) can check its own clock automatically by comparing it to<br>the time on another computer known to keep accurate time. Network Time Protocol (or NTP) does exactly<br>that. It is a method of verifying and correcting your computer's time by synchronizing it with a another<br>system. With NTP your system's time can be maintained to within milliseconds of Coordinated Universal<br>Time.&nbsp;[50]<br>
For more casual Linux users, this is just a nice luxury. At my home all our clocks are set based upon what my<br>Linux system says the time is. For larger organizations this &quot;luxury&quot; can become essential. Being able to<br>
Chapter 13. Keeping Time<br>
79<br>
<hr>
<A name=86></a>The Linux System Administrator's Guide<br>
search log files for events based upon time can make life a lot easier and take a lot of the &quot;guess work&quot; out of<br>debugging.<br>
Another example of how important NTP can be is with a SAN. Some SAN's require NTP be configured and<br>running properly to allow for proper synchronization over filesystem usage, and proper timestamp control.<br>Some SANs (and some applications) can become confused when dealing with files that have timestamps that<br>are in the future.<br>
Most Linux distributions come with a NTP package of some kind, either a .deb or .rpm package. You can use<br><a href="http://www.ntp.org/downloads.html">that to install NTP, or you can download the source files from http://www.ntp.org/downloads.html and<br></a>compile it yourself. Either way, the basic configuration is the same.<br>
<b>13.6. Basic NTP configuration</b><br>
The NTP program is configured using either the&nbsp;/etc/ntp.conf&nbsp;or&nbsp;/etc/xntp.conf&nbsp;file depending<br>on what distribution of Linux you have. I won't go into too much detail on how to configure NTP. Instead I'll<br>just cover the basics.<br>
An example of a basic ntp.conf file would look like:<br>
# −−− GENERAL CONFIGURATION −−−<br>
server &nbsp;aaa.bbb.ccc.ddd<br>
server &nbsp;127.127.1.0<br>
fudge &nbsp; 127.127.1.0 stratum 10<br>
# Drift file.<br>
driftfile /etc/ntp/drift<br>
The most basic ntp.conf file will simply list 2 servers, one that it wishes to synchronize with, and a pseudo IP<br>address for itself (in this case 127.127.1.0). The pseudo IP is used in case of network problems or if the<br>remote NTP server goes down. NTP will synchronize against itself until the it can start synchronizing with the<br>remote server again. It is recommended that you list at least 2 remote servers that you can synchronize against.<br>One will act as a primary server and the other as a backup.<br>
You should also list a location for a drift file. Over time NTP will &quot;learn&quot; the system clock's error rate and<br>automatically adjust for it.<br>
The restrict option can be used to provide better control and security over what NTP can do, and who can<br>effect it. For example:<br>
# Prohibit general access to this service.<br>
restrict default ignore<br>
# Permit systems on this network to synchronize with this<br>
# time service. But not modify our time.<br>
restrict aaa.bbb.ccc.ddd nomodify<br>
# Allow the following unrestricted access to ntpd<br>
restrict aaa.bbb.ccc.ddd<br>
restrict 127.0.0.1<br>
Chapter 13. Keeping Time<br>
80<br>
<hr>
<A name=87></a>The Linux System Administrator's Guide<br>
It is advised that you wait until you have NTP working properly before adding the restrict option. You can<br>accidental restrict yourself from synchronizing and waste time debugging why.<br>
NTP slowly corrects your systems time. Be patient! A simple test is to change your system clock by 10<br>minutes before you go to bed and then check it when you get up. The time should be correct.<br>
<b>13.7. NTP Toolkit</b><br>
There are a number of utilities available to check if NTP is doing it's job. The<b>&nbsp;ntpq −p</b>&nbsp;command will print<br>out your system's current time status.<br>
#&nbsp;<b>ntpq −p</b><br>
&nbsp; &nbsp; remote &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refid &nbsp; &nbsp; &nbsp;st t when poll reach &nbsp; delay &nbsp; offset &nbsp;jitter<br>
==============================================================================<br>
*cudns.cit.corne ntp0.usno.navy. &nbsp;2 u &nbsp;832 1024 &nbsp;377 &nbsp; 43.208 &nbsp; &nbsp;0.361 &nbsp; 2.646<br>
&nbsp;LOCAL(0) &nbsp; &nbsp; &nbsp; &nbsp;LOCAL(0) &nbsp; &nbsp; &nbsp; &nbsp;10 l &nbsp; 13 &nbsp; 64 &nbsp;377 &nbsp; &nbsp;0.000 &nbsp; &nbsp;0.000 &nbsp; 0.008<br>
The<b>&nbsp;ntpdc −c loopinfo</b>&nbsp;will display how far off the system time is in seconds, based upon the last time the<br>remote server was contacted.<br>
#&nbsp;<b>ntpdc −c loopinfo</b><br>
offset: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; −0.004479 s<br>
frequency: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;133.625 ppm<br>
poll adjust: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30<br>
watchdog timer: &nbsp; &nbsp; &nbsp; 404 s<br>
<b>ntpdc −c kerninfo</b>&nbsp;will display the current remaining correction.<br>
#&nbsp;<b>ntpdc −c kerninfo</b><br>
pll offset: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; −0.003917 s<br>
pll frequency: &nbsp; &nbsp; &nbsp; &nbsp;133.625 ppm<br>
maximum error: &nbsp; &nbsp; &nbsp; &nbsp;0.391414 s<br>
estimated error: &nbsp; &nbsp; &nbsp;0.003676 s<br>
status: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0001 &nbsp;pll<br>
pll time constant: &nbsp; &nbsp;6<br>
precision: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1e−06 s<br>
frequency tolerance: &nbsp;512 ppm<br>
pps frequency: &nbsp; &nbsp; &nbsp; &nbsp;0.000 ppm<br>
pps stability: &nbsp; &nbsp; &nbsp; &nbsp;512.000 ppm<br>
pps jitter: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0.0002 s<br>
calibration interval: 4 s<br>
calibration cycles: &nbsp; 0<br>
jitter exceeded: &nbsp; &nbsp; &nbsp;0<br>
stability exceeded: &nbsp; 0<br>
calibration errors: &nbsp; 0<br>
A slightly more different version of<b>&nbsp;ntpdc −c kerninfo</b>&nbsp;is<b>&nbsp;ntptime</b><br>
#&nbsp;<b>ntptime</b><br>
ntp_gettime() returns code 0 (OK)<br>
&nbsp; time c35e2cc7.879ba000 &nbsp;Thu, Nov 13 2003 11:16:07.529, (.529718),<br>
&nbsp; maximum error 425206 us, estimated error 3676 us<br>
ntp_adjtime() returns code 0 (OK)<br>
Chapter 13. Keeping Time<br>
81<br>
<hr>
<A name=88></a>The Linux System Administrator's Guide<br>
&nbsp; modes 0x0 (),<br>
&nbsp; offset −3854.000 us, frequency 133.625 ppm, interval 4 s,<br>
&nbsp; maximum error 425206 us, estimated error 3676 us,<br>
&nbsp; status 0x1 (PLL),<br>
&nbsp; time constant 6, precision 1.000 us, tolerance 512 ppm,<br>
&nbsp; pps frequency 0.000 ppm, stability 512.000 ppm, jitter 200.000 us,<br>
&nbsp; intervals 0, jitter exceeded 0, stability exceeded 0, errors 0.<br>
Yet another way to see how well NTP is working is with the<b>&nbsp;ntpdate −d</b>&nbsp;command. This will contact an NTP<br>server and determine the time difference but not change your system's time.<br>
#&nbsp;<b>ntpdate −d 132.236.56.250</b><br>
13 Nov 14:43:17 ntpdate[29631]: ntpdate 4.1.1c−rc1@1.836 Thu Feb 13 12:17:20 EST 2003 (1)<br>
transmit(132.236.56.250)<br>
receive(132.236.56.250)<br>
transmit(132.236.56.250)<br>
receive(132.236.56.250)<br>
transmit(132.236.56.250)<br>
receive(132.236.56.250)<br>
transmit(132.236.56.250)<br>
receive(132.236.56.250)<br>
transmit(132.236.56.250)<br>
server 132.236.56.250, port 123<br>
stratum 2, precision −17, leap 00, trust 000<br>
refid [192.5.41.209], delay 0.06372, dispersion 0.00044<br>
transmitted 4, in filter 4<br>
reference time: &nbsp; &nbsp;c35e5998.4a46cfc8 &nbsp;Thu, Nov 13 2003 14:27:20.290<br>
originate timestamp: c35e5d55.d69a6f82 &nbsp;Thu, Nov 13 2003 14:43:17.838<br>
transmit timestamp: &nbsp;c35e5d55.d16fc9bc &nbsp;Thu, Nov 13 2003 14:43:17.818<br>
filter delay: &nbsp;0.06522 &nbsp;0.06372 &nbsp;0.06442 &nbsp;0.06442<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0.00000 &nbsp;0.00000 &nbsp;0.00000 &nbsp;0.00000<br>
filter offset: 0.000036 0.001020 0.000527 0.000684<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0.000000 0.000000 0.000000 0.000000<br>
delay 0.06372, dispersion 0.00044<br>
offset 0.001020<br>
13 Nov 14:43:17 ntpdate[29631]: adjust time server 132.236.56.250 offset 0.001020 sec<br>
If you want actually watch the system synchronize you can use<b>&nbsp;ntptrace</b>.<br>
#&nbsp;<b>ntptrace 132.236.56.250</b><br>
cudns.cit.cornell.edu: stratum 2, offset −0.003278, synch distance 0.02779<br>
dtc−truetime.ntp.aol.com: stratum 1, offset −0.014363, synch distance 0.00000, refid 'ACTS'<br>
If you need your system time synchronized immediately you can use the<b>&nbsp;ntpdate remote−servername</b>&nbsp;to<br>force a synchronization. No waiting!<br>
#&nbsp;<b>ntpdate 132.236.56.250</b><br>
13 Nov 14:56:28 ntpdate[29676]: adjust time server 132.236.56.250 offset −0.003151 sec<br>
Chapter 13. Keeping Time<br>
82<br>
<hr>
<A name=89></a>The Linux System Administrator's Guide<br>
<b>13.8. Some known NTP servers</b><br>
<a href="http://www.eecis.udel.edu/~mills/ntp/servers.html/">A list of public NTP servers can be obtained from: http://www.eecis.udel.edu/~mills/ntp/servers.html. Please<br></a>read the usage information on the page prior so using a server. Not all servers have the available bandwidth to<br>allow a large number of systems syncronizing against them. Therefore it is a good idea to contact a system's<br>administrator prior to using his/her server for NTP services.<br>
<b>13.9. NTP Links</b><br>
<a href="http://www.ntp.org/">More detailed information on NTP can be obtained from the NTP homepage:http://www.ntp.org.</a><br>
<a href="http://www.ntp.org/ntpfaq/NTP-a-faq.htm">Or from http://www.ntp.org/ntpfaq/NTP−a−faq.htm</a><br>
Chapter 13. Keeping Time<br>
83<br>
<hr>
<A name=90></a><b>Chapter 14. Finding Help</b><br>
&quot;Help me if you can I'm feeling down. And I do appreciate you being 'round.&quot; − The Beatles<br>
<b>14.1. Newsgroups and Mailing Lists</b><br>
This guide cannot teach you everything about Linux. There just isn't enough space. It is almost inevitable that<br>at some point you will find something you need to do, that isn't covered in this (or any other) document at the<br>LDP.<br>
One of the nicest things about Linux is the large number of forums devoted to it. There are forums relating to<br>almost all facets of Linux ranging from newbie FAQs to in depth kernel development issues. To receive the<br>most from them, there are a few things you can do.<br>
<b>14.1.1. Finding The Right Forum</b><br>
The first thing to do is to find an appropriate forum. There are many newsgroups and mailing lists devoted to<br>Linux, so try to find and use the one which most closely matches your question. For example, there isn't much<br>point in you asking a question about sendmail in a forum devoted to Linux kernel development. At best the<br>people there will think you are stupid and you will get few responses, at worst you may receive lots of highly<br>insulting replies (flames). A quick look through the newsgroups available finds comp.mail.sendmail, which<br>looks like an appropriate place to ask a sendmail question. Your news client probably has a list of the<br>newsgroups available to you, but if not then a full list of newsgroups is available at<br><a href="http://groups.google.com/groups?group=*">http://groups.google.com/groups?group=*.</a><br>
<b>14.1.2. Before You Post</b><br>
Now that you have found your appropriate forum, you may think you are ready to post your question. Stop.<br>You aren't ready yet. Have you already looked for the answer yourself? There are a huge number of HOWTOs<br>and FAQs available, if any of them relate to the thing you are having a problem with then<i>&nbsp;read them first</i>.<br>Even if they don't contain the answer to your problem, what they will do is give you a better understanding of<br>the subject area, and that understanding will allow you to ask a more informed and sensible question. There<br>are also archives of newsgroups and mailing lists and it is entirely possible that your question has been asked<br><a href="http://www.google.com">and answered previously. http://www.google.com or a similar search engine should be something you try<br></a><i>before</i>&nbsp;posting a question.<br>
<b>14.1.3. Writing Your Post</b><br>
Okay, you have found your appropriate forum, you have read the relevant HOWTOs and FAQs, you have<br>searched the web, but you still have not found the answer you need. Now you can start writing your post. It is<br>always a good idea to make it clear that you already have read up on the subject by saying something like &quot;I<br>have read the Winmodem−HOWTO and the PPP FAQ, but neither contained what I was looking for,<br>searching for `Winmodem Linux PPP Setup' on google didn't return anything of use either&quot;. This shows you<br>to be someone who is willing to make an effort rather than a lazy idiot who requires spoonfeeding. The former<br>is likely to receive help if anyone knows the answer, the latter is likely to meet with either stony silence or<br>outright derision.<br>
Chapter 14. Finding Help<br>
84<br>
<hr>
<A name=91></a>The Linux System Administrator's Guide<br>
Write in clear, grammatical and correctly spelt English. This is incredibly important. It marks you as a precise<br>and considered thinker. There are no such words as &quot;u&quot; or &quot;b4.&quot; Try to make yourself look like an educated<br>and intelligent person rather than an idiot. It will help. I promise.<br>
Similarly do not type in all capitals LIKE THIS. That is considered shouting and looks very rude.<br>
Provide clear details stating what the problem is and what you have already tried to do to fix it. A question<br>like &quot;My linux has stopped working, what can I do?&quot; is totally useless. Where has it stopped working? In what<br>way has it stopped working? You need to be as precise as possible. There are limits however. Try not to<br>include irrelevant information either. If you are having problems with your mail client it is unlikely that a<br>dump of your kernel boot log (<b>dmesg</b>) would be of help.<br>
Don't ask for replies by private email. The point of most Linux forums is that everybody can learn something<br>from each other. Asking for private replies simply removes value from the newsgroup or mailing list.<br>
<b>14.1.4. Formatting Your Post</b><br>
Do not post in HTML. Many Linux users have mail clients which can't easily read HTML email. Whilst with<br>some effort, they<i>&nbsp;can</i>&nbsp;read HTML email, they usually don't. If you send them HTML mail it often gets deleted<br>unread. Send plain text emails, they will reach a wider audience that way.<br>
<b>14.1.5. Follow Up</b><br>
After your problem has been solved, post a short followup explaining what the problem was and how you<br>solved it. People will appreciate this as it not only gives a sense of closure about the problem but also helps<br>the next time someone has a similar question. When they look at the archives of the newsgroup or mailing list,<br>they will see you had the same problem, the discussion that followed your question and your final solution.<br>
<b>14.1.6. More Information</b><br>
This short guide is simply a paraphrase and summary of the excellent (and more detailed) document &quot;How To<br><a href="http://www.tuxedo.org/~esr/faqs/smart-questions.html">Ask Questions The Smart Way&quot; by Eric S Raymond. http://www.tuxedo.org/~esr/faqs/smart−questions.html.<br></a>It is recommend that you read it before you post anything. It will help you formulate your question to<br>maximise your chances of getting the answer you are looking for.<br>
<b>14.2. IRC</b><br>
IRC (Internet Relay Chat) is not covered in the Eric Raymond document, but IRC can also be an excellent<br>way of finding the answers you need. However it does require some practice in asking questions in the right<br>way. Most IRC networks have busy #linux channels and if the answer to your question is contained in the<br>manpages, or in the HOWTOs then expect to be told to go read them. The rule about typing in clear and<br>grammatical English still applies.<br>
Most of what has been said about newsgroups and mailing lists is still relevant for IRC, with a the following<br>additions<br>
Chapter 14. Finding Help<br>
85<br>
<hr>
<A name=92></a>The Linux System Administrator's Guide<br>
<b>14.2.1. Colours</b><br>
Do not use colours, bold, underline or strange (non ASCII) characters. This breaks some older terminals and is<br>just plain ugly to look at. If you arrive in a channel and start spewing colour or bold then expect to be kicked<br>out.<br>
<b>14.2.2. Be Polite</b><br>
Remember you are not entitled to an answer. If you ask the question in the right way then you will probably<br>get one, but you have no right to get one. The people in Linux IRC channels are all there on their own time,<br>nobody is paying them, especially not you.<br>
Be polite. Treat others as you would like to be treated. If you think people are not being polite to you then<br>don't start calling them names or getting annoyed, become even politer. This makes them look foolish rather<br>than dragging you down to their level.<br>
Don't go slapping anyone with large trouts. Would you believe this has been done before once or twice? And<br>that we it wasn't funny the first time?<br>
<b>14.2.3. Type Properly, in English</b><br>
Most #linux channels are English channels. Speak English whilst in them. Most of the larger IRC networks<br>also have #linux channel in other languages, for example the French language channel might be called<br>#linuxfr, the Spanish one might be #linuxes or #linuxlatino. If you can't find the right channel then asking in<br>the main #linux channel (preferably in English) should help you find the one you are looking for.<br>
Do not type like a &quot;1337 H4X0R d00d!!!&quot;. Even if other people are. It looks silly and thereby makes you look<br>silly. At best you will only look like an idiot, at worst you will be derided then kicked out.<br>
<b>14.2.4. Port scanning</b><br>
Never<i>&nbsp;ever</i>&nbsp;ask anyone to port scan you, or try to &quot;hack&quot; you. This is inviolable. There is no way of knowing<br>that you are who you say you are, or that the IP that you are connected from belongs to you. Don't put people<br>in the position where they have to say no to a request like this.<br>
<i>Don't ever port scan anyone</i>, even if they ask you to. You have no way to tell that they are who they say they<br>are or that the IP they are connected from is their own IP. In some jurisdictions port scanning may be illegal<br>and it is certainly against the Terms of Service of most ISPs. Most people log TCP connections, they will<br>notice they are being scanned. Most people<i>&nbsp;will</i>&nbsp;report you to your ISP for this (it is trivial to find out who that<br>is).<br>
<b>14.2.5. Keep it in the Channel</b><br>
Don't /msg anyone unless they ask you to. It diminishes the usefulness of the channel and some people just<br>prefer that you not do it.<br>
Chapter 14. Finding Help<br>
86<br>
<hr>
<A name=93></a>The Linux System Administrator's Guide<br>
<b>14.2.6. Stay On Topic</b><br>
Stay on topic. The channel is a &quot;Linux&quot; channel, not a &quot;What Uncle Bob Got Up To Last Weekend&quot; channel.<br>Even if you see other people being off topic, this does not mean that you should be. They are probably<br>channel regulars and different conventions apply to them.<br>
<b>14.2.7. CTCPs</b><br>
If you are thinking of mass CTCP&nbsp;[51] pinging the channel or CTCP version or CTCP anything, then think<br>again. It is liable to get you kicked out very quickly.<br>
<b>14.2.8. Hacking, Cracking, Phreaking, Warezing</b><br>
Don't ask about exploits, unless you are looking for a further way to be unceremoniously kicked out.<br>
Don't be in hacker/cracker/phreaker/warezer channels whilst in a #linux channel. For some reason the people<br>in charge of #linux channels seem to hate people who like causing destruction to people's machines or who<br>like to steal software. Can't imagine why.<br>
<b>14.2.9. Round Up</b><br>
Apologies if that seems like a lot of DON'Ts, and very few DOs. The DOs were already pretty much covered<br>in the section on newsgroups and mailing lists.<br>
Probably the best thing you can do is to go into a #linux channel, sit there and watch, getting the feel for a half<br>hour before you say anything. This can help you to recognise the correct tone you should be using.<br>
<b>14.2.10. Further Reading</b><br>
There are excellent FAQs about how to get the most of IRC #linux channels. Most #linux channels have an<br>FAQ and/or set or channel rules. How to find this will usually be in the channel topic (which you can see at<br>any time using the<b>&nbsp;/topic</b>&nbsp;command. Make sure you read the rules if there are any and follow them. One fairly<br>generic set of rules and advice is the &quot;Undernet #linux FAQ&quot; which can be found at<br><a href="http://linuxfaq.quartz.net.nz">http://linuxfaq.quartz.net.nz .</a><br>
Chapter 14. Finding Help<br>
87<br>
<hr>
<A name=94></a><b>Appendix A. GNU Free Documentation License</b><br>
Version 1.1, March 2000<br>
Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place, Suite 330, Boston, MA<br>02111−1307 USA Everyone is permitted to copy and distribute verbatim copies of this<br>license document, but changing it is not allowed.<br>
<b>0. PREAMBLE</b><br>
The purpose of this License is to make a manual, textbook, or other written document &quot;free&quot; in the sense of<br>freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it,<br>either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a<br>way to get credit for their work, while not being considered responsible for modifications made by others.<br>
This License is a kind of &quot;copyleft&quot;, which means that derivative works of the document must themselves be<br>free in the same sense. It complements the GNU General Public License, which is a copyleft license designed<br>for free software.<br>
We have designed this License in order to use it for manuals for free software, because free software needs<br>free documentation: a free program should come with manuals providing the same freedoms that the software<br>does. But this License is not limited to software manuals; it can be used for any textual work, regardless of<br>subject matter or whether it is published as a printed book. We recommend this License principally for works<br>whose purpose is instruction or reference.<br>
<b>1. APPLICABILITY AND DEFINITIONS</b><br>
This License applies to any manual or other work that contains a notice placed by the copyright holder saying<br>it can be distributed under the terms of this License. The &quot;Document&quot;, below, refers to any such manual or<br>work. Any member of the public is a licensee, and is addressed as &quot;you&quot;.<br>
A &quot;Modified Version&quot; of the Document means any work containing the Document or a portion of it, either<br>copied verbatim, or with modifications and/or translated into another language.<br>
A &quot;Secondary Section&quot; is a named appendix or a front−matter section of the Document that deals exclusively<br>with the relationship of the publishers or authors of the Document to the Document's overall subject (or to<br>related matters) and contains nothing that could fall directly within that overall subject. (For example, if the<br>Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The<br>relationship could be a matter of historical connection with the subject or with related matters, or of legal,<br>commercial, philosophical, ethical or political position regarding them.<br>
The &quot;Invariant Sections&quot; are certain Secondary Sections whose titles are designated, as being those of<br>Invariant Sections, in the notice that says that the Document is released under this License.<br>
The &quot;Cover Texts&quot; are certain short passages of text that are listed, as Front−Cover Texts or Back−Cover<br>Texts, in the notice that says that the Document is released under this License.<br>
Appendix A. GNU Free Documentation License<br>
88<br>
<hr>
<A name=95></a>The Linux System Administrator's Guide<br>
A &quot;Transparent&quot; copy of the Document means a machine−readable copy, represented in a format whose<br>specification is available to the general public, whose contents can be viewed and edited directly and<br>straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for<br>drawings) some widely available drawing editor, and that is suitable for input to text formatters or for<br>automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise<br>Transparent file format whose markup has been designed to thwart or discourage subsequent modification by<br>readers is not Transparent. A copy that is not &quot;Transparent&quot; is called &quot;Opaque&quot;.<br>
Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input<br>format, LaTeX input format, SGML or XML using a publicly available DTD, and standard−conforming<br>simple HTML designed for human modification. Opaque formats include PostScript, PDF, proprietary<br>formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD<br>and/or processing tools are not generally available, and the machine−generated HTML produced by some<br>word processors for output purposes only.<br>
The &quot;Title Page&quot; means, for a printed book, the title page itself, plus such following pages as are needed to<br>hold, legibly, the material this License requires to appear in the title page. For works in formats which do not<br>have any title page as such, &quot;Title Page&quot; means the text near the most prominent appearance of the work's<br>title, preceding the beginning of the body of the text.<br>
<b>2. VERBATIM COPYING</b><br>
You may copy and distribute the Document in any medium, either commercially or noncommercially,<br>provided that this License, the copyright notices, and the license notice saying this License applies to the<br>Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this<br>License. You may not use technical measures to obstruct or control the reading or further copying of the<br>copies you make or distribute. However, you may accept compensation in exchange for copies. If you<br>distribute a large enough number of copies you must also follow the conditions in section 3.<br>
You may also lend copies, under the same conditions stated above, and you may publicly display copies.<br>
<b>3. COPYING IN QUANTITY</b><br>
If you publish printed copies of the Document numbering more than 100, and the Document's license notice<br>requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover<br>Texts: Front−Cover Texts on the front cover, and Back−Cover Texts on the back cover. Both covers must also<br>clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with<br>all words of the title equally prominent and visible. You may add other material on the covers in addition.<br>Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy<br>these conditions, can be treated as verbatim copying in other respects.<br>
If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as<br>many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.<br>
If you publish or distribute Opaque copies of the Document numbering more than 100, you must either<br>include a machine−readable Transparent copy along with each Opaque copy, or state in or with each Opaque<br>copy a publicly−accessible computer−network location containing a complete Transparent copy of the<br>Document, free of added material, which the general network−using public has access to download<br>anonymously at no charge using public−standard network protocols. If you use the latter option, you must<br>
Appendix A. GNU Free Documentation License<br>
89<br>
<hr>
<A name=96></a>The Linux System Administrator's Guide<br>
take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this<br>Transparent copy will remain thus accessible at the stated location until at least one year after the last time<br>you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.<br>
It is requested, but not required, that you contact the authors of the Document well before redistributing any<br>large number of copies, to give them a chance to provide you with an updated version of the Document.<br>
<b>4. MODIFICATIONS</b><br>
You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3<br>above, provided that you release the Modified Version under precisely this License, with the Modified<br>Version filling the role of the Document, thus licensing distribution and modification of the Modified Version<br>to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:<br>
Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from<br>
A.&nbsp;<br>
those of previous versions (which should, if there were any, be listed in the History section of the<br>Document). You may use the same title as a previous version if the original publisher of that version<br>gives permission.<br>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the<br>
B.&nbsp;<br>
modifications in the Modified Version, together with at least five of the principal authors of the<br>Document (all of its principal authors, if it has less than five).<br>State on the Title page the name of the publisher of the Modified Version, as the publisher.<br>
C.&nbsp;<br>
Preserve all the copyright notices of the Document.<br>
D.&nbsp;<br>
Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.<br>
E.&nbsp;<br>
Include, immediately after the copyright notices, a license notice giving the public permission to use<br>
F.&nbsp;<br>
the Modified Version under the terms of this License, in the form shown in the Addendum below.<br>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the<br>
G.&nbsp;<br>
Document's license notice.<br>Include an unaltered copy of this License.<br>
H.&nbsp;<br>
Preserve the section entitled &quot;History&quot;, and its title, and add to it an item stating at least the title, year,<br>
I.&nbsp;<br>
new authors, and publisher of the Modified Version as given on the Title Page. If there is no section<br>entitled &quot;History&quot; in the Document, create one stating the title, year, authors, and publisher of the<br>Document as given on its Title Page, then add an item describing the Modified Version as stated in<br>the previous sentence.<br>Preserve the network location, if any, given in the Document for public access to a Transparent copy<br>
J.&nbsp;<br>
of the Document, and likewise the network locations given in the Document for previous versions it<br>was based on. These may be placed in the &quot;History&quot; section. You may omit a network location for a<br>work that was published at least four years before the Document itself, or if the original publisher of<br>the version it refers to gives permission.<br>In any section entitled &quot;Acknowledgements&quot; or &quot;Dedications&quot;, preserve the section's title, and<br>
K.&nbsp;<br>
preserve in the section all the substance and tone of each of the contributor acknowledgements and/or<br>dedications given therein.<br>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section<br>
L.&nbsp;<br>
numbers or the equivalent are not considered part of the section titles.<br>Delete any section entitled &quot;Endorsements&quot;. Such a section may not be included in the Modified<br>
M.&nbsp;<br>
Version.<br>Do not retitle any existing section as &quot;Endorsements&quot; or to conflict in title with any Invariant Section.<br>
N.&nbsp;<br>
If the Modified Version includes new front−matter sections or appendices that qualify as Secondary Sections<br>and contain no material copied from the Document, you may at your option designate some or all of these<br>
Appendix A. GNU Free Documentation License<br>
90<br>
<hr>
<A name=97></a>The Linux System Administrator's Guide<br>
sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version's<br>license notice. These titles must be distinct from any other section titles.<br>
You may add a section entitled &quot;Endorsements&quot;, provided it contains nothing but endorsements of your<br>Modified Version by various parties−−for example, statements of peer review or that the text has been<br>approved by an organization as the authoritative definition of a standard.<br>
You may add a passage of up to five words as a Front−Cover Text, and a passage of up to 25 words as a<br>Back−Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of<br>Front−Cover Text and one of Back−Cover Text may be added by (or through arrangements made by) any one<br>entity. If the Document already includes a cover text for the same cover, previously added by you or by<br>arrangement made by the same entity you are acting on behalf of, you may not add another; but you may<br>replace the old one, on explicit permission from the previous publisher that added the old one.<br>
The author(s) and publisher(s) of the Document do not by this License give permission to use their names for<br>publicity for or to assert or imply endorsement of any Modified Version.<br>
<b>5. COMBINING DOCUMENTS</b><br>
You may combine the Document with other documents released under this License, under the terms defined<br>in section 4 above for modified versions, provided that you include in the combination all of the Invariant<br>Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined<br>work in its license notice.<br>
The combined work need only contain one copy of this License, and multiple identical Invariant Sections may<br>be replaced with a single copy. If there are multiple Invariant Sections with the same name but different<br>contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the<br>original author or publisher of that section if known, or else a unique number. Make the same adjustment to<br>the section titles in the list of Invariant Sections in the license notice of the combined work.<br>
In the combination, you must combine any sections entitled &quot;History&quot; in the various original documents,<br>forming one section entitled &quot;History&quot;; likewise combine any sections entitled &quot;Acknowledgements&quot;, and any<br>sections entitled &quot;Dedications&quot;. You must delete all sections entitled &quot;Endorsements.&quot;<br>
<b>6. COLLECTIONS OF DOCUMENTS</b><br>
You may make a collection consisting of the Document and other documents released under this License, and<br>replace the individual copies of this License in the various documents with a single copy that is included in<br>the collection, provided that you follow the rules of this License for verbatim copying of each of the<br>documents in all other respects.<br>
You may extract a single document from such a collection, and distribute it individually under this License,<br>provided you insert a copy of this License into the extracted document, and follow this License in all other<br>respects regarding verbatim copying of that document.<br>
Appendix A. GNU Free Documentation License<br>
91<br>
<hr>
<A name=98></a>The Linux System Administrator's Guide<br>
<b>7. AGGREGATION WITH INDEPENDENT WORKS</b><br>
A compilation of the Document or its derivatives with other separate and independent documents or works, in<br>or on a volume of a storage or distribution medium, does not as a whole count as a Modified Version of the<br>Document, provided no compilation copyright is claimed for the compilation. Such a compilation is called an<br>&quot;aggregate&quot;, and this License does not apply to the other self−contained works thus compiled with the<br>Document, on account of their being thus compiled, if they are not themselves derivative works of the<br>Document.<br>
If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document<br>is less than one quarter of the entire aggregate, the Document's Cover Texts may be placed on covers that<br>surround only the Document within the aggregate. Otherwise they must appear on covers around the whole<br>aggregate.<br>
<b>8. TRANSLATION</b><br>
Translation is considered a kind of modification, so you may distribute translations of the Document under the<br>terms of section 4. Replacing Invariant Sections with translations requires special permission from their<br>copyright holders, but you may include translations of some or all Invariant Sections in addition to the<br>original versions of these Invariant Sections. You may include a translation of this License provided that you<br>also include the original English version of this License. In case of a disagreement between the translation and<br>the original English version of this License, the original English version will prevail.<br>
<b>9. TERMINATION</b><br>
You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this<br>License. Any other attempt to copy, modify, sublicense or distribute the Document is void, and will<br>automatically terminate your rights under this License. However, parties who have received copies, or rights,<br>from you under this License will not have their licenses terminated so long as such parties remain in full<br>compliance.<br>
<b>10. FUTURE REVISIONS OF THIS LICENSE</b><br>
The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License<br>from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to<br><a href="http://www.gnu.org/copyleft/">address new problems or concerns. See http://www.gnu.org/copyleft/.</a><br>
Each version of the License is given a distinguishing version number. If the Document specifies that a<br>particular numbered version of this License &quot;or any later version&quot; applies to it, you have the option of<br>following the terms and conditions either of that specified version or of any later version that has been<br>published (not as a draft) by the Free Software Foundation. If the Document does not specify a version<br>number of this License, you may choose any version ever published (not as a draft) by the Free Software<br>Foundation.<br>
Appendix A. GNU Free Documentation License<br>
92<br>
<hr>
<A name=99></a>The Linux System Administrator's Guide<br>
<b>How to use this License for your documents</b><br>
To use this License in a document you have written, include a copy of the License in the document and put the<br>following copyright and license notices just after the title page:<br>
Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify<br>this document under the terms of the GNU Free Documentation License, Version 1.1 or any<br>later version published by the Free Software Foundation; with the Invariant Sections being<br>LIST THEIR TITLES, with the Front−Cover Texts being LIST, and with the Back−Cover<br>Texts being LIST. A copy of the license is included in the section entitled &quot;GNU Free<br>Documentation License&quot;.<br>
If you have no Invariant Sections, write &quot;with no Invariant Sections&quot; instead of saying which ones are<br>invariant. If you have no Front−Cover Texts, write &quot;no Front−Cover Texts&quot; instead of &quot;Front−Cover Texts<br>being LIST&quot;; likewise for Back−Cover Texts.<br>
If your document contains nontrivial examples of program code, we recommend releasing these examples in<br>parallel under your choice of free software license, such as the GNU General Public License, to permit their<br>use in free software.<br>
Appendix A. GNU Free Documentation License<br>
93<br>
<hr>
<A name=100></a><b>Glossary (DRAFT, but not for long hopefully)</b><br>
&quot;The Librarian of the Unseen University had unilaterally decided to aid comprehension by<br>producing an Orang−utan/Human Dictionary. He'd been working on it for three months. It<br>wasn't easy. He'd got as far as `Oook.'&quot; (Terry Pratchett, &quot;Men At Arms&quot;)<br>
This is a short list of word definitions for concepts relating to Linux and system administration.<br>
<i><b>CMOS RAM</b></i><br>
CMOS stands for &quot;Complementary Metal Oxide Semiconductor&quot;. It is a complex technology, but put<br>very simply it is a type of transistor which maintains its state even if there is no power flowing, so it<br>provides a sort of static RAM. ie RAM which does not lose what it was storing when the power is<br>switched off.<br>
<i><b>account</b></i><br>
A Unix system gives users<i>&nbsp;accounts</i>. It gives them a username and a password with which to log on to<br>the account. A home directory in which to store files is usually provided, and permissions to access<br>hardware and software. These things taken as a whole are an<i>&nbsp;account</i>.<br>
<i><b>application program</b></i><br>
Software that does something useful. The results of using an application program is what the<br>computer was bought for. See also system program, operating system.<br>
<i><b>bad block</b></i><br>
A block (usually one sector on a disk) that cannot reliably hold data.<br>
<i><b>bad sector</b></i><br>
Similar to<i>&nbsp;bad block</i>&nbsp;but more precise in the case where a block and a sector may be of differing sizes.<br>
<i><b>boot sector</b></i><br>
Usually the first sector on any given partition. It contains a very short program (on the order of a few<br>hundred bytes) which will load and start running the operating system proper.<br>
<i><b>booting</b></i><br>
Everything that happens between the time the computer is switched on and it is ready to accept<br>commands/input from the user is known as<i>&nbsp;booting</i>.<br>
<i><b>bootstrap loader</b></i><br>
A very small program (usually residing in ROM) which reads a fixed location on a disk (eg. the<i>&nbsp;MBR</i>)<br>and passes control over to it. The data residing on that fixed location is, in general, slightly bigger and<br>more sophisticated, and it then takes responsibility for loading the actual operating system and<br>passing control to it.<br>
<i><b>cylinder</b></i><br>
The set of<i>&nbsp;tracks</i>&nbsp;on a multi−headed disk that may be accessed without head movement. In other<br>words the tracks which are the same distance from the spindle about which the disk<i>&nbsp;platters</i>&nbsp;rotate.<br>Placing data that is more likely to be accessed at the same time on the same cylinder can reduce the<br>access time significantly as moving the read−write heads is slow compared to the speed with which<br>the disks rotate.<br>
<i><b>daemon</b></i><br>
A process lurking in the background, usually unnoticed, until something triggers it into action. For<br>example, the<b>&nbsp;update</b>&nbsp;daemon wakes up every thirty seconds or so to flush the buffer cache, and the<br><b>sendmail</b>&nbsp;daemon awakes whenever someone sends mail.<br>
<i><b>daylight savings time</b></i><br>
A time of the year during which clocks are set forward one hour. Widely used around the world in<br>summer so that evenings have more daylight than they would otherwise.<br>
<i><b>disk controller</b></i><br>
Glossary (DRAFT, but not for long hopefully)<br>
94<br>
<hr>
<A name=101></a>The Linux System Administrator's Guide<br>
A hardware circuit which translates instructions about disk access from the operating system to the<br>physical disk. This provides a layer of abstraction that means that an operating system does not need<br>to know how to talk to the many different types of disks, but only needs to know about the<br>(comparatively low) number of types of disk controller. Common disk controller types are IDE and<br>SCSI.<br>
<i><b>file system</b></i><br>
The methods and data structures that an operating system uses to keep track of files on a disk or<br>partition; the way the files are organised on the disk. Also used about a partition or disk that is used to<br>store the files or the type of the filesystem.<br>
<i><b>emergency boot floppy</b></i><br>
A floppy disk which can be used to boot the system even if the hard disk has suffered damage on its<br>filesystem. Most linux distributions offer to make one of these during installation, this is highly<br>recommended. If your Linux distribution does not offer this facility then read the Boot floppy<br>HOWTO, available at the LDP (**Find URL to cite**).<br>
<i><b>filesystem</b></i><br>
A term which is used for two purposes and which can have two subtly different meanings. It is either<br>the collection of files and directories on a drive (whether hard drive, floppy, Cd−ROM, etc). Or it is<br>the markers put onto the disk media which the OS uses to decide where to write files to (inodes,<br>blocks, superblocks etc). The actual meaning can almost always be inferred from context.<br>
<i><b>formatting</b></i><br>
Strictly, formatting is organising and marking the surface of a disk into<i>&nbsp;tracks</i>,<i>&nbsp;sectors</i>&nbsp;, and<i>&nbsp;cylinders</i>.<br>It is also sometimes (incorrectly) a term used to signify the action of writing a<i>&nbsp;filesystem</i>&nbsp;to a disk<br>(especially in the MS Windows/MS DOS world).<br>
<i><b>fragmented</b></i><br>
When a file is not written to a disk in contiguous<i>&nbsp;blocks</i>. If there is not enough free space to write a<br>full file to a disk in one continuous stream of<i>&nbsp;blocks</i>&nbsp;then the file gets split up between two or more<br>parts of the disk surface. This is known as<i>&nbsp;fragmenting</i>&nbsp;and can make the time for loading a file longer<br>as the disk has to seek for the rest of the file.<br>
<i><b>full backup</b></i><br>
Taking a copy of the whole filesystem to a backup media (eg tape, floppy, or CD).<br>
<i><b>geometry</b></i><br>
How many cylinders, sectors per cylinder and heads a disk drive has.<br>
<i><b>high level formatting</b></i><br>
An incorrect term for writing a filesystem to a disk. Often used in the MS Windows and MS DOS<br>world.<br>
<i><b>incremental backups</b></i><br>
A backup of what has changed in a filesystem since the last<i>&nbsp;full backup</i>.<i>&nbsp;Incremental backups</i>&nbsp;if used<br>sensibly as part of a backup regime, can save a lot of time and effort in maintaining a backup of data.<br>
<i><b>inode</b></i><br>
A data structure holding information about files in a Unix file system. There is an inode for each file<br>and a file is uniquely identified by the file system on which it resides and its inode number on that<br>system. Each inode contains the following information: the device where the inode resides, locking<br>information, mode and type of file, the number of links to the file, the owner's user and group ids, the<br>number of bytes in the file, access and modification times, the time the inode itself was last modified<br>and the addresses of the file's blocks on disk. A Unix directory is an association between file<br>leafnames and inode numbers. A file's inode number can be found using the &quot;−i&quot; switch to ls.<br>
<i><b>kernel</b></i><br>
Part of an operating system that implements the interaction with hardware and the sharing of<br>resources. See also system program.<br>
<i><b>local time</b></i><br>
Glossary (DRAFT, but not for long hopefully)<br>
95<br>
<hr>
<A name=102></a>The Linux System Administrator's Guide<br>
The official time in a local region (adjusted for location around the Earth); established by law or<br>custom.<br>
<i><b>logical partition</b></i><br>
A partition inside an<i>&nbsp;extended partition</i>, which is &quot;logical&quot; in that it does not exist in reality, but only<br>inside the logical structure of the software.<br>
<i><b>low level formatting</b></i><br>
Synonymous with<i>&nbsp;formatting</i>&nbsp;and used in the MS DOS world so differentiate from creating a<br>filesystem which is also known as formatting sometimes.<br>
<i><b>mail transfer agent</b></i><br>
(MTA) The program responsible for delivering e−mail messages. Upon receiving a message from a<br><i>mail user agent</i>&nbsp;or another MTA it stores it temporarily locally and analyses the recipients and either<br>delivers it (local addressee) or forwards it to another MTA. In either case it may edit and/or add to the<br>message headers. A widely used MTA for Unix is sendmail.<br>
<i><b>mail user agent</b></i><br>
(MUA) The program that allows the user to compose and read electronic mail messages. The MUA<br>provides the interface between the user and the<i>&nbsp;mail transfer agent</i>&nbsp;. Outgoing mail is eventually<br>handed over to an MTA for delivery while the incoming messages are picked up from where the<br>MTA left it (although MUAs running on single−user machines may pick up mail using POP).<br>Examples of MUAs are pine, elm and mutt.<br>
<i><b>master boot record</b></i><br>
(MBR) The first logical sector on a disk, this is (usually) where the BIOS looks to load a small<br>program that will boot the computer.<br>
<i><b>network file system</b></i><br>
(NFS) A protocol developed by Sun Microsystems, and defined in RFC 1094 (FIND URL), which<br>allows a computer to access files over a network as if they were on its local disks.<br>
<i><b>operating system</b></i><br>
Software that shares a computer system's resources (processor, memory, disk space, network<br>bandwidth, and so on) between users and the application programs they run. Controls access to the<br>system to provide security. See also kernel, system program, application program.<br>
<i><b>partition</b></i><br>
A logical section of a disk. Each partition normally has its own file system. Unix tends to treat<br>partitions as though they were separate physical entities.<br>
<i><b>password file</b></i><br>
A file that holds usernames and information about their accounts like their password. On Unix<br>systems this file is usually&nbsp;/etc/passwd. On most modern Linux systems the&nbsp;/etc/passwd&nbsp;file<br>does not actually hold password data. That tends to be held in a different file&nbsp;/etc/shadow&nbsp;for<br>security reasons. See manual pages passwd(5) and shadow(5) for more information.<br>
<i><b>platters</b></i><br>
A physical disk inside a hard drive. Usually a hard drive is made up of multiple physical disks stacked<br>up on top of each other. One individual disk is known as a<i>&nbsp;platter</i>&nbsp;.<br>
<i><b>power on self test</b></i><br>
(POST) A series of diagnostic tests which are run when a computer is powered on. Typically this<br>might include testing the memory, testing that the hardware configuration is the same as the last saved<br>configuration, checking that any floppy drives, or hard drives which are known about by the BIOS are<br>installed and working.<br>
<i><b>print queue</b></i><br>
A file (or set of files) which the print<i>&nbsp;daemon</i>&nbsp;uses so that applications which wish to use the printer<br>do not have to wait until the print job they have sent is finished before they can continue. It also<br>allows multiple users to share a printer.<br>
<i><b>read−write head</b></i><br>
Glossary (DRAFT, but not for long hopefully)<br>
96<br>
<hr>
<A name=103></a>The Linux System Administrator's Guide<br>
A tiny electromagnetic coil and metal pole used to write and read magnetic patterns on a disk. These<br>coils move laterally against the rotary motion on the<i>&nbsp;platters</i>.<br>
<i><b>root filesystem</b></i><br>
The parent of all the other filesystems mounted in a Unix filesystem tree. Mounted as / it might have<br>other filesystems mounted on it (/usr for example). If the root filesystem cannot be mounted then the<br><i>kernel</i>&nbsp;will panic and the system will not be able to continue<i>&nbsp;booting</i><br>
<i><b>run level</b></i><br>
Linux has up to 10 runlevels (0−9) available (of which usually only the first 7 are defined). Each<br>runlevel may start a different set of services, giving multiple different configurations in the same<br>system. Runlevel 0 is defined as &quot;system halt&quot;, runlevel 1 is defined as &quot;<i>single user mode</i>&quot;, and<br>runlevel 6 is defined as &quot;reboot system&quot;. The remaining runlevels can, theoretically, be defined by the<br>system administrator in any way. However most distributions provide some other predefined<br>runlevels. For example, runlevel 2 might be defined as &quot;multi−user console&quot;, and runlevel 5 as<br>&quot;multi−user X−Window system&quot;. These definitions vary considerably from distribution to<br>distribution, so please check the documentation for your own distribution.<br>
<i><b>sectors</b></i><br>
The minimum<i>&nbsp;track</i>&nbsp;length that can be allocated to store data. This is usually (but not always) 512<br>bytes.<br>
<i><b>shadow passwords</b></i><br>
Because the<i>&nbsp;password file</i>&nbsp;on Unix systems often needs to be world readable it usually does not<br>actually contain the encrypted passwords for users' accounts. Instead a shadow file is employed<br>(which is not world readable) which holds the encrypted passwords for users' accounts.<br>
<i><b>single user mode</b></i><br>
Usually runlevel 1. A runlevel where logins are not allowed except by the root account. Used either<br>for system repairs (if the filesystem is partially damaged it may still be possible to boot into runlevel 1<br>and repair it), or for moving filesystems around between partitions. These are just two examples. Any<br>task that requires a system where only one person can write to a disk at a time is a candidate for<br>requiring runlevel 1.<br>
<i><b>spool</b></i><br>
To send a file (or other data) to a queue. Generally used in conjunction with printers, but might also<br>be used for other things (mail for example). The term is reported to be an acronym for &quot;Simultaneous<br><a href="http://www.tuxedo.org/~esr/jargon">Peripheral Operation On−Line&quot;, but according to the Jargon File it may have been a backronym<br></a>(something made up later for effect).<br>
<i><b>system call</b></i><br>
The services provided by the kernel to application programs, and the way in which they are invoked.<br>See section 2 of the manual pages.<br>
<i><b>swap space</b></i><br>
Space on a disk in which the system can write portions of memory to. Usually this is a dedicated<br>partition, but it may also be a swapfile.<br>
<i><b>system program</b></i><br>
Programs that implement high level functionality of an operating system, i.e., things that aren't<br>directly dependent on the hardware. May sometimes require special privileges to run (e.g., for<br>delivering electronic mail), but often just commonly thought of as part of the system (e.g., a<br>compiler). See also application program, kernel, operating system.<br>
<i><b>track</b></i><br>
The part of a disk<i>&nbsp;platter</i>&nbsp;which passes under one<i>&nbsp;read−write head</i>&nbsp;while the head is stationary but the<br>disk is spinning. Each track is divided into<i>&nbsp;sectors</i>, and a vertical collection of tracks is a<i>&nbsp;cylinder</i><br>
Glossary (DRAFT, but not for long hopefully)<br>
97<br>
<hr>
<A name=104></a>The Linux System Administrator's Guide<br>
<b>Notes</b><br>
[1]<br>
Understanding is the key to success with Linux. This book could just provide recipes, but what would<br>you do when confronted by a problem this book had no recipe for? If the book can provide<br>understanding then recipes are not required, they will be self evident<br>
[2]<br>
In fact, it is often mistakenly considered to be the operating system itself, but it is not. An operating<br>system provides many more services than a plain kernel.<br>
[3]<br>
I always think of this as a form of encapsulation which may help those of you with an object oriented<br>programming background to visualize it better.<br>
[4]<br>
Well, at least there can be many. Network bandwidth still being a scarce resource, there is still some<br>practical upper limit to the number of concurrent logins via one network connection.<br>
[5]<br>
These days many Linux system administrators consider<b>&nbsp;telnet</b>&nbsp;and<b>&nbsp;rlogin</b>&nbsp;to be insecure and prefer<b>&nbsp;ssh</b>&nbsp;,<br>the &quot;secure shell&quot;, which encrypts traffic going over the network, thereby making it far less likely that<br>the malicious can &quot;sniff&quot; your connection and gain sensitive data like usernames and passwords. It is<br>highly recommended you use<b>&nbsp;ssh</b>&nbsp;rather than<b>&nbsp;telnet</b>&nbsp;or<b>&nbsp;rlogin</b>.<br>
[6]<br>
Instead, they form a new queue<i>&nbsp;at</i>&nbsp;the printer, waiting for their printouts, since no one ever seems to be<br>able to get the queue software to know exactly when anyone's printout is really finished. This is a great<br>boost to intra−office social relations.<br>
[7]<br>
<a href="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</a><br>
[8]<br>
<a href="">http://www.pathname.com/fhs/</a><br>
[9]<br>
Or any Unix like system. For example the BSD derivatives.<br>
[10]&nbsp;This 1024 cylinder limit is no longer true in most cases. With modern BIOSes and later versions of<br>
LILO (the LInux LOader) the 1024 cylinder limit can be passed with logical block addressing (LBA).<br>See the<b>&nbsp;lilo</b>&nbsp;manual page for more details.<br>
[11]&nbsp;Although&nbsp;/proc&nbsp;does not reside on any disk in reality. See the section about&nbsp;/proc&nbsp;later in the<br>
chapter.<br>
[12]&nbsp;The platters are made of a hard substance, e.g., aluminum, which gives the hard disk its name.<br>
[13]&nbsp;The BIOS is some built−in software stored on ROM chips. It takes care, among other things, of the<br>
initial stages of booting.<br>
[14]&nbsp;The numbers are completely imaginary.<br>
[15]&nbsp;That is, the surface inside the disk, on the metal disk inside the plastic coating.<br>
[16]&nbsp;Ironically perhaps, wine actually stands for &quot;Wine Is Not an Emulator&quot;. Wine, more strictly, is an API<br>
(Application Program Interface) replacement. Please see the wine documentation at<br><a href="http://www.winehq.com">http://www.winehq.com for more information.</a><br>
[17]&nbsp;<a href="http://www.vmware.com">See the VMWare website, http://www.vmware.com for more information.</a><br>
[18]&nbsp;But completely different, of course.<br>
[19]&nbsp;This may no longer be true with newer versions of LILO that support LBA (Logical Block Addressing).<br>
Consult the documentation for your distribution to see if it has a version of LILO where LBA is<br>supported.<br>
[20]&nbsp;The<b>&nbsp;fips</b>&nbsp;program is included in most Linux distributions. The commercial partition manager &quot;Partition<br>
Magic&quot; also has a similar facility but with a nicer interface. Please do remember that partitioning is<br>dangerous. Make<i>&nbsp;sure</i>&nbsp;you have a recent backup of any important data before you try changing partition<br>sizes &quot;on the fly&quot;. The GNU program<b>&nbsp;parted</b>&nbsp;can resize other types of partitions as well as MS−DOS,<br>but sometimes in a limited manner. Consult the<b>&nbsp;parted</b>&nbsp;documentation before using it, better safe than<br>sorry.<br>
[21]&nbsp;For more information, see the kernel source or the Kernel Hackers' Guide.<br>
Glossary (DRAFT, but not for long hopefully)<br>
98<br>
<hr>
<A name=105></a>The Linux System Administrator's Guide<br>
[22]&nbsp;It should of course be<b>&nbsp;unmount</b>, but the n mysteriously disappeared in the 70s, and hasn't been seen<br>
since. Please return it to Bell Labs, NJ, if you find it.<br>
[23]&nbsp;It requires several seconds of hard thinking on the users' behalf. Furthermore<b>&nbsp;sudo</b>&nbsp;can be configured to<br>
only allow users to execute certain commands. See the sudo(8), sudoers(5), and visudo(8) manual<br>pages.<br>
[24]&nbsp;<a href="http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz">http://www.go.dlr.de/linux/src/defrag−0.73.tar.gz</a><br>
[25]&nbsp;This is not actually true, it is possible to move partitions and mountpoints without reinstalling, but it is<br>
(currently) beyond the scope of this book to explain how. It is on the TODO list to write a section on<br>this. If you have experience and knowledge in this area then perhaps you could write it for me and save<br>me the bother? :)<br>
[26]&nbsp;This section is somewhat out of date. Most people these days have disks that stretch into the multiple<br>
Gigabytes. It is still quite scalable (just multiply by some factor to make it fit your hardware) for the<br>moment though, updating it to take account of larger disks is planned.<br>
[27]&nbsp;Thus quite needlessly annoying a number of computer scientists greatly.<br>
[28]&nbsp;A gigabyte here, a gigabyte there, pretty soon we start talking about real memory.<br>
[29]&nbsp;Except a RAM disk, for obvious reasons.<br>
[30]&nbsp;On early computers, it wasn't enough to merely turn on the computer, you had to manually load the<br>
operating system as well. These new−fangled thing−a−ma−jigs do it all by themselves.<br>
[31]&nbsp;This is called the<i>&nbsp;power on self test</i>, or<i>&nbsp;POST</i>&nbsp;for short.<br>
[32]&nbsp;<b>sync</b>&nbsp;flushes the buffer cache.<br>
[33]&nbsp;<b>init</b>&nbsp;itself is not allowed to die. You can't kill<b>&nbsp;init</b>&nbsp;even with SIGKILL.<br>
[34]&nbsp;Using the command<b>&nbsp;kill −HUP 1</b>&nbsp;as root, for example<br>
[35]&nbsp;Different versions of<b>&nbsp;getty</b>&nbsp;are run differently. Consult your manual page, and make sure it is the correct<br>
manual page.<br>
[36]&nbsp;It probably shouldn't be used for playing<b>&nbsp;nethack</b>.<br>
[37]&nbsp;Good Linux distributions do this out of the box.<br>
[38]&nbsp;It might be quite embarrassing if my sister could read my love letters.<br>
[39]&nbsp;Yes, this means that the password file has all the information about a user<i>&nbsp;except</i>&nbsp;his password. The<br>
wonder of development.<br>
[40]&nbsp;Surreal users?<br>
[41]&nbsp;The user's name might change due to marriage, for example, and he might want to have his username<br>
reflect his new name.<br>
[42]&nbsp;But they can be<i>&nbsp;so</i>&nbsp;fun, if you're a BOFH.<br>
[43]&nbsp;The fifth reason is &quot;something else&quot;.<br>
[44]&nbsp;Don't laugh. This has happened to several people.<br>
[45]&nbsp;Been there, done that...<br>
[46]&nbsp;You get to decide what's easy. Some people consider installing from dozens of floppies easy.<br>
[47]&nbsp;If a tape drive doesn't data fast enough, it has to stop; this makes backups even slower, and can be bad<br>
for the tape and the drive.<br>
[48]&nbsp;According to recent research.<br>
[49]&nbsp;Beware of the<b>&nbsp;time</b>&nbsp;command, which does not show the current time.<br>
[50]&nbsp;<a href="http://www.time.gov/about.html/">Visit http://www.time.gov/about.html for more info.</a><br>
[51]&nbsp;If you are not familiar with IRC, CTCP stands for Client To Client Protocol. It is a method whereby you<br>
can find out things about other peoples' clients. See the documentation for your IRC client for more<br>
Glossary (DRAFT, but not for long hopefully)<br>
99<br>
<hr>
<A name=106></a>The Linux System Administrator's Guide<br>
details<br>
Glossary (DRAFT, but not for long hopefully)<br>
100<br>
<hr>
<A name="outline"></a><h1>Document Outline</h1>
<ul><li><A href="TLSAGs.html#3">Table of Contents</A>
<li><A href="TLSAGs.html#7">Source and pre-formatted versions available</A>
<li><A href="TLSAGs.html#8">Chapter 1. Introduction</A>
<li><A href="TLSAGs.html#10">Chapter 2. About This Book</A>
<ul><li><A href="TLSAGs.html#10">2.1. Acknowledgments</A>
<ul><li><A href="TLSAGs.html#10">2.1.1. Joanna's acknowledgments</A>
<li><A href="TLSAGs.html#10">2.1.2. Stephen's acknowledgments</A>
<li><A href="TLSAGs.html#11">2.1.3. Alex's Acknowledgments</A>
</ul><li><A href="TLSAGs.html#11">2.2. Typographical Conventions</A>
</ul><li><A href="TLSAGs.html#12">Chapter 3. Overview of a Linux System</A>
<ul><li><A href="TLSAGs.html#12">3.1. Various parts of an operating system</A>
<li><A href="TLSAGs.html#12">3.2. Important parts of the kernel</A>
<li><A href="TLSAGs.html#13">3.3. Major services in a UNIX system</A>
<ul><li><A href="TLSAGs.html#14">3.3.1. init</A>
<li><A href="TLSAGs.html#14">3.3.2. Logins from terminals</A>
<li><A href="TLSAGs.html#14">3.3.3. Syslog</A>
<li><A href="TLSAGs.html#14">3.3.4. Periodic command execution: cron and at</A>
<li><A href="TLSAGs.html#15">3.3.5. Graphical user interface</A>
<li><A href="TLSAGs.html#15">3.3.6. Networking</A>
<li><A href="TLSAGs.html#15">3.3.7. Network logins</A>
<li><A href="TLSAGs.html#16">3.3.8. Network file systems</A>
<li><A href="TLSAGs.html#16">3.3.9. Mail</A>
<li><A href="TLSAGs.html#16">3.3.10. Printing</A>
<li><A href="TLSAGs.html#16">3.3.11. The filesystem layout</A>
</ul></ul><li><A href="TLSAGs.html#18">Chapter 4. Overview of the Directory Tree</A>
<ul><li><A href="TLSAGs.html#18">4.1. Background</A>
<li><A href="TLSAGs.html#19">4.2. The root filesystem</A>
<li><A href="TLSAGs.html#20">4.3. The /etc directory</A>
<li><A href="TLSAGs.html#22">4.4. The /dev directory</A>
<li><A href="TLSAGs.html#22">4.5. The /usr filesystem</A>
<li><A href="TLSAGs.html#22">4.6. The /var filesystem</A>
<li><A href="TLSAGs.html#23">4.7. The /proc filesystem</A>
</ul><li><A href="TLSAGs.html#25">Chapter 5. Device Files</A>
<ul><li><A href="TLSAGs.html#25">5.1. The MAKEDEV Script</A>
<li><A href="TLSAGs.html#25">5.2. The mknod command</A>
<li><A href="TLSAGs.html#26">5.3. Device List</A>
</ul><li><A href="TLSAGs.html#28">Chapter 6. Using Disks and Other Storage Media</A>
<ul><li><A href="TLSAGs.html#28">6.1. Two kinds of devices</A>
<li><A href="TLSAGs.html#29">6.2. Hard disks</A>
<li><A href="TLSAGs.html#31">6.3. Floppies</A>
<li><A href="TLSAGs.html#32">6.4. CD-ROMs</A>
<li><A href="TLSAGs.html#32">6.5. Tapes</A>
<li><A href="TLSAGs.html#33">6.6. Formatting</A>
<li><A href="TLSAGs.html#34">6.7. Partitions</A>
<ul><li><A href="TLSAGs.html#35">6.7.1. The MBR, boot sectors and partition table</A>
<li><A href="TLSAGs.html#35">6.7.2. Extended and logical partitions</A>
<li><A href="TLSAGs.html#36">6.7.3. Partition types</A>
<li><A href="TLSAGs.html#37">6.7.4. Partitioning a hard disk</A>
<li><A href="TLSAGs.html#37">6.7.5. Device files and partitions</A>
</ul><li><A href="TLSAGs.html#38">6.8. Filesystems</A>
<ul><li><A href="TLSAGs.html#38">6.8.1. What are filesystems?</A>
<li><A href="TLSAGs.html#38">6.8.2. Filesystems galore</A>
<li><A href="TLSAGs.html#40">6.8.3. Which filesystem should be used?</A>
<li><A href="TLSAGs.html#41">6.8.4. Creating a filesystem</A>
<li><A href="TLSAGs.html#42">6.8.5. Mounting and unmounting</A>
<li><A href="TLSAGs.html#45">6.8.6. Checking filesystem integrity with fsck</A>
<li><A href="TLSAGs.html#45">6.8.7. Checking for disk errors with badblocks</A>
<li><A href="TLSAGs.html#46">6.8.8. Fighting fragmentation</A>
<li><A href="TLSAGs.html#46">6.8.9. Other tools for all filesystems</A>
<li><A href="TLSAGs.html#47">6.8.10. Other tools for the ext2/ext3 filesystem</A>
</ul><li><A href="TLSAGs.html#48">6.9. Disks without filesystems</A>
<li><A href="TLSAGs.html#49">6.10. Allocating disk space</A>
<ul><li><A href="TLSAGs.html#49">6.10.1. Partitioning schemes</A>
<li><A href="TLSAGs.html#49">6.10.2. Space requirements</A>
<li><A href="TLSAGs.html#50">6.10.3. Examples of hard disk allocation</A>
<li><A href="TLSAGs.html#50">6.10.4. Adding more disk space for Linux</A>
<li><A href="TLSAGs.html#50">6.10.5. Tips for saving disk space</A>
</ul></ul><li><A href="TLSAGs.html#52">Chapter 7. Memory Management</A>
<ul><li><A href="TLSAGs.html#52">7.1. What is virtual memory?</A>
<li><A href="TLSAGs.html#52">7.2. Creating a swap space</A>
<li><A href="TLSAGs.html#53">7.3. Using a swap space</A>
<li><A href="TLSAGs.html#55">7.4. Sharing swap spaces with other operating systems</A>
<li><A href="TLSAGs.html#55">7.5. Allocating swap space</A>
<li><A href="TLSAGs.html#56">7.6. The buffer cache</A>
</ul><li><A href="TLSAGs.html#58">Chapter 8. Boots And Shutdowns</A>
<ul><li><A href="TLSAGs.html#58">8.1. An overview of boots and shutdowns</A>
<li><A href="TLSAGs.html#58">8.2. The boot process in closer look</A>
<li><A href="TLSAGs.html#60">8.3. More about shutdowns</A>
<li><A href="TLSAGs.html#61">8.4. Rebooting</A>
<li><A href="TLSAGs.html#62">8.5. Single user mode</A>
<li><A href="TLSAGs.html#62">8.6. Emergency boot floppies</A>
</ul><li><A href="TLSAGs.html#63">Chapter 9. init</A>
<ul><li><A href="TLSAGs.html#63">9.1. init comes first</A>
<li><A href="TLSAGs.html#63">9.2. Configuring init to start getty: the /etc/inittab file</A>
<li><A href="TLSAGs.html#64">9.3. Run levels</A>
<li><A href="TLSAGs.html#65">9.4. Special configuration in /etc/inittab</A>
<li><A href="TLSAGs.html#66">9.5. Booting in single user mode</A>
</ul><li><A href="TLSAGs.html#67">Chapter 10. Logging In And Out</A>
<ul><li><A href="TLSAGs.html#67">10.1. Logins via terminals</A>
<li><A href="TLSAGs.html#68">10.2. Logins via the network</A>
<li><A href="TLSAGs.html#69">10.3. What login does</A>
<li><A href="TLSAGs.html#70">10.4. X and xdm</A>
<li><A href="TLSAGs.html#70">10.5. Access control</A>
<li><A href="TLSAGs.html#70">10.6. Shell startup</A>
</ul><li><A href="TLSAGs.html#71">Chapter 11. Managing user accounts</A>
<ul><li><A href="TLSAGs.html#71">11.1. What's an account?</A>
<li><A href="TLSAGs.html#71">11.2. Creating a user</A>
<ul><li><A href="TLSAGs.html#71">11.2.1. /etc/passwd and other informative files</A>
<li><A href="TLSAGs.html#72">11.2.2. Picking numeric user and group ids</A>
<li><A href="TLSAGs.html#72">11.2.3. Initial environment: /etc/skel</A>
<li><A href="TLSAGs.html#73">11.2.4. Creating a user by hand</A>
</ul><li><A href="TLSAGs.html#73">11.3. Changing user properties</A>
<li><A href="TLSAGs.html#74">11.4. Removing a user</A>
<li><A href="TLSAGs.html#74">11.5. Disabling a user temporarily</A>
</ul><li><A href="TLSAGs.html#76">Chapter 12. Backups</A>
<ul><li><A href="TLSAGs.html#76">12.1. On the importance of being backed up</A>
<li><A href="TLSAGs.html#76">12.2. Selecting the backup medium</A>
<li><A href="TLSAGs.html#77">12.3. Selecting the backup tool</A>
<li><A href="TLSAGs.html#78">12.4. Simple backups</A>
<ul><li><A href="TLSAGs.html#78">12.4.1. Making backups with tar</A>
<li><A href="TLSAGs.html#79">12.4.2. Restoring files with tar</A>
</ul><li><A href="TLSAGs.html#80">12.5. Multilevel backups</A>
<li><A href="TLSAGs.html#81">12.6. What to back up</A>
<li><A href="TLSAGs.html#82">12.7. Compressed backups</A>
</ul><li><A href="TLSAGs.html#83">Chapter 13. Keeping Time</A>
<ul><li><A href="TLSAGs.html#83">13.1. The concept of localtime</A>
<li><A href="TLSAGs.html#84">13.2. The hardware and software clocks</A>
<li><A href="TLSAGs.html#84">13.3. Showing and setting time</A>
<li><A href="TLSAGs.html#85">13.4. When the clock is wrong</A>
<li><A href="TLSAGs.html#85">13.5. NTP - Network Time Protocol</A>
<li><A href="TLSAGs.html#86">13.6. Basic NTP configuration</A>
<li><A href="TLSAGs.html#87">13.7. NTP Toolkit</A>
<li><A href="TLSAGs.html#89">13.8. Some known NTP servers</A>
<li><A href="TLSAGs.html#89">13.9. NTP Links</A>
</ul><li><A href="TLSAGs.html#90">Chapter 14. Finding Help</A>
<ul><li><A href="TLSAGs.html#90">14.1. Newsgroups and Mailing Lists</A>
<ul><li><A href="TLSAGs.html#90">14.1.1. Finding The Right Forum</A>
<li><A href="TLSAGs.html#90">14.1.2. Before You Post</A>
<li><A href="TLSAGs.html#90">14.1.3. Writing Your Post</A>
<li><A href="TLSAGs.html#91">14.1.4. Formatting Your Post</A>
<li><A href="TLSAGs.html#91">14.1.5. Follow Up</A>
<li><A href="TLSAGs.html#91">14.1.6. More Information</A>
</ul><li><A href="TLSAGs.html#91">14.2. IRC</A>
<ul><li><A href="TLSAGs.html#92">14.2.1. Colours</A>
<li><A href="TLSAGs.html#92">14.2.2. Be Polite</A>
<li><A href="TLSAGs.html#92">14.2.3. Type Properly, in English</A>
<li><A href="TLSAGs.html#92">14.2.4. Port scanning</A>
<li><A href="TLSAGs.html#92">14.2.5. Keep it in the Channel</A>
<li><A href="TLSAGs.html#93">14.2.6. Stay On Topic</A>
<li><A href="TLSAGs.html#93">14.2.7. CTCPs</A>
<li><A href="TLSAGs.html#93">14.2.8. Hacking, Cracking, Phreaking, Warezing</A>
<li><A href="TLSAGs.html#93">14.2.9. Round Up</A>
<li><A href="TLSAGs.html#93">14.2.10. Further Reading</A>
</ul></ul><li><A href="TLSAGs.html#94">Appendix A. GNU Free Documentation License</A>
<ul><li><A href="TLSAGs.html#94">0. PREAMBLE</A>
<li><A href="TLSAGs.html#94">1. APPLICABILITY AND DEFINITIONS</A>
<li><A href="TLSAGs.html#95">2. VERBATIM COPYING</A>
<li><A href="TLSAGs.html#95">3. COPYING IN QUANTITY</A>
<li><A href="TLSAGs.html#96">4. MODIFICATIONS</A>
<li><A href="TLSAGs.html#97">5. COMBINING DOCUMENTS</A>
<li><A href="TLSAGs.html#97">6. COLLECTIONS OF DOCUMENTS</A>
<li><A href="TLSAGs.html#98">7. AGGREGATION WITH INDEPENDENT WORKS</A>
<li><A href="TLSAGs.html#98">8. TRANSLATION</A>
<li><A href="TLSAGs.html#98">9. TERMINATION</A>
<li><A href="TLSAGs.html#98">10. FUTURE REVISIONS OF THIS LICENSE</A>
<li><A href="TLSAGs.html#99">How to use this License for your documents</A>
</ul><li><A href="TLSAGs.html#100">Glossary (DRAFT, but not for long hopefully)</A>
</ul><hr>
</BODY>
</HTML>
